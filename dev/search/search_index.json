{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"distilabel","text":"<p>AI Feedback (AIF) framework to build datasets with and for LLMs:</p> <ul> <li>Integrations with the most popular libraries and APIs for LLMs: HF Transformers, OpenAI, vLLM, etc.</li> <li>Multiple tasks for Self-Instruct, Preference datasets and more.</li> <li>Dataset export to Argilla for easy data exploration and further annotation.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p><pre><code>pip install distilabel\n</code></pre> Requires Python 3.8+</p> <p>In addition, the following extras are available:</p> <ul> <li><code>anthropic</code>: for using models available in Anthropic API via the <code>AnthropicLLM</code> integration.</li> <li><code>argilla</code>: for exporting the generated datasets to Argilla.</li> <li><code>cohere</code>: for using models available in Cohere via the <code>CohereLLM</code> integration.</li> <li><code>hf-inference-endpoints</code>: for using the Hugging Face Inference Endpoints via the <code>InferenceEndpointsLLM</code> integration.</li> <li><code>hf-transformers</code>: for using models available in transformers package via the <code>TransformersLLM</code> integration.</li> <li><code>litellm</code>: for using <code>LiteLLM</code> to call any LLM using OpenAI format via the <code>LiteLLM</code> integration.</li> <li><code>llama-cpp</code>: for using llama-cpp-python Python bindings for <code>llama.cpp</code> via the <code>LlamaCppLLM</code> integration.</li> <li><code>mistralai</code>: for using models available in Mistral AI API via the <code>MistralAILLM</code> integration.</li> <li><code>ollama</code>: for using Ollama and their available models via <code>OllamaLLM</code> integration.</li> <li><code>openai</code>: for using OpenAI API models via the <code>OpenAILLM</code> integration, or the rest of the integrations based on OpenAI and relying on its client as <code>AnyscaleLLM</code>, <code>AzureOpenAILLM</code>, and <code>TogetherLLM</code>.</li> <li><code>vertexai</code>: for using Google Vertex AI proprietary models via the <code>VertexAILLM</code> integration.</li> <li><code>vllm</code>: for using vllm serving engine via the <code>vLLM</code> integration.</li> </ul>"},{"location":"#quick-example","title":"Quick example","text":"<pre><code>from distilabel.llms import OpenAILLM\nfrom distilabel.pipeline import Pipeline\nfrom distilabel.steps import LoadHubDataset, TextGenerationToArgilla\nfrom distilabel.steps.tasks import TextGeneration\n\nwith Pipeline(\"pipe-name\", description=\"My first pipe\") as pipeline:\n    load_dataset = LoadHubDataset(\n        name=\"load_dataset\",\n        output_mappings={\"prompt\": \"instruction\"},\n    )\n\n    generate_with_openai = TextGeneration(\n        name=\"generate_with_openai\", llm=OpenAILLM(model=\"gpt-4-0125-preview\")\n    )\n\n    to_argilla = TextGenerationToArgilla(\n        name=\"to_argilla\", dataset_name=\"text-generation-with-gpt4\"\n    )\n\n    load_dataset.connect(generate_with_openai)\n    generate_with_openai.connect(to_argilla)\n\n\nif __name__ == \"__main__\":\n    distiset = pipeline.run(\n        parameters={\n            \"load_dataset\": {\n                \"repo_id\": \"distilabel-internal-testing/instruction-dataset-mini\",\n                \"split\": \"test\",\n            },\n            \"generate_with_openai\": {\n                \"llm\": {\n                    \"generation_kwargs\": {\n                        \"temperature\": 0.7,\n                        \"max_new_tokens\": 512,\n                    }\n                }\n            },\n            \"to_argilla\": {\n                \"api_url\": \"https://cloud.argilla.io\",\n                \"api_key\": \"i.love.argilla\",\n            },\n        },\n    )\n    distiset.push_to_hub(\n        \"distilabel-internal-testing/instruction-dataset-mini-with-generations\"\n    )\n</code></pre>"},{"location":"overview/","title":"Overview of Distilabel","text":"<p>AI Feedback (AIF) framework to build datasets with and for LLMs:</p>"},{"location":"overview/#pipeline","title":"Pipeline","text":"<p>Define your pipeline like you would a Directed Acyclic Graph (DAG)...</p>"},{"location":"overview/#steps","title":"Steps","text":"<p>...</p>"},{"location":"overview/#command-line-interface","title":"Command Line Interface","text":"<p>Distilabel comes with a CLI to easily reproduce datasets from a <code>pipeline.yaml</code>. ...</p>"},{"location":"api/cli/","title":"Command Line Interface","text":"<p>This section contains the API reference for the command line interface.</p>"},{"location":"api/cli/#cli-commands","title":"CLI commands","text":"<p>This section shows the CLI commands:</p>"},{"location":"api/cli/#distilabel-pipeline-run","title":"distilabel pipeline run","text":"<pre><code>$ distilabel pipeline info --help\n\n Usage: distilabel pipeline info [OPTIONS]\n\n Get information about a Distilabel pipeline.\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --config        TEXT  Path or URL to the Distilabel pipeline configuration file. \u2502\n\u2502                          [default: None]                                            \u2502\n\u2502                          [required]                                                 \u2502\n\u2502    --help                Show this message and exit.                                \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"api/cli/#distilabel-pipeline-info","title":"distilabel pipeline info","text":"<pre><code>$ distilabel pipeline --help\n\n Usage: distilabel pipeline [OPTIONS] COMMAND [ARGS]...\n\n Commands to run and inspect Distilabel pipelines.\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help          Show this message and exit.                                             \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 info      Get information about a Distilabel pipeline.                                  \u2502\n\u2502 run       Run a Distilabel pipeline.                                                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"api/cli/#utility-functions-for-the-pipeline-commands","title":"Utility functions for the pipeline commands","text":"<p>Here are some utility functions to help working with the pipelines in the console.</p>"},{"location":"api/cli/#distilabel.cli.pipeline.utils.display_pipeline_information","title":"<code>display_pipeline_information(pipeline)</code>","text":"<p>Displays the pipeline information to the console.</p> <p>Parameters:</p> Name Type Description Default <code>pipeline</code> <code>BasePipeline</code> <p>The pipeline.</p> required Source code in <code>src/distilabel/cli/pipeline/utils.py</code> <pre><code>def display_pipeline_information(pipeline: \"BasePipeline\") -&gt; None:\n    \"\"\"Displays the pipeline information to the console.\n\n    Args:\n        pipeline: The pipeline.\n    \"\"\"\n    from rich.console import Console\n\n    Console().print(_build_pipeline_panel(pipeline))\n</code></pre>"},{"location":"api/cli/#distilabel.cli.pipeline.utils.get_config_from_url","title":"<code>get_config_from_url(url)</code>","text":"<p>Loads the pipeline configuration from a URL pointing to a JSON or YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the pipeline configuration file.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The pipeline configuration as a dictionary.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file format is not supported.</p> Source code in <code>src/distilabel/cli/pipeline/utils.py</code> <pre><code>def get_config_from_url(url: str) -&gt; Dict[str, Any]:\n    \"\"\"Loads the pipeline configuration from a URL pointing to a JSON or YAML file.\n\n    Args:\n        url: The URL pointing to the pipeline configuration file.\n\n    Returns:\n        The pipeline configuration as a dictionary.\n\n    Raises:\n        ValueError: If the file format is not supported.\n    \"\"\"\n    if not url.endswith((\".json\", \".yaml\", \".yml\")):\n        raise ValueError(\n            f\"Unsupported file format for '{url}'. Only JSON and YAML are supported\"\n        )\n    if \"huggingface.co\" in url and \"HF_TOKEN\" in os.environ:\n        headers = {\"Authorization\": f\"Bearer {os.environ['HF_TOKEN']}\"}\n    else:\n        headers = None\n    response = requests.get(url, headers=headers)\n    response.raise_for_status()\n\n    if url.endswith((\".yaml\", \".yml\")):\n        content = response.content.decode(\"utf-8\")\n        return yaml.safe_load(content)\n\n    return response.json()\n</code></pre>"},{"location":"api/cli/#distilabel.cli.pipeline.utils.get_pipeline","title":"<code>get_pipeline(config)</code>","text":"<p>Get a pipeline from a configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>The path or URL to the pipeline configuration file.</p> required <p>Returns:</p> Type Description <code>BasePipeline</code> <p>The pipeline.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file format is not supported.</p> <code>FileNotFoundError</code> <p>If the configuration file does not exist.</p> Source code in <code>src/distilabel/cli/pipeline/utils.py</code> <pre><code>def get_pipeline(config: str) -&gt; \"BasePipeline\":\n    \"\"\"Get a pipeline from a configuration file.\n\n    Args:\n        config: The path or URL to the pipeline configuration file.\n\n    Returns:\n        The pipeline.\n\n    Raises:\n        ValueError: If the file format is not supported.\n        FileNotFoundError: If the configuration file does not exist.\n    \"\"\"\n    if valid_http_url(config):\n        return Pipeline.from_dict(get_config_from_url(config))\n\n    if Path(config).is_file():\n        return Pipeline.from_file(config)\n\n    raise FileNotFoundError(f\"Config file '{config}' does not exist.\")\n</code></pre>"},{"location":"api/cli/#distilabel.cli.pipeline.utils.parse_runtime_parameters","title":"<code>parse_runtime_parameters(params)</code>","text":"<p>Parses the runtime parameters from the CLI format to the format expected by the <code>Pipeline.run</code> method. The CLI format is a list of tuples, where the first element is a list of keys and the second element is the value.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>List[Tuple[List[str], str]]</code> <p>A list of tuples, where the first element is a list of keys and the second element is the value.</p> required <p>Returns:</p> Type Description <code>Dict[str, Dict[str, Any]]</code> <p>A dictionary with the runtime parameters in the format expected by the</p> <code>Dict[str, Dict[str, Any]]</code> <p><code>Pipeline.run</code> method.</p> Source code in <code>src/distilabel/cli/pipeline/utils.py</code> <pre><code>def parse_runtime_parameters(\n    params: List[Tuple[List[str], str]],\n) -&gt; Dict[str, Dict[str, Any]]:\n    \"\"\"Parses the runtime parameters from the CLI format to the format expected by the\n    `Pipeline.run` method. The CLI format is a list of tuples, where the first element is\n    a list of keys and the second element is the value.\n\n    Args:\n        params: A list of tuples, where the first element is a list of keys and the\n            second element is the value.\n\n    Returns:\n        A dictionary with the runtime parameters in the format expected by the\n        `Pipeline.run` method.\n    \"\"\"\n    runtime_params = {}\n    for keys, value in params:\n        current = runtime_params\n        for i, key in enumerate(keys):\n            if i == len(keys) - 1:\n                current[key] = value\n            else:\n                current = current.setdefault(key, {})\n    return runtime_params\n</code></pre>"},{"location":"api/cli/#distilabel.cli.pipeline.utils.valid_http_url","title":"<code>valid_http_url(url)</code>","text":"<p>Check if the URL is a valid HTTP URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code>, if the URL is a valid HTTP URL. <code>False</code>, otherwise.</p> Source code in <code>src/distilabel/cli/pipeline/utils.py</code> <pre><code>def valid_http_url(url: str) -&gt; bool:\n    \"\"\"Check if the URL is a valid HTTP URL.\n\n    Args:\n        url: The URL to check.\n\n    Returns:\n        `True`, if the URL is a valid HTTP URL. `False`, otherwise.\n    \"\"\"\n    try:\n        TypeAdapter(HttpUrl).validate_python(url)  # type: ignore\n    except ValidationError:\n        return False\n\n    return True\n</code></pre>"},{"location":"api/llms/anthropic/","title":"LLMs","text":""},{"location":"api/llms/anthropic/#anthropicllm","title":"AnthropicLLM","text":""},{"location":"api/llms/anthropic/#distilabel.llms.anthropic.AnthropicLLM","title":"<code>AnthropicLLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>Anthropic LLM implementation running the Async API client.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the name of the model to use for the LLM e.g. \"claude-3-opus-20240229\", \"claude-3-sonnet-20240229\", etc. Available models can be checked here: Anthropic: Models overview.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Anthropic API. If not provided, it will be read from <code>ANTHROPIC_API_KEY</code> environment variable.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the Anthropic API. Defaults to <code>None</code> which means that <code>https://api.anthropic.com</code> will be used internally.</p> <code>timeout</code> <code>RuntimeParameter[float]</code> <p>the maximum time in seconds to wait for a response. Defaults to <code>600.0</code>.</p> <code>max_retries</code> <code>RuntimeParameter[int]</code> <p>The maximum number of times to retry the request before failing. Defaults to <code>6</code>.</p> <code>http_client</code> <code>Optional[AsyncClient]</code> <p>if provided, an alternative HTTP client to use for calling Anthropic API. Defaults to <code>None</code>.</p> <code>_api_key_env_var</code> <code>str</code> <p>the name of the environment variable to use for the API key. It is meant to be used internally.</p> <code>_aclient</code> <code>Optional[AsyncAnthropic]</code> <p>the <code>AsyncAnthropic</code> client to use for the Anthropic API. It is meant to be used internally. Set in the <code>load</code> method.</p> Runtime parameters <ul> <li><code>api_key</code>: the API key to authenticate the requests to the Anthropic API. If not     provided, it will be read from <code>ANTHROPIC_API_KEY</code> environment variable.</li> <li><code>base_url</code>: the base URL to use for the Anthropic API. Defaults to <code>\"https://api.anthropic.com\"</code>.</li> <li><code>timeout</code>: the maximum time in seconds to wait for a response. Defaults to <code>600.0</code>.</li> <li><code>max_retries</code>: the maximum number of times to retry the request before failing.     Defaults to <code>6</code>.</li> </ul> Source code in <code>src/distilabel/llms/anthropic.py</code> <pre><code>class AnthropicLLM(AsyncLLM):\n    \"\"\"Anthropic LLM implementation running the Async API client.\n\n    Attributes:\n        model: the name of the model to use for the LLM e.g. \"claude-3-opus-20240229\",\n            \"claude-3-sonnet-20240229\", etc. Available models can be checked here:\n            [Anthropic: Models overview](https://docs.anthropic.com/claude/docs/models-overview).\n        api_key: the API key to authenticate the requests to the Anthropic API. If not provided,\n            it will be read from `ANTHROPIC_API_KEY` environment variable.\n        base_url: the base URL to use for the Anthropic API. Defaults to `None` which means\n            that `https://api.anthropic.com` will be used internally.\n        timeout: the maximum time in seconds to wait for a response. Defaults to `600.0`.\n        max_retries: The maximum number of times to retry the request before failing. Defaults\n            to `6`.\n        http_client: if provided, an alternative HTTP client to use for calling Anthropic\n            API. Defaults to `None`.\n        _api_key_env_var: the name of the environment variable to use for the API key. It\n            is meant to be used internally.\n        _aclient: the `AsyncAnthropic` client to use for the Anthropic API. It is meant\n            to be used internally. Set in the `load` method.\n\n    Runtime parameters:\n        - `api_key`: the API key to authenticate the requests to the Anthropic API. If not\n            provided, it will be read from `ANTHROPIC_API_KEY` environment variable.\n        - `base_url`: the base URL to use for the Anthropic API. Defaults to `\"https://api.anthropic.com\"`.\n        - `timeout`: the maximum time in seconds to wait for a response. Defaults to `600.0`.\n        - `max_retries`: the maximum number of times to retry the request before failing.\n            Defaults to `6`.\n    \"\"\"\n\n    model: str\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(\n            \"ANTHROPIC_BASE_URL\", \"https://api.anthropic.com\"\n        ),\n        description=\"The base URL to use for the Anthropic API.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_ANTHROPIC_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Anthropic API.\",\n    )\n    timeout: RuntimeParameter[float] = Field(\n        default=600.0,\n        description=\"The maximum time in seconds to wait for a response from the API.\",\n    )\n    max_retries: RuntimeParameter[int] = Field(\n        default=6,\n        description=\"The maximum number of times to retry the request to the API before\"\n        \" failing.\",\n    )\n    http_client: Optional[AsyncClient] = Field(default=None, exclude=True)\n\n    _api_key_env_var: str = PrivateAttr(default=_ANTHROPIC_API_KEY_ENV_VAR_NAME)\n    _aclient: Optional[\"AsyncAnthropic\"] = PrivateAttr(...)\n\n    def _check_model_exists(self) -&gt; None:\n        \"\"\"Checks if the specified model exists in the available models.\"\"\"\n        from anthropic import AsyncAnthropic\n\n        annotation = get_type_hints(AsyncAnthropic().messages.create).get(\"model\", None)\n        models = [\n            value\n            for type_ in get_args(annotation)\n            if get_origin(type_) is Literal\n            for value in get_args(type_)\n        ]\n\n        if self.model not in models:\n            raise ValueError(\n                f\"Model {self.model} does not exist among available models. \"\n                f\"The available models are {', '.join(models)}\"\n            )\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `AsyncAnthropic` client to use the Anthropic async API.\"\"\"\n        super().load()\n\n        try:\n            from anthropic import AsyncAnthropic\n        except ImportError as ie:\n            raise ImportError(\n                \"Anthropic Python client is not installed. Please install it using\"\n                \" `pip install anthropic`.\"\n            ) from ie\n\n        if self.api_key is None:\n            raise ValueError(\n                f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n                f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n            )\n\n        self._check_model_exists()\n\n        self._aclient = AsyncAnthropic(\n            api_key=self.api_key.get_secret_value(),\n            base_url=self.base_url,\n            timeout=self.timeout,\n            http_client=self.http_client,\n            max_retries=self.max_retries,\n        )\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        max_tokens: int = 128,\n        stop_sequences: Union[List[str], None] = None,\n        temperature: float = 1.0,\n        top_p: Union[float, None] = None,\n        top_k: Union[int, None] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates a response asynchronously, using the [Anthropic Async API definition](https://github.com/anthropics/anthropic-sdk-python).\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            max_tokens: the maximum number of new tokens that the model will generate. Defaults to `128`.\n            stop_sequences: custom text sequences that will cause the model to stop generating. Defaults to `NOT_GIVEN`.\n            temperature: the temperature to use for the generation. Set only if top_p is None. Defaults to `1.0`.\n            top_p: the top-p value to use for the generation. Defaults to `NOT_GIVEN`.\n            top_k: the top-k value to use for the generation. Defaults to `NOT_GIVEN`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        from anthropic._types import NOT_GIVEN\n\n        completion = await self._aclient.messages.create(\n            model=self.model,\n            system=(\n                input.pop(0)[\"content\"]\n                if input and input[0][\"role\"] == \"system\"\n                else NOT_GIVEN\n            ),\n            messages=input,\n            max_tokens=max_tokens,\n            stream=False,\n            stop_sequences=NOT_GIVEN if stop_sequences is None else stop_sequences,\n            temperature=temperature,\n            top_p=NOT_GIVEN if top_p is None else top_p,\n            top_k=NOT_GIVEN if top_k is None else top_k,\n        )\n        generations = []\n        if (content := completion.content[0].text) is None:\n            self._logger.warning(\n                f\"Received no response using Anthropic client (model: '{self.model}').\"\n                f\" Finish reason was: {completion.stop_reason}\"\n            )\n        generations.append(content)\n        return generations\n\n    # TODO: remove this function once Anthropic client allows `n` parameter\n    @override\n    def generate(\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        **kwargs: Any,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Method to generate a list of responses asynchronously, returning the output\n        synchronously awaiting for the response of each input sent to `agenerate`.\n        \"\"\"\n\n        async def agenerate(\n            inputs: List[\"ChatType\"], **kwargs: Any\n        ) -&gt; \"GenerateOutput\":\n            \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n            tasks = [\n                asyncio.create_task(self.agenerate(input=input, **kwargs))\n                for input in inputs\n                for _ in range(num_generations)\n            ]\n            return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n        outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n        return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"api/llms/anthropic/#distilabel.llms.anthropic.AnthropicLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"api/llms/anthropic/#distilabel.llms.anthropic.AnthropicLLM.agenerate","title":"<code>agenerate(input, max_tokens=128, stop_sequences=None, temperature=1.0, top_p=None, top_k=None)</code>  <code>async</code>","text":"<p>Generates a response asynchronously, using the Anthropic Async API definition.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>max_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>stop_sequences</code> <code>Union[List[str], None]</code> <p>custom text sequences that will cause the model to stop generating. Defaults to <code>NOT_GIVEN</code>.</p> <code>None</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Set only if top_p is None. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>top_p</code> <code>Union[float, None]</code> <p>the top-p value to use for the generation. Defaults to <code>NOT_GIVEN</code>.</p> <code>None</code> <code>top_k</code> <code>Union[int, None]</code> <p>the top-k value to use for the generation. Defaults to <code>NOT_GIVEN</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>GenerateOutput</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/anthropic.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    max_tokens: int = 128,\n    stop_sequences: Union[List[str], None] = None,\n    temperature: float = 1.0,\n    top_p: Union[float, None] = None,\n    top_k: Union[int, None] = None,\n) -&gt; \"GenerateOutput\":\n    \"\"\"Generates a response asynchronously, using the [Anthropic Async API definition](https://github.com/anthropics/anthropic-sdk-python).\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        max_tokens: the maximum number of new tokens that the model will generate. Defaults to `128`.\n        stop_sequences: custom text sequences that will cause the model to stop generating. Defaults to `NOT_GIVEN`.\n        temperature: the temperature to use for the generation. Set only if top_p is None. Defaults to `1.0`.\n        top_p: the top-p value to use for the generation. Defaults to `NOT_GIVEN`.\n        top_k: the top-k value to use for the generation. Defaults to `NOT_GIVEN`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    from anthropic._types import NOT_GIVEN\n\n    completion = await self._aclient.messages.create(\n        model=self.model,\n        system=(\n            input.pop(0)[\"content\"]\n            if input and input[0][\"role\"] == \"system\"\n            else NOT_GIVEN\n        ),\n        messages=input,\n        max_tokens=max_tokens,\n        stream=False,\n        stop_sequences=NOT_GIVEN if stop_sequences is None else stop_sequences,\n        temperature=temperature,\n        top_p=NOT_GIVEN if top_p is None else top_p,\n        top_k=NOT_GIVEN if top_k is None else top_k,\n    )\n    generations = []\n    if (content := completion.content[0].text) is None:\n        self._logger.warning(\n            f\"Received no response using Anthropic client (model: '{self.model}').\"\n            f\" Finish reason was: {completion.stop_reason}\"\n        )\n    generations.append(content)\n    return generations\n</code></pre>"},{"location":"api/llms/anthropic/#distilabel.llms.anthropic.AnthropicLLM.generate","title":"<code>generate(inputs, num_generations=1, **kwargs)</code>","text":"<p>Method to generate a list of responses asynchronously, returning the output synchronously awaiting for the response of each input sent to <code>agenerate</code>.</p> Source code in <code>src/distilabel/llms/anthropic.py</code> <pre><code>@override\ndef generate(\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    **kwargs: Any,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Method to generate a list of responses asynchronously, returning the output\n    synchronously awaiting for the response of each input sent to `agenerate`.\n    \"\"\"\n\n    async def agenerate(\n        inputs: List[\"ChatType\"], **kwargs: Any\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n        tasks = [\n            asyncio.create_task(self.agenerate(input=input, **kwargs))\n            for input in inputs\n            for _ in range(num_generations)\n        ]\n        return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n    outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n    return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"api/llms/anthropic/#distilabel.llms.anthropic.AnthropicLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>AsyncAnthropic</code> client to use the Anthropic async API.</p> Source code in <code>src/distilabel/llms/anthropic.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `AsyncAnthropic` client to use the Anthropic async API.\"\"\"\n    super().load()\n\n    try:\n        from anthropic import AsyncAnthropic\n    except ImportError as ie:\n        raise ImportError(\n            \"Anthropic Python client is not installed. Please install it using\"\n            \" `pip install anthropic`.\"\n        ) from ie\n\n    if self.api_key is None:\n        raise ValueError(\n            f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n            f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n        )\n\n    self._check_model_exists()\n\n    self._aclient = AsyncAnthropic(\n        api_key=self.api_key.get_secret_value(),\n        base_url=self.base_url,\n        timeout=self.timeout,\n        http_client=self.http_client,\n        max_retries=self.max_retries,\n    )\n</code></pre>"},{"location":"api/llms/anyscale/","title":"Anyscale","text":""},{"location":"api/llms/anyscale/#anyscalellm","title":"AnyscaleLLM","text":""},{"location":"api/llms/anyscale/#distilabel.llms.anyscale.AnyscaleLLM","title":"<code>AnyscaleLLM</code>","text":"<p>             Bases: <code>OpenAILLM</code></p> <p>Anyscale LLM implementation running the async API client of OpenAI because of duplicate API behavior.</p> <p>Attributes:</p> Name Type Description <code>model</code> <p>the model name to use for the LLM, e.g., <code>google/gemma-7b-it</code>. See the supported models under the \"Text Generation -&gt; Supported Models\" section here.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the Anyscale API requests. Defaults to <code>None</code>, which means that the value set for the environment variable <code>ANYSCALE_BASE_URL</code> will be used, or \"https://api.endpoints.anyscale.com/v1\" if not set.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Anyscale API. Defaults to <code>None</code> which means that the value set for the environment variable <code>ANYSCALE_API_KEY</code> will be used, or <code>None</code> if not set.</p> <code>_api_key_env_var</code> <code>str</code> <p>the name of the environment variable to use for the API key. It is meant to be used internally.</p> Source code in <code>src/distilabel/llms/anyscale.py</code> <pre><code>class AnyscaleLLM(OpenAILLM):\n    \"\"\"Anyscale LLM implementation running the async API client of OpenAI because of\n    duplicate API behavior.\n\n    Attributes:\n        model: the model name to use for the LLM, e.g., `google/gemma-7b-it`. See the\n            supported models under the \"Text Generation -&gt; Supported Models\" section\n            [here](https://docs.endpoints.anyscale.com/).\n        base_url: the base URL to use for the Anyscale API requests. Defaults to `None`, which\n            means that the value set for the environment variable `ANYSCALE_BASE_URL` will be used, or\n            \"https://api.endpoints.anyscale.com/v1\" if not set.\n        api_key: the API key to authenticate the requests to the Anyscale API. Defaults to `None` which\n            means that the value set for the environment variable `ANYSCALE_API_KEY` will be used, or\n            `None` if not set.\n        _api_key_env_var: the name of the environment variable to use for the API key.\n            It is meant to be used internally.\n    \"\"\"\n\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(\n            \"ANYSCALE_BASE_URL\", \"https://api.endpoints.anyscale.com/v1\"\n        ),\n        description=\"The base URL to use for the Anyscale API requests.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_ANYSCALE_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Anyscale API.\",\n    )\n\n    _api_key_env_var: str = PrivateAttr(_ANYSCALE_API_KEY_ENV_VAR_NAME)\n</code></pre>"},{"location":"api/llms/azure/","title":"Azure","text":""},{"location":"api/llms/azure/#azureopenaillm","title":"AzureOpenAILLM","text":""},{"location":"api/llms/azure/#distilabel.llms.azure.AzureOpenAILLM","title":"<code>AzureOpenAILLM</code>","text":"<p>             Bases: <code>OpenAILLM</code></p> <p>Azure OpenAI LLM implementation running the async API client of OpenAI because of duplicate API behavior, but with Azure-specific parameters.</p> <p>Attributes:</p> Name Type Description <code>model</code> <p>the model name to use for the LLM i.e. the name of the Azure deployment.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the Azure OpenAI API can be set with <code>AZURE_OPENAI_ENDPOINT</code>. Defaults to <code>None</code> which means that the value set for the environment variable <code>AZURE_OPENAI_ENDPOINT</code> will be used, or <code>None</code> if not set.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Azure OpenAI API. Defaults to <code>None</code> which means that the value set for the environment variable <code>AZURE_OPENAI_API_KEY</code> will be used, or <code>None</code> if not set.</p> <code>api_version</code> <code>Optional[RuntimeParameter[str]]</code> <p>the API version to use for the Azure OpenAI API. Defaults to <code>None</code> which means that the value set for the environment variable <code>OPENAI_API_VERSION</code> will be used, or <code>None</code> if not set.</p> Source code in <code>src/distilabel/llms/azure.py</code> <pre><code>class AzureOpenAILLM(OpenAILLM):\n    \"\"\"Azure OpenAI LLM implementation running the async API client of OpenAI because of\n    duplicate API behavior, but with Azure-specific parameters.\n\n    Attributes:\n        model: the model name to use for the LLM i.e. the name of the Azure deployment.\n        base_url: the base URL to use for the Azure OpenAI API can be set with `AZURE_OPENAI_ENDPOINT`.\n            Defaults to `None` which means that the value set for the environment variable\n            `AZURE_OPENAI_ENDPOINT` will be used, or `None` if not set.\n        api_key: the API key to authenticate the requests to the Azure OpenAI API. Defaults to `None`\n            which means that the value set for the environment variable `AZURE_OPENAI_API_KEY` will be\n            used, or `None` if not set.\n        api_version: the API version to use for the Azure OpenAI API. Defaults to `None` which means\n            that the value set for the environment variable `OPENAI_API_VERSION` will be used, or\n            `None` if not set.\n    \"\"\"\n\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(_AZURE_OPENAI_ENDPOINT_ENV_VAR_NAME),\n        description=\"The base URL to use for the Azure OpenAI API requests i.e. the Azure OpenAI endpoint.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_AZURE_OPENAI_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Azure OpenAI API.\",\n    )\n\n    api_version: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(\"OPENAI_API_VERSION\"),\n        description=\"The API version to use for the Azure OpenAI API.\",\n    )\n\n    _base_url_env_var: str = PrivateAttr(_AZURE_OPENAI_ENDPOINT_ENV_VAR_NAME)\n    _api_key_env_var: str = PrivateAttr(_AZURE_OPENAI_API_KEY_ENV_VAR_NAME)\n    _aclient: Optional[\"AsyncAzureOpenAI\"] = PrivateAttr(...)  # type: ignore\n\n    @override\n    def load(self) -&gt; None:\n        \"\"\"Loads the `AsyncAzureOpenAI` client to benefit from async requests.\"\"\"\n        super().load()\n\n        try:\n            from openai import AsyncAzureOpenAI\n        except ImportError as ie:\n            raise ImportError(\n                \"OpenAI Python client is not installed. Please install it using\"\n                \" `pip install openai`.\"\n            ) from ie\n\n        if self.api_key is None:\n            raise ValueError(\n                f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n                f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n            )\n\n        # TODO: May be worth adding the AD auth too? Also the `organization`?\n        self._aclient = AsyncAzureOpenAI(  # type: ignore\n            azure_endpoint=self.base_url,  # type: ignore\n            azure_deployment=self.model,\n            api_version=self.api_version,\n            api_key=self.api_key.get_secret_value(),\n            max_retries=self.max_retries,  # type: ignore\n            timeout=self.timeout,\n        )\n</code></pre>"},{"location":"api/llms/azure/#distilabel.llms.azure.AzureOpenAILLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>AsyncAzureOpenAI</code> client to benefit from async requests.</p> Source code in <code>src/distilabel/llms/azure.py</code> <pre><code>@override\ndef load(self) -&gt; None:\n    \"\"\"Loads the `AsyncAzureOpenAI` client to benefit from async requests.\"\"\"\n    super().load()\n\n    try:\n        from openai import AsyncAzureOpenAI\n    except ImportError as ie:\n        raise ImportError(\n            \"OpenAI Python client is not installed. Please install it using\"\n            \" `pip install openai`.\"\n        ) from ie\n\n    if self.api_key is None:\n        raise ValueError(\n            f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n            f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n        )\n\n    # TODO: May be worth adding the AD auth too? Also the `organization`?\n    self._aclient = AsyncAzureOpenAI(  # type: ignore\n        azure_endpoint=self.base_url,  # type: ignore\n        azure_deployment=self.model,\n        api_version=self.api_version,\n        api_key=self.api_key.get_secret_value(),\n        max_retries=self.max_retries,  # type: ignore\n        timeout=self.timeout,\n    )\n</code></pre>"},{"location":"api/llms/huggingface/","title":"Hugging Face","text":"<p>This section contains the reference for Hugging Face integrations:</p>"},{"location":"api/llms/huggingface/#inference-endpoints","title":"Inference Endpoints","text":""},{"location":"api/llms/huggingface/#distilabel.llms.huggingface.inference_endpoints.InferenceEndpointsLLM","title":"<code>InferenceEndpointsLLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>InferenceEndpoints LLM implementation running the async API client via either the <code>huggingface_hub.AsyncInferenceClient</code> or via <code>openai.AsyncOpenAI</code>.</p> <p>Attributes:</p> Name Type Description <code>model_id</code> <code>Optional[str]</code> <p>the model ID to use for the LLM as available in the Hugging Face Hub, which will be used to resolve the base URL for the serverless Inference Endpoints API requests. Defaults to <code>None</code>.</p> <code>endpoint_name</code> <code>Optional[RuntimeParameter[str]]</code> <p>the name of the Inference Endpoint to use for the LLM. Defaults to <code>None</code>.</p> <code>endpoint_namespace</code> <code>Optional[RuntimeParameter[str]]</code> <p>the namespace of the Inference Endpoint to use for the LLM. Defaults to <code>None</code>.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the Inference Endpoints API requests.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Inference Endpoints API.</p> <code>tokenizer_id</code> <code>Optional[str]</code> <p>the tokenizer ID to use for the LLM as available in the Hugging Face Hub. Defaults to <code>None</code>, but defining one is recommended to properly format the prompt.</p> <code>model_display_name</code> <code>Optional[str]</code> <p>the model display name to use for the LLM. Defaults to <code>None</code>.</p> <code>use_openai_client</code> <code>bool</code> <p>whether to use the OpenAI client instead of the Hugging Face client.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from distilabel.llms.huggingface import AsyncInferenceEndpointsLLM\n&gt;&gt;&gt; llm = AsyncInferenceEndpointsLLM(model_id=\"model-id\")\n&gt;&gt;&gt; llm.load()\n&gt;&gt;&gt; output = await llm.agenerate([{\"role\": \"user\", \"content\": \"Hello world!\"}])\n</code></pre> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>class InferenceEndpointsLLM(AsyncLLM):\n    \"\"\"InferenceEndpoints LLM implementation running the async API client via either\n    the `huggingface_hub.AsyncInferenceClient` or via `openai.AsyncOpenAI`.\n\n    Attributes:\n        model_id: the model ID to use for the LLM as available in the Hugging Face Hub, which\n            will be used to resolve the base URL for the serverless Inference Endpoints API requests.\n            Defaults to `None`.\n        endpoint_name: the name of the Inference Endpoint to use for the LLM. Defaults to `None`.\n        endpoint_namespace: the namespace of the Inference Endpoint to use for the LLM. Defaults to `None`.\n        base_url: the base URL to use for the Inference Endpoints API requests.\n        api_key: the API key to authenticate the requests to the Inference Endpoints API.\n        tokenizer_id: the tokenizer ID to use for the LLM as available in the Hugging Face Hub.\n            Defaults to `None`, but defining one is recommended to properly format the prompt.\n        model_display_name: the model display name to use for the LLM. Defaults to `None`.\n        use_openai_client: whether to use the OpenAI client instead of the Hugging Face client.\n\n    Examples:\n        &gt;&gt;&gt; from distilabel.llms.huggingface import AsyncInferenceEndpointsLLM\n        &gt;&gt;&gt; llm = AsyncInferenceEndpointsLLM(model_id=\"model-id\")\n        &gt;&gt;&gt; llm.load()\n        &gt;&gt;&gt; output = await llm.agenerate([{\"role\": \"user\", \"content\": \"Hello world!\"}])\n    \"\"\"\n\n    model_id: Optional[str] = None\n\n    endpoint_name: Optional[RuntimeParameter[str]] = Field(\n        default=None,\n        description=\"The name of the Inference Endpoint to use for the LLM.\",\n    )\n    endpoint_namespace: Optional[RuntimeParameter[str]] = Field(\n        default=None,\n        description=\"The namespace of the Inference Endpoint to use for the LLM.\",\n    )\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default=None,\n        description=\"The base URL to use for the Inference Endpoints API requests.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default=os.getenv(_INFERENCE_ENDPOINTS_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Inference Endpoints API.\",\n    )\n\n    tokenizer_id: Optional[str] = None\n    model_display_name: Optional[str] = None\n    use_openai_client: bool = False\n\n    _model_name: Optional[str] = PrivateAttr(default=None)\n    _tokenizer: Optional[\"PreTrainedTokenizer\"] = PrivateAttr(default=None)\n    _api_key_env_var: str = PrivateAttr(_INFERENCE_ENDPOINTS_API_KEY_ENV_VAR_NAME)\n    _aclient: Optional[Union[\"AsyncInferenceClient\", \"AsyncOpenAI\"]] = PrivateAttr(...)\n\n    @model_validator(mode=\"after\")  # type: ignore\n    def only_one_of_model_id_endpoint_name_or_base_url_provided(\n        self,\n    ) -&gt; \"InferenceEndpointsLLM\":\n        \"\"\"Validates that only one of `model_id`, `endpoint_name`, or `base_url` is provided.\"\"\"\n\n        if self.model_id and (not self.endpoint_name and not self.base_url):\n            return self\n\n        if self.endpoint_name and (not self.model_id and not self.base_url):\n            return self\n\n        if self.base_url and (not self.model_id and not self.endpoint_name):\n            return self\n\n        raise ValidationError(\n            \"Only one of `model_id`, `endpoint_name`, or `base_url` must be provided. Found\"\n            f\" `model_id`={self.model_id}, `endpoint_name`={self.endpoint_name}, and\"\n            f\" `base_url`={self.base_url}.\"\n        )\n\n    def load(self) -&gt; None:  # noqa: C901\n        \"\"\"Loads the either the `AsyncInferenceClient` or the `AsyncOpenAI` client to benefit\n        from async requests, running the Hugging Face Inference Endpoint underneath via the\n        `/v1/chat/completions` endpoint, exposed for the models running on TGI using the\n        `text-generation` task.\n\n        Raises:\n            ImportError: if the `openai` Python client is not installed.\n            ImportError: if the `huggingface-hub` Python client is not installed.\n            ValueError: if the model is not currently deployed or is not running the TGI framework.\n            ImportError: if the `transformers` Python client is not installed.\n        \"\"\"\n        super().load()\n\n        try:\n            from huggingface_hub import (\n                AsyncInferenceClient,\n                InferenceClient,\n                get_inference_endpoint,\n            )\n        except ImportError as ie:\n            raise ImportError(\n                \"Hugging Face Hub Python client is not installed. Please install it using\"\n                \" `pip install huggingface-hub`.\"\n            ) from ie\n\n        if self.api_key is None:\n            raise ValueError(\n                f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n                f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n            )\n\n        if self.model_id is not None:\n            client = InferenceClient()\n            status = client.get_model_status(self.model_id)\n\n            if (\n                status.state not in {\"Loadable\", \"Loaded\"}\n                and status.framework != \"text-generation-inference\"\n            ):\n                raise ValueError(\n                    f\"Model {self.model_id} is not currently deployed or is not running the TGI framework\"\n                )\n\n            self.base_url = client._resolve_url(\n                model=self.model_id, task=\"text-generation\"\n            )\n\n        if self.endpoint_name is not None:\n            client = get_inference_endpoint(\n                name=self.endpoint_name,\n                namespace=self.endpoint_namespace,\n                token=self.api_key.get_secret_value(),\n            )\n            if client.status in [\"paused\", \"scaledToZero\"]:\n                client.resume().wait(timeout=300)\n            elif client.status in [\"initializing\"]:\n                client.wait(timeout=300)\n\n            self.base_url = client.url\n            self._model_name = client.repository\n\n        if self.use_openai_client:\n            try:\n                from openai import AsyncOpenAI\n            except ImportError as ie:\n                raise ImportError(\n                    \"OpenAI Python client is not installed. Please install it using\"\n                    \" `pip install openai`.\"\n                ) from ie\n\n            self._aclient = AsyncOpenAI(\n                base_url=self.base_url,\n                api_key=self.api_key.get_secret_value(),\n                max_retries=6,\n            )\n        else:\n            self._aclient = AsyncInferenceClient(\n                model=self.base_url,\n                token=self.api_key.get_secret_value(),\n            )\n\n        if self.tokenizer_id:\n            try:\n                from transformers import AutoTokenizer\n            except ImportError as ie:\n                raise ImportError(\n                    \"Transformers Python client is not installed. Please install it using\"\n                    \" `pip install transformers`.\"\n                ) from ie\n\n            self._tokenizer = AutoTokenizer.from_pretrained(self.tokenizer_id)\n\n    @property\n    @override\n    def model_name(self) -&gt; Union[str, None]:  # type: ignore\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return (\n            self.model_display_name\n            or self._model_name\n            or self.model_id\n            or self.endpoint_name\n            or self.base_url\n        )\n\n    async def _openai_agenerate(\n        self,\n        input: \"ChatType\",\n        max_new_tokens: int = 128,\n        frequency_penalty: float = 0.0,\n        presence_penalty: float = 0.0,\n        temperature: float = 1.0,\n        top_p: Optional[float] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates completions for the given input using the OpenAI async client.\"\"\"\n        completion = await self._aclient.chat.completions.create(  # type: ignore\n            messages=input,  # type: ignore\n            model=\"tgi\",\n            max_tokens=max_new_tokens,\n            n=1,\n            frequency_penalty=frequency_penalty,\n            presence_penalty=presence_penalty,\n            temperature=temperature,\n            top_p=top_p,\n            timeout=50,\n        )\n        if completion.choices[0].message.content is None:\n            self._logger.warning(\n                f\"\u26a0\ufe0f Received no response using OpenAI client (model: '{self.model_name}').\"\n                f\" Finish reason was: {completion.choices[0].finish_reason}\"\n            )\n        return [completion.choices[0].message.content]\n\n    # TODO: add `num_generations` parameter once either TGI or `AsyncInferenceClient` allows `n` parameter\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        max_new_tokens: int = 128,\n        frequency_penalty: float = 0.0,\n        presence_penalty: float = 0.0,\n        repetition_penalty: Optional[float] = None,\n        temperature: float = 1.0,\n        do_sample: bool = False,\n        top_k: Optional[int] = None,\n        top_p: Optional[float] = None,\n        typical_p: Optional[float] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates completions for the given input using the OpenAI async client.\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            frequency_penalty: the repetition penalty to use for the generation. Defaults\n                to `0.0`. Only applies if `use_openai_client=True`.\n            presence_penalty: the presence penalty to use for the generation. Defaults to\n                `0.0`. Only applies if `use_openai_client=True`.\n            repetition_penalty: the repetition penalty to use for the generation. Defaults\n                to `None`. Only applies if `use_openai_client=False`.\n            temperature: the temperature to use for the generation. Defaults to `1.0`.\n            do_sample: whether to use sampling for the generation. Defaults to `False`.\n                Only applies if `use_openai_client=False`.\n            top_k: the top-k value to use for the generation. Defaults to `0.8`, since neither\n                `0.0` nor `1.0` are valid values in TGI.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n            typical_p: the typical-p value to use for the generation. Defaults to `0.5`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n\n        if self.use_openai_client:\n            return await self._openai_agenerate(\n                input=input,\n                max_new_tokens=max_new_tokens,\n                frequency_penalty=frequency_penalty,\n                presence_penalty=presence_penalty,\n                temperature=temperature,\n                top_p=top_p,\n            )\n\n        if self._tokenizer is not None:\n            prompt = self._tokenizer.apply_chat_template(  # type: ignore\n                conversation=input,  # type: ignore\n                tokenize=False,\n                add_generation_prompt=True,\n            )\n        else:\n            prompt = \"\\n\".join([message[\"content\"] for message in input])\n\n        try:\n            completion = await self._aclient.text_generation(  # type: ignore\n                prompt=prompt,  # type: ignore\n                max_new_tokens=max_new_tokens,\n                do_sample=do_sample,\n                typical_p=typical_p,\n                repetition_penalty=repetition_penalty,\n                temperature=temperature,\n                top_p=top_p,\n                top_k=top_k,\n            )\n            return [completion]\n        except Exception as e:\n            self._logger.warning(\n                f\"\u26a0\ufe0f Received no response using Inference Client (model: '{self.model_name}').\"\n                f\" Finish reason was: {e}\"\n            )\n            return [None]\n\n    # TODO: remove this function once `AsyncInferenceClient` allows `n` parameter\n    @override\n    def generate(\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        **kwargs: Any,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Method to generate a list of responses asynchronously, returning the output\n        synchronously awaiting for the response of each input sent to `agenerate`.\n        \"\"\"\n\n        async def agenerate(\n            inputs: List[\"ChatType\"], **kwargs: Any\n        ) -&gt; \"GenerateOutput\":\n            \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n            tasks = [\n                asyncio.create_task(self.agenerate(input=input, **kwargs))\n                for input in inputs\n                for _ in range(num_generations)\n            ]\n            return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n        outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n        return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"api/llms/huggingface/#distilabel.llms.huggingface.inference_endpoints.InferenceEndpointsLLM.model_name","title":"<code>model_name: Union[str, None]</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"api/llms/huggingface/#distilabel.llms.huggingface.inference_endpoints.InferenceEndpointsLLM.agenerate","title":"<code>agenerate(input, max_new_tokens=128, frequency_penalty=0.0, presence_penalty=0.0, repetition_penalty=None, temperature=1.0, do_sample=False, top_k=None, top_p=None, typical_p=None)</code>  <code>async</code>","text":"<p>Generates completions for the given input using the OpenAI async client.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>max_new_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>frequency_penalty</code> <code>float</code> <p>the repetition penalty to use for the generation. Defaults to <code>0.0</code>. Only applies if <code>use_openai_client=True</code>.</p> <code>0.0</code> <code>presence_penalty</code> <code>float</code> <p>the presence penalty to use for the generation. Defaults to <code>0.0</code>. Only applies if <code>use_openai_client=True</code>.</p> <code>0.0</code> <code>repetition_penalty</code> <code>Optional[float]</code> <p>the repetition penalty to use for the generation. Defaults to <code>None</code>. Only applies if <code>use_openai_client=False</code>.</p> <code>None</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>do_sample</code> <code>bool</code> <p>whether to use sampling for the generation. Defaults to <code>False</code>. Only applies if <code>use_openai_client=False</code>.</p> <code>False</code> <code>top_k</code> <code>Optional[int]</code> <p>the top-k value to use for the generation. Defaults to <code>0.8</code>, since neither <code>0.0</code> nor <code>1.0</code> are valid values in TGI.</p> <code>None</code> <code>top_p</code> <code>Optional[float]</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>None</code> <code>typical_p</code> <code>Optional[float]</code> <p>the typical-p value to use for the generation. Defaults to <code>0.5</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>GenerateOutput</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    max_new_tokens: int = 128,\n    frequency_penalty: float = 0.0,\n    presence_penalty: float = 0.0,\n    repetition_penalty: Optional[float] = None,\n    temperature: float = 1.0,\n    do_sample: bool = False,\n    top_k: Optional[int] = None,\n    top_p: Optional[float] = None,\n    typical_p: Optional[float] = None,\n) -&gt; \"GenerateOutput\":\n    \"\"\"Generates completions for the given input using the OpenAI async client.\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        frequency_penalty: the repetition penalty to use for the generation. Defaults\n            to `0.0`. Only applies if `use_openai_client=True`.\n        presence_penalty: the presence penalty to use for the generation. Defaults to\n            `0.0`. Only applies if `use_openai_client=True`.\n        repetition_penalty: the repetition penalty to use for the generation. Defaults\n            to `None`. Only applies if `use_openai_client=False`.\n        temperature: the temperature to use for the generation. Defaults to `1.0`.\n        do_sample: whether to use sampling for the generation. Defaults to `False`.\n            Only applies if `use_openai_client=False`.\n        top_k: the top-k value to use for the generation. Defaults to `0.8`, since neither\n            `0.0` nor `1.0` are valid values in TGI.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n        typical_p: the typical-p value to use for the generation. Defaults to `0.5`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n\n    if self.use_openai_client:\n        return await self._openai_agenerate(\n            input=input,\n            max_new_tokens=max_new_tokens,\n            frequency_penalty=frequency_penalty,\n            presence_penalty=presence_penalty,\n            temperature=temperature,\n            top_p=top_p,\n        )\n\n    if self._tokenizer is not None:\n        prompt = self._tokenizer.apply_chat_template(  # type: ignore\n            conversation=input,  # type: ignore\n            tokenize=False,\n            add_generation_prompt=True,\n        )\n    else:\n        prompt = \"\\n\".join([message[\"content\"] for message in input])\n\n    try:\n        completion = await self._aclient.text_generation(  # type: ignore\n            prompt=prompt,  # type: ignore\n            max_new_tokens=max_new_tokens,\n            do_sample=do_sample,\n            typical_p=typical_p,\n            repetition_penalty=repetition_penalty,\n            temperature=temperature,\n            top_p=top_p,\n            top_k=top_k,\n        )\n        return [completion]\n    except Exception as e:\n        self._logger.warning(\n            f\"\u26a0\ufe0f Received no response using Inference Client (model: '{self.model_name}').\"\n            f\" Finish reason was: {e}\"\n        )\n        return [None]\n</code></pre>"},{"location":"api/llms/huggingface/#distilabel.llms.huggingface.inference_endpoints.InferenceEndpointsLLM.generate","title":"<code>generate(inputs, num_generations=1, **kwargs)</code>","text":"<p>Method to generate a list of responses asynchronously, returning the output synchronously awaiting for the response of each input sent to <code>agenerate</code>.</p> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>@override\ndef generate(\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    **kwargs: Any,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Method to generate a list of responses asynchronously, returning the output\n    synchronously awaiting for the response of each input sent to `agenerate`.\n    \"\"\"\n\n    async def agenerate(\n        inputs: List[\"ChatType\"], **kwargs: Any\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n        tasks = [\n            asyncio.create_task(self.agenerate(input=input, **kwargs))\n            for input in inputs\n            for _ in range(num_generations)\n        ]\n        return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n    outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n    return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"api/llms/huggingface/#distilabel.llms.huggingface.inference_endpoints.InferenceEndpointsLLM.load","title":"<code>load()</code>","text":"<p>Loads the either the <code>AsyncInferenceClient</code> or the <code>AsyncOpenAI</code> client to benefit from async requests, running the Hugging Face Inference Endpoint underneath via the <code>/v1/chat/completions</code> endpoint, exposed for the models running on TGI using the <code>text-generation</code> task.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>if the <code>openai</code> Python client is not installed.</p> <code>ImportError</code> <p>if the <code>huggingface-hub</code> Python client is not installed.</p> <code>ValueError</code> <p>if the model is not currently deployed or is not running the TGI framework.</p> <code>ImportError</code> <p>if the <code>transformers</code> Python client is not installed.</p> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>def load(self) -&gt; None:  # noqa: C901\n    \"\"\"Loads the either the `AsyncInferenceClient` or the `AsyncOpenAI` client to benefit\n    from async requests, running the Hugging Face Inference Endpoint underneath via the\n    `/v1/chat/completions` endpoint, exposed for the models running on TGI using the\n    `text-generation` task.\n\n    Raises:\n        ImportError: if the `openai` Python client is not installed.\n        ImportError: if the `huggingface-hub` Python client is not installed.\n        ValueError: if the model is not currently deployed or is not running the TGI framework.\n        ImportError: if the `transformers` Python client is not installed.\n    \"\"\"\n    super().load()\n\n    try:\n        from huggingface_hub import (\n            AsyncInferenceClient,\n            InferenceClient,\n            get_inference_endpoint,\n        )\n    except ImportError as ie:\n        raise ImportError(\n            \"Hugging Face Hub Python client is not installed. Please install it using\"\n            \" `pip install huggingface-hub`.\"\n        ) from ie\n\n    if self.api_key is None:\n        raise ValueError(\n            f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n            f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n        )\n\n    if self.model_id is not None:\n        client = InferenceClient()\n        status = client.get_model_status(self.model_id)\n\n        if (\n            status.state not in {\"Loadable\", \"Loaded\"}\n            and status.framework != \"text-generation-inference\"\n        ):\n            raise ValueError(\n                f\"Model {self.model_id} is not currently deployed or is not running the TGI framework\"\n            )\n\n        self.base_url = client._resolve_url(\n            model=self.model_id, task=\"text-generation\"\n        )\n\n    if self.endpoint_name is not None:\n        client = get_inference_endpoint(\n            name=self.endpoint_name,\n            namespace=self.endpoint_namespace,\n            token=self.api_key.get_secret_value(),\n        )\n        if client.status in [\"paused\", \"scaledToZero\"]:\n            client.resume().wait(timeout=300)\n        elif client.status in [\"initializing\"]:\n            client.wait(timeout=300)\n\n        self.base_url = client.url\n        self._model_name = client.repository\n\n    if self.use_openai_client:\n        try:\n            from openai import AsyncOpenAI\n        except ImportError as ie:\n            raise ImportError(\n                \"OpenAI Python client is not installed. Please install it using\"\n                \" `pip install openai`.\"\n            ) from ie\n\n        self._aclient = AsyncOpenAI(\n            base_url=self.base_url,\n            api_key=self.api_key.get_secret_value(),\n            max_retries=6,\n        )\n    else:\n        self._aclient = AsyncInferenceClient(\n            model=self.base_url,\n            token=self.api_key.get_secret_value(),\n        )\n\n    if self.tokenizer_id:\n        try:\n            from transformers import AutoTokenizer\n        except ImportError as ie:\n            raise ImportError(\n                \"Transformers Python client is not installed. Please install it using\"\n                \" `pip install transformers`.\"\n            ) from ie\n\n        self._tokenizer = AutoTokenizer.from_pretrained(self.tokenizer_id)\n</code></pre>"},{"location":"api/llms/huggingface/#distilabel.llms.huggingface.inference_endpoints.InferenceEndpointsLLM.only_one_of_model_id_endpoint_name_or_base_url_provided","title":"<code>only_one_of_model_id_endpoint_name_or_base_url_provided()</code>","text":"<p>Validates that only one of <code>model_id</code>, <code>endpoint_name</code>, or <code>base_url</code> is provided.</p> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>@model_validator(mode=\"after\")  # type: ignore\ndef only_one_of_model_id_endpoint_name_or_base_url_provided(\n    self,\n) -&gt; \"InferenceEndpointsLLM\":\n    \"\"\"Validates that only one of `model_id`, `endpoint_name`, or `base_url` is provided.\"\"\"\n\n    if self.model_id and (not self.endpoint_name and not self.base_url):\n        return self\n\n    if self.endpoint_name and (not self.model_id and not self.base_url):\n        return self\n\n    if self.base_url and (not self.model_id and not self.endpoint_name):\n        return self\n\n    raise ValidationError(\n        \"Only one of `model_id`, `endpoint_name`, or `base_url` must be provided. Found\"\n        f\" `model_id`={self.model_id}, `endpoint_name`={self.endpoint_name}, and\"\n        f\" `base_url`={self.base_url}.\"\n    )\n</code></pre>"},{"location":"api/llms/huggingface/#transformers","title":"Transformers","text":""},{"location":"api/llms/huggingface/#distilabel.llms.huggingface.transformers.TransformersLLM","title":"<code>TransformersLLM</code>","text":"<p>             Bases: <code>LLM</code>, <code>CudaDevicePlacementMixin</code></p> <p>Hugging Face <code>transformers</code> library LLM implementation using the text generation pipeline.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model Hugging Face Hub repo id or a path to a directory containing the model weights and configuration files.</p> <code>revision</code> <code>str</code> <p>if <code>model</code> refers to a Hugging Face Hub repository, then the revision (e.g. a branch name or a commit id) to use. Defaults to <code>\"main\"</code>.</p> <code>torch_dtype</code> <code>str</code> <p>the torch dtype to use for the model e.g. \"float16\", \"float32\", etc. Defaults to <code>\"auto\"</code>.</p> <code>trust_remote_code</code> <code>bool</code> <p>whether to trust or not remote (code in the Hugging Face Hub repository) code to load the model. Defaults to <code>False</code>.</p> <code>model_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>additional dictionary of keyword arguments that will be passed to the <code>from_pretrained</code> method of the model.</p> <code>tokenizer</code> <code>Optional[str]</code> <p>the tokenizer Hugging Face Hub repo id or a path to a directory containing the tokenizer config files. If not provided, the one associated to the <code>model</code> will be used. Defaults to <code>None</code>.</p> <code>use_fast</code> <code>bool</code> <p>whether to use a fast tokenizer or not. Defaults to <code>True</code>.</p> <code>chat_template</code> <code>Optional[str]</code> <p>a chat template that will be used to build the prompts before sending them to the model. If not provided, the chat template defined in the tokenizer config will be used. If not provided and the tokenizer doesn't have a chat template, then ChatML template will be used. Defaults to <code>None</code>.</p> <code>device</code> <code>Optional[Union[str, int]]</code> <p>the name or index of the device where the model will be loaded. Defaults to <code>None</code>.</p> <code>device_map</code> <code>Optional[Union[str, Dict[str, Any]]]</code> <p>a dictionary mapping each layer of the model to a device, or a mode like <code>\"sequential\"</code> or <code>\"auto\"</code>. Defaults to <code>None</code>.</p> <code>token</code> <code>Optional[str]</code> <p>the Hugging Face Hub token that will be used to authenticate to the Hugging Face Hub. If not provided, the <code>HF_TOKEN</code> environment or <code>huggingface_hub</code> package local configuration will be used. Defaults to <code>None</code>.</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>class TransformersLLM(LLM, CudaDevicePlacementMixin):\n    \"\"\"Hugging Face `transformers` library LLM implementation using the text generation\n    pipeline.\n\n    Attributes:\n        model: the model Hugging Face Hub repo id or a path to a directory containing the\n            model weights and configuration files.\n        revision: if `model` refers to a Hugging Face Hub repository, then the revision\n            (e.g. a branch name or a commit id) to use. Defaults to `\"main\"`.\n        torch_dtype: the torch dtype to use for the model e.g. \"float16\", \"float32\", etc.\n            Defaults to `\"auto\"`.\n        trust_remote_code: whether to trust or not remote (code in the Hugging Face Hub\n            repository) code to load the model. Defaults to `False`.\n        model_kwargs: additional dictionary of keyword arguments that will be passed to\n            the `from_pretrained` method of the model.\n        tokenizer: the tokenizer Hugging Face Hub repo id or a path to a directory containing\n            the tokenizer config files. If not provided, the one associated to the `model`\n            will be used. Defaults to `None`.\n        use_fast: whether to use a fast tokenizer or not. Defaults to `True`.\n        chat_template: a chat template that will be used to build the prompts before\n            sending them to the model. If not provided, the chat template defined in the\n            tokenizer config will be used. If not provided and the tokenizer doesn't have\n            a chat template, then ChatML template will be used. Defaults to `None`.\n        device: the name or index of the device where the model will be loaded. Defaults\n            to `None`.\n        device_map: a dictionary mapping each layer of the model to a device, or a mode\n            like `\"sequential\"` or `\"auto\"`. Defaults to `None`.\n        token: the Hugging Face Hub token that will be used to authenticate to the Hugging\n            Face Hub. If not provided, the `HF_TOKEN` environment or `huggingface_hub` package\n            local configuration will be used. Defaults to `None`.\n    \"\"\"\n\n    model: str\n    revision: str = \"main\"\n    torch_dtype: str = \"auto\"\n    trust_remote_code: bool = False\n    model_kwargs: Optional[Dict[str, Any]] = None\n    tokenizer: Optional[str] = None\n    use_fast: bool = True\n    chat_template: Optional[str] = None\n    device: Optional[Union[str, int]] = None\n    device_map: Optional[Union[str, Dict[str, Any]]] = None\n    token: Optional[str] = None\n\n    _pipeline: Optional[\"Pipeline\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the model and tokenizer and creates the text generation pipeline. In addition,\n        it will configure the tokenizer chat template.\"\"\"\n        super().load()\n\n        if self.device == \"cuda\":\n            CudaDevicePlacementMixin.load(self)\n\n        try:\n            from transformers import pipeline\n        except ImportError as ie:\n            raise ImportError(\n                \"Transformers is not installed. Please install it using `pip install transformers`.\"\n            ) from ie\n\n        self._pipeline = pipeline(\n            \"text-generation\",\n            model=self.model,\n            revision=self.revision,\n            torch_dtype=self.torch_dtype,\n            trust_remote_code=self.trust_remote_code,\n            model_kwargs=self.model_kwargs or {},\n            tokenizer=self.tokenizer or self.model,\n            use_fast=self.use_fast,\n            device=self.device,\n            device_map=self.device_map,\n            token=self.token or os.getenv(\"HF_TOKEN\"),\n            return_full_text=False,\n        )\n\n        if self.chat_template is not None:\n            self._pipeline.tokenizer.chat_template = self.chat_template  # type: ignore\n        elif (\n            self._pipeline.tokenizer.chat_template is None  # type: ignore\n            and self._pipeline.tokenizer.default_chat_template is None  # type: ignore\n        ):\n            self._pipeline.tokenizer.chat_template = CHATML_TEMPLATE  # type: ignore\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    def prepare_input(self, input: \"ChatType\") -&gt; str:\n        \"\"\"Prepares the input by applying the chat template to the input, which is formatted\n        as an OpenAI conversation, and adding the generation prompt.\n        \"\"\"\n        return self._pipeline.tokenizer.apply_chat_template(  # type: ignore\n            input,  # type: ignore\n            tokenize=False,\n            add_generation_prompt=True,\n        )\n\n    def generate(  # type: ignore\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        max_new_tokens: int = 128,\n        temperature: float = 0.1,\n        repetition_penalty: float = 1.1,\n        top_p: float = 1.0,\n        top_k: int = 0,\n        do_sample: bool = True,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Generates `num_generations` responses for each input using the text generation\n        pipeline.\n\n        Args:\n            inputs: a list of inputs in chat format to generate responses for.\n            num_generations: the number of generations to create per input. Defaults to\n                `1`.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            temperature: the temperature to use for the generation. Defaults to `0.1`.\n            repetition_penalty: the repetition penalty to use for the generation. Defaults\n                to `1.1`.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n            top_k: the top-k value to use for the generation. Defaults to `0`.\n            do_sample: whether to use sampling or not. Defaults to `True`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        outputs: List[List[Dict[str, str]]] = self._pipeline(  # type: ignore\n            [self.prepare_input(input=input) for input in inputs],\n            max_new_tokens=max_new_tokens,\n            temperature=temperature,\n            repetition_penalty=repetition_penalty,\n            top_p=top_p,\n            top_k=top_k,\n            do_sample=do_sample,\n            num_return_sequences=num_generations,\n        )\n        return [\n            [generation[\"generated_text\"] for generation in output]\n            for output in outputs\n        ]\n\n    def get_last_hidden_states(self, inputs: List[\"ChatType\"]) -&gt; List[\"HiddenState\"]:\n        \"\"\"Gets the last `hidden_states` of the model for the given inputs. It doesn't\n        execute the task head.\n\n        Args:\n            inputs: a list of inputs in chat format to generate the embeddings for.\n\n        Returns:\n            A list containing the last hidden state for each sequence using a NumPy array\n            with shape [num_tokens, hidden_size].\n        \"\"\"\n        model: \"PreTrainedModel\" = (\n            self._pipeline.model.model  # type: ignore\n            if hasattr(self._pipeline.model, \"model\")  # type: ignore\n            else next(self._pipeline.model.children())  # type: ignore\n        )\n        tokenizer: \"PreTrainedTokenizer\" = self._pipeline.tokenizer  # type: ignore\n        input_ids = tokenizer(\n            [self.prepare_input(input) for input in inputs],  # type: ignore\n            return_tensors=\"pt\",\n            padding=True,\n        ).to(model.device)\n        last_hidden_states = model(**input_ids)[\"last_hidden_state\"]\n\n        return [\n            seq_last_hidden_state[attention_mask.bool(), :].detach().cpu().numpy()\n            for seq_last_hidden_state, attention_mask in zip(\n                last_hidden_states,\n                input_ids[\"attention_mask\"],  # type: ignore\n            )\n        ]\n</code></pre>"},{"location":"api/llms/huggingface/#distilabel.llms.huggingface.transformers.TransformersLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"api/llms/huggingface/#distilabel.llms.huggingface.transformers.TransformersLLM.generate","title":"<code>generate(inputs, num_generations=1, max_new_tokens=128, temperature=0.1, repetition_penalty=1.1, top_p=1.0, top_k=0, do_sample=True)</code>","text":"<p>Generates <code>num_generations</code> responses for each input using the text generation pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>List[ChatType]</code> <p>a list of inputs in chat format to generate responses for.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to create per input. Defaults to <code>1</code>.</p> <code>1</code> <code>max_new_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Defaults to <code>0.1</code>.</p> <code>0.1</code> <code>repetition_penalty</code> <code>float</code> <p>the repetition penalty to use for the generation. Defaults to <code>1.1</code>.</p> <code>1.1</code> <code>top_p</code> <code>float</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>top_k</code> <code>int</code> <p>the top-k value to use for the generation. Defaults to <code>0</code>.</p> <code>0</code> <code>do_sample</code> <code>bool</code> <p>whether to use sampling or not. Defaults to <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>List[GenerateOutput]</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>def generate(  # type: ignore\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    max_new_tokens: int = 128,\n    temperature: float = 0.1,\n    repetition_penalty: float = 1.1,\n    top_p: float = 1.0,\n    top_k: int = 0,\n    do_sample: bool = True,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Generates `num_generations` responses for each input using the text generation\n    pipeline.\n\n    Args:\n        inputs: a list of inputs in chat format to generate responses for.\n        num_generations: the number of generations to create per input. Defaults to\n            `1`.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        temperature: the temperature to use for the generation. Defaults to `0.1`.\n        repetition_penalty: the repetition penalty to use for the generation. Defaults\n            to `1.1`.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n        top_k: the top-k value to use for the generation. Defaults to `0`.\n        do_sample: whether to use sampling or not. Defaults to `True`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    outputs: List[List[Dict[str, str]]] = self._pipeline(  # type: ignore\n        [self.prepare_input(input=input) for input in inputs],\n        max_new_tokens=max_new_tokens,\n        temperature=temperature,\n        repetition_penalty=repetition_penalty,\n        top_p=top_p,\n        top_k=top_k,\n        do_sample=do_sample,\n        num_return_sequences=num_generations,\n    )\n    return [\n        [generation[\"generated_text\"] for generation in output]\n        for output in outputs\n    ]\n</code></pre>"},{"location":"api/llms/huggingface/#distilabel.llms.huggingface.transformers.TransformersLLM.get_last_hidden_states","title":"<code>get_last_hidden_states(inputs)</code>","text":"<p>Gets the last <code>hidden_states</code> of the model for the given inputs. It doesn't execute the task head.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>List[ChatType]</code> <p>a list of inputs in chat format to generate the embeddings for.</p> required <p>Returns:</p> Type Description <code>List[HiddenState]</code> <p>A list containing the last hidden state for each sequence using a NumPy array</p> <code>List[HiddenState]</code> <p>with shape [num_tokens, hidden_size].</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>def get_last_hidden_states(self, inputs: List[\"ChatType\"]) -&gt; List[\"HiddenState\"]:\n    \"\"\"Gets the last `hidden_states` of the model for the given inputs. It doesn't\n    execute the task head.\n\n    Args:\n        inputs: a list of inputs in chat format to generate the embeddings for.\n\n    Returns:\n        A list containing the last hidden state for each sequence using a NumPy array\n        with shape [num_tokens, hidden_size].\n    \"\"\"\n    model: \"PreTrainedModel\" = (\n        self._pipeline.model.model  # type: ignore\n        if hasattr(self._pipeline.model, \"model\")  # type: ignore\n        else next(self._pipeline.model.children())  # type: ignore\n    )\n    tokenizer: \"PreTrainedTokenizer\" = self._pipeline.tokenizer  # type: ignore\n    input_ids = tokenizer(\n        [self.prepare_input(input) for input in inputs],  # type: ignore\n        return_tensors=\"pt\",\n        padding=True,\n    ).to(model.device)\n    last_hidden_states = model(**input_ids)[\"last_hidden_state\"]\n\n    return [\n        seq_last_hidden_state[attention_mask.bool(), :].detach().cpu().numpy()\n        for seq_last_hidden_state, attention_mask in zip(\n            last_hidden_states,\n            input_ids[\"attention_mask\"],  # type: ignore\n        )\n    ]\n</code></pre>"},{"location":"api/llms/huggingface/#distilabel.llms.huggingface.transformers.TransformersLLM.load","title":"<code>load()</code>","text":"<p>Loads the model and tokenizer and creates the text generation pipeline. In addition, it will configure the tokenizer chat template.</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the model and tokenizer and creates the text generation pipeline. In addition,\n    it will configure the tokenizer chat template.\"\"\"\n    super().load()\n\n    if self.device == \"cuda\":\n        CudaDevicePlacementMixin.load(self)\n\n    try:\n        from transformers import pipeline\n    except ImportError as ie:\n        raise ImportError(\n            \"Transformers is not installed. Please install it using `pip install transformers`.\"\n        ) from ie\n\n    self._pipeline = pipeline(\n        \"text-generation\",\n        model=self.model,\n        revision=self.revision,\n        torch_dtype=self.torch_dtype,\n        trust_remote_code=self.trust_remote_code,\n        model_kwargs=self.model_kwargs or {},\n        tokenizer=self.tokenizer or self.model,\n        use_fast=self.use_fast,\n        device=self.device,\n        device_map=self.device_map,\n        token=self.token or os.getenv(\"HF_TOKEN\"),\n        return_full_text=False,\n    )\n\n    if self.chat_template is not None:\n        self._pipeline.tokenizer.chat_template = self.chat_template  # type: ignore\n    elif (\n        self._pipeline.tokenizer.chat_template is None  # type: ignore\n        and self._pipeline.tokenizer.default_chat_template is None  # type: ignore\n    ):\n        self._pipeline.tokenizer.chat_template = CHATML_TEMPLATE  # type: ignore\n</code></pre>"},{"location":"api/llms/huggingface/#distilabel.llms.huggingface.transformers.TransformersLLM.prepare_input","title":"<code>prepare_input(input)</code>","text":"<p>Prepares the input by applying the chat template to the input, which is formatted as an OpenAI conversation, and adding the generation prompt.</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>def prepare_input(self, input: \"ChatType\") -&gt; str:\n    \"\"\"Prepares the input by applying the chat template to the input, which is formatted\n    as an OpenAI conversation, and adding the generation prompt.\n    \"\"\"\n    return self._pipeline.tokenizer.apply_chat_template(  # type: ignore\n        input,  # type: ignore\n        tokenize=False,\n        add_generation_prompt=True,\n    )\n</code></pre>"},{"location":"api/llms/litellm/","title":"Litellm","text":""},{"location":"api/llms/litellm/#litellm","title":"LiteLLM","text":""},{"location":"api/llms/litellm/#distilabel.llms.litellm.LiteLLM","title":"<code>LiteLLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>LiteLLM implementation running the async API client.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model name to use for the LLM e.g. \"gpt-3.5-turbo\" or \"mistral/mistral-large\", etc.</p> <code>verbose</code> <code>RuntimeParameter[bool]</code> <p>whether to log the LiteLLM client's logs. Defaults to <code>False</code>.</p> Runtime parameters <ul> <li><code>verbose</code>: whether to log the LiteLLM client's logs. Defaults to <code>False</code>.</li> </ul> Source code in <code>src/distilabel/llms/litellm.py</code> <pre><code>class LiteLLM(AsyncLLM):\n    \"\"\"LiteLLM implementation running the async API client.\n\n    Attributes:\n        model: the model name to use for the LLM e.g. \"gpt-3.5-turbo\" or \"mistral/mistral-large\", etc.\n        verbose: whether to log the LiteLLM client's logs. Defaults to `False`.\n\n    Runtime parameters:\n        - `verbose`: whether to log the LiteLLM client's logs. Defaults to `False`.\n    \"\"\"\n\n    model: str\n    verbose: RuntimeParameter[bool] = Field(\n        default=False, description=\"Whether to log the LiteLLM client's logs.\"\n    )\n\n    _aclient: Optional[Callable] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"\n        Loads the `acompletion` LiteLLM client to benefit from async requests.\n        \"\"\"\n        super().load()\n\n        try:\n            import litellm\n\n            litellm.telemetry = False\n        except ImportError as e:\n            raise ImportError(\n                \"LiteLLM Python client is not installed. Please install it using\"\n                \" `pip install litellm`.\"\n            ) from e\n        self._aclient = litellm.acompletion\n\n        if not self.verbose:\n            litellm.suppress_debug_info = True\n            for key in logging.Logger.manager.loggerDict.keys():\n                if \"litellm\" not in key.lower():\n                    continue\n                logging.getLogger(key).setLevel(logging.CRITICAL)\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        num_generations: int = 1,\n        functions: Optional[List] = None,\n        function_call: Optional[str] = None,\n        temperature: Optional[float] = 1.0,\n        top_p: Optional[float] = 1.0,\n        stop: Optional[Union[str, list]] = None,\n        max_tokens: Optional[int] = None,\n        presence_penalty: Optional[float] = None,\n        frequency_penalty: Optional[float] = None,\n        logit_bias: Optional[dict] = None,\n        user: Optional[str] = None,\n        metadata: Optional[dict] = None,\n        api_base: Optional[str] = None,\n        api_version: Optional[str] = None,\n        api_key: Optional[str] = None,\n        model_list: Optional[list] = None,\n        mock_response: Optional[str] = None,\n        force_timeout: Optional[int] = 600,\n        custom_llm_provider: Optional[str] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates `num_generations` responses for the given input using the [LiteLLM async client](https://github.com/BerriAI/litellm).\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            num_generations: the number of generations to create per input. Defaults to\n                `1`.\n            functions: a list of functions to apply to the conversation messages. Defaults to\n                `None`.\n            function_call: the name of the function to call within the conversation. Defaults\n                to `None`.\n            temperature: the temperature to use for the generation. Defaults to `1.0`.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n            stop: Up to 4 sequences where the LLM API will stop generating further tokens.\n                Defaults to `None`.\n            max_tokens: The maximum number of tokens in the generated completion. Defaults to\n                `None`.\n            presence_penalty: It is used to penalize new tokens based on their existence in the\n                text so far. Defaults to `None`.\n            frequency_penalty: It is used to penalize new tokens based on their frequency in the\n                text so far. Defaults to `None`.\n            logit_bias: Used to modify the probability of specific tokens appearing in the\n                completion. Defaults to `None`.\n            user: A unique identifier representing your end-user. This can help the LLM provider\n                to monitor and detect abuse. Defaults to `None`.\n            metadata: Pass in additional metadata to tag your completion calls - eg. prompt\n                version, details, etc. Defaults to `None`.\n            api_base: Base URL for the API. Defaults to `None`.\n            api_version: API version. Defaults to `None`.\n            api_key: API key. Defaults to `None`.\n            model_list: List of api base, version, keys. Defaults to `None`.\n            mock_response: If provided, return a mock completion response for testing or debugging\n                purposes. Defaults to `None`.\n            force_timeout: The maximum execution time in seconds for the completion request.\n                Defaults to `600`.\n            custom_llm_provider: Used for Non-OpenAI LLMs, Example usage for bedrock, set(iterable)\n                model=\"amazon.titan-tg1-large\" and custom_llm_provider=\"bedrock\". Defaults to\n                `None`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        import litellm\n\n        async def _call_aclient_until_n_choices() -&gt; List[\"Choices\"]:\n            choices = []\n            while len(choices) &lt; num_generations:\n                completion = await self._aclient(  # type: ignore\n                    model=self.model,\n                    messages=input,\n                    n=num_generations,\n                    functions=functions,\n                    function_call=function_call,\n                    temperature=temperature,\n                    top_p=top_p,\n                    stream=False,\n                    stop=stop,\n                    max_tokens=max_tokens,\n                    presence_penalty=presence_penalty,\n                    frequency_penalty=frequency_penalty,\n                    logit_bias=logit_bias,\n                    user=user,\n                    metadata=metadata,\n                    api_base=api_base,\n                    api_version=api_version,\n                    api_key=api_key,\n                    model_list=model_list,\n                    mock_response=mock_response,\n                    force_timeout=force_timeout,\n                    custom_llm_provider=custom_llm_provider,\n                )\n                choices.extend(completion.choices)\n            return choices\n\n        # litellm.drop_params is used to en/disable sending **kwargs parameters to the API if they cannot be used\n        try:\n            litellm.drop_params = False\n            choices = await _call_aclient_until_n_choices()\n        except litellm.exceptions.APIError as e:\n            if \"does not support parameters\" in str(e):\n                litellm.drop_params = True\n                choices = await _call_aclient_until_n_choices()\n            else:\n                raise e\n\n        generations = []\n        for choice in choices:\n            if (content := choice.message.content) is None:\n                self._logger.warning(\n                    f\"Received no response using LiteLLM client (model: '{self.model}').\"\n                    f\" Finish reason was: {choice.finish_reason}\"\n                )\n            generations.append(content)\n        return generations\n</code></pre>"},{"location":"api/llms/litellm/#distilabel.llms.litellm.LiteLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"api/llms/litellm/#distilabel.llms.litellm.LiteLLM.agenerate","title":"<code>agenerate(input, num_generations=1, functions=None, function_call=None, temperature=1.0, top_p=1.0, stop=None, max_tokens=None, presence_penalty=None, frequency_penalty=None, logit_bias=None, user=None, metadata=None, api_base=None, api_version=None, api_key=None, model_list=None, mock_response=None, force_timeout=600, custom_llm_provider=None)</code>  <code>async</code>","text":"<p>Generates <code>num_generations</code> responses for the given input using the LiteLLM async client.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to create per input. Defaults to <code>1</code>.</p> <code>1</code> <code>functions</code> <code>Optional[List]</code> <p>a list of functions to apply to the conversation messages. Defaults to <code>None</code>.</p> <code>None</code> <code>function_call</code> <code>Optional[str]</code> <p>the name of the function to call within the conversation. Defaults to <code>None</code>.</p> <code>None</code> <code>temperature</code> <code>Optional[float]</code> <p>the temperature to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>top_p</code> <code>Optional[float]</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>stop</code> <code>Optional[Union[str, list]]</code> <p>Up to 4 sequences where the LLM API will stop generating further tokens. Defaults to <code>None</code>.</p> <code>None</code> <code>max_tokens</code> <code>Optional[int]</code> <p>The maximum number of tokens in the generated completion. Defaults to <code>None</code>.</p> <code>None</code> <code>presence_penalty</code> <code>Optional[float]</code> <p>It is used to penalize new tokens based on their existence in the text so far. Defaults to <code>None</code>.</p> <code>None</code> <code>frequency_penalty</code> <code>Optional[float]</code> <p>It is used to penalize new tokens based on their frequency in the text so far. Defaults to <code>None</code>.</p> <code>None</code> <code>logit_bias</code> <code>Optional[dict]</code> <p>Used to modify the probability of specific tokens appearing in the completion. Defaults to <code>None</code>.</p> <code>None</code> <code>user</code> <code>Optional[str]</code> <p>A unique identifier representing your end-user. This can help the LLM provider to monitor and detect abuse. Defaults to <code>None</code>.</p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>Pass in additional metadata to tag your completion calls - eg. prompt version, details, etc. Defaults to <code>None</code>.</p> <code>None</code> <code>api_base</code> <code>Optional[str]</code> <p>Base URL for the API. Defaults to <code>None</code>.</p> <code>None</code> <code>api_version</code> <code>Optional[str]</code> <p>API version. Defaults to <code>None</code>.</p> <code>None</code> <code>api_key</code> <code>Optional[str]</code> <p>API key. Defaults to <code>None</code>.</p> <code>None</code> <code>model_list</code> <code>Optional[list]</code> <p>List of api base, version, keys. Defaults to <code>None</code>.</p> <code>None</code> <code>mock_response</code> <code>Optional[str]</code> <p>If provided, return a mock completion response for testing or debugging purposes. Defaults to <code>None</code>.</p> <code>None</code> <code>force_timeout</code> <code>Optional[int]</code> <p>The maximum execution time in seconds for the completion request. Defaults to <code>600</code>.</p> <code>600</code> <code>custom_llm_provider</code> <code>Optional[str]</code> <p>Used for Non-OpenAI LLMs, Example usage for bedrock, set(iterable) model=\"amazon.titan-tg1-large\" and custom_llm_provider=\"bedrock\". Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>GenerateOutput</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/litellm.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    num_generations: int = 1,\n    functions: Optional[List] = None,\n    function_call: Optional[str] = None,\n    temperature: Optional[float] = 1.0,\n    top_p: Optional[float] = 1.0,\n    stop: Optional[Union[str, list]] = None,\n    max_tokens: Optional[int] = None,\n    presence_penalty: Optional[float] = None,\n    frequency_penalty: Optional[float] = None,\n    logit_bias: Optional[dict] = None,\n    user: Optional[str] = None,\n    metadata: Optional[dict] = None,\n    api_base: Optional[str] = None,\n    api_version: Optional[str] = None,\n    api_key: Optional[str] = None,\n    model_list: Optional[list] = None,\n    mock_response: Optional[str] = None,\n    force_timeout: Optional[int] = 600,\n    custom_llm_provider: Optional[str] = None,\n) -&gt; \"GenerateOutput\":\n    \"\"\"Generates `num_generations` responses for the given input using the [LiteLLM async client](https://github.com/BerriAI/litellm).\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        num_generations: the number of generations to create per input. Defaults to\n            `1`.\n        functions: a list of functions to apply to the conversation messages. Defaults to\n            `None`.\n        function_call: the name of the function to call within the conversation. Defaults\n            to `None`.\n        temperature: the temperature to use for the generation. Defaults to `1.0`.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n        stop: Up to 4 sequences where the LLM API will stop generating further tokens.\n            Defaults to `None`.\n        max_tokens: The maximum number of tokens in the generated completion. Defaults to\n            `None`.\n        presence_penalty: It is used to penalize new tokens based on their existence in the\n            text so far. Defaults to `None`.\n        frequency_penalty: It is used to penalize new tokens based on their frequency in the\n            text so far. Defaults to `None`.\n        logit_bias: Used to modify the probability of specific tokens appearing in the\n            completion. Defaults to `None`.\n        user: A unique identifier representing your end-user. This can help the LLM provider\n            to monitor and detect abuse. Defaults to `None`.\n        metadata: Pass in additional metadata to tag your completion calls - eg. prompt\n            version, details, etc. Defaults to `None`.\n        api_base: Base URL for the API. Defaults to `None`.\n        api_version: API version. Defaults to `None`.\n        api_key: API key. Defaults to `None`.\n        model_list: List of api base, version, keys. Defaults to `None`.\n        mock_response: If provided, return a mock completion response for testing or debugging\n            purposes. Defaults to `None`.\n        force_timeout: The maximum execution time in seconds for the completion request.\n            Defaults to `600`.\n        custom_llm_provider: Used for Non-OpenAI LLMs, Example usage for bedrock, set(iterable)\n            model=\"amazon.titan-tg1-large\" and custom_llm_provider=\"bedrock\". Defaults to\n            `None`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    import litellm\n\n    async def _call_aclient_until_n_choices() -&gt; List[\"Choices\"]:\n        choices = []\n        while len(choices) &lt; num_generations:\n            completion = await self._aclient(  # type: ignore\n                model=self.model,\n                messages=input,\n                n=num_generations,\n                functions=functions,\n                function_call=function_call,\n                temperature=temperature,\n                top_p=top_p,\n                stream=False,\n                stop=stop,\n                max_tokens=max_tokens,\n                presence_penalty=presence_penalty,\n                frequency_penalty=frequency_penalty,\n                logit_bias=logit_bias,\n                user=user,\n                metadata=metadata,\n                api_base=api_base,\n                api_version=api_version,\n                api_key=api_key,\n                model_list=model_list,\n                mock_response=mock_response,\n                force_timeout=force_timeout,\n                custom_llm_provider=custom_llm_provider,\n            )\n            choices.extend(completion.choices)\n        return choices\n\n    # litellm.drop_params is used to en/disable sending **kwargs parameters to the API if they cannot be used\n    try:\n        litellm.drop_params = False\n        choices = await _call_aclient_until_n_choices()\n    except litellm.exceptions.APIError as e:\n        if \"does not support parameters\" in str(e):\n            litellm.drop_params = True\n            choices = await _call_aclient_until_n_choices()\n        else:\n            raise e\n\n    generations = []\n    for choice in choices:\n        if (content := choice.message.content) is None:\n            self._logger.warning(\n                f\"Received no response using LiteLLM client (model: '{self.model}').\"\n                f\" Finish reason was: {choice.finish_reason}\"\n            )\n        generations.append(content)\n    return generations\n</code></pre>"},{"location":"api/llms/litellm/#distilabel.llms.litellm.LiteLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>acompletion</code> LiteLLM client to benefit from async requests.</p> Source code in <code>src/distilabel/llms/litellm.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"\n    Loads the `acompletion` LiteLLM client to benefit from async requests.\n    \"\"\"\n    super().load()\n\n    try:\n        import litellm\n\n        litellm.telemetry = False\n    except ImportError as e:\n        raise ImportError(\n            \"LiteLLM Python client is not installed. Please install it using\"\n            \" `pip install litellm`.\"\n        ) from e\n    self._aclient = litellm.acompletion\n\n    if not self.verbose:\n        litellm.suppress_debug_info = True\n        for key in logging.Logger.manager.loggerDict.keys():\n            if \"litellm\" not in key.lower():\n                continue\n            logging.getLogger(key).setLevel(logging.CRITICAL)\n</code></pre>"},{"location":"api/llms/llamacpp/","title":"Llamacpp","text":""},{"location":"api/llms/llamacpp/#llamacppllm","title":"LlamacppLLM","text":""},{"location":"api/llms/llamacpp/#distilabel.llms.llamacpp.LlamaCppLLM","title":"<code>LlamaCppLLM</code>","text":"<p>             Bases: <code>LLM</code></p> <p>llama.cpp LLM implementation running the Python bindings for the C++ code.</p> <p>Attributes:</p> Name Type Description <code>chat_format</code> <code>str</code> <p>the chat format to use for the model. Defaults to <code>chatml</code>.</p> <code>model_path</code> <code>RuntimeParameter[FilePath]</code> <p>contains the path to the GGUF quantized model, compatible with the installed version of the <code>llama.cpp</code> Python bindings.</p> <code>n_gpu_layers</code> <code>RuntimeParameter[int]</code> <p>the number of layers to use for the GPU. Defaults to <code>-1</code>, meaning that the available GPU device will be used.</p> <code>verbose</code> <code>RuntimeParameter[bool]</code> <p>whether to print verbose output. Defaults to <code>False</code>.</p> <code>_model</code> <code>Optional[Llama]</code> <p>the Llama model instance. This attribute is meant to be used internally and should not be accessed directly. It will be set in the <code>load</code> method.</p> Runtime parameters <ul> <li><code>model_path</code>: the path to the GGUF quantized model.</li> <li><code>n_gpu_layers</code>: the number of layers to use for the GPU. Defaults to <code>-1</code>.</li> <li><code>verbose</code>: whether to print verbose output. Defaults to <code>False</code>.</li> </ul> Source code in <code>src/distilabel/llms/llamacpp.py</code> <pre><code>class LlamaCppLLM(LLM):\n    \"\"\"llama.cpp LLM implementation running the Python bindings for the C++ code.\n\n    Attributes:\n        chat_format: the chat format to use for the model. Defaults to `chatml`.\n        model_path: contains the path to the GGUF quantized model, compatible with the\n            installed version of the `llama.cpp` Python bindings.\n        n_gpu_layers: the number of layers to use for the GPU. Defaults to `-1`, meaning that\n            the available GPU device will be used.\n        verbose: whether to print verbose output. Defaults to `False`.\n        _model: the Llama model instance. This attribute is meant to be used internally and\n            should not be accessed directly. It will be set in the `load` method.\n\n    Runtime parameters:\n        - `model_path`: the path to the GGUF quantized model.\n        - `n_gpu_layers`: the number of layers to use for the GPU. Defaults to `-1`.\n        - `verbose`: whether to print verbose output. Defaults to `False`.\n    \"\"\"\n\n    chat_format: str = \"chatml\"\n    model_path: RuntimeParameter[FilePath] = Field(\n        default=None, description=\"The path to the GGUF quantized model.\"\n    )\n    n_gpu_layers: RuntimeParameter[int] = Field(\n        default=-1,\n        description=\"The number of layers that will be loaded in the GPU.\",\n    )\n    verbose: RuntimeParameter[bool] = Field(\n        default=False,\n        description=\"Whether to print verbose output from llama.cpp library.\",\n    )\n\n    _model: Optional[\"Llama\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `Llama` model from the `model_path`.\"\"\"\n\n        try:\n            from llama_cpp import Llama\n        except ImportError as ie:\n            raise ImportError(\n                \"The `llama_cpp` package is required to use the `LlamaCppLLM` class.\"\n            ) from ie\n\n        self._model = Llama(\n            model_path=self.model_path.as_posix(),\n            chat_format=self.chat_format,\n            n_gpu_layers=self.n_gpu_layers,\n            verbose=self.verbose,\n        )\n\n        super().load()\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self._model.model_path  # type: ignore\n\n    def generate(  # type: ignore\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        max_new_tokens: int = 128,\n        frequency_penalty: float = 0.0,\n        presence_penalty: float = 0.0,\n        temperature: float = 1.0,\n        top_p: float = 1.0,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Generates `num_generations` responses for the given input using the Llama model.\n\n        Args:\n            inputs: a list of inputs in chat format to generate responses for.\n            num_generations: the number of generations to create per input. Defaults to\n                `1`.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            frequency_penalty: the repetition penalty to use for the generation. Defaults\n                to `0.0`.\n            presence_penalty: the presence penalty to use for the generation. Defaults to\n                `0.0`.\n            temperature: the temperature to use for the generation. Defaults to `0.1`.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        batch_outputs = []\n        for input in inputs:\n            outputs = []\n            for _ in range(num_generations):\n                chat_completions: \"CreateChatCompletionResponse\" = (\n                    self._model.create_chat_completion(  # type: ignore\n                        messages=input,  # type: ignore\n                        max_tokens=max_new_tokens,\n                        frequency_penalty=frequency_penalty,\n                        presence_penalty=presence_penalty,\n                        temperature=temperature,\n                        top_p=top_p,\n                    )\n                )\n                outputs.append(chat_completions[\"choices\"][0][\"message\"][\"content\"])\n            batch_outputs.append(outputs)\n        return batch_outputs\n</code></pre>"},{"location":"api/llms/llamacpp/#distilabel.llms.llamacpp.LlamaCppLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"api/llms/llamacpp/#distilabel.llms.llamacpp.LlamaCppLLM.generate","title":"<code>generate(inputs, num_generations=1, max_new_tokens=128, frequency_penalty=0.0, presence_penalty=0.0, temperature=1.0, top_p=1.0)</code>","text":"<p>Generates <code>num_generations</code> responses for the given input using the Llama model.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>List[ChatType]</code> <p>a list of inputs in chat format to generate responses for.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to create per input. Defaults to <code>1</code>.</p> <code>1</code> <code>max_new_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>frequency_penalty</code> <code>float</code> <p>the repetition penalty to use for the generation. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>presence_penalty</code> <code>float</code> <p>the presence penalty to use for the generation. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Defaults to <code>0.1</code>.</p> <code>1.0</code> <code>top_p</code> <code>float</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>List[GenerateOutput]</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/llamacpp.py</code> <pre><code>def generate(  # type: ignore\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    max_new_tokens: int = 128,\n    frequency_penalty: float = 0.0,\n    presence_penalty: float = 0.0,\n    temperature: float = 1.0,\n    top_p: float = 1.0,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Generates `num_generations` responses for the given input using the Llama model.\n\n    Args:\n        inputs: a list of inputs in chat format to generate responses for.\n        num_generations: the number of generations to create per input. Defaults to\n            `1`.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        frequency_penalty: the repetition penalty to use for the generation. Defaults\n            to `0.0`.\n        presence_penalty: the presence penalty to use for the generation. Defaults to\n            `0.0`.\n        temperature: the temperature to use for the generation. Defaults to `0.1`.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    batch_outputs = []\n    for input in inputs:\n        outputs = []\n        for _ in range(num_generations):\n            chat_completions: \"CreateChatCompletionResponse\" = (\n                self._model.create_chat_completion(  # type: ignore\n                    messages=input,  # type: ignore\n                    max_tokens=max_new_tokens,\n                    frequency_penalty=frequency_penalty,\n                    presence_penalty=presence_penalty,\n                    temperature=temperature,\n                    top_p=top_p,\n                )\n            )\n            outputs.append(chat_completions[\"choices\"][0][\"message\"][\"content\"])\n        batch_outputs.append(outputs)\n    return batch_outputs\n</code></pre>"},{"location":"api/llms/llamacpp/#distilabel.llms.llamacpp.LlamaCppLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>Llama</code> model from the <code>model_path</code>.</p> Source code in <code>src/distilabel/llms/llamacpp.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `Llama` model from the `model_path`.\"\"\"\n\n    try:\n        from llama_cpp import Llama\n    except ImportError as ie:\n        raise ImportError(\n            \"The `llama_cpp` package is required to use the `LlamaCppLLM` class.\"\n        ) from ie\n\n    self._model = Llama(\n        model_path=self.model_path.as_posix(),\n        chat_format=self.chat_format,\n        n_gpu_layers=self.n_gpu_layers,\n        verbose=self.verbose,\n    )\n\n    super().load()\n</code></pre>"},{"location":"api/llms/mistral/","title":"Mistral","text":""},{"location":"api/llms/mistral/#mistralllm","title":"MistralLLM","text":""},{"location":"api/llms/mistral/#distilabel.llms.mistral.MistralLLM","title":"<code>MistralLLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>Mistral LLM implementation running the async API client.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model name to use for the LLM e.g. \"mistral-tiny\", \"mistral-large\", etc.</p> <code>endpoint</code> <code>str</code> <p>the endpoint to use for the Mistral API. Defaults to \"https://api.mistral.ai\".</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Mistral API. Defaults to <code>None</code> which means that the value set for the environment variable <code>OPENAI_API_KEY</code> will be used, or <code>None</code> if not set.</p> <code>max_retries</code> <code>RuntimeParameter[int]</code> <p>the maximum number of retries to attempt when a request fails. Defaults to <code>5</code>.</p> <code>timeout</code> <code>RuntimeParameter[int]</code> <p>the maximum time in seconds to wait for a response. Defaults to <code>120</code>.</p> <code>max_concurrent_requests</code> <code>RuntimeParameter[int]</code> <p>the maximum number of concurrent requests to send. Defaults to <code>64</code>.</p> <code>_api_key_env_var</code> <code>str</code> <p>the name of the environment variable to use for the API key. It is meant to be used internally.</p> <code>_aclient</code> <code>Optional[MistralAsyncClient]</code> <p>the <code>MistralAsyncClient</code> to use for the Mistral API. It is meant to be used internally. Set in the <code>load</code> method.</p> Runtime parameters <ul> <li><code>api_key</code>: the API key to authenticate the requests to the Mistral API.</li> <li><code>max_retries</code>: the maximum number of retries to attempt when a request fails.     Defaults to <code>5</code>.</li> <li><code>timeout</code>: the maximum time in seconds to wait for a response. Defaults to <code>120</code>.</li> <li><code>max_concurrent_requests</code>: the maximum number of concurrent requests to send.     Defaults to <code>64</code>.</li> </ul> Source code in <code>src/distilabel/llms/mistral.py</code> <pre><code>class MistralLLM(AsyncLLM):\n    \"\"\"Mistral LLM implementation running the async API client.\n\n    Attributes:\n        model: the model name to use for the LLM e.g. \"mistral-tiny\", \"mistral-large\", etc.\n        endpoint: the endpoint to use for the Mistral API. Defaults to \"https://api.mistral.ai\".\n        api_key: the API key to authenticate the requests to the Mistral API. Defaults to `None` which\n            means that the value set for the environment variable `OPENAI_API_KEY` will be used, or\n            `None` if not set.\n        max_retries: the maximum number of retries to attempt when a request fails. Defaults to `5`.\n        timeout: the maximum time in seconds to wait for a response. Defaults to `120`.\n        max_concurrent_requests: the maximum number of concurrent requests to send. Defaults\n            to `64`.\n        _api_key_env_var: the name of the environment variable to use for the API key. It is meant to\n            be used internally.\n        _aclient: the `MistralAsyncClient` to use for the Mistral API. It is meant to be used internally.\n            Set in the `load` method.\n\n    Runtime parameters:\n        - `api_key`: the API key to authenticate the requests to the Mistral API.\n        - `max_retries`: the maximum number of retries to attempt when a request fails.\n            Defaults to `5`.\n        - `timeout`: the maximum time in seconds to wait for a response. Defaults to `120`.\n        - `max_concurrent_requests`: the maximum number of concurrent requests to send.\n            Defaults to `64`.\n    \"\"\"\n\n    model: str\n    endpoint: str = \"https://api.mistral.ai\"\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_MISTRALAI_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Mistral API.\",\n    )\n    max_retries: RuntimeParameter[int] = Field(\n        default=6,\n        description=\"The maximum number of times to retry the request to the API before\"\n        \" failing.\",\n    )\n    timeout: RuntimeParameter[int] = Field(\n        default=120,\n        description=\"The maximum time in seconds to wait for a response from the API.\",\n    )\n    max_concurrent_requests: RuntimeParameter[int] = Field(\n        default=64, description=\"The maximum number of concurrent requests to send.\"\n    )\n\n    _api_key_env_var: str = PrivateAttr(_MISTRALAI_API_KEY_ENV_VAR_NAME)\n    _aclient: Optional[\"MistralAsyncClient\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `MistralAsyncClient` client to benefit from async requests.\"\"\"\n        super().load()\n\n        try:\n            from mistralai.async_client import MistralAsyncClient\n        except ImportError as ie:\n            raise ImportError(\n                \"MistralAI Python client is not installed. Please install it using\"\n                \" `pip install mistralai`.\"\n            ) from ie\n\n        if self.api_key is None:\n            raise ValueError(\n                f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n                f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n            )\n\n        self._aclient = MistralAsyncClient(\n            api_key=self.api_key.get_secret_value(),\n            endpoint=self.endpoint,\n            max_retries=self.max_retries,\n            timeout=self.timeout,\n            max_concurrent_requests=self.max_concurrent_requests,\n        )\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    # TODO: add `num_generations` parameter once Mistral client allows `n` parameter\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        max_new_tokens: Optional[int] = None,\n        temperature: Optional[float] = None,\n        top_p: Optional[float] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates `num_generations` responses for the given input using the MistralAI async\n        client.\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            temperature: the temperature to use for the generation. Defaults to `0.1`.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        completion = await self._aclient.chat(  # type: ignore\n            messages=input,\n            model=self.model,\n            temperature=temperature,\n            max_tokens=max_new_tokens,\n            top_p=top_p,\n        )\n        generations = []\n        for choice in completion.choices:\n            if (content := choice.message.content) is None:\n                self._logger.warning(\n                    f\"Received no response using MistralAI client (model: '{self.model}').\"\n                    f\" Finish reason was: {choice.finish_reason}\"\n                )\n            generations.append(content)\n        return generations\n\n    # TODO: remove this function once Mistral client allows `n` parameter\n    @override\n    def generate(\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        **kwargs: Any,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Method to generate a list of responses asynchronously, returning the output\n        synchronously awaiting for the response of each input sent to `agenerate`.\n        \"\"\"\n\n        async def agenerate(\n            inputs: List[\"ChatType\"], **kwargs: Any\n        ) -&gt; \"GenerateOutput\":\n            \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n            tasks = [\n                asyncio.create_task(self.agenerate(input=input, **kwargs))\n                for input in inputs\n                for _ in range(num_generations)\n            ]\n            return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n        outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n        return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"api/llms/mistral/#distilabel.llms.mistral.MistralLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"api/llms/mistral/#distilabel.llms.mistral.MistralLLM.agenerate","title":"<code>agenerate(input, max_new_tokens=None, temperature=None, top_p=None)</code>  <code>async</code>","text":"<p>Generates <code>num_generations</code> responses for the given input using the MistralAI async client.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>max_new_tokens</code> <code>Optional[int]</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>None</code> <code>temperature</code> <code>Optional[float]</code> <p>the temperature to use for the generation. Defaults to <code>0.1</code>.</p> <code>None</code> <code>top_p</code> <code>Optional[float]</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>GenerateOutput</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/mistral.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    max_new_tokens: Optional[int] = None,\n    temperature: Optional[float] = None,\n    top_p: Optional[float] = None,\n) -&gt; \"GenerateOutput\":\n    \"\"\"Generates `num_generations` responses for the given input using the MistralAI async\n    client.\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        temperature: the temperature to use for the generation. Defaults to `0.1`.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    completion = await self._aclient.chat(  # type: ignore\n        messages=input,\n        model=self.model,\n        temperature=temperature,\n        max_tokens=max_new_tokens,\n        top_p=top_p,\n    )\n    generations = []\n    for choice in completion.choices:\n        if (content := choice.message.content) is None:\n            self._logger.warning(\n                f\"Received no response using MistralAI client (model: '{self.model}').\"\n                f\" Finish reason was: {choice.finish_reason}\"\n            )\n        generations.append(content)\n    return generations\n</code></pre>"},{"location":"api/llms/mistral/#distilabel.llms.mistral.MistralLLM.generate","title":"<code>generate(inputs, num_generations=1, **kwargs)</code>","text":"<p>Method to generate a list of responses asynchronously, returning the output synchronously awaiting for the response of each input sent to <code>agenerate</code>.</p> Source code in <code>src/distilabel/llms/mistral.py</code> <pre><code>@override\ndef generate(\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    **kwargs: Any,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Method to generate a list of responses asynchronously, returning the output\n    synchronously awaiting for the response of each input sent to `agenerate`.\n    \"\"\"\n\n    async def agenerate(\n        inputs: List[\"ChatType\"], **kwargs: Any\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n        tasks = [\n            asyncio.create_task(self.agenerate(input=input, **kwargs))\n            for input in inputs\n            for _ in range(num_generations)\n        ]\n        return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n    outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n    return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"api/llms/mistral/#distilabel.llms.mistral.MistralLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>MistralAsyncClient</code> client to benefit from async requests.</p> Source code in <code>src/distilabel/llms/mistral.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `MistralAsyncClient` client to benefit from async requests.\"\"\"\n    super().load()\n\n    try:\n        from mistralai.async_client import MistralAsyncClient\n    except ImportError as ie:\n        raise ImportError(\n            \"MistralAI Python client is not installed. Please install it using\"\n            \" `pip install mistralai`.\"\n        ) from ie\n\n    if self.api_key is None:\n        raise ValueError(\n            f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n            f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n        )\n\n    self._aclient = MistralAsyncClient(\n        api_key=self.api_key.get_secret_value(),\n        endpoint=self.endpoint,\n        max_retries=self.max_retries,\n        timeout=self.timeout,\n        max_concurrent_requests=self.max_concurrent_requests,\n    )\n</code></pre>"},{"location":"api/llms/ollama/","title":"Ollama","text":""},{"location":"api/llms/ollama/#ollamallm","title":"OllamaLLM","text":""},{"location":"api/llms/ollama/#distilabel.llms.ollama.OllamaLLM","title":"<code>OllamaLLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>Ollama LLM implementation running the Async API client.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model name to use for the LLM e.g. \"notus\".</p> <code>host</code> <code>Optional[RuntimeParameter[str]]</code> <p>the Ollama server host.</p> <code>timeout</code> <code>RuntimeParameter[int]</code> <p>the timeout for the LLM. Defaults to <code>120</code>.</p> <code>_aclient</code> <code>Optional[AsyncClient]</code> <p>the <code>AsyncClient</code> to use for the Ollama API. It is meant to be used internally. Set in the <code>load</code> method.</p> Runtime parameters <ul> <li><code>host</code>: the Ollama server host.</li> <li><code>timeout</code>: the client timeout for the Ollama API. Defaults to <code>120</code>.</li> </ul> Source code in <code>src/distilabel/llms/ollama.py</code> <pre><code>class OllamaLLM(AsyncLLM):\n    \"\"\"Ollama LLM implementation running the Async API client.\n\n    Attributes:\n        model: the model name to use for the LLM e.g. \"notus\".\n        host: the Ollama server host.\n        timeout: the timeout for the LLM. Defaults to `120`.\n        _aclient: the `AsyncClient` to use for the Ollama API. It is meant to be used internally.\n            Set in the `load` method.\n\n    Runtime parameters:\n        - `host`: the Ollama server host.\n        - `timeout`: the client timeout for the Ollama API. Defaults to `120`.\n    \"\"\"\n\n    model: str\n    host: Optional[RuntimeParameter[str]] = Field(\n        default=None, description=\"The host of the Ollama API.\"\n    )\n    timeout: RuntimeParameter[int] = Field(\n        default=120, description=\"The timeout for the Ollama API.\"\n    )\n    follow_redirects: bool = True\n\n    _aclient: Optional[\"AsyncClient\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `AsyncClient` to use Ollama async API.\"\"\"\n        super().load()\n\n        try:\n            from ollama import AsyncClient\n\n            self._aclient = AsyncClient(\n                host=self.host,\n                timeout=self.timeout,\n                follow_redirects=self.follow_redirects,\n            )\n        except ImportError as e:\n            raise ImportError(\n                \"Ollama Python client is not installed. Please install it using\"\n                \" `pip install ollama`.\"\n            ) from e\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        num_generations: int = 1,\n        format: Literal[\"\", \"json\"] = \"\",\n        options: Union[\"Options\", None] = None,\n        keep_alive: Union[bool, None] = None,\n    ) -&gt; List[str]:\n        \"\"\"\n        Generates a response asynchronously, using the [Ollama Async API definition](https://github.com/ollama/ollama-python).\n\n        Args:\n            input: the input to use for the generation.\n            num_generations: the number of generations to produce. Defaults to `1`.\n            format: the format to use for the generation. Defaults to `\"\"`.\n            options: the options to use for the generation. Defaults to `None`.\n            keep_alive: whether to keep the connection alive. Defaults to `None`.\n\n        Returns:\n            A list of strings as completion for the given input.\n        \"\"\"\n        generations = []\n        # TODO: remove this for-loop and override the `generate` method\n        for _ in range(num_generations):\n            completion = await self._aclient.chat(  # type: ignore\n                model=self.model,\n                messages=input,  # type: ignore\n                stream=False,\n                format=format,\n                options=options,\n                keep_alive=keep_alive,\n            )\n            # TODO: improve error handling\n            generations.append(completion[\"message\"][\"content\"])\n\n        return generations\n</code></pre>"},{"location":"api/llms/ollama/#distilabel.llms.ollama.OllamaLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"api/llms/ollama/#distilabel.llms.ollama.OllamaLLM.agenerate","title":"<code>agenerate(input, num_generations=1, format='', options=None, keep_alive=None)</code>  <code>async</code>","text":"<p>Generates a response asynchronously, using the Ollama Async API definition.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>the input to use for the generation.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to produce. Defaults to <code>1</code>.</p> <code>1</code> <code>format</code> <code>Literal['', 'json']</code> <p>the format to use for the generation. Defaults to <code>\"\"</code>.</p> <code>''</code> <code>options</code> <code>Union[Options, None]</code> <p>the options to use for the generation. Defaults to <code>None</code>.</p> <code>None</code> <code>keep_alive</code> <code>Union[bool, None]</code> <p>whether to keep the connection alive. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of strings as completion for the given input.</p> Source code in <code>src/distilabel/llms/ollama.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    num_generations: int = 1,\n    format: Literal[\"\", \"json\"] = \"\",\n    options: Union[\"Options\", None] = None,\n    keep_alive: Union[bool, None] = None,\n) -&gt; List[str]:\n    \"\"\"\n    Generates a response asynchronously, using the [Ollama Async API definition](https://github.com/ollama/ollama-python).\n\n    Args:\n        input: the input to use for the generation.\n        num_generations: the number of generations to produce. Defaults to `1`.\n        format: the format to use for the generation. Defaults to `\"\"`.\n        options: the options to use for the generation. Defaults to `None`.\n        keep_alive: whether to keep the connection alive. Defaults to `None`.\n\n    Returns:\n        A list of strings as completion for the given input.\n    \"\"\"\n    generations = []\n    # TODO: remove this for-loop and override the `generate` method\n    for _ in range(num_generations):\n        completion = await self._aclient.chat(  # type: ignore\n            model=self.model,\n            messages=input,  # type: ignore\n            stream=False,\n            format=format,\n            options=options,\n            keep_alive=keep_alive,\n        )\n        # TODO: improve error handling\n        generations.append(completion[\"message\"][\"content\"])\n\n    return generations\n</code></pre>"},{"location":"api/llms/ollama/#distilabel.llms.ollama.OllamaLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>AsyncClient</code> to use Ollama async API.</p> Source code in <code>src/distilabel/llms/ollama.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `AsyncClient` to use Ollama async API.\"\"\"\n    super().load()\n\n    try:\n        from ollama import AsyncClient\n\n        self._aclient = AsyncClient(\n            host=self.host,\n            timeout=self.timeout,\n            follow_redirects=self.follow_redirects,\n        )\n    except ImportError as e:\n        raise ImportError(\n            \"Ollama Python client is not installed. Please install it using\"\n            \" `pip install ollama`.\"\n        ) from e\n</code></pre>"},{"location":"api/llms/openai/","title":"Openai","text":""},{"location":"api/llms/openai/#openaillm","title":"OpenaiLLM","text":""},{"location":"api/llms/openai/#distilabel.llms.openai.OpenAILLM","title":"<code>OpenAILLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>OpenAI LLM implementation running the async API client.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model name to use for the LLM e.g. \"gpt-3.5-turbo\", \"gpt-4\", etc. Supported models can be found here.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the OpenAI API requests. Defaults to <code>None</code>, which means that the value set for the environment variable <code>OPENAI_BASE_URL</code> will be used, or \"https://api.openai.com/v1\" if not set.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the OpenAI API. Defaults to <code>None</code> which means that the value set for the environment variable <code>OPENAI_API_KEY</code> will be used, or <code>None</code> if not set.</p> <code>max_retries</code> <code>RuntimeParameter[int]</code> <p>the maximum number of times to retry the request to the API before failing. Defaults to <code>6</code>.</p> <code>timeout</code> <code>RuntimeParameter[int]</code> <p>the maximum time in seconds to wait for a response from the API. Defaults to <code>120</code>.</p> Runtime parameters <ul> <li><code>base_url</code>: the base URL to use for the OpenAI API requests. Defaults to <code>None</code>.</li> <li><code>api_key</code>: the API key to authenticate the requests to the OpenAI API. Defaults     to <code>None</code>.</li> <li><code>max_retries</code>: the maximum number of times to retry the request to the API before     failing. Defaults to <code>6</code>.</li> <li><code>timeout</code>: the maximum time in seconds to wait for a response from the API. Defaults     to <code>120</code>.</li> </ul> Source code in <code>src/distilabel/llms/openai.py</code> <pre><code>class OpenAILLM(AsyncLLM):\n    \"\"\"OpenAI LLM implementation running the async API client.\n\n    Attributes:\n        model: the model name to use for the LLM e.g. \"gpt-3.5-turbo\", \"gpt-4\", etc.\n            Supported models can be found [here](https://platform.openai.com/docs/guides/text-generation).\n        base_url: the base URL to use for the OpenAI API requests. Defaults to `None`, which\n            means that the value set for the environment variable `OPENAI_BASE_URL` will\n            be used, or \"https://api.openai.com/v1\" if not set.\n        api_key: the API key to authenticate the requests to the OpenAI API. Defaults to\n            `None` which means that the value set for the environment variable `OPENAI_API_KEY`\n            will be used, or `None` if not set.\n        max_retries: the maximum number of times to retry the request to the API before\n            failing. Defaults to `6`.\n        timeout: the maximum time in seconds to wait for a response from the API. Defaults\n            to `120`.\n\n    Runtime parameters:\n        - `base_url`: the base URL to use for the OpenAI API requests. Defaults to `None`.\n        - `api_key`: the API key to authenticate the requests to the OpenAI API. Defaults\n            to `None`.\n        - `max_retries`: the maximum number of times to retry the request to the API before\n            failing. Defaults to `6`.\n        - `timeout`: the maximum time in seconds to wait for a response from the API. Defaults\n            to `120`.\n    \"\"\"\n\n    model: str\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(\n            \"OPENAI_BASE_URL\", \"https://api.openai.com/v1\"\n        ),\n        description=\"The base URL to use for the OpenAI API requests.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_OPENAI_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the OpenAI API.\",\n    )\n    max_retries: RuntimeParameter[int] = Field(\n        default=6,\n        description=\"The maximum number of times to retry the request to the API before\"\n        \" failing.\",\n    )\n    timeout: RuntimeParameter[int] = Field(\n        default=120,\n        description=\"The maximum time in seconds to wait for a response from the API.\",\n    )\n\n    _api_key_env_var: str = PrivateAttr(_OPENAI_API_KEY_ENV_VAR_NAME)\n    _aclient: Optional[\"AsyncOpenAI\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `AsyncOpenAI` client to benefit from async requests.\"\"\"\n        super().load()\n\n        try:\n            from openai import AsyncOpenAI\n        except ImportError as ie:\n            raise ImportError(\n                \"OpenAI Python client is not installed. Please install it using\"\n                \" `pip install openai`.\"\n            ) from ie\n\n        if self.api_key is None:\n            raise ValueError(\n                f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n                f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n            )\n\n        self._aclient = AsyncOpenAI(\n            base_url=self.base_url,\n            api_key=self.api_key.get_secret_value(),\n            max_retries=self.max_retries,\n            timeout=self.timeout,\n        )\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        num_generations: int = 1,\n        max_new_tokens: int = 128,\n        frequency_penalty: float = 0.0,\n        presence_penalty: float = 0.0,\n        temperature: float = 1.0,\n        top_p: float = 1.0,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates `num_generations` responses for the given input using the OpenAI async\n        client.\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            num_generations: the number of generations to create per input. Defaults to\n                `1`.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            frequency_penalty: the repetition penalty to use for the generation. Defaults\n                to `0.0`.\n            presence_penalty: the presence penalty to use for the generation. Defaults to\n                `0.0`.\n            temperature: the temperature to use for the generation. Defaults to `0.1`.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        completion = await self._aclient.chat.completions.create(  # type: ignore\n            messages=input,  # type: ignore\n            model=self.model,\n            max_tokens=max_new_tokens,\n            n=num_generations,\n            frequency_penalty=frequency_penalty,\n            presence_penalty=presence_penalty,\n            temperature=temperature,\n            top_p=top_p,\n            timeout=50,\n        )\n        generations = []\n        for choice in completion.choices:\n            if (content := choice.message.content) is None:\n                self._logger.warning(\n                    f\"Received no response using OpenAI client (model: '{self.model}').\"\n                    f\" Finish reason was: {choice.finish_reason}\"\n                )\n            generations.append(content)\n        return generations\n</code></pre>"},{"location":"api/llms/openai/#distilabel.llms.openai.OpenAILLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"api/llms/openai/#distilabel.llms.openai.OpenAILLM.agenerate","title":"<code>agenerate(input, num_generations=1, max_new_tokens=128, frequency_penalty=0.0, presence_penalty=0.0, temperature=1.0, top_p=1.0)</code>  <code>async</code>","text":"<p>Generates <code>num_generations</code> responses for the given input using the OpenAI async client.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to create per input. Defaults to <code>1</code>.</p> <code>1</code> <code>max_new_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>frequency_penalty</code> <code>float</code> <p>the repetition penalty to use for the generation. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>presence_penalty</code> <code>float</code> <p>the presence penalty to use for the generation. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Defaults to <code>0.1</code>.</p> <code>1.0</code> <code>top_p</code> <code>float</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>GenerateOutput</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/openai.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    num_generations: int = 1,\n    max_new_tokens: int = 128,\n    frequency_penalty: float = 0.0,\n    presence_penalty: float = 0.0,\n    temperature: float = 1.0,\n    top_p: float = 1.0,\n) -&gt; \"GenerateOutput\":\n    \"\"\"Generates `num_generations` responses for the given input using the OpenAI async\n    client.\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        num_generations: the number of generations to create per input. Defaults to\n            `1`.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        frequency_penalty: the repetition penalty to use for the generation. Defaults\n            to `0.0`.\n        presence_penalty: the presence penalty to use for the generation. Defaults to\n            `0.0`.\n        temperature: the temperature to use for the generation. Defaults to `0.1`.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    completion = await self._aclient.chat.completions.create(  # type: ignore\n        messages=input,  # type: ignore\n        model=self.model,\n        max_tokens=max_new_tokens,\n        n=num_generations,\n        frequency_penalty=frequency_penalty,\n        presence_penalty=presence_penalty,\n        temperature=temperature,\n        top_p=top_p,\n        timeout=50,\n    )\n    generations = []\n    for choice in completion.choices:\n        if (content := choice.message.content) is None:\n            self._logger.warning(\n                f\"Received no response using OpenAI client (model: '{self.model}').\"\n                f\" Finish reason was: {choice.finish_reason}\"\n            )\n        generations.append(content)\n    return generations\n</code></pre>"},{"location":"api/llms/openai/#distilabel.llms.openai.OpenAILLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>AsyncOpenAI</code> client to benefit from async requests.</p> Source code in <code>src/distilabel/llms/openai.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `AsyncOpenAI` client to benefit from async requests.\"\"\"\n    super().load()\n\n    try:\n        from openai import AsyncOpenAI\n    except ImportError as ie:\n        raise ImportError(\n            \"OpenAI Python client is not installed. Please install it using\"\n            \" `pip install openai`.\"\n        ) from ie\n\n    if self.api_key is None:\n        raise ValueError(\n            f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n            f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n        )\n\n    self._aclient = AsyncOpenAI(\n        base_url=self.base_url,\n        api_key=self.api_key.get_secret_value(),\n        max_retries=self.max_retries,\n        timeout=self.timeout,\n    )\n</code></pre>"},{"location":"api/llms/together/","title":"Together","text":""},{"location":"api/llms/together/#togetherllm","title":"TogetherLLM","text":""},{"location":"api/llms/together/#distilabel.llms.together.TogetherLLM","title":"<code>TogetherLLM</code>","text":"<p>             Bases: <code>OpenAILLM</code></p> <p>TogetherLLM LLM implementation running the async API client of OpenAI because of duplicate API behavior.</p> <p>Attributes:</p> Name Type Description <code>model</code> <p>the model name to use for the LLM e.g. \"mistralai/Mixtral-8x7B-Instruct-v0.1\". Supported models can be found here.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the Together API can be set with <code>TOGETHER_BASE_URL</code>. Defaults to <code>None</code> which means that the value set for the environment variable <code>TOGETHER_BASE_URL</code> will be used, or \"https://api.together.xyz/v1\" if not set.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Together API. Defaults to <code>None</code> which means that the value set for the environment variable <code>TOGETHER_API_KEY</code> will be used, or <code>None</code> if not set.</p> <code>_api_key_env_var</code> <code>str</code> <p>the name of the environment variable to use for the API key. It is meant to be used internally.</p> Source code in <code>src/distilabel/llms/together.py</code> <pre><code>class TogetherLLM(OpenAILLM):\n    \"\"\"TogetherLLM LLM implementation running the async API client of OpenAI because of\n    duplicate API behavior.\n\n    Attributes:\n        model: the model name to use for the LLM e.g. \"mistralai/Mixtral-8x7B-Instruct-v0.1\".\n            Supported models can be found [here](https://api.together.xyz/models).\n        base_url: the base URL to use for the Together API can be set with `TOGETHER_BASE_URL`.\n            Defaults to `None` which means that the value set for the environment variable\n            `TOGETHER_BASE_URL` will be used, or \"https://api.together.xyz/v1\" if not set.\n        api_key: the API key to authenticate the requests to the Together API. Defaults to `None`\n            which means that the value set for the environment variable `TOGETHER_API_KEY` will be\n            used, or `None` if not set.\n        _api_key_env_var: the name of the environment variable to use for the API key. It\n            is meant to be used internally.\n    \"\"\"\n\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(\n            \"TOGETHER_BASE_URL\", \"https://api.together.xyz/v1\"\n        ),\n        description=\"The base URL to use for the Together API requests.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_TOGETHER_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Together API.\",\n    )\n\n    _api_key_env_var: str = PrivateAttr(_TOGETHER_API_KEY_ENV_VAR_NAME)\n</code></pre>"},{"location":"api/llms/vertexai/","title":"Vertexai","text":""},{"location":"api/llms/vertexai/#vertexaillm","title":"VertexaiLLM","text":""},{"location":"api/llms/vertexai/#distilabel.llms.vertexai.VertexAILLM","title":"<code>VertexAILLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>VertexAI LLM implementation running the async API clients for Gemini.</p> <ul> <li>Gemini API: https://cloud.google.com/vertex-ai/docs/generative-ai/model-reference/gemini</li> </ul> <p>To use the <code>VertexAILLM</code> is necessary to have configured the Google Cloud authentication using one of these methods:</p> <ul> <li>Setting <code>GOOGLE_CLOUD_CREDENTIALS</code> environment variable</li> <li>Using <code>gcloud auth application-default login</code> command</li> <li>Using <code>vertexai.init</code> function from the <code>google-cloud-aiplatform</code> library</li> </ul> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model name to use for the LLM e.g. \"gemini-1.0-pro\". Supported models.</p> <code>_aclient</code> <code>Optional[GenerativeModel]</code> <p>the <code>GenerativeModel</code> to use for the Vertex AI Gemini API. It is meant to be used internally. Set in the <code>load</code> method.</p> Source code in <code>src/distilabel/llms/vertexai.py</code> <pre><code>class VertexAILLM(AsyncLLM):\n    \"\"\"VertexAI LLM implementation running the async API clients for Gemini.\n\n    - Gemini API: https://cloud.google.com/vertex-ai/docs/generative-ai/model-reference/gemini\n\n    To use the `VertexAILLM` is necessary to have configured the Google Cloud authentication\n    using one of these methods:\n\n    - Setting `GOOGLE_CLOUD_CREDENTIALS` environment variable\n    - Using `gcloud auth application-default login` command\n    - Using `vertexai.init` function from the `google-cloud-aiplatform` library\n\n    Attributes:\n        model: the model name to use for the LLM e.g. \"gemini-1.0-pro\". [Supported models](https://cloud.google.com/vertex-ai/generative-ai/docs/learn/models).\n        _aclient: the `GenerativeModel` to use for the Vertex AI Gemini API. It is meant\n            to be used internally. Set in the `load` method.\n    \"\"\"\n\n    model: str\n    _aclient: Optional[\"GenerativeModel\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `GenerativeModel` class which has access to `generate_content_async` to benefit from async requests.\"\"\"\n        super().load()\n\n        try:\n            from vertexai.generative_models import GenerationConfig, GenerativeModel\n\n            self._generation_config_class = GenerationConfig\n        except ImportError as e:\n            raise ImportError(\n                \"vertexai is not installed. Please install it using\"\n                \" `pip install google-cloud-aiplatform`.\"\n            ) from e\n\n        if _is_gemini_model(self.model):\n            self._aclient = GenerativeModel(model_name=self.model)\n        else:\n            raise NotImplementedError(\n                \"`VertexAILLM` is only implemented for `gemini` models that allow for `ChatType` data.\"\n            )\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    def _chattype_to_content(self, input: \"ChatType\") -&gt; List[\"Content\"]:\n        \"\"\"Converts a chat type to a list of content items expected by the API.\n\n        Args:\n            input: the chat type to be converted.\n\n        Returns:\n            List[str]: a list of content items expected by the API.\n        \"\"\"\n        from vertexai.generative_models import Content, Part\n\n        contents = []\n        for message in input:\n            if message[\"role\"] not in [\"user\", \"model\"]:\n                raise ValueError(\n                    \"`VertexAILLM only supports the roles 'user' or 'model'.\"\n                )\n            contents.append(\n                Content(\n                    role=message[\"role\"], parts=[Part.from_text(message[\"content\"])]\n                )\n            )\n        return contents\n\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        num_generations: int = 1,\n        temperature: Optional[float] = None,\n        top_p: Optional[float] = None,\n        top_k: Optional[int] = None,\n        max_output_tokens: Optional[int] = None,\n        stop_sequences: Optional[List[str]] = None,\n        safety_settings: Optional[\"SafetySettingsType\"] = None,\n        tools: Optional[List[\"Tool\"]] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates `num_generations` responses for the given input using the [VertexAI async client definition](https://cloud.google.com/vertex-ai/docs/generative-ai/model-reference/gemini).\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            num_generations: the number of generations to create per input. Defaults to\n                `1`.\n            temperature: Controls the randomness of predictions. Range: [0.0, 1.0]. Defaults to `None`.\n            top_p: If specified, nucleus sampling will be used. Range: (0.0, 1.0]. Defaults to `None`.\n            top_k: If specified, top-k sampling will be used. Defaults to `None`.\n            max_output_tokens: The maximum number of output tokens to generate per message. Defaults to `None`.\n            stop_sequences: A list of stop sequences. Defaults to `None`.\n            safety_settings: Safety configuration for returned content from the API. Defaults to `None`.\n            tools: A potential list of tools that can be used by the API. Defaults to `None`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        from vertexai.generative_models import GenerationConfig\n\n        contents = self._chattype_to_content(input)\n        generations = []\n        # TODO: remove this for-loop and override `generate`\n        for _ in range(num_generations):\n            content = await self._aclient.generate_content_async(  # type: ignore\n                contents=contents,\n                generation_config=GenerationConfig(\n                    candidate_count=1,  # only one candidate allowed per call\n                    temperature=temperature,\n                    top_k=top_k,\n                    top_p=top_p,\n                    max_output_tokens=max_output_tokens,\n                    stop_sequences=stop_sequences,\n                ),\n                safety_settings=safety_settings,\n                tools=tools,\n                stream=False,\n            )\n\n            text = None\n            try:\n                text = content.candidates[0].text\n            except ValueError:\n                self._logger.warning(\n                    f\"Received no response using VertexAI client (model: '{self.model}').\"\n                    f\" Finish reason was: '{content.candidates[0].finish_reason}'.\"\n                )\n            generations.append(text)\n\n        return generations\n</code></pre>"},{"location":"api/llms/vertexai/#distilabel.llms.vertexai.VertexAILLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"api/llms/vertexai/#distilabel.llms.vertexai.VertexAILLM.agenerate","title":"<code>agenerate(input, num_generations=1, temperature=None, top_p=None, top_k=None, max_output_tokens=None, stop_sequences=None, safety_settings=None, tools=None)</code>  <code>async</code>","text":"<p>Generates <code>num_generations</code> responses for the given input using the VertexAI async client definition.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to create per input. Defaults to <code>1</code>.</p> <code>1</code> <code>temperature</code> <code>Optional[float]</code> <p>Controls the randomness of predictions. Range: [0.0, 1.0]. Defaults to <code>None</code>.</p> <code>None</code> <code>top_p</code> <code>Optional[float]</code> <p>If specified, nucleus sampling will be used. Range: (0.0, 1.0]. Defaults to <code>None</code>.</p> <code>None</code> <code>top_k</code> <code>Optional[int]</code> <p>If specified, top-k sampling will be used. Defaults to <code>None</code>.</p> <code>None</code> <code>max_output_tokens</code> <code>Optional[int]</code> <p>The maximum number of output tokens to generate per message. Defaults to <code>None</code>.</p> <code>None</code> <code>stop_sequences</code> <code>Optional[List[str]]</code> <p>A list of stop sequences. Defaults to <code>None</code>.</p> <code>None</code> <code>safety_settings</code> <code>Optional[SafetySettingsType]</code> <p>Safety configuration for returned content from the API. Defaults to <code>None</code>.</p> <code>None</code> <code>tools</code> <code>Optional[List[Tool]]</code> <p>A potential list of tools that can be used by the API. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>GenerateOutput</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/vertexai.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    num_generations: int = 1,\n    temperature: Optional[float] = None,\n    top_p: Optional[float] = None,\n    top_k: Optional[int] = None,\n    max_output_tokens: Optional[int] = None,\n    stop_sequences: Optional[List[str]] = None,\n    safety_settings: Optional[\"SafetySettingsType\"] = None,\n    tools: Optional[List[\"Tool\"]] = None,\n) -&gt; \"GenerateOutput\":\n    \"\"\"Generates `num_generations` responses for the given input using the [VertexAI async client definition](https://cloud.google.com/vertex-ai/docs/generative-ai/model-reference/gemini).\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        num_generations: the number of generations to create per input. Defaults to\n            `1`.\n        temperature: Controls the randomness of predictions. Range: [0.0, 1.0]. Defaults to `None`.\n        top_p: If specified, nucleus sampling will be used. Range: (0.0, 1.0]. Defaults to `None`.\n        top_k: If specified, top-k sampling will be used. Defaults to `None`.\n        max_output_tokens: The maximum number of output tokens to generate per message. Defaults to `None`.\n        stop_sequences: A list of stop sequences. Defaults to `None`.\n        safety_settings: Safety configuration for returned content from the API. Defaults to `None`.\n        tools: A potential list of tools that can be used by the API. Defaults to `None`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    from vertexai.generative_models import GenerationConfig\n\n    contents = self._chattype_to_content(input)\n    generations = []\n    # TODO: remove this for-loop and override `generate`\n    for _ in range(num_generations):\n        content = await self._aclient.generate_content_async(  # type: ignore\n            contents=contents,\n            generation_config=GenerationConfig(\n                candidate_count=1,  # only one candidate allowed per call\n                temperature=temperature,\n                top_k=top_k,\n                top_p=top_p,\n                max_output_tokens=max_output_tokens,\n                stop_sequences=stop_sequences,\n            ),\n            safety_settings=safety_settings,\n            tools=tools,\n            stream=False,\n        )\n\n        text = None\n        try:\n            text = content.candidates[0].text\n        except ValueError:\n            self._logger.warning(\n                f\"Received no response using VertexAI client (model: '{self.model}').\"\n                f\" Finish reason was: '{content.candidates[0].finish_reason}'.\"\n            )\n        generations.append(text)\n\n    return generations\n</code></pre>"},{"location":"api/llms/vertexai/#distilabel.llms.vertexai.VertexAILLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>GenerativeModel</code> class which has access to <code>generate_content_async</code> to benefit from async requests.</p> Source code in <code>src/distilabel/llms/vertexai.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `GenerativeModel` class which has access to `generate_content_async` to benefit from async requests.\"\"\"\n    super().load()\n\n    try:\n        from vertexai.generative_models import GenerationConfig, GenerativeModel\n\n        self._generation_config_class = GenerationConfig\n    except ImportError as e:\n        raise ImportError(\n            \"vertexai is not installed. Please install it using\"\n            \" `pip install google-cloud-aiplatform`.\"\n        ) from e\n\n    if _is_gemini_model(self.model):\n        self._aclient = GenerativeModel(model_name=self.model)\n    else:\n        raise NotImplementedError(\n            \"`VertexAILLM` is only implemented for `gemini` models that allow for `ChatType` data.\"\n        )\n</code></pre>"},{"location":"api/llms/vllm/","title":"vLLM","text":""},{"location":"api/llms/vllm/#distilabel.llms.vllm.vLLM","title":"<code>vLLM</code>","text":"<p>             Bases: <code>LLM</code>, <code>CudaDevicePlacementMixin</code></p> <p><code>vLLM</code> library LLM implementation.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model Hugging Face Hub repo id or a path to a directory containing the model weights and configuration files.</p> <code>model_kwargs</code> <code>Optional[RuntimeParameter[Dict[str, Any]]]</code> <p>additional dictionary of keyword arguments that will be passed to the <code>LLM</code> class of <code>vllm</code> library.</p> <code>chat_template</code> <code>Optional[str]</code> <p>a chat template that will be used to build the prompts before sending them to the model. If not provided, the chat template defined in the tokenizer config will be used. If not provided and the tokenizer doesn't have a chat template, then ChatML template will be used. Defaults to <code>None</code>.</p> <code>_model</code> <code>Optional[LLM]</code> <p>the <code>vLLM</code> model instance. This attribute is meant to be used internally and should not be accessed directly. It will be set in the <code>load</code> method.</p> <code>_tokenizer</code> <code>Optional[PreTrainedTokenizer]</code> <p>the tokenizer instance used to format the prompt before passing it to the <code>LLM</code>. This attribute is meant to be used internally and should not be accessed directly. It will be set in the <code>load</code> method.</p> Runtime parameters <ul> <li><code>model_kwargs</code>: additional dictionary of keyword arguments that will be passed to     the <code>LLM</code> class of <code>vllm</code> library.</li> </ul> Source code in <code>src/distilabel/llms/vllm.py</code> <pre><code>class vLLM(LLM, CudaDevicePlacementMixin):\n    \"\"\"`vLLM` library LLM implementation.\n\n    Attributes:\n        model: the model Hugging Face Hub repo id or a path to a directory containing the\n            model weights and configuration files.\n        model_kwargs: additional dictionary of keyword arguments that will be passed to\n            the `LLM` class of `vllm` library.\n        chat_template: a chat template that will be used to build the prompts before\n            sending them to the model. If not provided, the chat template defined in the\n            tokenizer config will be used. If not provided and the tokenizer doesn't have\n            a chat template, then ChatML template will be used. Defaults to `None`.\n        _model: the `vLLM` model instance. This attribute is meant to be used internally\n            and should not be accessed directly. It will be set in the `load` method.\n        _tokenizer: the tokenizer instance used to format the prompt before passing it to\n            the `LLM`. This attribute is meant to be used internally and should not be\n            accessed directly. It will be set in the `load` method.\n\n    Runtime parameters:\n        - `model_kwargs`: additional dictionary of keyword arguments that will be passed to\n            the `LLM` class of `vllm` library.\n    \"\"\"\n\n    model: str\n    model_kwargs: Optional[RuntimeParameter[Dict[str, Any]]] = Field(\n        default_factory=dict,\n        description=\"Additional dictionary of keyword arguments that will be passed to the\"\n        \" `LLM` class of `vllm` library.\",\n    )\n    chat_template: Optional[str] = None\n\n    _model: Optional[\"_vLLM\"] = PrivateAttr(...)\n    _tokenizer: Optional[\"PreTrainedTokenizer\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `vLLM` model using either the path or the Hugging Face Hub repository id.\n        Additionally, this method also sets the `chat_template` for the tokenizer, so as to properly\n        parse the list of OpenAI formatted inputs using the expected format by the model, otherwise, the\n        default value is ChatML format, unless explicitly provided.\n        \"\"\"\n        super().load()\n\n        CudaDevicePlacementMixin.load(self)\n\n        try:\n            from vllm import LLM as _vLLM\n            from vllm import SamplingParams as _SamplingParams\n\n            global SamplingParams\n            SamplingParams = _SamplingParams\n        except ImportError as ie:\n            raise ImportError(\n                \"vLLM is not installed. Please install it using `pip install vllm`.\"\n            ) from ie\n\n        self._model = _vLLM(self.model, **self.model_kwargs)  # type: ignore\n        self._tokenizer = self._model.get_tokenizer()  # type: ignore\n\n        if self.chat_template is not None:\n            self._tokenizer.chat_template = self.chat_template  # type: ignore\n        elif (\n            self._tokenizer.chat_template is None  # type: ignore\n            and self._tokenizer.default_chat_template is None  # type: ignore\n        ):\n            self._tokenizer.chat_template = CHATML_TEMPLATE\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    def prepare_input(self, input: \"ChatType\") -&gt; str:\n        \"\"\"Prepares the input by applying the chat template to the input, which is formatted\n        as an OpenAI conversation, and adding the generation prompt.\n        \"\"\"\n        return self._tokenizer.apply_chat_template(  # type: ignore\n            input,  # type: ignore\n            tokenize=False,\n            add_generation_prompt=True,  # type: ignore\n        )\n\n    def generate(\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        max_new_tokens: int = 128,\n        frequency_penalty: float = 0.0,\n        presence_penalty: float = 0.0,\n        temperature: float = 1.0,\n        top_p: float = 1.0,\n        top_k: int = -1,\n        extra_sampling_params: Optional[Dict[str, Any]] = None,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Generates `num_generations` responses for each input using the text generation\n        pipeline.\n\n        Args:\n            inputs: a list of inputs in chat format to generate responses for.\n            num_generations: the number of generations to create per input. Defaults to\n                `1`.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            frequency_penalty: the repetition penalty to use for the generation. Defaults\n                to `0.0`.\n            presence_penalty: the presence penalty to use for the generation. Defaults to\n                `0.0`.\n            temperature: the temperature to use for the generation. Defaults to `0.1`.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n            top_k: the top-k value to use for the generation. Defaults to `0`.\n            extra_sampling_params: dictionary with additional arguments to be passed to\n                the `SamplingParams` class from `vllm`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        if extra_sampling_params is None:\n            extra_sampling_params = {}\n        sampling_params = SamplingParams(  # type: ignore\n            n=num_generations,\n            presence_penalty=presence_penalty,\n            frequency_penalty=frequency_penalty,\n            temperature=temperature,\n            top_p=top_p,\n            top_k=top_k,\n            max_tokens=max_new_tokens,\n            **extra_sampling_params,\n        )\n\n        prepared_inputs = [self.prepare_input(input) for input in inputs]\n        batch_outputs = self._model.generate(  # type: ignore\n            prepared_inputs,\n            sampling_params,\n            use_tqdm=False,  # type: ignore\n        )\n        return [\n            [output.text for output in outputs.outputs] for outputs in batch_outputs\n        ]\n</code></pre>"},{"location":"api/llms/vllm/#distilabel.llms.vllm.vLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"api/llms/vllm/#distilabel.llms.vllm.vLLM.generate","title":"<code>generate(inputs, num_generations=1, max_new_tokens=128, frequency_penalty=0.0, presence_penalty=0.0, temperature=1.0, top_p=1.0, top_k=-1, extra_sampling_params=None)</code>","text":"<p>Generates <code>num_generations</code> responses for each input using the text generation pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>List[ChatType]</code> <p>a list of inputs in chat format to generate responses for.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to create per input. Defaults to <code>1</code>.</p> <code>1</code> <code>max_new_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>frequency_penalty</code> <code>float</code> <p>the repetition penalty to use for the generation. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>presence_penalty</code> <code>float</code> <p>the presence penalty to use for the generation. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Defaults to <code>0.1</code>.</p> <code>1.0</code> <code>top_p</code> <code>float</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>top_k</code> <code>int</code> <p>the top-k value to use for the generation. Defaults to <code>0</code>.</p> <code>-1</code> <code>extra_sampling_params</code> <code>Optional[Dict[str, Any]]</code> <p>dictionary with additional arguments to be passed to the <code>SamplingParams</code> class from <code>vllm</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[GenerateOutput]</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/vllm.py</code> <pre><code>def generate(\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    max_new_tokens: int = 128,\n    frequency_penalty: float = 0.0,\n    presence_penalty: float = 0.0,\n    temperature: float = 1.0,\n    top_p: float = 1.0,\n    top_k: int = -1,\n    extra_sampling_params: Optional[Dict[str, Any]] = None,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Generates `num_generations` responses for each input using the text generation\n    pipeline.\n\n    Args:\n        inputs: a list of inputs in chat format to generate responses for.\n        num_generations: the number of generations to create per input. Defaults to\n            `1`.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        frequency_penalty: the repetition penalty to use for the generation. Defaults\n            to `0.0`.\n        presence_penalty: the presence penalty to use for the generation. Defaults to\n            `0.0`.\n        temperature: the temperature to use for the generation. Defaults to `0.1`.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n        top_k: the top-k value to use for the generation. Defaults to `0`.\n        extra_sampling_params: dictionary with additional arguments to be passed to\n            the `SamplingParams` class from `vllm`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    if extra_sampling_params is None:\n        extra_sampling_params = {}\n    sampling_params = SamplingParams(  # type: ignore\n        n=num_generations,\n        presence_penalty=presence_penalty,\n        frequency_penalty=frequency_penalty,\n        temperature=temperature,\n        top_p=top_p,\n        top_k=top_k,\n        max_tokens=max_new_tokens,\n        **extra_sampling_params,\n    )\n\n    prepared_inputs = [self.prepare_input(input) for input in inputs]\n    batch_outputs = self._model.generate(  # type: ignore\n        prepared_inputs,\n        sampling_params,\n        use_tqdm=False,  # type: ignore\n    )\n    return [\n        [output.text for output in outputs.outputs] for outputs in batch_outputs\n    ]\n</code></pre>"},{"location":"api/llms/vllm/#distilabel.llms.vllm.vLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>vLLM</code> model using either the path or the Hugging Face Hub repository id. Additionally, this method also sets the <code>chat_template</code> for the tokenizer, so as to properly parse the list of OpenAI formatted inputs using the expected format by the model, otherwise, the default value is ChatML format, unless explicitly provided.</p> Source code in <code>src/distilabel/llms/vllm.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `vLLM` model using either the path or the Hugging Face Hub repository id.\n    Additionally, this method also sets the `chat_template` for the tokenizer, so as to properly\n    parse the list of OpenAI formatted inputs using the expected format by the model, otherwise, the\n    default value is ChatML format, unless explicitly provided.\n    \"\"\"\n    super().load()\n\n    CudaDevicePlacementMixin.load(self)\n\n    try:\n        from vllm import LLM as _vLLM\n        from vllm import SamplingParams as _SamplingParams\n\n        global SamplingParams\n        SamplingParams = _SamplingParams\n    except ImportError as ie:\n        raise ImportError(\n            \"vLLM is not installed. Please install it using `pip install vllm`.\"\n        ) from ie\n\n    self._model = _vLLM(self.model, **self.model_kwargs)  # type: ignore\n    self._tokenizer = self._model.get_tokenizer()  # type: ignore\n\n    if self.chat_template is not None:\n        self._tokenizer.chat_template = self.chat_template  # type: ignore\n    elif (\n        self._tokenizer.chat_template is None  # type: ignore\n        and self._tokenizer.default_chat_template is None  # type: ignore\n    ):\n        self._tokenizer.chat_template = CHATML_TEMPLATE\n</code></pre>"},{"location":"api/llms/vllm/#distilabel.llms.vllm.vLLM.prepare_input","title":"<code>prepare_input(input)</code>","text":"<p>Prepares the input by applying the chat template to the input, which is formatted as an OpenAI conversation, and adding the generation prompt.</p> Source code in <code>src/distilabel/llms/vllm.py</code> <pre><code>def prepare_input(self, input: \"ChatType\") -&gt; str:\n    \"\"\"Prepares the input by applying the chat template to the input, which is formatted\n    as an OpenAI conversation, and adding the generation prompt.\n    \"\"\"\n    return self._tokenizer.apply_chat_template(  # type: ignore\n        input,  # type: ignore\n        tokenize=False,\n        add_generation_prompt=True,  # type: ignore\n    )\n</code></pre>"},{"location":"api/pipeline/pipeline/","title":"Pipeline","text":""},{"location":"api/pipeline/pipeline/#base-pipeline","title":"Base Pipeline","text":""},{"location":"api/pipeline/pipeline/#distilabel.pipeline.base.BasePipeline","title":"<code>BasePipeline</code>","text":"<p>             Bases: <code>_Serializable</code></p> <p>Base class for a <code>distilabel</code> pipeline.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>The name of the pipeline.</p> <code>description</code> <p>A description of the pipeline.</p> <code>dag</code> <p>The <code>DAG</code> instance that represents the pipeline.</p> <code>_cache_dir</code> <p>The directory where the pipeline will be cached.</p> <code>_logger</code> <p>The logger instance that will be used by the pipeline.</p> <code>_batch_manager</code> <code>Optional[_BatchManager]</code> <p>The batch manager that will manage the batches received from the steps while running the pipeline.</p> Source code in <code>src/distilabel/pipeline/base.py</code> <pre><code>class BasePipeline(_Serializable):\n    \"\"\"Base class for a `distilabel` pipeline.\n\n    Attributes:\n        name: The name of the pipeline.\n        description: A description of the pipeline.\n        dag: The `DAG` instance that represents the pipeline.\n        _cache_dir: The directory where the pipeline will be cached.\n        _logger: The logger instance that will be used by the pipeline.\n        _batch_manager: The batch manager that will manage the batches received from the\n            steps while running the pipeline.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        description: Optional[str] = None,\n        cache_dir: Optional[\"PathLike\"] = None,\n    ) -&gt; None:\n        \"\"\"Initialize the `BasePipeline` instance.\n\n        Args:\n            name: The name of the pipeline.\n            description: A description of the pipeline. Defaults to `None`.\n            cache_dir: A directory where the pipeline will be cached. Defaults to `None`.\n        \"\"\"\n        self.name = name\n        self.description = description\n        self.dag = DAG()\n\n        if cache_dir:\n            self._cache_dir = Path(cache_dir)\n        elif env_cache_dir := os.getenv(\"DISTILABEL_CACHE_DIR\"):\n            self._cache_dir = Path(env_cache_dir)\n        else:\n            self._cache_dir = BASE_CACHE_DIR\n\n        self._logger = logging.getLogger(\"distilabel.pipeline\")\n\n        # It's set to None here, will be created in the call to run\n        self._batch_manager: Optional[\"_BatchManager\"] = None\n\n    def __enter__(self) -&gt; Self:\n        \"\"\"Set the global pipeline instance when entering a pipeline context.\"\"\"\n        _GlobalPipelineManager.set_pipeline(self)\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback) -&gt; None:\n        \"\"\"Unset the global pipeline instance when exiting a pipeline context.\"\"\"\n        _GlobalPipelineManager.set_pipeline(None)\n\n    def _create_signature(self) -&gt; str:\n        \"\"\"Makes a signature (hash) of a pipeline, using the step ids and the adjacency between them.\n\n        The main use is to find the pipeline in the cache folder.\n\n        Returns:\n            int: Signature of the pipeline.\n        \"\"\"\n        hasher = hashlib.sha1()\n\n        steps_info = []\n        pipeline_dump = self.dump()[\"pipeline\"]\n        for step in pipeline_dump[\"steps\"]:\n            step_info = step[\"name\"]\n            for argument, value in sorted(step[\"step\"].items()):\n                if (\n                    (argument == TYPE_INFO_KEY)\n                    or (argument == \"llm\")\n                    or (value is None)\n                ):\n                    # NOTE: Should we include the LLM info at this stage??\n                    continue\n\n                if isinstance(value, dict):\n                    # input_mappings/output_mappings\n                    step_info += \"-\".join(\n                        [f\"{str(k)}-{str(v)}\" for k, v in value.items()]\n                    )\n                elif isinstance(value, (list, tuple)):\n                    # runtime_parameters_info\n                    step_info += \"-\".join([str(v) for v in value])\n                elif isinstance(value, (int, str, float)):\n                    # batch_size/name\n                    step_info += str(value)\n                else:\n                    raise ValueError(\n                        f\"Field '{argument}' in step '{step['name']}' has type {type(value)}, explicitly cast the type to 'str'.\"\n                    )\n\n            steps_info.append(step_info)\n\n        connections_info = [\n            f\"{c['from']}-{'-'.join(c['to'])}\" for c in pipeline_dump[\"connections\"]\n        ]\n        hasher.update(\",\".join(steps_info + connections_info).encode())\n\n        return hasher.hexdigest()\n\n    def run(\n        self,\n        parameters: Optional[Dict[str, Dict[str, Any]]] = None,\n        use_cache: bool = True,\n    ) -&gt; \"Distiset\":  # type: ignore\n        \"\"\"Run the pipeline. It will set the runtime parameters for the steps and validate\n        the pipeline.\n\n        This method should be extended by the specific pipeline implementation,\n        adding the logic to run the pipeline.\n\n        Args:\n            parameters: A dictionary with the step name as the key and a dictionary with\n                the runtime parameters for the step as the value. Defaults to `None`.\n            use_cache: Whether to use the cache from previous pipeline runs. Defaults to\n                `True`.\n\n        Returns:\n            The `Distiset` created by the pipeline.\n        \"\"\"\n        self._set_runtime_parameters(parameters or {})\n        self.dag.validate()\n        if use_cache:\n            self._load_from_cache()\n\n    def get_runtime_parameters_info(self) -&gt; Dict[str, List[Dict[str, Any]]]:\n        \"\"\"Get the runtime parameters for the steps in the pipeline.\n\n        Returns:\n            A dictionary with the step name as the key and a list of dictionaries with\n            the parameter name and the parameter info as the value.\n        \"\"\"\n        runtime_parameters = {}\n        for step_name in self.dag:\n            step: \"_Step\" = self.dag.get_step(step_name)[\"step\"]\n            runtime_parameters[step_name] = step.get_runtime_parameters_info()\n        return runtime_parameters\n\n    def _add_step(self, step: \"_Step\") -&gt; None:\n        \"\"\"Add a step to the pipeline.\n\n        Args:\n            step: The step to be added to the pipeline.\n        \"\"\"\n        self.dag.add_step(step)\n\n    def _add_edge(self, from_step: str, to_step: str) -&gt; None:\n        \"\"\"Add an edge between two steps in the pipeline.\n\n        Args:\n            from_step: The name of the step that will generate the input for `to_step`.\n            to_step: The name of the step that will receive the input from `from_step`.\n        \"\"\"\n        self.dag.add_edge(from_step, to_step)\n\n    def _set_runtime_parameters(self, parameters: Dict[str, Dict[str, Any]]) -&gt; None:\n        \"\"\"Set the runtime parameters for the steps in the pipeline.\n\n        Args:\n            parameters: A dictionary with the step name as the key and a dictionary with\n            the parameter name as the key and the parameter value as the value.\n        \"\"\"\n        for step_name, step_parameters in parameters.items():\n            step: \"_Step\" = self.dag.get_step(step_name)[\"step\"]\n            step.set_runtime_parameters(step_parameters)\n\n    def _model_dump(self, obj: Any, **kwargs: Any) -&gt; Dict[str, Any]:\n        \"\"\"Dumps the DAG content to a dict.\n\n        Args:\n            obj (Any): Unused, just kept to match the signature of the parent method.\n            kwargs (Any): Unused, just kept to match the signature of the parent method.\n\n        Returns:\n            Dict[str, Any]: Internal representation of the DAG from networkx in a serializable format.\n        \"\"\"\n        return self.dag.dump()\n\n    def dump(self, **kwargs: Any) -&gt; Dict[str, Any]:\n        return {\n            \"distilabel\": {\"version\": __version__},\n            \"pipeline\": {\n                \"name\": self.name,\n                \"description\": self.description,\n                **super().dump(),\n            },\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; Self:\n        \"\"\"Create a Pipeline from a dict containing the serialized data.\n\n        Note:\n            It's intended for internal use.\n\n        Args:\n            data (Dict[str, Any]): Dictionary containing the serialized data from a Pipeline.\n\n        Returns:\n            BasePipeline: Pipeline recreated from the dictionary info.\n        \"\"\"\n        name = data[\"pipeline\"][\"name\"]\n        description = data[\"pipeline\"].get(\"description\")\n        with cls(name=name, description=description) as pipe:\n            pipe.dag = DAG.from_dict(data[\"pipeline\"])\n        return pipe\n\n    @property\n    def _cache_location(self) -&gt; CacheLocation:\n        \"\"\"Dictionary containing the the object that will stored and the location,\n        whether it is a filename or a folder.\n\n        Returns:\n            Path: Filenames where the pipeline content will be serialized.\n        \"\"\"\n        folder = self._cache_dir / self._create_signature()\n        return {\n            \"pipeline\": folder / \"pipeline.yaml\",\n            \"batch_manager\": folder / \"batch_manager.json\",\n            \"data\": folder / \"data\",\n        }\n\n    def _cache(self) -&gt; None:\n        \"\"\"Saves the `BasePipeline` using the `_cache_filename`.\"\"\"\n        self.save(\n            path=self._cache_location[\"pipeline\"],\n            format=self._cache_location[\"pipeline\"].suffix.replace(\".\", \"\"),\n        )\n        if self._batch_manager is not None:\n            self._batch_manager.save(\n                self._cache_location[\"batch_manager\"],\n                format=self._cache_location[\"batch_manager\"].suffix.replace(\".\", \"\"),\n            )\n        self._logger.debug(\"Pipeline and batch manager saved to cache.\")\n\n    def _load_from_cache(self) -&gt; None:\n        \"\"\"Will try to load the `BasePipeline` from the cache dir if found, updating\n        the internal `DAG` and `_BatchManager`.\n        \"\"\"\n        cache_loc = self._cache_location\n        if cache_loc[\"pipeline\"].exists():\n            # Refresh the DAG to avoid errors when it's created within a context manager\n            # (it will check the steps aren't already defined for the DAG).\n            self.dag = DAG()\n            new_class = self.from_yaml(cache_loc[\"pipeline\"])\n            # Update the internal dag and batch_manager\n            self.dag.G = new_class.dag.G\n            if cache_loc[\"batch_manager\"].exists():\n                self._batch_manager = _BatchManager.from_json(\n                    cache_loc[\"batch_manager\"]\n                )\n            self._logger.info(\"\ud83d\udcbe Load pipeline from cache\")\n</code></pre>"},{"location":"api/pipeline/pipeline/#distilabel.pipeline.base.BasePipeline.__enter__","title":"<code>__enter__()</code>","text":"<p>Set the global pipeline instance when entering a pipeline context.</p> Source code in <code>src/distilabel/pipeline/base.py</code> <pre><code>def __enter__(self) -&gt; Self:\n    \"\"\"Set the global pipeline instance when entering a pipeline context.\"\"\"\n    _GlobalPipelineManager.set_pipeline(self)\n    return self\n</code></pre>"},{"location":"api/pipeline/pipeline/#distilabel.pipeline.base.BasePipeline.__exit__","title":"<code>__exit__(exc_type, exc_value, traceback)</code>","text":"<p>Unset the global pipeline instance when exiting a pipeline context.</p> Source code in <code>src/distilabel/pipeline/base.py</code> <pre><code>def __exit__(self, exc_type, exc_value, traceback) -&gt; None:\n    \"\"\"Unset the global pipeline instance when exiting a pipeline context.\"\"\"\n    _GlobalPipelineManager.set_pipeline(None)\n</code></pre>"},{"location":"api/pipeline/pipeline/#distilabel.pipeline.base.BasePipeline.__init__","title":"<code>__init__(name, description=None, cache_dir=None)</code>","text":"<p>Initialize the <code>BasePipeline</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the pipeline.</p> required <code>description</code> <code>Optional[str]</code> <p>A description of the pipeline. Defaults to <code>None</code>.</p> <code>None</code> <code>cache_dir</code> <code>Optional[PathLike]</code> <p>A directory where the pipeline will be cached. Defaults to <code>None</code>.</p> <code>None</code> Source code in <code>src/distilabel/pipeline/base.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    description: Optional[str] = None,\n    cache_dir: Optional[\"PathLike\"] = None,\n) -&gt; None:\n    \"\"\"Initialize the `BasePipeline` instance.\n\n    Args:\n        name: The name of the pipeline.\n        description: A description of the pipeline. Defaults to `None`.\n        cache_dir: A directory where the pipeline will be cached. Defaults to `None`.\n    \"\"\"\n    self.name = name\n    self.description = description\n    self.dag = DAG()\n\n    if cache_dir:\n        self._cache_dir = Path(cache_dir)\n    elif env_cache_dir := os.getenv(\"DISTILABEL_CACHE_DIR\"):\n        self._cache_dir = Path(env_cache_dir)\n    else:\n        self._cache_dir = BASE_CACHE_DIR\n\n    self._logger = logging.getLogger(\"distilabel.pipeline\")\n\n    # It's set to None here, will be created in the call to run\n    self._batch_manager: Optional[\"_BatchManager\"] = None\n</code></pre>"},{"location":"api/pipeline/pipeline/#distilabel.pipeline.base.BasePipeline.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a Pipeline from a dict containing the serialized data.</p> Note <p>It's intended for internal use.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>Dictionary containing the serialized data from a Pipeline.</p> required <p>Returns:</p> Name Type Description <code>BasePipeline</code> <code>Self</code> <p>Pipeline recreated from the dictionary info.</p> Source code in <code>src/distilabel/pipeline/base.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; Self:\n    \"\"\"Create a Pipeline from a dict containing the serialized data.\n\n    Note:\n        It's intended for internal use.\n\n    Args:\n        data (Dict[str, Any]): Dictionary containing the serialized data from a Pipeline.\n\n    Returns:\n        BasePipeline: Pipeline recreated from the dictionary info.\n    \"\"\"\n    name = data[\"pipeline\"][\"name\"]\n    description = data[\"pipeline\"].get(\"description\")\n    with cls(name=name, description=description) as pipe:\n        pipe.dag = DAG.from_dict(data[\"pipeline\"])\n    return pipe\n</code></pre>"},{"location":"api/pipeline/pipeline/#distilabel.pipeline.base.BasePipeline.get_runtime_parameters_info","title":"<code>get_runtime_parameters_info()</code>","text":"<p>Get the runtime parameters for the steps in the pipeline.</p> <p>Returns:</p> Type Description <code>Dict[str, List[Dict[str, Any]]]</code> <p>A dictionary with the step name as the key and a list of dictionaries with</p> <code>Dict[str, List[Dict[str, Any]]]</code> <p>the parameter name and the parameter info as the value.</p> Source code in <code>src/distilabel/pipeline/base.py</code> <pre><code>def get_runtime_parameters_info(self) -&gt; Dict[str, List[Dict[str, Any]]]:\n    \"\"\"Get the runtime parameters for the steps in the pipeline.\n\n    Returns:\n        A dictionary with the step name as the key and a list of dictionaries with\n        the parameter name and the parameter info as the value.\n    \"\"\"\n    runtime_parameters = {}\n    for step_name in self.dag:\n        step: \"_Step\" = self.dag.get_step(step_name)[\"step\"]\n        runtime_parameters[step_name] = step.get_runtime_parameters_info()\n    return runtime_parameters\n</code></pre>"},{"location":"api/pipeline/pipeline/#distilabel.pipeline.base.BasePipeline.run","title":"<code>run(parameters=None, use_cache=True)</code>","text":"<p>Run the pipeline. It will set the runtime parameters for the steps and validate the pipeline.</p> <p>This method should be extended by the specific pipeline implementation, adding the logic to run the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Optional[Dict[str, Dict[str, Any]]]</code> <p>A dictionary with the step name as the key and a dictionary with the runtime parameters for the step as the value. Defaults to <code>None</code>.</p> <code>None</code> <code>use_cache</code> <code>bool</code> <p>Whether to use the cache from previous pipeline runs. Defaults to <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>Distiset</code> <p>The <code>Distiset</code> created by the pipeline.</p> Source code in <code>src/distilabel/pipeline/base.py</code> <pre><code>def run(\n    self,\n    parameters: Optional[Dict[str, Dict[str, Any]]] = None,\n    use_cache: bool = True,\n) -&gt; \"Distiset\":  # type: ignore\n    \"\"\"Run the pipeline. It will set the runtime parameters for the steps and validate\n    the pipeline.\n\n    This method should be extended by the specific pipeline implementation,\n    adding the logic to run the pipeline.\n\n    Args:\n        parameters: A dictionary with the step name as the key and a dictionary with\n            the runtime parameters for the step as the value. Defaults to `None`.\n        use_cache: Whether to use the cache from previous pipeline runs. Defaults to\n            `True`.\n\n    Returns:\n        The `Distiset` created by the pipeline.\n    \"\"\"\n    self._set_runtime_parameters(parameters or {})\n    self.dag.validate()\n    if use_cache:\n        self._load_from_cache()\n</code></pre>"},{"location":"api/pipeline/pipeline/#distilabel.pipeline.base.CacheLocation","title":"<code>CacheLocation</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>Dictionary to store the filenames and directories of a cached pipeline.</p> Source code in <code>src/distilabel/pipeline/base.py</code> <pre><code>class CacheLocation(TypedDict):\n    \"\"\"Dictionary to store the filenames and directories of a cached pipeline.\"\"\"\n\n    pipeline: Path\n    batch_manager: Path\n    data: Path\n</code></pre>"},{"location":"api/pipeline/pipeline/#local-pipeline","title":"Local Pipeline","text":""},{"location":"api/pipeline/pipeline/#distilabel.pipeline.local.Pipeline","title":"<code>Pipeline</code>","text":"<p>             Bases: <code>BasePipeline</code></p> <p>Local pipeline implementation using <code>multiprocessing</code>.</p> Source code in <code>src/distilabel/pipeline/local.py</code> <pre><code>class Pipeline(BasePipeline):\n    \"\"\"Local pipeline implementation using `multiprocessing`.\"\"\"\n\n    def run(\n        self,\n        parameters: Optional[Dict[str, Dict[str, Any]]] = None,\n        use_cache: bool = True,\n    ) -&gt; \"Distiset\":\n        \"\"\"Runs the pipeline.\n\n        Args:\n            parameters: A dictionary with the step name as the key and a dictionary with\n                the runtime parameters for the step as the value. Defaults to `None`.\n            use_cache: Whether to use the cache from previous pipeline runs. Defaults to\n                `True`.\n\n        Returns:\n            The `Distiset` created by the pipeline.\n\n        Raises:\n            RuntimeError: If the pipeline fails to load all the steps.\n        \"\"\"\n        try:\n            mp.set_start_method(\"forkserver\")\n        except RuntimeError:\n            pass\n        log_queue = mp.Queue()\n        setup_logging(log_queue)  # type: ignore\n        self._logger = logging.getLogger(\"distilabel.pipeline.local\")\n\n        super().run(parameters, use_cache)\n\n        if self._batch_manager is None:\n            self._batch_manager = _BatchManager.from_dag(self.dag)\n\n        # If the batch manager is not able to generate batches, that means that the loaded\n        # `_BatchManager` from cache didn't have any remaining batches to process i.e.\n        # the previous pipeline execution was completed successfully.\n        if not self._batch_manager.can_generate():\n            self._logger.info(\n                \"\ud83d\udcbe Loaded batch manager from cache doesn't have any remaining data. Returning\"\n                \" `Distiset` from cache data...\"\n            )\n            stop_logging()\n            return create_distiset(\n                self._cache_location[\"data\"],\n                pipeline_path=self._cache_location[\"pipeline\"],\n            )\n\n        buffer_data_path = self._cache_location[\"data\"]\n        self._logger.info(f\"\ud83d\udcdd Pipeline data will be written to '{buffer_data_path}'\")\n        write_buffer = _WriteBuffer(buffer_data_path, self.dag.leaf_steps)\n\n        num_processes = len(self.dag)\n        ctx = mp.get_context(\"forkserver\")  # type: ignore\n        with ctx.Manager() as manager, ctx.Pool(\n            num_processes, initializer=_init_worker, initargs=(log_queue,)\n        ) as pool:\n            self.output_queue: \"Queue[Any]\" = manager.Queue()\n            self.shared_info = self._create_shared_info_dict(manager)\n            self._handle_keyboard_interrupt()\n\n            # Run the steps using the pool of processes\n            self._run_steps_in_loop(pool, manager, self.output_queue, self.shared_info)\n\n            # Wait for all the steps to be loaded correctly\n            if not self._all_steps_loaded():\n                write_buffer.close()\n                self._batch_manager = None\n                stop_logging()\n                raise RuntimeError(\n                    \"Failed to load all the steps. Could not run pipeline.\"\n                )\n\n            # Send the \"first\" batches to the steps so the batches starts flowing through\n            # the input queues and output queue\n            self._request_initial_batches()\n\n            # Start a loop to receive the output batches from the steps\n            self._run_output_queue_loop_in_thread(write_buffer)\n\n            pool.close()\n            pool.join()\n\n        write_buffer.close()\n        distiset = create_distiset(\n            self._cache_location[\"data\"], pipeline_path=self._cache_location[\"pipeline\"]\n        )\n        stop_logging()\n        return distiset\n\n    def _run_output_queue_loop_in_thread(self, write_buffer: \"_WriteBuffer\") -&gt; None:\n        \"\"\"Runs the output queue loop in a separate thread to receive the output batches\n        from the steps. This is done to avoid the signal handler to block the loop, which\n        would prevent the pipeline from stopping correctly.\n\n        Args:\n            write_buffer: The write buffer to write the data from the leaf steps to disk.\n        \"\"\"\n        thread = threading.Thread(target=self._output_queue_loop, args=(write_buffer,))\n        thread.start()\n        thread.join()\n\n    def _output_queue_loop(self, write_buffer: \"_WriteBuffer\") -&gt; None:\n        \"\"\"Loop to receive the output batches from the steps and manage the flow of the\n        batches through the pipeline.\n\n        Args:\n            write_buffer: The write buffer to write the data from the leaf steps to disk.\n        \"\"\"\n        while self._batch_manager.can_generate() and not _STOP_LOOP:  # type: ignore\n            self._logger.debug(\"Waiting for output batch from step...\")\n            if (batch := self.output_queue.get()) is None:\n                self._logger.debug(\"Received `None` from output queue. Breaking loop.\")\n                break\n\n            if batch.step_name in self.dag.leaf_steps:\n                write_buffer.add_batch(batch)\n\n            # If `_STOP_LOOP` was set to `True` while waiting for the output queue, then\n            # we need to handle the stop of the pipeline and break the loop to avoid\n            # propagating the batches through the pipeline and making the stop process\n            # slower.\n            if _STOP_LOOP:\n                self._handle_batch_on_stop(batch)\n                self._handle_stop(write_buffer)\n                break\n\n            self._logger.debug(\n                f\"Received batch with seq_no {batch.seq_no} from step '{batch.step_name}'\"\n                f\" from output queue: {batch}\"\n            )\n\n            self._manage_batch_flow(batch)\n\n        if _STOP_LOOP:\n            self._handle_stop(write_buffer)\n\n    def _manage_batch_flow(self, batch: \"_Batch\") -&gt; None:\n        \"\"\"Checks if the step that generated the batch has more data in its buffer to\n        generate a new batch. If there's data, then a new batch is sent to the step. If\n        the step has no data in its buffer, then the predecessors generator steps are\n        requested to send a new batch.\n\n        Args:\n            batch: The batch that was processed.\n        \"\"\"\n        assert self._batch_manager, \"Batch manager is not set\"\n\n        self._batch_manager.register_batch(batch)\n        self._logger.debug(\n            f\"Batch {batch.seq_no} from step '{batch.step_name}' registered in batch\"\n            \" manager\"\n        )\n\n        step: \"Step\" = self.dag.get_step(batch.step_name)[\"step\"]\n\n        for successor in self.dag.get_step_successors(step.name):\n            self._batch_manager.add_batch(successor, batch)\n\n            # Check if the step is a generator and if there are successors that need data\n            # from this step. This usually happens when the generator `batch_size` is smaller\n            # than the `input_batch_size` of the successor steps.\n            if (\n                step.is_generator\n                and step.name in self._batch_manager.step_empty_buffers(successor)\n            ):\n                last_batch = self._batch_manager.get_last_batch(step.name)\n                self._send_batch_to_step(last_batch.next_batch())  # type: ignore\n\n            if new_batch := self._batch_manager.get_batch(successor):\n                self._send_batch_to_step(new_batch)\n\n        if step.is_generator:\n            return\n\n        # Step has enough data on its buffers to create a new batch\n        if next_batch := self._batch_manager.get_batch(step.name):\n            self._send_batch_to_step(next_batch)\n            return\n\n        # Request more batches to the predecessors generator steps\n        empty_buffers = self._batch_manager.step_empty_buffers(step.name)\n        for previous_step_name in empty_buffers:\n            if previous_step_name not in self.dag.root_steps:\n                continue\n\n            if last_batch := self._batch_manager.get_last_batch(previous_step_name):\n                self._logger.debug(\n                    f\"Step '{step.name}' input buffer for step '{previous_step_name}' is\"\n                    \" empty. Requesting new batch...\"\n                )\n                self._send_batch_to_step(last_batch.next_batch())\n\n        self._cache()\n\n    def _handle_stop(self, write_buffer: \"_WriteBuffer\") -&gt; None:\n        \"\"\"Handles the stop of the pipeline execution, which will stop the steps from\n        processing more batches and wait for the output queue to be empty, to not lose\n        any data that was already processed by the steps before the stop was called.\n\n        Args:\n            write_buffer: The write buffer to write the data from the leaf steps to disk.\n        \"\"\"\n        self._logger.debug(\"Handling stop of the pipeline execution...\")\n\n        # Send `None` to the input queues of all the steps to notify them to stop\n        # processing batches.\n        for step_name in self.dag:\n            if input_queue := self._wait_step_input_queue_empty(step_name):\n                if self._check_step_not_loaded_or_finished(step_name):\n                    self._logger.debug(\n                        f\"Step '{step_name}' not loaded or already finished. Skipping sending\"\n                        \" sentinel `None`\"\n                    )\n                    continue\n                input_queue.put(None)\n                self._logger.debug(f\"Send `None` to step '{step_name}' input queue.\")\n\n        # Wait for the input queue to be empty, which means that all the steps finished\n        # processing the batches that were sent before the stop flag.\n        for step_name in self.dag:\n            self._wait_step_input_queue_empty(step_name)\n\n        # Consume the output queue until it's empty to not lose any data that was already\n        # processed by the steps before stop was called.\n        while not self.output_queue.empty():\n            batch = self.output_queue.get()\n            if batch.step_name in self.dag.leaf_steps:\n                write_buffer.add_batch(batch)\n            self._handle_batch_on_stop(batch)\n\n        self._cache()\n\n    def _handle_batch_on_stop(self, batch: \"_Batch\") -&gt; None:\n        \"\"\"Handles a batch that was received from the output queue when the pipeline was\n        stopped. It will add and register the batch in the batch manager.\n\n        Args:\n            batch: The batch to handle.\n        \"\"\"\n        self._batch_manager.register_batch(batch)  # type: ignore\n        step: \"Step\" = self.dag.get_step(batch.step_name)[\"step\"]\n        for successor in self.dag.get_step_successors(step.name):\n            self._batch_manager.add_batch(successor, batch)  # type: ignore\n\n    def _wait_step_input_queue_empty(self, step_name: str) -&gt; Union[\"Queue[Any]\", None]:\n        \"\"\"Waits for the input queue of a step to be empty.\n\n        Args:\n            step_name: The name of the step.\n\n        Returns:\n            The input queue of the step if it's not loaded or finished, `None` otherwise.\n        \"\"\"\n        if self._check_step_not_loaded_or_finished(step_name):\n            return None\n\n        if input_queue := self.dag.get_step(step_name).get(\"input_queue\"):\n            while input_queue.qsize() != 0:\n                pass\n            return input_queue\n\n    def _create_shared_info_dict(self, manager: \"SyncManager\") -&gt; \"DictProxy[str, Any]\":\n        \"\"\"Creates the shared information dictionary to be used by the processes.\n\n        Args:\n            manager: The manager to create the shared information.\n\n        Returns:\n            The shared information dictionary.\n        \"\"\"\n        # TODO: not very important, but we could use a different lock for each matter\n        return manager.dict(\n            **{\n                _STEPS_LOADED_KEY: manager.list(),\n                _STEPS_LOADED_LOCK_KEY: manager.Lock(),\n                _CUDA_LLM_DEVICE_PLACEMENT_KEY: manager.dict(**{}),\n                _CUDA_LLM_DEVICE_PLACEMENT_LOCK_KEY: manager.Lock(),\n            }\n        )\n\n    def _all_steps_loaded(self) -&gt; bool:\n        \"\"\"Waits for all the steps to load.\n\n        Returns:\n            `True` if all the steps have been loaded correctly, `False` otherwise.\n        \"\"\"\n\n        def _update_all_steps_loaded(steps_loaded: List[str]) -&gt; None:\n            with _STEPS_LOADED_LOCK:\n                _STEPS_LOADED.update(steps_loaded)\n\n        self._logger.info(\"\u23f3 Waiting for all the steps to load...\")\n        previous_message = None\n        while True:\n            with self.shared_info[_STEPS_LOADED_LOCK_KEY]:\n                steps_loaded = self.shared_info[_STEPS_LOADED_KEY]\n                num_steps_loaded = (\n                    len(steps_loaded)\n                    if steps_loaded != [_STEPS_LOADED_ERROR_CODE]\n                    else 0\n                )\n                self._logger.debug(f\"Steps loaded: {steps_loaded}\")\n\n                message = f\"\u23f3 Steps loaded: {num_steps_loaded}/{len(self.dag)}\"\n                if num_steps_loaded &gt; 0 and message != previous_message:\n                    self._logger.info(message)\n                    previous_message = message\n\n                if num_steps_loaded == len(self.dag):\n                    self._logger.info(\"\u2705 All the steps have been loaded!\")\n                    _update_all_steps_loaded(steps_loaded)\n                    return True\n\n                if steps_loaded == [_STEPS_LOADED_ERROR_CODE]:\n                    self._logger.error(\"\u274c Failed to load all the steps\")\n                    _update_all_steps_loaded(steps_loaded)\n                    return False\n\n            time.sleep(2.5)\n\n    def _request_initial_batches(self) -&gt; None:\n        \"\"\"Requests the initial batches to the generator steps.\"\"\"\n        assert self._batch_manager, \"Batch manager is not set\"\n\n        for step in self._batch_manager._steps.values():\n            if batch := step.get_batch():\n                self._send_batch_to_step(batch)\n\n        for step_name in self.dag.root_steps:\n            seq_no = 0\n            if last_batch := self._batch_manager.get_last_batch(step_name):\n                seq_no = last_batch.seq_no + 1\n            batch = _Batch(seq_no=seq_no, step_name=step_name, last_batch=False)\n            self._send_batch_to_step(batch)\n\n    def _send_batch_to_step(self, batch: \"_Batch\") -&gt; None:\n        \"\"\"Sends a batch to the input queue of a step.\n\n        Args:\n            batch: The batch to send.\n        \"\"\"\n        self._logger.debug(\n            f\"Sending batch {batch.seq_no} to step '{batch.step_name}': {batch}\"\n        )\n        input_queue = self.dag.get_step(batch.step_name)[\"input_queue\"]\n        input_queue.put(batch)\n\n    def _run_steps_in_loop(\n        self,\n        pool: \"Pool\",\n        manager: \"SyncManager\",\n        output_queue: \"Queue[_Batch]\",\n        shared_info: \"DictProxy[str, Any]\",\n    ) -&gt; None:\n        \"\"\"Using the `pool`, runs the steps in the DAG in an infinite loop waiting for\n        input batches and sending the output batches to the `output_queue`.\n\n        Each `Step` is wrapped in a `_ProcessWrapper`, which will handle the lifecycle of\n        the `Step` and the communication with the `input_queue` and `output_queue`. The\n        `_ProcessWrapper.run` method is the target function of the process.\n\n        Args:\n            pool: The pool of processes.\n            manager: The manager to create the queues.\n            output_queue: The queue to send the output batches.\n            shared_info: The shared information between the processes.\n        \"\"\"\n        for step_name in self.dag:\n            step: \"Step\" = self.dag.get_step(step_name)[\"step\"]\n            input_queue = manager.Queue()\n            self.dag.set_step_attr(step.name, \"input_queue\", input_queue)\n\n            # Set `pipeline` to `None` as in some Python environments the pipeline is not\n            # picklable and it will raise an error when trying to send the step to the process.\n            # `TypeError: cannot pickle 'code' object`\n            step.pipeline = None\n\n            process_wrapper = _ProcessWrapper(\n                step=step,\n                input_queue=input_queue,\n                output_queue=output_queue,\n                shared_info=shared_info,\n            )\n\n            pool.apply_async(\n                process_wrapper.run,\n                callback=self._finished_callback,\n                error_callback=self._error_callback,\n            )  # type: ignore\n\n    def _error_callback(self, e: BaseException) -&gt; None:\n        \"\"\"Error callback that will be called when an error occurs in a `Step` process.\n\n        Args:\n            e: The exception raised by the process.\n        \"\"\"\n        # First we check that the exception is a `_ProcessWrapperException`, otherwise, we\n        # print it out and stop the pipeline, since some errors may be unhandled\n        if not isinstance(e, _ProcessWrapperException):\n            self._logger.error(f\"\u274c Failed with an unhandled exception: {e}\")\n            self._stop()\n            return\n\n        if e.is_load_error:\n            self._logger.error(f\"\u274c Failed to load step '{e.step.name}': {e.message}\")\n            with self.shared_info[_STEPS_LOADED_LOCK_KEY]:\n                self.shared_info[_STEPS_LOADED_KEY] = [_STEPS_LOADED_ERROR_CODE]\n            return\n\n        # If the step is global, is not in the last trophic level and has no successors,\n        # then we can ignore the error and continue executing the pipeline\n        if (\n            e.step.is_global\n            and not self.dag.step_in_last_trophic_level(e.step.name)\n            and list(self.dag.get_step_successors(e.step.name)) == []\n        ):\n            self._logger.error(\n                f\"\u270b An error occurred when running global step '{e.step.name}' with no\"\n                \" successors and not in the last trophic level. Pipeline execution can\"\n                f\" continue. Error will be ignored: {e.message}\"\n            )\n            return\n\n        self._logger.error(f\"An error occurred in step '{e.step.name}': {e.message}\")\n        self._cache()\n        self._stop()\n\n    def _finished_callback(self, step_name: str) -&gt; None:\n        \"\"\"Callback that will be called when a `Step` process finishes.\n\n        Args:\n            step_name: The name of the step that finished.\n        \"\"\"\n        with _STEPS_FINISHED_LOCK:\n            _STEPS_FINISHED.add(step_name)\n\n    def _check_step_not_loaded_or_finished(self, step_name: str) -&gt; bool:\n        \"\"\"Checks if a step is not loaded or already finished.\n\n        Args:\n            step_name: The name of the step.\n\n        Returns:\n            `True` if the step is not loaded or already finished, `False` otherwise.\n        \"\"\"\n        with _STEPS_LOADED_LOCK:\n            if step_name not in _STEPS_LOADED:\n                return True\n\n        with _STEPS_FINISHED_LOCK:\n            if step_name in _STEPS_FINISHED:\n                return True\n\n        return False\n\n    def _stop(self) -&gt; None:\n        \"\"\"Stops the pipeline execution. It will first send `None` to the input queues\n        of all the steps and then wait until the output queue is empty i.e. all the steps\n        finished processing the batches that were sent before the stop flag. Then it will\n        send `None` to the output queue to notify the pipeline to stop.\"\"\"\n\n        global _STOP_LOOP, _STOP_CALLED\n\n        _STOP_LOOP = True\n\n        with _STOP_CALLED_LOCK:\n            if _STOP_CALLED:\n                self._logger.warning(\n                    \"\ud83d\uded1 Stop has already been called. Ignoring subsequent calls and waiting\"\n                    \" for the pipeline to finish...\"\n                )\n                return\n            _STOP_CALLED = True\n\n        self._logger.debug(f\"Steps loaded before calling `stop`: {_STEPS_LOADED}\")\n        self._logger.info(\n            \"\ud83d\uded1 Stopping pipeline. Waiting for steps to finish processing batches...\"\n        )\n\n    def _handle_keyboard_interrupt(self) -&gt; None:\n        \"\"\"Handles KeyboardInterrupt signal sent during the Pipeline.run method.\n\n        It will try to call self._stop (if the pipeline didn't started yet, it won't\n        have any effect), and if the pool is already started, will close it before exiting\n        the program.\n        \"\"\"\n\n        def signal_handler(signumber: int, frame: Any) -&gt; None:\n            self._stop()\n\n        signal.signal(signal.SIGINT, signal_handler)\n</code></pre>"},{"location":"api/pipeline/pipeline/#distilabel.pipeline.local.Pipeline.run","title":"<code>run(parameters=None, use_cache=True)</code>","text":"<p>Runs the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Optional[Dict[str, Dict[str, Any]]]</code> <p>A dictionary with the step name as the key and a dictionary with the runtime parameters for the step as the value. Defaults to <code>None</code>.</p> <code>None</code> <code>use_cache</code> <code>bool</code> <p>Whether to use the cache from previous pipeline runs. Defaults to <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>Distiset</code> <p>The <code>Distiset</code> created by the pipeline.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the pipeline fails to load all the steps.</p> Source code in <code>src/distilabel/pipeline/local.py</code> <pre><code>def run(\n    self,\n    parameters: Optional[Dict[str, Dict[str, Any]]] = None,\n    use_cache: bool = True,\n) -&gt; \"Distiset\":\n    \"\"\"Runs the pipeline.\n\n    Args:\n        parameters: A dictionary with the step name as the key and a dictionary with\n            the runtime parameters for the step as the value. Defaults to `None`.\n        use_cache: Whether to use the cache from previous pipeline runs. Defaults to\n            `True`.\n\n    Returns:\n        The `Distiset` created by the pipeline.\n\n    Raises:\n        RuntimeError: If the pipeline fails to load all the steps.\n    \"\"\"\n    try:\n        mp.set_start_method(\"forkserver\")\n    except RuntimeError:\n        pass\n    log_queue = mp.Queue()\n    setup_logging(log_queue)  # type: ignore\n    self._logger = logging.getLogger(\"distilabel.pipeline.local\")\n\n    super().run(parameters, use_cache)\n\n    if self._batch_manager is None:\n        self._batch_manager = _BatchManager.from_dag(self.dag)\n\n    # If the batch manager is not able to generate batches, that means that the loaded\n    # `_BatchManager` from cache didn't have any remaining batches to process i.e.\n    # the previous pipeline execution was completed successfully.\n    if not self._batch_manager.can_generate():\n        self._logger.info(\n            \"\ud83d\udcbe Loaded batch manager from cache doesn't have any remaining data. Returning\"\n            \" `Distiset` from cache data...\"\n        )\n        stop_logging()\n        return create_distiset(\n            self._cache_location[\"data\"],\n            pipeline_path=self._cache_location[\"pipeline\"],\n        )\n\n    buffer_data_path = self._cache_location[\"data\"]\n    self._logger.info(f\"\ud83d\udcdd Pipeline data will be written to '{buffer_data_path}'\")\n    write_buffer = _WriteBuffer(buffer_data_path, self.dag.leaf_steps)\n\n    num_processes = len(self.dag)\n    ctx = mp.get_context(\"forkserver\")  # type: ignore\n    with ctx.Manager() as manager, ctx.Pool(\n        num_processes, initializer=_init_worker, initargs=(log_queue,)\n    ) as pool:\n        self.output_queue: \"Queue[Any]\" = manager.Queue()\n        self.shared_info = self._create_shared_info_dict(manager)\n        self._handle_keyboard_interrupt()\n\n        # Run the steps using the pool of processes\n        self._run_steps_in_loop(pool, manager, self.output_queue, self.shared_info)\n\n        # Wait for all the steps to be loaded correctly\n        if not self._all_steps_loaded():\n            write_buffer.close()\n            self._batch_manager = None\n            stop_logging()\n            raise RuntimeError(\n                \"Failed to load all the steps. Could not run pipeline.\"\n            )\n\n        # Send the \"first\" batches to the steps so the batches starts flowing through\n        # the input queues and output queue\n        self._request_initial_batches()\n\n        # Start a loop to receive the output batches from the steps\n        self._run_output_queue_loop_in_thread(write_buffer)\n\n        pool.close()\n        pool.join()\n\n    write_buffer.close()\n    distiset = create_distiset(\n        self._cache_location[\"data\"], pipeline_path=self._cache_location[\"pipeline\"]\n    )\n    stop_logging()\n    return distiset\n</code></pre>"},{"location":"api/pipeline/pipeline/#extra","title":"Extra","text":""},{"location":"api/steps/argilla/","title":"Argilla","text":""},{"location":"api/steps/argilla/#distilabel.steps.argilla.base.Argilla","title":"<code>Argilla</code>","text":"<p>             Bases: <code>Step</code>, <code>ABC</code></p> <p>Abstract step that provides a class to subclass from, that contains the boilerplate code required to interact with Argilla, as well as some extra validations on top of it. It also defines the abstract methods that need to be implemented in order to add a new dataset type as a step.</p> Note <p>This class is not intended to be instanced directly, but via subclass.</p> <p>Attributes:</p> Name Type Description <code>dataset_name</code> <code>str</code> <p>The name of the dataset in Argilla.</p> <code>dataset_workspace</code> <code>Optional[str]</code> <p>The workspace where the dataset will be created in Argilla. Defaults to None, which means it will be created in the default workspace.</p> <code>api_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>The URL of the Argilla API. Defaults to <code>None</code>, which means it will be read from the <code>ARGILLA_API_URL</code> environment variable.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>The API key to authenticate with Argilla. Defaults to <code>None</code>, which means it will be read from the <code>ARGILLA_API_KEY</code> environment variable.</p> Runtime parameters <ul> <li><code>api_url</code>: The base URL to use for the Argilla API requests.</li> <li><code>api_key</code>: The API key to authenticate the requests to the Argilla API.</li> </ul> Input columns <ul> <li>dynamic, based on the <code>inputs</code> value provided</li> </ul> Source code in <code>src/distilabel/steps/argilla/base.py</code> <pre><code>class Argilla(Step, ABC):\n    \"\"\"Abstract step that provides a class to subclass from, that contains the boilerplate code\n    required to interact with Argilla, as well as some extra validations on top of it. It also defines\n    the abstract methods that need to be implemented in order to add a new dataset type as a step.\n\n    Note:\n        This class is not intended to be instanced directly, but via subclass.\n\n    Attributes:\n        dataset_name: The name of the dataset in Argilla.\n        dataset_workspace: The workspace where the dataset will be created in Argilla. Defaults to\n            None, which means it will be created in the default workspace.\n        api_url: The URL of the Argilla API. Defaults to `None`, which means it will be read from\n            the `ARGILLA_API_URL` environment variable.\n        api_key: The API key to authenticate with Argilla. Defaults to `None`, which means it will\n            be read from the `ARGILLA_API_KEY` environment variable.\n\n    Runtime parameters:\n        - `api_url`: The base URL to use for the Argilla API requests.\n        - `api_key`: The API key to authenticate the requests to the Argilla API.\n\n    Input columns:\n        - dynamic, based on the `inputs` value provided\n    \"\"\"\n\n    dataset_name: str\n    dataset_workspace: Optional[str] = None\n\n    api_url: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(\"ARGILLA_BASE_URL\"),\n        description=\"The base URL to use for the Argilla API requests.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_ARGILLA_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Argilla API.\",\n    )\n\n    _rg_dataset: Optional[\"RemoteFeedbackDataset\"] = PrivateAttr(...)\n\n    def model_post_init(self, __context: Any) -&gt; None:\n        \"\"\"Checks that the Argilla Python SDK is installed, and then filters the Argilla warnings.\"\"\"\n        try:\n            import argilla as rg  # noqa\n        except ImportError as ie:\n            raise ImportError(\n                \"Argilla is not installed. Please install it using `pip install argilla`.\"\n            ) from ie\n\n        warnings.filterwarnings(\"ignore\")\n        return super().model_post_init(__context)\n\n    def _rg_init(self) -&gt; None:\n        \"\"\"Initializes the Argilla API client with the provided `api_url` and `api_key`.\"\"\"\n        try:\n            if \"hf.space\" in self.api_url and \"HF_TOKEN\" in os.environ:\n                headers = {\"Authorization\": f\"Bearer {os.environ['HF_TOKEN']}\"}\n            else:\n                headers = None\n            rg.init(\n                api_url=self.api_url,\n                api_key=self.api_key.get_secret_value(),\n                extra_headers=headers,\n            )  # type: ignore\n        except Exception as e:\n            raise ValueError(f\"Failed to initialize the Argilla API: {e}\") from e\n\n    def _rg_dataset_exists(self) -&gt; bool:\n        \"\"\"Checks if the dataset already exists in Argilla.\"\"\"\n        return self.dataset_name in [\n            dataset.name\n            for dataset in rg.FeedbackDataset.list(workspace=self.dataset_workspace)  # type: ignore\n        ]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The outputs of the step is an empty list, since the steps subclassing from this one, will\n        always be leaf nodes and won't propagate the inputs neither generate any outputs.\n        \"\"\"\n        return []\n\n    def load(self) -&gt; None:\n        \"\"\"Method to perform any initialization logic before the `process` method is\n        called. For example, to load an LLM, stablish a connection to a database, etc.\n        \"\"\"\n        super().load()\n\n    @property\n    @abstractmethod\n    def inputs(self) -&gt; List[str]:\n        ...\n\n    @abstractmethod\n    def process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n        ...\n</code></pre>"},{"location":"api/steps/argilla/#distilabel.steps.argilla.base.Argilla.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The outputs of the step is an empty list, since the steps subclassing from this one, will always be leaf nodes and won't propagate the inputs neither generate any outputs.</p>"},{"location":"api/steps/argilla/#distilabel.steps.argilla.base.Argilla.load","title":"<code>load()</code>","text":"<p>Method to perform any initialization logic before the <code>process</code> method is called. For example, to load an LLM, stablish a connection to a database, etc.</p> Source code in <code>src/distilabel/steps/argilla/base.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Method to perform any initialization logic before the `process` method is\n    called. For example, to load an LLM, stablish a connection to a database, etc.\n    \"\"\"\n    super().load()\n</code></pre>"},{"location":"api/steps/argilla/#distilabel.steps.argilla.base.Argilla.model_post_init","title":"<code>model_post_init(__context)</code>","text":"<p>Checks that the Argilla Python SDK is installed, and then filters the Argilla warnings.</p> Source code in <code>src/distilabel/steps/argilla/base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Checks that the Argilla Python SDK is installed, and then filters the Argilla warnings.\"\"\"\n    try:\n        import argilla as rg  # noqa\n    except ImportError as ie:\n        raise ImportError(\n            \"Argilla is not installed. Please install it using `pip install argilla`.\"\n        ) from ie\n\n    warnings.filterwarnings(\"ignore\")\n    return super().model_post_init(__context)\n</code></pre>"},{"location":"api/steps/argilla/#distilabel.steps.argilla.preference.PreferenceToArgilla","title":"<code>PreferenceToArgilla</code>","text":"<p>             Bases: <code>Argilla</code></p> <p>Step that creates a dataset in Argilla during the load phase, and then pushes the input batches into it as records. This dataset is a preference dataset, where there's one field for the instruction and one extra field per each generation within the same record, and then a rating question per each of the generation fields. The rating question asks the annotator to set a rating from 1 to 5 for each of the provided generations.</p> Note <p>This step is meant to be used in conjunction with the <code>UltraFeedback</code> step, or any other step generating both ratings and responses for a given set of instruction and generations for the given instruction. But alternatively, it can also be used with any other task or step generating only the <code>instruction</code> and <code>generations</code>, as the <code>ratings</code> and <code>rationales</code> are optional.</p> <p>Attributes:</p> Name Type Description <code>num_generations</code> <code>int</code> <p>The number of generations to include in the dataset.</p> <code>dataset_name</code> <code>int</code> <p>The name of the dataset in Argilla.</p> <code>dataset_workspace</code> <code>int</code> <p>The workspace where the dataset will be created in Argilla. Defaults to <code>None</code>, which means it will be created in the default workspace.</p> <code>api_url</code> <code>int</code> <p>The URL of the Argilla API. Defaults to <code>None</code>, which means it will be read from the <code>ARGILLA_API_URL</code> environment variable.</p> <code>api_key</code> <code>int</code> <p>The API key to authenticate with Argilla. Defaults to <code>None</code>, which means it will be read from the <code>ARGILLA_API_KEY</code> environment variable.</p> Runtime parameters <ul> <li><code>api_url</code>: The base URL to use for the Argilla API requests.</li> <li><code>api_key</code>: The API key to authenticate the requests to the Argilla API.</li> </ul> Input columns <ul> <li>instruction (<code>str</code>): The instruction that was used to generate the completion.</li> <li>generations (<code>List[str]</code>): The completion that was generated based on the input instruction.</li> <li>ratings (<code>List[str]</code>, optional): The ratings for the generations. If not provided, the     generated ratings won't be pushed to Argilla.</li> <li>rationales (<code>List[str]</code>, optional): The rationales for the ratings. If not provided, the     generated rationales won't be pushed to Argilla.</li> </ul> Source code in <code>src/distilabel/steps/argilla/preference.py</code> <pre><code>class PreferenceToArgilla(Argilla):\n    \"\"\"Step that creates a dataset in Argilla during the load phase, and then pushes the input\n    batches into it as records. This dataset is a preference dataset, where there's one field\n    for the instruction and one extra field per each generation within the same record, and then\n    a rating question per each of the generation fields. The rating question asks the annotator to\n    set a rating from 1 to 5 for each of the provided generations.\n\n    Note:\n        This step is meant to be used in conjunction with the `UltraFeedback` step, or any other step\n        generating both ratings and responses for a given set of instruction and generations for the\n        given instruction. But alternatively, it can also be used with any other task or step generating\n        only the `instruction` and `generations`, as the `ratings` and `rationales` are optional.\n\n    Attributes:\n        num_generations: The number of generations to include in the dataset.\n        dataset_name: The name of the dataset in Argilla.\n        dataset_workspace: The workspace where the dataset will be created in Argilla. Defaults to\n            `None`, which means it will be created in the default workspace.\n        api_url: The URL of the Argilla API. Defaults to `None`, which means it will be read from\n            the `ARGILLA_API_URL` environment variable.\n        api_key: The API key to authenticate with Argilla. Defaults to `None`, which means it will\n            be read from the `ARGILLA_API_KEY` environment variable.\n\n    Runtime parameters:\n        - `api_url`: The base URL to use for the Argilla API requests.\n        - `api_key`: The API key to authenticate the requests to the Argilla API.\n\n    Input columns:\n        - instruction (`str`): The instruction that was used to generate the completion.\n        - generations (`List[str]`): The completion that was generated based on the input instruction.\n        - ratings (`List[str]`, optional): The ratings for the generations. If not provided, the\n            generated ratings won't be pushed to Argilla.\n        - rationales (`List[str]`, optional): The rationales for the ratings. If not provided, the\n            generated rationales won't be pushed to Argilla.\n    \"\"\"\n\n    num_generations: int\n\n    _id: str = PrivateAttr(default=\"id\")\n    _instruction: str = PrivateAttr(...)\n    _generations: str = PrivateAttr(...)\n    _ratings: str = PrivateAttr(...)\n    _rationales: str = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Sets the `_instruction` and `_generations` attributes based on the `inputs_mapping`, otherwise\n        uses the default values; and then uses those values to create a `FeedbackDataset` suited for\n        the text-generation scenario. And then it pushes it to Argilla.\n        \"\"\"\n        super().load()\n\n        self._rg_init()\n\n        # Both `instruction` and `generations` will be used as the fields of the dataset\n        self._instruction = self.input_mappings.get(\"instruction\", \"instruction\")\n        self._generations = self.input_mappings.get(\"generations\", \"generations\")\n        # Both `ratings` and `rationales` will be used as suggestions to the default questions of the dataset\n        self._ratings = self.input_mappings.get(\"ratings\", \"ratings\")\n        self._rationales = self.input_mappings.get(\"rationales\", \"rationales\")\n\n        if self._rg_dataset_exists():\n            _rg_dataset = rg.FeedbackDataset.from_argilla(  # type: ignore\n                name=self.dataset_name,\n                workspace=self.dataset_workspace,\n            )\n\n            for field in _rg_dataset.fields:\n                if (\n                    field.name\n                    not in [self._id, self._instruction]\n                    + [\n                        f\"{self._generations}-{idx}\"\n                        for idx in range(self.num_generations)\n                    ]\n                    and field.required\n                ):\n                    raise ValueError(\n                        f\"The dataset {self.dataset_name} in the workspace {self.dataset_workspace} already exists,\"\n                        f\" but contains at least a required field that is neither `{self._id}`, `{self._instruction}`,\"\n                        f\" nor `{self._generations}`.\"\n                    )\n\n            self._rg_dataset = _rg_dataset\n        else:\n            _rg_dataset = rg.FeedbackDataset(  # type: ignore\n                fields=[\n                    rg.TextField(name=self._id, title=self._id),  # type: ignore\n                    rg.TextField(name=self._instruction, title=self._instruction),  # type: ignore\n                    *self._generation_fields(),  # type: ignore\n                ],\n                questions=self._rating_rationale_pairs(),  # type: ignore\n            )\n            self._rg_dataset = _rg_dataset.push_to_argilla(\n                name=self.dataset_name, workspace=self.dataset_workspace\n            )\n\n    def _generation_fields(self) -&gt; List[\"TextField\"]:\n        \"\"\"Method to generate the fields for each of the generations.\"\"\"\n        return [\n            rg.TextField(  # type: ignore\n                name=f\"{self._generations}-{idx}\",\n                title=f\"{self._generations}-{idx}\",\n                required=True if idx == 0 else False,\n            )\n            for idx in range(self.num_generations)\n        ]\n\n    def _rating_rationale_pairs(\n        self,\n    ) -&gt; List[Union[\"RatingQuestion\", \"TextQuestion\"]]:\n        \"\"\"Method to generate the rating and rationale questions for each of the generations.\"\"\"\n        questions = []\n        for idx in range(self.num_generations):\n            questions.extend(\n                [\n                    rg.RatingQuestion(  # type: ignore\n                        name=f\"{self._generations}-{idx}-rating\",\n                        title=f\"Rate {self._generations}-{idx} given {self._instruction} based on the annotation guidelines.\",\n                        description=f\"Ignore this question if the corresponding `{self._generations}-{idx}` field is not available.\"\n                        if idx != 0\n                        else None,\n                        values=[1, 2, 3, 4, 5],\n                        required=True if idx == 0 else False,\n                    ),\n                    rg.TextQuestion(  # type: ignore\n                        name=f\"{self._generations}-{idx}-rationale\",\n                        title=f\"Specify the rationale for {self._generations}-{idx}'s rating.\",\n                        description=f\"Ignore this question if the corresponding `{self._generations}-{idx}` field is not available.\"\n                        if idx != 0\n                        else None,\n                        required=False,\n                    ),\n                ]\n            )\n        return questions\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The inputs for the step are the `instruction` and the `generations`. Optionally, one could also\n        provide the `ratings` and the `rationales` for the generations.\"\"\"\n        return [\"instruction\", \"generations\"]\n\n    def _add_suggestions_if_any(\n        self, input: Dict[str, Any]\n    ) -&gt; List[\"SuggestionSchema\"]:\n        \"\"\"Method to generate the suggestions for the `FeedbackRecord` based on the input.\"\"\"\n        # Since the `suggestions` i.e. answers to the `questions` are optional, will default to {}\n        suggestions = []\n        # If `ratings` is in `input`, then add those as suggestions\n        if self._ratings in input:\n            suggestions.extend(\n                [\n                    {\n                        \"question_name\": f\"{self._generations}-{idx}-rating\",\n                        \"value\": rating,\n                    }\n                    for idx, rating in enumerate(input[self._ratings])\n                    if rating is not None\n                    and isinstance(rating, int)\n                    and rating in [1, 2, 3, 4, 5]\n                ],\n            )\n        # If `rationales` is in `input`, then add those as suggestions\n        if self._rationales in input:\n            suggestions.extend(\n                [\n                    {\n                        \"question_name\": f\"{self._generations}-{idx}-rationale\",\n                        \"value\": rationale,\n                    }\n                    for idx, rationale in enumerate(input[self._rationales])\n                    if rationale is not None and isinstance(rationale, str)\n                ],\n            )\n        return suggestions\n\n    @override\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Creates and pushes the records as FeedbackRecords to the Argilla dataset.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Returns:\n            A list of Python dictionaries with the outputs of the task.\n        \"\"\"\n        records = []\n        for input in inputs:\n            # Generate the SHA-256 hash of the instruction to use it as the metadata\n            instruction_id = hashlib.sha256(\n                input[\"instruction\"].encode(\"utf-8\")  # type: ignore\n            ).hexdigest()\n\n            generations = {\n                f\"{self._generations}-{idx}\": generation\n                for idx, generation in enumerate(input[\"generations\"])  # type: ignore\n            }\n\n            records.append(  # type: ignore\n                rg.FeedbackRecord(  # type: ignore\n                    fields={\n                        \"id\": instruction_id,\n                        \"instruction\": input[\"instruction\"],  # type: ignore\n                        **generations,\n                    },\n                    suggestions=self._add_suggestions_if_any(input),  # type: ignore\n                )\n            )\n        self._rg_dataset.add_records(records)  # type: ignore\n        yield inputs\n</code></pre>"},{"location":"api/steps/argilla/#distilabel.steps.argilla.preference.PreferenceToArgilla.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The inputs for the step are the <code>instruction</code> and the <code>generations</code>. Optionally, one could also provide the <code>ratings</code> and the <code>rationales</code> for the generations.</p>"},{"location":"api/steps/argilla/#distilabel.steps.argilla.preference.PreferenceToArgilla.load","title":"<code>load()</code>","text":"<p>Sets the <code>_instruction</code> and <code>_generations</code> attributes based on the <code>inputs_mapping</code>, otherwise uses the default values; and then uses those values to create a <code>FeedbackDataset</code> suited for the text-generation scenario. And then it pushes it to Argilla.</p> Source code in <code>src/distilabel/steps/argilla/preference.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Sets the `_instruction` and `_generations` attributes based on the `inputs_mapping`, otherwise\n    uses the default values; and then uses those values to create a `FeedbackDataset` suited for\n    the text-generation scenario. And then it pushes it to Argilla.\n    \"\"\"\n    super().load()\n\n    self._rg_init()\n\n    # Both `instruction` and `generations` will be used as the fields of the dataset\n    self._instruction = self.input_mappings.get(\"instruction\", \"instruction\")\n    self._generations = self.input_mappings.get(\"generations\", \"generations\")\n    # Both `ratings` and `rationales` will be used as suggestions to the default questions of the dataset\n    self._ratings = self.input_mappings.get(\"ratings\", \"ratings\")\n    self._rationales = self.input_mappings.get(\"rationales\", \"rationales\")\n\n    if self._rg_dataset_exists():\n        _rg_dataset = rg.FeedbackDataset.from_argilla(  # type: ignore\n            name=self.dataset_name,\n            workspace=self.dataset_workspace,\n        )\n\n        for field in _rg_dataset.fields:\n            if (\n                field.name\n                not in [self._id, self._instruction]\n                + [\n                    f\"{self._generations}-{idx}\"\n                    for idx in range(self.num_generations)\n                ]\n                and field.required\n            ):\n                raise ValueError(\n                    f\"The dataset {self.dataset_name} in the workspace {self.dataset_workspace} already exists,\"\n                    f\" but contains at least a required field that is neither `{self._id}`, `{self._instruction}`,\"\n                    f\" nor `{self._generations}`.\"\n                )\n\n        self._rg_dataset = _rg_dataset\n    else:\n        _rg_dataset = rg.FeedbackDataset(  # type: ignore\n            fields=[\n                rg.TextField(name=self._id, title=self._id),  # type: ignore\n                rg.TextField(name=self._instruction, title=self._instruction),  # type: ignore\n                *self._generation_fields(),  # type: ignore\n            ],\n            questions=self._rating_rationale_pairs(),  # type: ignore\n        )\n        self._rg_dataset = _rg_dataset.push_to_argilla(\n            name=self.dataset_name, workspace=self.dataset_workspace\n        )\n</code></pre>"},{"location":"api/steps/argilla/#distilabel.steps.argilla.preference.PreferenceToArgilla.process","title":"<code>process(inputs)</code>","text":"<p>Creates and pushes the records as FeedbackRecords to the Argilla dataset.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>A list of Python dictionaries with the inputs of the task.</p> required <p>Returns:</p> Type Description <code>StepOutput</code> <p>A list of Python dictionaries with the outputs of the task.</p> Source code in <code>src/distilabel/steps/argilla/preference.py</code> <pre><code>@override\ndef process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Creates and pushes the records as FeedbackRecords to the Argilla dataset.\n\n    Args:\n        inputs: A list of Python dictionaries with the inputs of the task.\n\n    Returns:\n        A list of Python dictionaries with the outputs of the task.\n    \"\"\"\n    records = []\n    for input in inputs:\n        # Generate the SHA-256 hash of the instruction to use it as the metadata\n        instruction_id = hashlib.sha256(\n            input[\"instruction\"].encode(\"utf-8\")  # type: ignore\n        ).hexdigest()\n\n        generations = {\n            f\"{self._generations}-{idx}\": generation\n            for idx, generation in enumerate(input[\"generations\"])  # type: ignore\n        }\n\n        records.append(  # type: ignore\n            rg.FeedbackRecord(  # type: ignore\n                fields={\n                    \"id\": instruction_id,\n                    \"instruction\": input[\"instruction\"],  # type: ignore\n                    **generations,\n                },\n                suggestions=self._add_suggestions_if_any(input),  # type: ignore\n            )\n        )\n    self._rg_dataset.add_records(records)  # type: ignore\n    yield inputs\n</code></pre>"},{"location":"api/steps/argilla/#distilabel.steps.argilla.text_generation.TextGenerationToArgilla","title":"<code>TextGenerationToArgilla</code>","text":"<p>             Bases: <code>Argilla</code></p> <p>Step that creates a dataset in Argilla during the load phase, and then pushes the input batches into it as records. This dataset is a text-generation dataset, where there's one field per each input, and then a label question to rate the quality of the completion in either bad (represented with \ud83d\udc4e) or good (represented with \ud83d\udc4d).</p> Note <p>This step is meant to be used in conjunction with a <code>TextGeneration</code> step and no column mapping is needed, as it will use the default values for the <code>instruction</code> and <code>generation</code> columns.</p> <p>Attributes:</p> Name Type Description <code>dataset_name</code> <p>The name of the dataset in Argilla.</p> <code>dataset_workspace</code> <p>The workspace where the dataset will be created in Argilla. Defaults to <code>None</code>, which means it will be created in the default workspace.</p> <code>api_url</code> <p>The URL of the Argilla API. Defaults to <code>None</code>, which means it will be read from the <code>ARGILLA_API_URL</code> environment variable.</p> <code>api_key</code> <p>The API key to authenticate with Argilla. Defaults to <code>None</code>, which means it will be read from the <code>ARGILLA_API_KEY</code> environment variable.</p> Runtime parameters <ul> <li><code>api_url</code>: The base URL to use for the Argilla API requests.</li> <li><code>api_key</code>: The API key to authenticate the requests to the Argilla API.</li> </ul> Input columns <ul> <li>instruction (<code>str</code>): The instruction that was used to generate the completion.</li> <li>generation (<code>str</code> or <code>List[str]</code>): The completions that were generated based on the input instruction.</li> </ul> Source code in <code>src/distilabel/steps/argilla/text_generation.py</code> <pre><code>class TextGenerationToArgilla(Argilla):\n    \"\"\"Step that creates a dataset in Argilla during the load phase, and then pushes the input\n    batches into it as records. This dataset is a text-generation dataset, where there's one field\n    per each input, and then a label question to rate the quality of the completion in either bad\n    (represented with \ud83d\udc4e) or good (represented with \ud83d\udc4d).\n\n    Note:\n        This step is meant to be used in conjunction with a `TextGeneration` step and no column mapping\n        is needed, as it will use the default values for the `instruction` and `generation` columns.\n\n    Attributes:\n        dataset_name: The name of the dataset in Argilla.\n        dataset_workspace: The workspace where the dataset will be created in Argilla. Defaults to\n            `None`, which means it will be created in the default workspace.\n        api_url: The URL of the Argilla API. Defaults to `None`, which means it will be read from\n            the `ARGILLA_API_URL` environment variable.\n        api_key: The API key to authenticate with Argilla. Defaults to `None`, which means it will\n            be read from the `ARGILLA_API_KEY` environment variable.\n\n    Runtime parameters:\n        - `api_url`: The base URL to use for the Argilla API requests.\n        - `api_key`: The API key to authenticate the requests to the Argilla API.\n\n    Input columns:\n        - instruction (`str`): The instruction that was used to generate the completion.\n        - generation (`str` or `List[str]`): The completions that were generated based on the input instruction.\n    \"\"\"\n\n    _id: str = PrivateAttr(default=\"id\")\n    _instruction: str = PrivateAttr(...)\n    _generation: str = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Sets the `_instruction` and `_generation` attributes based on the `inputs_mapping`, otherwise\n        uses the default values; and then uses those values to create a `FeedbackDataset` suited for\n        the text-generation scenario. And then it pushes it to Argilla.\n        \"\"\"\n        super().load()\n\n        self._rg_init()\n\n        self._instruction = self.input_mappings.get(\"instruction\", \"instruction\")\n        self._generation = self.input_mappings.get(\"generation\", \"generation\")\n\n        if self._rg_dataset_exists():\n            _rg_dataset = rg.FeedbackDataset.from_argilla(\n                name=self.dataset_name,\n                workspace=self.dataset_workspace,\n            )\n\n            for field in _rg_dataset.fields:\n                if (\n                    field.name not in [self._id, self._instruction, self._generation]\n                    and field.required\n                ):\n                    raise ValueError(\n                        f\"The dataset {self.dataset_name} in the workspace {self.dataset_workspace} already exists,\"\n                        f\" but contains at least a required field that is neither `{self._id}`, `{self._instruction}`\"\n                        f\", nor `{self._generation}`.\"\n                    )\n\n            self._rg_dataset = _rg_dataset\n        else:\n            _rg_dataset = rg.FeedbackDataset(\n                fields=[\n                    rg.TextField(name=self._id, title=self._id),  # type: ignore\n                    rg.TextField(name=self._instruction, title=self._instruction),  # type: ignore\n                    rg.TextField(name=self._generation, title=self._generation),  # type: ignore\n                ],\n                questions=[\n                    rg.LabelQuestion(  # type: ignore\n                        name=\"quality\",\n                        title=f\"What's the quality of the {self._generation} for the given {self._instruction}?\",\n                        labels={\"bad\": \"\ud83d\udc4e\", \"good\": \"\ud83d\udc4d\"},\n                    )\n                ],\n            )\n            self._rg_dataset = _rg_dataset.push_to_argilla(\n                name=self.dataset_name, workspace=self.dataset_workspace\n            )\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The inputs for the step are the `instruction` and the `generation`.\"\"\"\n        return [\"instruction\", \"generation\"]\n\n    @override\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Creates and pushes the records as FeedbackRecords to the Argilla dataset.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Returns:\n            A list of Python dictionaries with the outputs of the task.\n        \"\"\"\n        records = []\n        for input in inputs:\n            # Generate the SHA-256 hash of the instruction to use it as the metadata\n            instruction_id = hashlib.sha256(\n                input[\"instruction\"].encode(\"utf-8\")\n            ).hexdigest()\n\n            generations = input[\"generation\"]\n\n            # If the `generation` is not a list, then convert it into a list\n            if not isinstance(generations, list):\n                generations = [generations]\n\n            # Create a `generations_set` to avoid adding duplicates\n            generations_set = set()\n\n            for generation in generations:\n                # If the generation is already in the set, then skip it\n                if generation in generations_set:\n                    continue\n                # Otherwise, add it to the set\n                generations_set.add(generation)\n\n                records.append(\n                    rg.FeedbackRecord(\n                        fields={\n                            self._id: instruction_id,\n                            self._instruction: input[\"instruction\"],\n                            self._generation: generation,\n                        },\n                    )\n                )\n        self._rg_dataset.add_records(records)  # type: ignore\n        yield inputs\n</code></pre>"},{"location":"api/steps/argilla/#distilabel.steps.argilla.text_generation.TextGenerationToArgilla.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The inputs for the step are the <code>instruction</code> and the <code>generation</code>.</p>"},{"location":"api/steps/argilla/#distilabel.steps.argilla.text_generation.TextGenerationToArgilla.load","title":"<code>load()</code>","text":"<p>Sets the <code>_instruction</code> and <code>_generation</code> attributes based on the <code>inputs_mapping</code>, otherwise uses the default values; and then uses those values to create a <code>FeedbackDataset</code> suited for the text-generation scenario. And then it pushes it to Argilla.</p> Source code in <code>src/distilabel/steps/argilla/text_generation.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Sets the `_instruction` and `_generation` attributes based on the `inputs_mapping`, otherwise\n    uses the default values; and then uses those values to create a `FeedbackDataset` suited for\n    the text-generation scenario. And then it pushes it to Argilla.\n    \"\"\"\n    super().load()\n\n    self._rg_init()\n\n    self._instruction = self.input_mappings.get(\"instruction\", \"instruction\")\n    self._generation = self.input_mappings.get(\"generation\", \"generation\")\n\n    if self._rg_dataset_exists():\n        _rg_dataset = rg.FeedbackDataset.from_argilla(\n            name=self.dataset_name,\n            workspace=self.dataset_workspace,\n        )\n\n        for field in _rg_dataset.fields:\n            if (\n                field.name not in [self._id, self._instruction, self._generation]\n                and field.required\n            ):\n                raise ValueError(\n                    f\"The dataset {self.dataset_name} in the workspace {self.dataset_workspace} already exists,\"\n                    f\" but contains at least a required field that is neither `{self._id}`, `{self._instruction}`\"\n                    f\", nor `{self._generation}`.\"\n                )\n\n        self._rg_dataset = _rg_dataset\n    else:\n        _rg_dataset = rg.FeedbackDataset(\n            fields=[\n                rg.TextField(name=self._id, title=self._id),  # type: ignore\n                rg.TextField(name=self._instruction, title=self._instruction),  # type: ignore\n                rg.TextField(name=self._generation, title=self._generation),  # type: ignore\n            ],\n            questions=[\n                rg.LabelQuestion(  # type: ignore\n                    name=\"quality\",\n                    title=f\"What's the quality of the {self._generation} for the given {self._instruction}?\",\n                    labels={\"bad\": \"\ud83d\udc4e\", \"good\": \"\ud83d\udc4d\"},\n                )\n            ],\n        )\n        self._rg_dataset = _rg_dataset.push_to_argilla(\n            name=self.dataset_name, workspace=self.dataset_workspace\n        )\n</code></pre>"},{"location":"api/steps/argilla/#distilabel.steps.argilla.text_generation.TextGenerationToArgilla.process","title":"<code>process(inputs)</code>","text":"<p>Creates and pushes the records as FeedbackRecords to the Argilla dataset.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>A list of Python dictionaries with the inputs of the task.</p> required <p>Returns:</p> Type Description <code>StepOutput</code> <p>A list of Python dictionaries with the outputs of the task.</p> Source code in <code>src/distilabel/steps/argilla/text_generation.py</code> <pre><code>@override\ndef process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Creates and pushes the records as FeedbackRecords to the Argilla dataset.\n\n    Args:\n        inputs: A list of Python dictionaries with the inputs of the task.\n\n    Returns:\n        A list of Python dictionaries with the outputs of the task.\n    \"\"\"\n    records = []\n    for input in inputs:\n        # Generate the SHA-256 hash of the instruction to use it as the metadata\n        instruction_id = hashlib.sha256(\n            input[\"instruction\"].encode(\"utf-8\")\n        ).hexdigest()\n\n        generations = input[\"generation\"]\n\n        # If the `generation` is not a list, then convert it into a list\n        if not isinstance(generations, list):\n            generations = [generations]\n\n        # Create a `generations_set` to avoid adding duplicates\n        generations_set = set()\n\n        for generation in generations:\n            # If the generation is already in the set, then skip it\n            if generation in generations_set:\n                continue\n            # Otherwise, add it to the set\n            generations_set.add(generation)\n\n            records.append(\n                rg.FeedbackRecord(\n                    fields={\n                        self._id: instruction_id,\n                        self._instruction: input[\"instruction\"],\n                        self._generation: generation,\n                    },\n                )\n            )\n    self._rg_dataset.add_records(records)  # type: ignore\n    yield inputs\n</code></pre>"},{"location":"api/steps/decorator/","title":"step decorator","text":"<p>This section contains the reference for the <code>@step</code> decorator,</p>"},{"location":"api/steps/decorator/#distilabel.steps.decorator.step","title":"<code>step(inputs=None, outputs=None, step_type='normal')</code>","text":"<p>Creates an <code>Step</code> from a processing function.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Union[List[str], None]</code> <p>a list containing the name of the inputs columns/keys expected by this step. If not provided the default will be an empty list <code>[]</code> and it will be assumed that the step doesn't need any specific columns. Defaults to <code>None</code>.</p> <code>None</code> <code>outputs</code> <code>Union[List[str], None]</code> <p>a list containing the name of the outputs columns/keys that the step will generate. If not provided the default will be an empty list <code>[]</code> and it will be assumed that the step doesn't need any specific columns. Defaults to <code>None</code>.</p> <code>None</code> <code>step_type</code> <code>Literal['normal', 'global', 'generator']</code> <p>the kind of step to create. Valid choices are: \"normal\" (<code>Step</code>), \"global\" (<code>GlobalStep</code>) or \"generator\" (<code>GeneratorStep</code>). Defaults to <code>\"normal\"</code>.</p> <code>'normal'</code> <p>Returns:</p> Type Description <code>Callable[..., Type[_Step]]</code> <p>A callable that will generate the type given the processing function.</p> <p>Example:</p> <pre><code># Normal step\n@step(inputs=[\"instruction\"], outputs=[\"generation\"])\ndef GenerationStep(inputs: StepInput, dummy_generation: RuntimeParameter[str]) -&gt; StepOutput:\n    for input in inputs:\n        input[\"generation\"] = dummy_generation\n    yield inputs\n\n# Global step\n@step(inputs=[\"instruction\"], step_type=\"global\")\ndef FilteringStep(inputs: StepInput, max_length: RuntimeParameter[int] = 256) -&gt; StepOutput:\n    yield [\n        input\n        for input in inputs\n        if len(input[\"instruction\"]) &lt;= max_length\n    ]\n\n# Generator step\n@step(outputs=[\"num\"], step_type=\"generator\")\ndef RowGenerator(num_rows: RuntimeParameter[int] = 500) -&gt; GeneratorStepOutput:\n    data = list(range(num_rows))\n    for i in range(0, len(data), 100):\n        last_batch = i + 100 &gt;= len(data)\n        yield [{\"num\": num} for num in data[i : i + 100]], last_batch\n</code></pre> Source code in <code>src/distilabel/steps/decorator.py</code> <pre><code>def step(\n    inputs: Union[List[str], None] = None,\n    outputs: Union[List[str], None] = None,\n    step_type: Literal[\"normal\", \"global\", \"generator\"] = \"normal\",\n) -&gt; Callable[..., Type[\"_Step\"]]:\n    \"\"\"Creates an `Step` from a processing function.\n\n    Args:\n        inputs: a list containing the name of the inputs columns/keys expected by this step.\n            If not provided the default will be an empty list `[]` and it will be assumed\n            that the step doesn't need any specific columns. Defaults to `None`.\n        outputs: a list containing the name of the outputs columns/keys that the step\n            will generate. If not provided the default will be an empty list `[]` and it\n            will be assumed that the step doesn't need any specific columns. Defaults to\n            `None`.\n        step_type: the kind of step to create. Valid choices are: \"normal\" (`Step`),\n            \"global\" (`GlobalStep`) or \"generator\" (`GeneratorStep`). Defaults to\n            `\"normal\"`.\n\n    Returns:\n        A callable that will generate the type given the processing function.\n\n    Example:\n\n    ```python\n    # Normal step\n    @step(inputs=[\"instruction\"], outputs=[\"generation\"])\n    def GenerationStep(inputs: StepInput, dummy_generation: RuntimeParameter[str]) -&gt; StepOutput:\n        for input in inputs:\n            input[\"generation\"] = dummy_generation\n        yield inputs\n\n    # Global step\n    @step(inputs=[\"instruction\"], step_type=\"global\")\n    def FilteringStep(inputs: StepInput, max_length: RuntimeParameter[int] = 256) -&gt; StepOutput:\n        yield [\n            input\n            for input in inputs\n            if len(input[\"instruction\"]) &lt;= max_length\n        ]\n\n    # Generator step\n    @step(outputs=[\"num\"], step_type=\"generator\")\n    def RowGenerator(num_rows: RuntimeParameter[int] = 500) -&gt; GeneratorStepOutput:\n        data = list(range(num_rows))\n        for i in range(0, len(data), 100):\n            last_batch = i + 100 &gt;= len(data)\n            yield [{\"num\": num} for num in data[i : i + 100]], last_batch\n    ```\n    \"\"\"\n\n    inputs = inputs or []\n    outputs = outputs or []\n\n    def decorator(func: ProcessingFunc) -&gt; Type[\"_Step\"]:\n        if step_type not in _STEP_MAPPING:\n            raise ValueError(\n                f\"Invalid step type '{step_type}'. Please, review the '{func.__name__}'\"\n                \" function decorated with the `@step` decorator and provide a valid\"\n                \" `step_type`. Valid choices are: 'normal', 'global' or 'generator'.\"\n            )\n\n        BaseClass = _STEP_MAPPING[step_type]\n\n        signature = inspect.signature(func)\n\n        runtime_parameters = {\n            name: (\n                param.annotation,\n                param.default if param.default != param.empty else None,\n            )\n            for name, param in signature.parameters.items()\n        }\n\n        runtime_parameters = {}\n        step_input_parameter = None\n        for name, param in signature.parameters.items():\n            if is_parameter_annotated_with(param, _RUNTIME_PARAMETER_ANNOTATION):\n                runtime_parameters[name] = (\n                    param.annotation,\n                    param.default if param.default != param.empty else None,\n                )\n\n            if not step_type == \"generator\" and is_parameter_annotated_with(\n                param, _STEP_INPUT_ANNOTATION\n            ):\n                if step_input_parameter is not None:\n                    raise ValueError(\n                        f\"Function '{func.__name__}' has more than one parameter annotated\"\n                        f\" with `StepInput`. Please, review the '{func.__name__}' function\"\n                        \" decorated with the `@step` decorator and provide only one\"\n                        \" argument annotated with `StepInput`.\"\n                    )\n                step_input_parameter = param\n\n        RuntimeParametersModel = create_model(  # type: ignore\n            \"RuntimeParametersModel\",\n            **runtime_parameters,  # type: ignore\n        )\n\n        def inputs_property(self) -&gt; List[str]:\n            return inputs\n\n        def outputs_property(self) -&gt; List[str]:\n            return outputs\n\n        def process(\n            self, *args: Any, **kwargs: Any\n        ) -&gt; Union[\"StepOutput\", \"GeneratorStepOutput\"]:\n            return func(*args, **kwargs)\n\n        return type(  # type: ignore\n            func.__name__,\n            (\n                BaseClass,\n                RuntimeParametersModel,\n            ),\n            {\n                \"process\": process,\n                \"inputs\": property(inputs_property),\n                \"outputs\": property(outputs_property),\n                \"__module__\": func.__module__,\n                \"__doc__\": func.__doc__,\n                \"_built_from_decorator\": True,\n                # Override the `get_process_step_input` method to return the parameter\n                # of the original function annotated with `StepInput`.\n                \"get_process_step_input\": lambda self: step_input_parameter,\n            },\n        )\n\n    return decorator\n</code></pre>"},{"location":"api/steps/extra/","title":"Extra","text":""},{"location":"api/steps/extra/#distilabel.steps.combine.CombineColumns","title":"<code>CombineColumns</code>","text":"<p>             Bases: <code>Step</code></p> <p>CombineColumns is a Step that implements the <code>process</code> method that calls the <code>combine_dicts</code> function to handle and combine a list of <code>StepInput</code>. Also <code>CombineColumns</code> provides two attributes <code>columns</code> and <code>output_columns</code> to specify the columns to merge and the output columns which will override the default value for the properties <code>inputs</code> and <code>outputs</code>, respectively.</p> <p>Attributes:</p> Name Type Description <code>columns</code> <code>List[str]</code> <p>List of strings with the names of the columns to merge.</p> <code>output_columns</code> <code>Optional[List[str]]</code> <p>Optional list of strings with the names of the output columns.</p> Input columns <ul> <li>dynamic, based on the <code>columns</code> value provided.</li> </ul> Output columns <ul> <li>dynamic, based on the <code>output_columns</code> value provided or <code>merged_{column}</code> for each column in <code>columns</code>.</li> </ul> Source code in <code>src/distilabel/steps/combine.py</code> <pre><code>class CombineColumns(Step):\n    \"\"\"CombineColumns is a Step that implements the `process` method that calls the `combine_dicts`\n    function to handle and combine a list of `StepInput`. Also `CombineColumns` provides two attributes\n    `columns` and `output_columns` to specify the columns to merge and the output columns\n    which will override the default value for the properties `inputs` and `outputs`, respectively.\n\n    Attributes:\n        columns: List of strings with the names of the columns to merge.\n        output_columns: Optional list of strings with the names of the output columns.\n\n    Input columns:\n        - dynamic, based on the `columns` value provided.\n\n    Output columns:\n        - dynamic, based on the `output_columns` value provided or `merged_{column}` for each column in `columns`.\n    \"\"\"\n\n    columns: List[str]\n    output_columns: Optional[List[str]] = None\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The inputs for the task are the column names in `columns`.\"\"\"\n        return self.columns\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The outputs for the task are the column names in `output_columns` or\n        `merged_{column}` for each column in `columns`.\"\"\"\n        return (\n            self.output_columns\n            if self.output_columns is not None\n            else [f\"merged_{column}\" for column in self.columns]\n        )\n\n    @override\n    def process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n        \"\"\"The `process` method calls the `combine_dicts` function to handle and combine a list of `StepInput`.\n\n        Args:\n            *inputs: A list of `StepInput` to be combined.\n\n        Yields:\n            A `StepOutput` with the combined `StepInput` using the `combine_dicts` function.\n        \"\"\"\n        yield combine_dicts(\n            *inputs,\n            merge_keys=self.inputs,\n            output_merge_keys=self.outputs,\n        )\n</code></pre>"},{"location":"api/steps/extra/#distilabel.steps.combine.CombineColumns.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The inputs for the task are the column names in <code>columns</code>.</p>"},{"location":"api/steps/extra/#distilabel.steps.combine.CombineColumns.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The outputs for the task are the column names in <code>output_columns</code> or <code>merged_{column}</code> for each column in <code>columns</code>.</p>"},{"location":"api/steps/extra/#distilabel.steps.combine.CombineColumns.process","title":"<code>process(*inputs)</code>","text":"<p>The <code>process</code> method calls the <code>combine_dicts</code> function to handle and combine a list of <code>StepInput</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*inputs</code> <code>StepInput</code> <p>A list of <code>StepInput</code> to be combined.</p> <code>()</code> <p>Yields:</p> Type Description <code>StepOutput</code> <p>A <code>StepOutput</code> with the combined <code>StepInput</code> using the <code>combine_dicts</code> function.</p> Source code in <code>src/distilabel/steps/combine.py</code> <pre><code>@override\ndef process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n    \"\"\"The `process` method calls the `combine_dicts` function to handle and combine a list of `StepInput`.\n\n    Args:\n        *inputs: A list of `StepInput` to be combined.\n\n    Yields:\n        A `StepOutput` with the combined `StepInput` using the `combine_dicts` function.\n    \"\"\"\n    yield combine_dicts(\n        *inputs,\n        merge_keys=self.inputs,\n        output_merge_keys=self.outputs,\n    )\n</code></pre>"},{"location":"api/steps/extra/#distilabel.steps.conversation.ConversationTemplate","title":"<code>ConversationTemplate</code>","text":"<p>             Bases: <code>Step</code></p> <p>Generate a conversation template from an instruction and a response.</p> Input columns <ul> <li>instruction (<code>str</code>): The instruction to be used in the conversation.</li> <li>response (<code>str</code>): The response to be used in the conversation.</li> </ul> Output columns <ul> <li>conversation (<code>ChatType</code>): The conversation template.</li> </ul> Source code in <code>src/distilabel/steps/conversation.py</code> <pre><code>class ConversationTemplate(Step):\n    \"\"\"Generate a conversation template from an instruction and a response.\n\n    Input columns:\n        - instruction (`str`): The instruction to be used in the conversation.\n        - response (`str`): The response to be used in the conversation.\n\n    Output columns:\n        - conversation (`ChatType`): The conversation template.\n    \"\"\"\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The instruction and response.\"\"\"\n        return [\"instruction\", \"response\"]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The conversation template.\"\"\"\n        return [\"conversation\"]\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Generate a conversation template from an instruction and a response.\n\n        Args:\n            inputs: The input data.\n\n        Yields:\n            The input data with the conversation template.\n        \"\"\"\n        for input in inputs:\n            input[\"conversation\"] = [\n                {\"role\": \"user\", \"content\": input[\"instruction\"]},\n                {\"role\": \"assistant\", \"content\": input[\"response\"]},\n            ]\n        yield inputs\n</code></pre>"},{"location":"api/steps/extra/#distilabel.steps.conversation.ConversationTemplate.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The instruction and response.</p>"},{"location":"api/steps/extra/#distilabel.steps.conversation.ConversationTemplate.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The conversation template.</p>"},{"location":"api/steps/extra/#distilabel.steps.conversation.ConversationTemplate.process","title":"<code>process(inputs)</code>","text":"<p>Generate a conversation template from an instruction and a response.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>The input data.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>The input data with the conversation template.</p> Source code in <code>src/distilabel/steps/conversation.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Generate a conversation template from an instruction and a response.\n\n    Args:\n        inputs: The input data.\n\n    Yields:\n        The input data with the conversation template.\n    \"\"\"\n    for input in inputs:\n        input[\"conversation\"] = [\n            {\"role\": \"user\", \"content\": input[\"instruction\"]},\n            {\"role\": \"assistant\", \"content\": input[\"response\"]},\n        ]\n    yield inputs\n</code></pre>"},{"location":"api/steps/extra/#distilabel.steps.decorator.step","title":"<code>step(inputs=None, outputs=None, step_type='normal')</code>","text":"<p>Creates an <code>Step</code> from a processing function.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Union[List[str], None]</code> <p>a list containing the name of the inputs columns/keys expected by this step. If not provided the default will be an empty list <code>[]</code> and it will be assumed that the step doesn't need any specific columns. Defaults to <code>None</code>.</p> <code>None</code> <code>outputs</code> <code>Union[List[str], None]</code> <p>a list containing the name of the outputs columns/keys that the step will generate. If not provided the default will be an empty list <code>[]</code> and it will be assumed that the step doesn't need any specific columns. Defaults to <code>None</code>.</p> <code>None</code> <code>step_type</code> <code>Literal['normal', 'global', 'generator']</code> <p>the kind of step to create. Valid choices are: \"normal\" (<code>Step</code>), \"global\" (<code>GlobalStep</code>) or \"generator\" (<code>GeneratorStep</code>). Defaults to <code>\"normal\"</code>.</p> <code>'normal'</code> <p>Returns:</p> Type Description <code>Callable[..., Type[_Step]]</code> <p>A callable that will generate the type given the processing function.</p> <p>Example:</p> <pre><code># Normal step\n@step(inputs=[\"instruction\"], outputs=[\"generation\"])\ndef GenerationStep(inputs: StepInput, dummy_generation: RuntimeParameter[str]) -&gt; StepOutput:\n    for input in inputs:\n        input[\"generation\"] = dummy_generation\n    yield inputs\n\n# Global step\n@step(inputs=[\"instruction\"], step_type=\"global\")\ndef FilteringStep(inputs: StepInput, max_length: RuntimeParameter[int] = 256) -&gt; StepOutput:\n    yield [\n        input\n        for input in inputs\n        if len(input[\"instruction\"]) &lt;= max_length\n    ]\n\n# Generator step\n@step(outputs=[\"num\"], step_type=\"generator\")\ndef RowGenerator(num_rows: RuntimeParameter[int] = 500) -&gt; GeneratorStepOutput:\n    data = list(range(num_rows))\n    for i in range(0, len(data), 100):\n        last_batch = i + 100 &gt;= len(data)\n        yield [{\"num\": num} for num in data[i : i + 100]], last_batch\n</code></pre> Source code in <code>src/distilabel/steps/decorator.py</code> <pre><code>def step(\n    inputs: Union[List[str], None] = None,\n    outputs: Union[List[str], None] = None,\n    step_type: Literal[\"normal\", \"global\", \"generator\"] = \"normal\",\n) -&gt; Callable[..., Type[\"_Step\"]]:\n    \"\"\"Creates an `Step` from a processing function.\n\n    Args:\n        inputs: a list containing the name of the inputs columns/keys expected by this step.\n            If not provided the default will be an empty list `[]` and it will be assumed\n            that the step doesn't need any specific columns. Defaults to `None`.\n        outputs: a list containing the name of the outputs columns/keys that the step\n            will generate. If not provided the default will be an empty list `[]` and it\n            will be assumed that the step doesn't need any specific columns. Defaults to\n            `None`.\n        step_type: the kind of step to create. Valid choices are: \"normal\" (`Step`),\n            \"global\" (`GlobalStep`) or \"generator\" (`GeneratorStep`). Defaults to\n            `\"normal\"`.\n\n    Returns:\n        A callable that will generate the type given the processing function.\n\n    Example:\n\n    ```python\n    # Normal step\n    @step(inputs=[\"instruction\"], outputs=[\"generation\"])\n    def GenerationStep(inputs: StepInput, dummy_generation: RuntimeParameter[str]) -&gt; StepOutput:\n        for input in inputs:\n            input[\"generation\"] = dummy_generation\n        yield inputs\n\n    # Global step\n    @step(inputs=[\"instruction\"], step_type=\"global\")\n    def FilteringStep(inputs: StepInput, max_length: RuntimeParameter[int] = 256) -&gt; StepOutput:\n        yield [\n            input\n            for input in inputs\n            if len(input[\"instruction\"]) &lt;= max_length\n        ]\n\n    # Generator step\n    @step(outputs=[\"num\"], step_type=\"generator\")\n    def RowGenerator(num_rows: RuntimeParameter[int] = 500) -&gt; GeneratorStepOutput:\n        data = list(range(num_rows))\n        for i in range(0, len(data), 100):\n            last_batch = i + 100 &gt;= len(data)\n            yield [{\"num\": num} for num in data[i : i + 100]], last_batch\n    ```\n    \"\"\"\n\n    inputs = inputs or []\n    outputs = outputs or []\n\n    def decorator(func: ProcessingFunc) -&gt; Type[\"_Step\"]:\n        if step_type not in _STEP_MAPPING:\n            raise ValueError(\n                f\"Invalid step type '{step_type}'. Please, review the '{func.__name__}'\"\n                \" function decorated with the `@step` decorator and provide a valid\"\n                \" `step_type`. Valid choices are: 'normal', 'global' or 'generator'.\"\n            )\n\n        BaseClass = _STEP_MAPPING[step_type]\n\n        signature = inspect.signature(func)\n\n        runtime_parameters = {\n            name: (\n                param.annotation,\n                param.default if param.default != param.empty else None,\n            )\n            for name, param in signature.parameters.items()\n        }\n\n        runtime_parameters = {}\n        step_input_parameter = None\n        for name, param in signature.parameters.items():\n            if is_parameter_annotated_with(param, _RUNTIME_PARAMETER_ANNOTATION):\n                runtime_parameters[name] = (\n                    param.annotation,\n                    param.default if param.default != param.empty else None,\n                )\n\n            if not step_type == \"generator\" and is_parameter_annotated_with(\n                param, _STEP_INPUT_ANNOTATION\n            ):\n                if step_input_parameter is not None:\n                    raise ValueError(\n                        f\"Function '{func.__name__}' has more than one parameter annotated\"\n                        f\" with `StepInput`. Please, review the '{func.__name__}' function\"\n                        \" decorated with the `@step` decorator and provide only one\"\n                        \" argument annotated with `StepInput`.\"\n                    )\n                step_input_parameter = param\n\n        RuntimeParametersModel = create_model(  # type: ignore\n            \"RuntimeParametersModel\",\n            **runtime_parameters,  # type: ignore\n        )\n\n        def inputs_property(self) -&gt; List[str]:\n            return inputs\n\n        def outputs_property(self) -&gt; List[str]:\n            return outputs\n\n        def process(\n            self, *args: Any, **kwargs: Any\n        ) -&gt; Union[\"StepOutput\", \"GeneratorStepOutput\"]:\n            return func(*args, **kwargs)\n\n        return type(  # type: ignore\n            func.__name__,\n            (\n                BaseClass,\n                RuntimeParametersModel,\n            ),\n            {\n                \"process\": process,\n                \"inputs\": property(inputs_property),\n                \"outputs\": property(outputs_property),\n                \"__module__\": func.__module__,\n                \"__doc__\": func.__doc__,\n                \"_built_from_decorator\": True,\n                # Override the `get_process_step_input` method to return the parameter\n                # of the original function annotated with `StepInput`.\n                \"get_process_step_input\": lambda self: step_input_parameter,\n            },\n        )\n\n    return decorator\n</code></pre>"},{"location":"api/steps/extra/#distilabel.steps.deita.DeitaFiltering","title":"<code>DeitaFiltering</code>","text":"<p>             Bases: <code>GlobalStep</code></p> <p>Filter the dataset based on the DEITA score and the cosine distance between the embeddings. It's an implementation of the filtering step from the paper 'What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.</p> <p>Attributes:</p> Name Type Description <code>data_budget</code> <code>RuntimeParameter[int]</code> <p>The desired size of the dataset after filtering.</p> <code>diversity_threshold</code> <code>RuntimeParameter[float]</code> <p>If a row has a cosine distance with respect to it's nearest neighbor greater than this value, it will be included in the filtered dataset. Defaults to <code>0.9</code>.</p> <code>normalize_embeddings</code> <code>RuntimeParameter[bool]</code> <p>Whether to normalize the embeddings before computing the cosine distance. Defaults to <code>True</code>.</p> Runtime parameters <ul> <li><code>data_budget</code>: The desired size of the dataset after filtering.</li> <li><code>diversity_threshold</code>: If a row has a cosine distance with respect to it's nearest     neighbor greater than this value, it will be included in the filtered dataset.</li> </ul> Input columns <ul> <li>evol_instruction_score (<code>float</code>): The score of the instruction generated by     <code>ComplexityScorer</code> step.</li> <li>evol_response_score (<code>float</code>): The score of the response generated by     <code>QualityScorer</code> step.</li> <li>embedding (<code>List[float]</code>): The embedding generated for the conversation of the     instruction-response pair using <code>GenerateEmbeddings</code> step.</li> </ul> Output columns <ul> <li>deita_score (<code>float</code>): The DEITA score for the instruction-response pair.</li> <li>deita_score_computed_with (<code>List[str]</code>): The scores used to compute the DEITA     score.</li> <li>nearest_neighbor_distance (<code>float</code>): The cosine distance between the embeddings     of the instruction-response pair.</li> </ul> References <ul> <li><code>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</code></li> </ul> Source code in <code>src/distilabel/steps/deita.py</code> <pre><code>class DeitaFiltering(GlobalStep):\n    \"\"\"Filter the dataset based on the DEITA score and the cosine distance between the embeddings.\n    It's an implementation of the filtering step from the paper 'What Makes Good Data\n    for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.\n\n    Attributes:\n        data_budget: The desired size of the dataset after filtering.\n        diversity_threshold: If a row has a cosine distance with respect to it's nearest\n            neighbor greater than this value, it will be included in the filtered dataset.\n            Defaults to `0.9`.\n        normalize_embeddings: Whether to normalize the embeddings before computing the cosine\n            distance. Defaults to `True`.\n\n    Runtime parameters:\n        - `data_budget`: The desired size of the dataset after filtering.\n        - `diversity_threshold`: If a row has a cosine distance with respect to it's nearest\n            neighbor greater than this value, it will be included in the filtered dataset.\n\n    Input columns:\n        - evol_instruction_score (`float`): The score of the instruction generated by\n            `ComplexityScorer` step.\n        - evol_response_score (`float`): The score of the response generated by\n            `QualityScorer` step.\n        - embedding (`List[float]`): The embedding generated for the conversation of the\n            instruction-response pair using `GenerateEmbeddings` step.\n\n    Output columns:\n        - deita_score (`float`): The DEITA score for the instruction-response pair.\n        - deita_score_computed_with (`List[str]`): The scores used to compute the DEITA\n            score.\n        - nearest_neighbor_distance (`float`): The cosine distance between the embeddings\n            of the instruction-response pair.\n\n    References:\n        - [`What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning`](https://arxiv.org/abs/2312.15685)\n    \"\"\"\n\n    data_budget: RuntimeParameter[int] = Field(\n        default=None, description=\"The desired size of the dataset after filtering.\"\n    )\n    diversity_threshold: RuntimeParameter[float] = Field(\n        default=0.9,\n        description=\"If a row has a cosine distance with respect to it's nearest neighbor\"\n        \" greater than this value, it will be included in the filtered dataset.\",\n    )\n    normalize_embeddings: RuntimeParameter[bool] = Field(\n        default=True,\n        description=\"Whether to normalize the embeddings before computing the cosine distance.\",\n    )\n    distance_metric: RuntimeParameter[Literal[\"cosine\", \"manhattan\"]] = Field(\n        default=\"cosine\",\n        description=\"The distance metric to use. Currently only 'cosine' is supported.\",\n    )\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        return [\"evol_instruction_score\", \"evol_response_score\", \"embedding\"]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        return [\"deita_score\", \"nearest_neighbor_distance\", \"deita_score_computed_with\"]\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Filter the dataset based on the DEITA score and the cosine distance between the\n        embeddings.\n\n        Args:\n            inputs: The input data.\n\n        Returns:\n            The filtered dataset.\n        \"\"\"\n        inputs = self._compute_deita_score(inputs)\n        inputs = self._compute_nearest_neighbor(inputs)\n        inputs.sort(key=lambda x: x[\"deita_score\"], reverse=True)\n\n        selected_rows = []\n        for input in inputs:\n            if len(selected_rows) &gt;= self.data_budget:  # type: ignore\n                break\n            if input[\"nearest_neighbor_distance\"] &gt;= self.diversity_threshold:\n                selected_rows.append(input)\n        yield selected_rows\n\n    def _compute_deita_score(self, inputs: StepInput) -&gt; StepInput:\n        \"\"\"Computes the DEITA score for each instruction-response pair. The DEITA score is\n        the product of the instruction score and the response score.\n\n        Args:\n            inputs: The input data.\n\n        Returns:\n            The input data with the DEITA score computed.\n        \"\"\"\n        for input_ in inputs:\n            evol_instruction_score = input_.get(\"evol_instruction_score\")\n            evol_response_score = input_.get(\"evol_response_score\")\n\n            if evol_instruction_score and evol_response_score:\n                deita_score = evol_instruction_score * evol_response_score\n                score_computed_with = [\"evol_instruction_score\", \"evol_response_score\"]\n            elif evol_instruction_score:\n                self._logger.warning(\n                    \"Response score is missing for the instruction-response pair. Using\"\n                    \" instruction score as DEITA score.\"\n                )\n                deita_score = evol_instruction_score\n                score_computed_with = [\"evol_instruction_score\"]\n            elif evol_response_score:\n                self._logger.warning(\n                    \"Instruction score is missing for the instruction-response pair. Using\"\n                    \" response score as DEITA score.\"\n                )\n                deita_score = evol_response_score\n                score_computed_with = [\"evol_response_score\"]\n            else:\n                self._logger.warning(\n                    \"Instruction and response scores are missing for the instruction-response\"\n                    \" pair. Setting DEITA score to 0.\"\n                )\n                deita_score = 0\n                score_computed_with = []\n\n            input_.update(\n                {\n                    \"deita_score\": deita_score,\n                    \"deita_score_computed_with\": score_computed_with,\n                }\n            )\n        return inputs\n\n    def _compute_nearest_neighbor(self, inputs: StepInput) -&gt; StepInput:\n        \"\"\"Computes the cosine distance between the embeddings of the instruction-response\n        pairs and the nearest neighbor.\n\n        Args:\n            inputs: The input data.\n\n        Returns:\n            The input data with the cosine distance computed.\n        \"\"\"\n        embeddings = np.array([input[\"embedding\"] for input in inputs])\n        if self.normalize_embeddings:\n            embeddings = self._normalize_embeddings(embeddings)\n        self._logger.info(\"\ud83d\udccf Computing nearest neighbor distance...\")\n\n        if self.distance_metric == \"cosine\":\n            self._logger.info(\"\ud83d\udccf Using cosine distance.\")\n            distances = self._cosine_distance(embeddings)\n        else:\n            self._logger.info(\"\ud83d\udccf Using manhattan distance.\")\n            distances = self._manhattan_distance(embeddings)\n\n        for distance, input in zip(distances, inputs):\n            input[\"nearest_neighbor_distance\"] = distance\n        return inputs\n\n    def _normalize_embeddings(self, embeddings: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Normalize the embeddings.\n\n        Args:\n            embeddings: The embeddings to normalize.\n\n        Returns:\n            The normalized embeddings.\n        \"\"\"\n        self._logger.info(\"\u2696\ufe0f Normalizing embeddings...\")\n        norms = np.linalg.norm(embeddings, axis=1, keepdims=True)\n        return embeddings / norms\n\n    def _cosine_distance(self, embeddings: np.array) -&gt; np.array:  # type: ignore\n        \"\"\"Computes the cosine distance between the embeddings.\n\n        Args:\n            embeddings: The embeddings.\n\n        Returns:\n            The cosine distance between the embeddings.\n        \"\"\"\n        cosine_similarity = np.dot(embeddings, embeddings.T)\n        cosine_distance = 1 - cosine_similarity\n        # Ignore self-distance\n        np.fill_diagonal(cosine_distance, np.inf)\n        return np.min(cosine_distance, axis=1)\n\n    def _manhattan_distance(self, embeddings: np.array) -&gt; np.array:  # type: ignore\n        \"\"\"Computes the manhattan distance between the embeddings.\n\n        Args:\n            embeddings: The embeddings.\n\n        Returns:\n            The manhattan distance between the embeddings.\n        \"\"\"\n        manhattan_distance = np.abs(embeddings[:, None] - embeddings).sum(-1)\n        # Ignore self-distance\n        np.fill_diagonal(manhattan_distance, np.inf)\n        return np.min(manhattan_distance, axis=1)\n</code></pre>"},{"location":"api/steps/extra/#distilabel.steps.deita.DeitaFiltering.process","title":"<code>process(inputs)</code>","text":"<p>Filter the dataset based on the DEITA score and the cosine distance between the embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>The input data.</p> required <p>Returns:</p> Type Description <code>StepOutput</code> <p>The filtered dataset.</p> Source code in <code>src/distilabel/steps/deita.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Filter the dataset based on the DEITA score and the cosine distance between the\n    embeddings.\n\n    Args:\n        inputs: The input data.\n\n    Returns:\n        The filtered dataset.\n    \"\"\"\n    inputs = self._compute_deita_score(inputs)\n    inputs = self._compute_nearest_neighbor(inputs)\n    inputs.sort(key=lambda x: x[\"deita_score\"], reverse=True)\n\n    selected_rows = []\n    for input in inputs:\n        if len(selected_rows) &gt;= self.data_budget:  # type: ignore\n            break\n        if input[\"nearest_neighbor_distance\"] &gt;= self.diversity_threshold:\n            selected_rows.append(input)\n    yield selected_rows\n</code></pre>"},{"location":"api/steps/extra/#distilabel.steps.expand.ExpandColumns","title":"<code>ExpandColumns</code>","text":"<p>             Bases: <code>Step</code></p> <p>Expand columns that contain lists into multiple rows.</p> <p>Attributes:</p> Name Type Description <code>columns</code> <code>Union[Dict[str, str], List[str]]</code> <p>A dictionary that maps the column to be expanded to the new column name or a list of columns to be expanded. If a list is provided, the new column name will be the same as the column name.</p> Input columns <ul> <li>The columns to be expanded.</li> </ul> Output columns <ul> <li>The expanded columns.</li> </ul> Source code in <code>src/distilabel/steps/expand.py</code> <pre><code>class ExpandColumns(Step):\n    \"\"\"Expand columns that contain lists into multiple rows.\n\n    Attributes:\n        columns: A dictionary that maps the column to be expanded to the new column name\n            or a list of columns to be expanded. If a list is provided, the new column name\n            will be the same as the column name.\n\n    Input columns:\n        - The columns to be expanded.\n\n    Output columns:\n        - The expanded columns.\n    \"\"\"\n\n    columns: Union[Dict[str, str], List[str]]\n\n    @field_validator(\"columns\")\n    @classmethod\n    def always_dict(cls, value: Union[Dict[str, str], List[str]]) -&gt; Dict[str, str]:\n        \"\"\"Ensure that the columns are always a dictionary.\n\n        Args:\n            value: The columns to be expanded.\n\n        Returns:\n            The columns to be expanded as a dictionary.\n        \"\"\"\n        if isinstance(value, list):\n            return {col: col for col in value}\n\n        return value\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The columns to be expanded.\"\"\"\n        return list(self.columns.keys())\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The expanded columns.\"\"\"\n        return [\n            new_column if new_column else expand_column\n            for expand_column, new_column in self.columns.items()\n        ]\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Expand the columns in the input data.\n\n        Args:\n            inputs: The input data.\n\n        Yields:\n            The expanded rows.\n        \"\"\"\n        yield [row for input in inputs for row in self._expand_columns(input)]\n\n    def _expand_columns(self, input: Dict[str, Any]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Expand the columns in the input data.\n\n        Args:\n            input: The input data.\n\n        Returns:\n            The expanded rows.\n        \"\"\"\n        expanded_rows = []\n        for expand_column, new_column in self.columns.items():  # type: ignore\n            data = input.get(expand_column)\n            rows = []\n            for item, expanded in zip_longest(*[data, expanded_rows], fillvalue=input):\n                rows.append({**expanded, new_column: item})\n            expanded_rows = rows\n        return expanded_rows\n</code></pre>"},{"location":"api/steps/extra/#distilabel.steps.expand.ExpandColumns.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The columns to be expanded.</p>"},{"location":"api/steps/extra/#distilabel.steps.expand.ExpandColumns.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The expanded columns.</p>"},{"location":"api/steps/extra/#distilabel.steps.expand.ExpandColumns.always_dict","title":"<code>always_dict(value)</code>  <code>classmethod</code>","text":"<p>Ensure that the columns are always a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[Dict[str, str], List[str]]</code> <p>The columns to be expanded.</p> required <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>The columns to be expanded as a dictionary.</p> Source code in <code>src/distilabel/steps/expand.py</code> <pre><code>@field_validator(\"columns\")\n@classmethod\ndef always_dict(cls, value: Union[Dict[str, str], List[str]]) -&gt; Dict[str, str]:\n    \"\"\"Ensure that the columns are always a dictionary.\n\n    Args:\n        value: The columns to be expanded.\n\n    Returns:\n        The columns to be expanded as a dictionary.\n    \"\"\"\n    if isinstance(value, list):\n        return {col: col for col in value}\n\n    return value\n</code></pre>"},{"location":"api/steps/extra/#distilabel.steps.expand.ExpandColumns.process","title":"<code>process(inputs)</code>","text":"<p>Expand the columns in the input data.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>The input data.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>The expanded rows.</p> Source code in <code>src/distilabel/steps/expand.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Expand the columns in the input data.\n\n    Args:\n        inputs: The input data.\n\n    Yields:\n        The expanded rows.\n    \"\"\"\n    yield [row for input in inputs for row in self._expand_columns(input)]\n</code></pre>"},{"location":"api/steps/extra/#distilabel.steps.keep.KeepColumns","title":"<code>KeepColumns</code>","text":"<p>             Bases: <code>Step</code></p> <p>KeepColumns is a Step that implements the <code>process</code> method that keeps only the columns specified in the <code>columns</code> attribute. Also <code>KeepColumns</code> provides an attribute <code>columns</code> to specify the columns to keep which will override the default value for the properties <code>inputs</code> and <code>outputs</code>.</p> Note <p>The order in which the columns are provided is important, as the output will be sorted using the provided order, which is useful before pushing either a <code>dataset.Dataset</code> via the <code>PushToHub</code> step or a <code>distilabel.Distiset</code> via the <code>Pipeline.run</code> output variable.</p> <p>Attributes:</p> Name Type Description <code>columns</code> <code>List[str]</code> <p>List of strings with the names of the columns to keep.</p> Input columns <ul> <li>dynamic, based on the <code>columns</code> value provided.</li> </ul> Output columns <ul> <li>dynamic, based on the <code>columns</code> value provided.</li> </ul> Source code in <code>src/distilabel/steps/keep.py</code> <pre><code>class KeepColumns(Step):\n    \"\"\"KeepColumns is a Step that implements the `process` method that keeps only the columns\n    specified in the `columns` attribute. Also `KeepColumns` provides an attribute `columns` to\n    specify the columns to keep which will override the default value for the properties `inputs`\n    and `outputs`.\n\n    Note:\n        The order in which the columns are provided is important, as the output will be sorted\n        using the provided order, which is useful before pushing either a `dataset.Dataset` via\n        the `PushToHub` step or a `distilabel.Distiset` via the `Pipeline.run` output variable.\n\n    Attributes:\n        columns: List of strings with the names of the columns to keep.\n\n    Input columns:\n        - dynamic, based on the `columns` value provided.\n\n    Output columns:\n        - dynamic, based on the `columns` value provided.\n    \"\"\"\n\n    columns: List[str]\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The inputs for the task are the column names in `columns`.\"\"\"\n        return self.columns\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The outputs for the task are the column names in `columns`.\"\"\"\n        return self.columns\n\n    @override\n    def process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n        \"\"\"The `process` method keeps only the columns specified in the `columns` attribute.\n\n        Args:\n            *inputs: A list of dictionaries with the input data.\n\n        Yields:\n            A list of dictionaries with the output data.\n        \"\"\"\n        for input in inputs:\n            outputs = []\n            for item in input:\n                outputs.append({col: item[col] for col in self.columns})\n            yield outputs\n</code></pre>"},{"location":"api/steps/extra/#distilabel.steps.keep.KeepColumns.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The inputs for the task are the column names in <code>columns</code>.</p>"},{"location":"api/steps/extra/#distilabel.steps.keep.KeepColumns.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The outputs for the task are the column names in <code>columns</code>.</p>"},{"location":"api/steps/extra/#distilabel.steps.keep.KeepColumns.process","title":"<code>process(*inputs)</code>","text":"<p>The <code>process</code> method keeps only the columns specified in the <code>columns</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>*inputs</code> <code>StepInput</code> <p>A list of dictionaries with the input data.</p> <code>()</code> <p>Yields:</p> Type Description <code>StepOutput</code> <p>A list of dictionaries with the output data.</p> Source code in <code>src/distilabel/steps/keep.py</code> <pre><code>@override\ndef process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n    \"\"\"The `process` method keeps only the columns specified in the `columns` attribute.\n\n    Args:\n        *inputs: A list of dictionaries with the input data.\n\n    Yields:\n        A list of dictionaries with the output data.\n    \"\"\"\n    for input in inputs:\n        outputs = []\n        for item in input:\n            outputs.append({col: item[col] for col in self.columns})\n        yield outputs\n</code></pre>"},{"location":"api/steps/extra/#distilabel.steps.typing.GeneratorStepOutput","title":"<code>GeneratorStepOutput = Iterator[Tuple[List[Dict[str, Any]], bool]]</code>  <code>module-attribute</code>","text":"<p>GeneratorStepOutput is an alias of the typing <code>Iterator[Tuple[List[Dict[str, Any]], bool]]</code></p>"},{"location":"api/steps/extra/#distilabel.steps.typing.StepOutput","title":"<code>StepOutput = Iterator[List[Dict[str, Any]]]</code>  <code>module-attribute</code>","text":"<p>StepOutput is an alias of the typing <code>Iterator[List[Dict[str, Any]]]</code></p>"},{"location":"api/steps/extra/#distilabel.steps.tasks.typing.ChatType","title":"<code>ChatType = List[ChatItem]</code>  <code>module-attribute</code>","text":"<p>ChatType is a type alias for a <code>list</code> of <code>dict</code>s following the OpenAI conversational format.</p>"},{"location":"api/steps/steps/","title":"Steps","text":""},{"location":"api/steps/steps/#distilabel.steps.base.StepInput","title":"<code>StepInput = Annotated[List[Dict[str, Any]], _STEP_INPUT_ANNOTATION]</code>  <code>module-attribute</code>","text":"<p>StepInput is just an <code>Annotated</code> alias of the typing <code>List[Dict[str, Any]]</code> with extra metadata that allows <code>distilabel</code> to perform validations over the <code>process</code> step method defined in each <code>Step</code></p>"},{"location":"api/steps/steps/#distilabel.steps.base.GeneratorStep","title":"<code>GeneratorStep</code>","text":"<p>             Bases: <code>_Step</code>, <code>ABC</code></p> <p>A special kind of <code>Step</code> that is able to generate data i.e. it doesn't receive any input from the previous steps.</p> <p>Attributes:</p> Name Type Description <code>batch_size</code> <code>RuntimeParameter[int]</code> <p>The number of rows that will contain the batches generated by the step. Defaults to <code>50</code>.</p> Runtime parameters <ul> <li><code>batch_size</code>: The number of rows that will contain the batches generated by     the step. Defaults to <code>50</code>.</li> </ul> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>class GeneratorStep(_Step, ABC):\n    \"\"\"A special kind of `Step` that is able to generate data i.e. it doesn't receive\n    any input from the previous steps.\n\n    Attributes:\n        batch_size: The number of rows that will contain the batches generated by the\n            step. Defaults to `50`.\n\n    Runtime parameters:\n        - `batch_size`: The number of rows that will contain the batches generated by\n            the step. Defaults to `50`.\n    \"\"\"\n\n    batch_size: RuntimeParameter[int] = Field(\n        default=50,\n        description=\"The number of rows that will contain the batches generated by the\"\n        \" step.\",\n    )\n\n    @abstractmethod\n    def process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":\n        \"\"\"Method that defines the generation logic of the step. It should yield the\n        output rows and a boolean indicating if it's the last batch or not.\n\n        Args:\n            offset: The offset to start the generation from. Defaults to 0.\n\n        Yields:\n            The output rows and a boolean indicating if it's the last batch or not.\n        \"\"\"\n        pass\n\n    def process_applying_mappings(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":\n        \"\"\"Runs the `process` method of the step applying the `outputs_mappings` to the\n        output rows. This is the function that should be used to run the generation logic\n        of the step.\n\n        Args:\n            offset: The offset to start the generation from. Defaults to 0.\n\n        Yields:\n            The output rows and a boolean indicating if it's the last batch or not.\n        \"\"\"\n\n        # If the `Step` was built using the `@step` decorator, then we need to pass\n        # the runtime parameters as `kwargs`, so they can be used within the processing\n        # function\n        generator = (\n            self.process(offset=offset)\n            if not self._built_from_decorator\n            else self.process(offset=offset, **self._runtime_parameters)\n        )\n\n        for output_rows, last_batch in generator:\n            yield (\n                [\n                    {self.output_mappings.get(k, k): v for k, v in row.items()}\n                    for row in output_rows\n                ],\n                last_batch,\n            )\n</code></pre>"},{"location":"api/steps/steps/#distilabel.steps.base.GeneratorStep.process","title":"<code>process(offset=0)</code>  <code>abstractmethod</code>","text":"<p>Method that defines the generation logic of the step. It should yield the output rows and a boolean indicating if it's the last batch or not.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The offset to start the generation from. Defaults to 0.</p> <code>0</code> <p>Yields:</p> Type Description <code>GeneratorStepOutput</code> <p>The output rows and a boolean indicating if it's the last batch or not.</p> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>@abstractmethod\ndef process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":\n    \"\"\"Method that defines the generation logic of the step. It should yield the\n    output rows and a boolean indicating if it's the last batch or not.\n\n    Args:\n        offset: The offset to start the generation from. Defaults to 0.\n\n    Yields:\n        The output rows and a boolean indicating if it's the last batch or not.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/steps/steps/#distilabel.steps.base.GeneratorStep.process_applying_mappings","title":"<code>process_applying_mappings(offset=0)</code>","text":"<p>Runs the <code>process</code> method of the step applying the <code>outputs_mappings</code> to the output rows. This is the function that should be used to run the generation logic of the step.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The offset to start the generation from. Defaults to 0.</p> <code>0</code> <p>Yields:</p> Type Description <code>GeneratorStepOutput</code> <p>The output rows and a boolean indicating if it's the last batch or not.</p> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>def process_applying_mappings(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":\n    \"\"\"Runs the `process` method of the step applying the `outputs_mappings` to the\n    output rows. This is the function that should be used to run the generation logic\n    of the step.\n\n    Args:\n        offset: The offset to start the generation from. Defaults to 0.\n\n    Yields:\n        The output rows and a boolean indicating if it's the last batch or not.\n    \"\"\"\n\n    # If the `Step` was built using the `@step` decorator, then we need to pass\n    # the runtime parameters as `kwargs`, so they can be used within the processing\n    # function\n    generator = (\n        self.process(offset=offset)\n        if not self._built_from_decorator\n        else self.process(offset=offset, **self._runtime_parameters)\n    )\n\n    for output_rows, last_batch in generator:\n        yield (\n            [\n                {self.output_mappings.get(k, k): v for k, v in row.items()}\n                for row in output_rows\n            ],\n            last_batch,\n        )\n</code></pre>"},{"location":"api/steps/steps/#distilabel.steps.base.GlobalStep","title":"<code>GlobalStep</code>","text":"<p>             Bases: <code>Step</code>, <code>ABC</code></p> <p>A special kind of <code>Step</code> which it's <code>process</code> method receives all the data processed by their previous steps at once, instead of receiving it in batches. This kind of steps are useful when the processing logic requires to have all the data at once, for example to train a model, to perform a global aggregation, etc.</p> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>class GlobalStep(Step, ABC):\n    \"\"\"A special kind of `Step` which it's `process` method receives all the data processed\n    by their previous steps at once, instead of receiving it in batches. This kind of steps\n    are useful when the processing logic requires to have all the data at once, for example\n    to train a model, to perform a global aggregation, etc.\n    \"\"\"\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        return []\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        return []\n</code></pre>"},{"location":"api/steps/steps/#distilabel.steps.base.Step","title":"<code>Step</code>","text":"<p>             Bases: <code>_Step</code>, <code>ABC</code></p> <p>Base class for the steps that can be included in a <code>Pipeline</code>.</p> <p>Attributes:</p> Name Type Description <code>input_batch_size</code> <code>RuntimeParameter[PositiveInt]</code> <p>The number of rows that will contain the batches processed by the step. Defaults to <code>50</code>.</p> Runtime parameters <ul> <li><code>input_batch_size</code>: The number of rows that will contain the batches processed     by the step. Defaults to <code>50</code>.</li> </ul> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>class Step(_Step, ABC):\n    \"\"\"Base class for the steps that can be included in a `Pipeline`.\n\n    Attributes:\n        input_batch_size: The number of rows that will contain the batches processed by\n            the step. Defaults to `50`.\n\n    Runtime parameters:\n        - `input_batch_size`: The number of rows that will contain the batches processed\n            by the step. Defaults to `50`.\n    \"\"\"\n\n    input_batch_size: RuntimeParameter[PositiveInt] = Field(\n        default=DEFAULT_INPUT_BATCH_SIZE,\n        description=\"The number of rows that will contain the batches processed by the\"\n        \" step.\",\n    )\n\n    @abstractmethod\n    def process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n        \"\"\"Method that defines the processing logic of the step. It should yield the\n        output rows.\n\n        Args:\n            *inputs: An argument used to receive the outputs of the previous steps. The\n                number of arguments depends on the number of previous steps. It doesn't\n                need to be an `*args` argument, it can be a regular argument annotated\n                with `StepInput` if the step has only one previous step.\n        \"\"\"\n        pass\n\n    def process_applying_mappings(self, *args: List[Dict[str, Any]]) -&gt; \"StepOutput\":\n        \"\"\"Runs the `process` method of the step applying the `input_mappings` to the input\n        rows and the `outputs_mappings` to the output rows. This is the function that\n        should be used to run the processing logic of the step.\n\n        Yields:\n            The output rows.\n        \"\"\"\n\n        inputs = self._apply_input_mappings(args) if self.input_mappings else args\n\n        # If the `Step` was built using the `@step` decorator, then we need to pass\n        # the runtime parameters as kwargs, so they can be used within the processing\n        # function\n        generator = (\n            self.process(*inputs)\n            if not self._built_from_decorator\n            else self.process(*inputs, **self._runtime_parameters)\n        )\n\n        for output_rows in generator:\n            yield [\n                {\n                    # Apply output mapping and revert input mapping\n                    self.output_mappings.get(k, None)\n                    or self.input_mappings.get(k, None)\n                    or k: v\n                    for k, v in row.items()\n                }\n                for row in output_rows\n            ]\n\n    def _revert_input_mappings(self, input: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Reverts the `input_mappings` of the step to the input row.\n\n        Args:\n            input: The input row.\n\n        Returns:\n            The input row with the `input_mappings` reverted.\n        \"\"\"\n        return {self.input_mappings.get(k, k): v for k, v in input.items()}\n\n    def _apply_input_mappings(\n        self, inputs: Tuple[List[Dict[str, Any]], ...]\n    ) -&gt; List[List[Dict[str, Any]]]:\n        \"\"\"Applies the `input_mappings` to the input rows.\n\n        Args:\n            inputs: The input rows.\n\n        Returns:\n            The input rows with the `input_mappings` applied.\n        \"\"\"\n        reverted_input_mappings = {v: k for k, v in self.input_mappings.items()}\n\n        return [\n            [\n                {reverted_input_mappings.get(k, k): v for k, v in row.items()}\n                for row in row_inputs\n            ]\n            for row_inputs in inputs\n        ]\n</code></pre>"},{"location":"api/steps/steps/#distilabel.steps.base.Step.process","title":"<code>process(*inputs)</code>  <code>abstractmethod</code>","text":"<p>Method that defines the processing logic of the step. It should yield the output rows.</p> <p>Parameters:</p> Name Type Description Default <code>*inputs</code> <code>StepInput</code> <p>An argument used to receive the outputs of the previous steps. The number of arguments depends on the number of previous steps. It doesn't need to be an <code>*args</code> argument, it can be a regular argument annotated with <code>StepInput</code> if the step has only one previous step.</p> <code>()</code> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>@abstractmethod\ndef process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n    \"\"\"Method that defines the processing logic of the step. It should yield the\n    output rows.\n\n    Args:\n        *inputs: An argument used to receive the outputs of the previous steps. The\n            number of arguments depends on the number of previous steps. It doesn't\n            need to be an `*args` argument, it can be a regular argument annotated\n            with `StepInput` if the step has only one previous step.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/steps/steps/#distilabel.steps.base.Step.process_applying_mappings","title":"<code>process_applying_mappings(*args)</code>","text":"<p>Runs the <code>process</code> method of the step applying the <code>input_mappings</code> to the input rows and the <code>outputs_mappings</code> to the output rows. This is the function that should be used to run the processing logic of the step.</p> <p>Yields:</p> Type Description <code>StepOutput</code> <p>The output rows.</p> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>def process_applying_mappings(self, *args: List[Dict[str, Any]]) -&gt; \"StepOutput\":\n    \"\"\"Runs the `process` method of the step applying the `input_mappings` to the input\n    rows and the `outputs_mappings` to the output rows. This is the function that\n    should be used to run the processing logic of the step.\n\n    Yields:\n        The output rows.\n    \"\"\"\n\n    inputs = self._apply_input_mappings(args) if self.input_mappings else args\n\n    # If the `Step` was built using the `@step` decorator, then we need to pass\n    # the runtime parameters as kwargs, so they can be used within the processing\n    # function\n    generator = (\n        self.process(*inputs)\n        if not self._built_from_decorator\n        else self.process(*inputs, **self._runtime_parameters)\n    )\n\n    for output_rows in generator:\n        yield [\n            {\n                # Apply output mapping and revert input mapping\n                self.output_mappings.get(k, None)\n                or self.input_mappings.get(k, None)\n                or k: v\n                for k, v in row.items()\n            }\n            for row in output_rows\n        ]\n</code></pre>"},{"location":"api/steps/generator_steps/generator_steps/","title":"Generator Steps","text":""},{"location":"api/steps/generator_steps/generator_steps/#distilabel.steps.generators.data.LoadDataFromDicts","title":"<code>LoadDataFromDicts</code>","text":"<p>             Bases: <code>GeneratorStep</code></p> <p>A generator step that loads a dataset from a list of dictionaries.</p> <p>This step will load the dataset and yield the transformed data as it is loaded from the list of dictionaries.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>List[Dict[str, Any]]</code> <p>The list of dictionaries to load the data from.</p> Runtime parameters <ul> <li><code>batch_size</code>: The batch size to use when processing the data.</li> </ul> Output columns <p>Dynamic, based on the keys found on the first dictionary of the list</p> Source code in <code>src/distilabel/steps/generators/data.py</code> <pre><code>class LoadDataFromDicts(GeneratorStep):\n    \"\"\"A generator step that loads a dataset from a list of dictionaries.\n\n    This step will load the dataset and yield the transformed data as it is loaded from the list of dictionaries.\n\n    Attributes:\n        data: The list of dictionaries to load the data from.\n\n    Runtime parameters:\n        - `batch_size`: The batch size to use when processing the data.\n\n    Output columns:\n        Dynamic, based on the keys found on the first dictionary of the list\n    \"\"\"\n\n    data: List[Dict[str, Any]]\n\n    @override\n    def process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":  # type: ignore\n        \"\"\"Yields batches from a list of dictionaries.\n\n        Args:\n            offset: The offset to start the generation from. Defaults to `0`.\n\n        Yields:\n            A list of Python dictionaries as read from the inputs (propagated in batches)\n            and a flag indicating whether the yield batch is the last one.\n        \"\"\"\n        if offset:\n            self.data = self.data[offset:]\n\n        while self.data:\n            batch = self.data[: self.batch_size]\n            self.data = self.data[self.batch_size :]\n            yield (\n                batch,\n                True if len(self.data) == 0 else False,\n            )\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"Returns a list of strings with the names of the columns that the step will generate.\"\"\"\n        return list(self.data[0].keys())\n</code></pre>"},{"location":"api/steps/generator_steps/generator_steps/#distilabel.steps.generators.data.LoadDataFromDicts.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>Returns a list of strings with the names of the columns that the step will generate.</p>"},{"location":"api/steps/generator_steps/generator_steps/#distilabel.steps.generators.data.LoadDataFromDicts.process","title":"<code>process(offset=0)</code>","text":"<p>Yields batches from a list of dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The offset to start the generation from. Defaults to <code>0</code>.</p> <code>0</code> <p>Yields:</p> Type Description <code>GeneratorStepOutput</code> <p>A list of Python dictionaries as read from the inputs (propagated in batches)</p> <code>GeneratorStepOutput</code> <p>and a flag indicating whether the yield batch is the last one.</p> Source code in <code>src/distilabel/steps/generators/data.py</code> <pre><code>@override\ndef process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":  # type: ignore\n    \"\"\"Yields batches from a list of dictionaries.\n\n    Args:\n        offset: The offset to start the generation from. Defaults to `0`.\n\n    Yields:\n        A list of Python dictionaries as read from the inputs (propagated in batches)\n        and a flag indicating whether the yield batch is the last one.\n    \"\"\"\n    if offset:\n        self.data = self.data[offset:]\n\n    while self.data:\n        batch = self.data[: self.batch_size]\n        self.data = self.data[self.batch_size :]\n        yield (\n            batch,\n            True if len(self.data) == 0 else False,\n        )\n</code></pre>"},{"location":"api/steps/generator_steps/generator_steps/#distilabel.steps.generators.huggingface.LoadHubDataset","title":"<code>LoadHubDataset</code>","text":"<p>             Bases: <code>GeneratorStep</code></p> <p>A generator step that loads a dataset from the Hugging Face Hub using the <code>datasets</code> library.</p> <p>This step will load the dataset in streaming mode, which means that it will not load the entire dataset into memory at once. Instead, it will load the dataset in chunks and yield the transformed data as it is loaded from the Hugging Face Hub.</p> <p>Attributes:</p> Name Type Description <code>repo_id</code> <code>RuntimeParameter[str]</code> <p>The Hugging Face Hub repository ID of the dataset to load.</p> <code>split</code> <code>RuntimeParameter[str]</code> <p>The split of the dataset to load.</p> <code>config</code> <code>Optional[RuntimeParameter[str]]</code> <p>The configuration of the dataset to load. This is optional and only needed if the dataset has multiple configurations.</p> Runtime parameters <ul> <li><code>batch_size</code>: The batch size to use when processing the data.</li> <li><code>repo_id</code>: The Hugging Face Hub repository ID of the dataset to load.</li> <li><code>split</code>: The split of the dataset to load. Defaults to 'train'.</li> <li><code>config</code>: The configuration of the dataset to load. This is optional and only     needed if the dataset has multiple configurations.</li> </ul> <p>Output columns     - dynamic, based on the dataset being loaded</p> Source code in <code>src/distilabel/steps/generators/huggingface.py</code> <pre><code>class LoadHubDataset(GeneratorStep):\n    \"\"\"A generator step that loads a dataset from the Hugging Face Hub using the `datasets`\n    library.\n\n    This step will load the dataset in streaming mode, which means that it will not load the\n    entire dataset into memory at once. Instead, it will load the dataset in chunks and yield\n    the transformed data as it is loaded from the Hugging Face Hub.\n\n    Attributes:\n        repo_id: The Hugging Face Hub repository ID of the dataset to load.\n        split: The split of the dataset to load.\n        config: The configuration of the dataset to load. This is optional and only needed\n            if the dataset has multiple configurations.\n\n    Runtime parameters:\n        - `batch_size`: The batch size to use when processing the data.\n        - `repo_id`: The Hugging Face Hub repository ID of the dataset to load.\n        - `split`: The split of the dataset to load. Defaults to 'train'.\n        - `config`: The configuration of the dataset to load. This is optional and only\n            needed if the dataset has multiple configurations.\n\n    Output columns\n        - dynamic, based on the dataset being loaded\n    \"\"\"\n\n    repo_id: RuntimeParameter[str] = Field(\n        default=None,\n        description=\"The Hugging Face Hub repository ID of the dataset to load.\",\n    )\n    split: RuntimeParameter[str] = Field(\n        default=\"train\",\n        description=\"The split of the dataset to load. Defaults to 'train'.\",\n    )\n    config: Optional[RuntimeParameter[str]] = Field(\n        default=None,\n        description=\"The configuration of the dataset to load. This is optional and only\"\n        \" needed if the dataset has multiple configurations.\",\n    )\n\n    _dataset: Union[IterableDataset, None] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Load the dataset from the Hugging Face Hub\"\"\"\n        super().load()\n\n        self._dataset = load_dataset(\n            self.repo_id,  # type: ignore\n            self.config,\n            split=self.split,\n            streaming=True,\n        )\n\n    def process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":\n        \"\"\"Yields batches from the loaded dataset from the Hugging Face Hub.\n\n        Args:\n            offset: The offset to start yielding the data from. Will be used during the caching\n                process to help skipping already processed data.\n\n        Yields:\n            A tuple containing a batch of rows and a boolean indicating if the batch is\n            the last one.\n        \"\"\"\n        num_examples = self._get_dataset_num_examples()\n        num_returned_rows = 0\n        for batch_num, batch in enumerate(\n            self._dataset.iter(batch_size=self.batch_size)  # type: ignore\n        ):\n            if batch_num * self.batch_size &lt; offset:\n                continue\n            transformed_batch = self._transform_batch(batch)\n            batch_size = len(transformed_batch)\n            num_returned_rows += batch_size\n            yield transformed_batch, num_returned_rows == num_examples\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The columns that will be generated by this step, based on the datasets loaded\n        from the Hugging Face Hub.\n\n        Returns:\n            The columns that will be generated by this step.\n        \"\"\"\n        return self._get_dataset_columns()\n\n    def _transform_batch(self, batch: Dict[str, Any]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Transform a batch of data from the Hugging Face Hub into a list of rows.\n\n        Args:\n            batch: The batch of data from the Hugging Face Hub.\n\n        Returns:\n            A list of rows, where each row is a dictionary of column names and values.\n        \"\"\"\n        length = len(next(iter(batch.values())))\n        rows = []\n        for i in range(length):\n            rows.append({col: values[i] for col, values in batch.items()})\n        return rows\n\n    def _get_dataset_num_examples(self) -&gt; int:\n        \"\"\"Get the number of examples in the dataset, based on the `split` and `config`\n        runtime parameters provided.\n\n        Returns:\n            The number of examples in the dataset.\n        \"\"\"\n        dataset_info = self._get_dataset_info()\n        split = self.split\n        if self.config:\n            return dataset_info[\"splits\"][split][\"num_examples\"]\n        return dataset_info[\"default\"][\"splits\"][split][\"num_examples\"]\n\n    def _get_dataset_columns(self) -&gt; List[str]:\n        \"\"\"Get the columns of the dataset, based on the `config` runtime parameter provided.\n\n        Returns:\n            The columns of the dataset.\n        \"\"\"\n        dataset_info = self._get_dataset_info()\n        if self.config:\n            return list(dataset_info[\"features\"].keys())\n        return list(dataset_info[\"default\"][\"features\"].keys())\n\n    def _get_dataset_info(self) -&gt; Dict[str, Any]:\n        \"\"\"Calls the Datasets Server API from Hugging Face to obtain the dataset information.\n\n        Returns:\n            The dataset information.\n        \"\"\"\n        repo_id = self.repo_id\n        config = self.config\n        return _get_hf_dataset_info(repo_id, config)\n</code></pre>"},{"location":"api/steps/generator_steps/generator_steps/#distilabel.steps.generators.huggingface.LoadHubDataset.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The columns that will be generated by this step, based on the datasets loaded from the Hugging Face Hub.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The columns that will be generated by this step.</p>"},{"location":"api/steps/generator_steps/generator_steps/#distilabel.steps.generators.huggingface.LoadHubDataset.load","title":"<code>load()</code>","text":"<p>Load the dataset from the Hugging Face Hub</p> Source code in <code>src/distilabel/steps/generators/huggingface.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Load the dataset from the Hugging Face Hub\"\"\"\n    super().load()\n\n    self._dataset = load_dataset(\n        self.repo_id,  # type: ignore\n        self.config,\n        split=self.split,\n        streaming=True,\n    )\n</code></pre>"},{"location":"api/steps/generator_steps/generator_steps/#distilabel.steps.generators.huggingface.LoadHubDataset.process","title":"<code>process(offset=0)</code>","text":"<p>Yields batches from the loaded dataset from the Hugging Face Hub.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The offset to start yielding the data from. Will be used during the caching process to help skipping already processed data.</p> <code>0</code> <p>Yields:</p> Type Description <code>GeneratorStepOutput</code> <p>A tuple containing a batch of rows and a boolean indicating if the batch is</p> <code>GeneratorStepOutput</code> <p>the last one.</p> Source code in <code>src/distilabel/steps/generators/huggingface.py</code> <pre><code>def process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":\n    \"\"\"Yields batches from the loaded dataset from the Hugging Face Hub.\n\n    Args:\n        offset: The offset to start yielding the data from. Will be used during the caching\n            process to help skipping already processed data.\n\n    Yields:\n        A tuple containing a batch of rows and a boolean indicating if the batch is\n        the last one.\n    \"\"\"\n    num_examples = self._get_dataset_num_examples()\n    num_returned_rows = 0\n    for batch_num, batch in enumerate(\n        self._dataset.iter(batch_size=self.batch_size)  # type: ignore\n    ):\n        if batch_num * self.batch_size &lt; offset:\n            continue\n        transformed_batch = self._transform_batch(batch)\n        batch_size = len(transformed_batch)\n        num_returned_rows += batch_size\n        yield transformed_batch, num_returned_rows == num_examples\n</code></pre>"},{"location":"api/steps/global_steps/global_steps/","title":"Global Steps","text":""},{"location":"api/steps/global_steps/global_steps/#distilabel.steps.globals.huggingface.PushToHub","title":"<code>PushToHub</code>","text":"<p>             Bases: <code>GlobalStep</code></p> <p>A <code>GlobalStep</code> which creates a <code>datasets.Dataset</code> with the input data and pushes it to the Hugging Face Hub.</p> <p>Attributes:</p> Name Type Description <code>repo_id</code> <code>RuntimeParameter[str]</code> <p>The Hugging Face Hub repository ID where the dataset will be uploaded.</p> <code>split</code> <code>RuntimeParameter[str]</code> <p>The split of the dataset that will be pushed. Defaults to <code>\"train\"</code>.</p> <code>private</code> <code>RuntimeParameter[bool]</code> <p>Whether the dataset to be pushed should be private or not. Defaults to <code>False</code>.</p> <code>token</code> <code>Optional[RuntimeParameter[str]]</code> <p>The token that will be used to authenticate in the Hub. If not provided, the token will be tried to be obtained from the environment variable <code>HF_TOKEN</code>. If not provided using one of the previous methods, then <code>huggingface_hub</code> library will try to use the token from the local Hugging Face CLI configuration. Defaults to <code>None</code>.</p> Runtime parameters <ul> <li><code>repo_id</code>: The Hugging Face Hub repository ID where the dataset will be uploaded.</li> <li><code>split</code>: The split of the dataset that will be pushed.</li> <li><code>private</code>: Whether the dataset to be pushed should be private or not.</li> <li><code>token</code>: The token that will be used to authenticate in the Hub.</li> </ul> Input columns <ul> <li>dynamic, based on the existing data within inputs</li> </ul> Source code in <code>src/distilabel/steps/globals/huggingface.py</code> <pre><code>class PushToHub(GlobalStep):\n    \"\"\"A `GlobalStep` which creates a `datasets.Dataset` with the input data and pushes\n    it to the Hugging Face Hub.\n\n    Attributes:\n        repo_id: The Hugging Face Hub repository ID where the dataset will be uploaded.\n        split: The split of the dataset that will be pushed. Defaults to `\"train\"`.\n        private: Whether the dataset to be pushed should be private or not. Defaults to\n            `False`.\n        token: The token that will be used to authenticate in the Hub. If not provided, the\n            token will be tried to be obtained from the environment variable `HF_TOKEN`.\n            If not provided using one of the previous methods, then `huggingface_hub` library\n            will try to use the token from the local Hugging Face CLI configuration. Defaults\n            to `None`.\n\n    Runtime parameters:\n        - `repo_id`: The Hugging Face Hub repository ID where the dataset will be uploaded.\n        - `split`: The split of the dataset that will be pushed.\n        - `private`: Whether the dataset to be pushed should be private or not.\n        - `token`: The token that will be used to authenticate in the Hub.\n\n    Input columns:\n        - dynamic, based on the existing data within inputs\n    \"\"\"\n\n    repo_id: RuntimeParameter[str] = Field(\n        default=None,\n        description=\"The Hugging Face Hub repository ID where the dataset will be uploaded.\",\n    )\n    split: RuntimeParameter[str] = Field(\n        default=\"train\",\n        description=\"The split of the dataset that will be pushed. Defaults to 'train'.\",\n    )\n    private: RuntimeParameter[bool] = Field(\n        default=False,\n        description=\"Whether the dataset to be pushed should be private or not. Defaults\"\n        \" to `False`.\",\n    )\n    token: Optional[RuntimeParameter[str]] = Field(\n        default=None,\n        description=\"The token that will be used to authenticate in the Hub. If not provided,\"\n        \" the token will be tried to be obtained from the environment variable `HF_TOKEN`.\"\n        \" If not provided using one of the previous methods, then `huggingface_hub` library\"\n        \" will try to use the token from the local Hugging Face CLI configuration. Defaults\"\n        \" to `None`\",\n    )\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Method that processes the input data, respecting the `datasets.Dataset` formatting,\n        and pushes it to the Hugging Face Hub based on the `RuntimeParameter`s attributes.\n\n        Args:\n            inputs: that input data within a single object (as it's a GlobalStep) that\n                will be transformed into a `datasets.Dataset`.\n\n        Yields:\n            Propagates the received inputs so that the `Distiset` can be generated if this is\n            the last step of the `Pipeline`, or if this is not a leaf step and has follow up\n            steps.\n        \"\"\"\n        dataset_dict = defaultdict(list)\n        for input in inputs:\n            for key, value in input.items():\n                dataset_dict[key].append(value)\n        dataset_dict = dict(dataset_dict)\n        dataset = Dataset.from_dict(dataset_dict)\n        dataset.push_to_hub(\n            self.repo_id,  # type: ignore\n            split=self.split,\n            private=self.private,\n            token=self.token or os.getenv(\"HF_TOKEN\"),\n        )\n        yield inputs\n</code></pre>"},{"location":"api/steps/global_steps/global_steps/#distilabel.steps.globals.huggingface.PushToHub.process","title":"<code>process(inputs)</code>","text":"<p>Method that processes the input data, respecting the <code>datasets.Dataset</code> formatting, and pushes it to the Hugging Face Hub based on the <code>RuntimeParameter</code>s attributes.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>that input data within a single object (as it's a GlobalStep) that will be transformed into a <code>datasets.Dataset</code>.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>Propagates the received inputs so that the <code>Distiset</code> can be generated if this is</p> <code>StepOutput</code> <p>the last step of the <code>Pipeline</code>, or if this is not a leaf step and has follow up</p> <code>StepOutput</code> <p>steps.</p> Source code in <code>src/distilabel/steps/globals/huggingface.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Method that processes the input data, respecting the `datasets.Dataset` formatting,\n    and pushes it to the Hugging Face Hub based on the `RuntimeParameter`s attributes.\n\n    Args:\n        inputs: that input data within a single object (as it's a GlobalStep) that\n            will be transformed into a `datasets.Dataset`.\n\n    Yields:\n        Propagates the received inputs so that the `Distiset` can be generated if this is\n        the last step of the `Pipeline`, or if this is not a leaf step and has follow up\n        steps.\n    \"\"\"\n    dataset_dict = defaultdict(list)\n    for input in inputs:\n        for key, value in input.items():\n            dataset_dict[key].append(value)\n    dataset_dict = dict(dataset_dict)\n    dataset = Dataset.from_dict(dataset_dict)\n    dataset.push_to_hub(\n        self.repo_id,  # type: ignore\n        split=self.split,\n        private=self.private,\n        token=self.token or os.getenv(\"HF_TOKEN\"),\n    )\n    yield inputs\n</code></pre>"},{"location":"api/steps/tasks/embeddings/","title":"Embeddings","text":""},{"location":"api/steps/tasks/embeddings/#distilabel.steps.tasks.generate_embeddings.GenerateEmbeddings","title":"<code>GenerateEmbeddings</code>","text":"<p>             Bases: <code>Step</code></p> <p>Generate embeddings for a text input using the last hidden state of an <code>LLM</code>, as described in the paper 'What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.</p> <p>Attributes:</p> Name Type Description <code>llm</code> <code>LLM</code> <p>The <code>LLM</code> to use to generate the embeddings.</p> Input columns <ul> <li>text (<code>str</code>, <code>List[Dict[str, str]]</code>): The input text or conversation to generate     embeddings for.</li> </ul> Output columns <ul> <li>embedding (<code>List[float]</code>): The embedding of the input text or conversation.</li> </ul> References <ul> <li>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</li> </ul> Source code in <code>src/distilabel/steps/tasks/generate_embeddings.py</code> <pre><code>class GenerateEmbeddings(Step):\n    \"\"\"Generate embeddings for a text input using the last hidden state of an `LLM`, as\n    described in the paper 'What Makes Good Data for Alignment? A Comprehensive Study of\n    Automatic Data Selection in Instruction Tuning'.\n\n    Attributes:\n        llm: The `LLM` to use to generate the embeddings.\n\n    Input columns:\n        - text (`str`, `List[Dict[str, str]]`): The input text or conversation to generate\n            embeddings for.\n\n    Output columns:\n        - embedding (`List[float]`): The embedding of the input text or conversation.\n\n    References:\n        - [What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning](https://arxiv.org/abs/2312.15685)\n    \"\"\"\n\n    llm: LLM\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `LLM` used to generate the embeddings.\"\"\"\n        super().load()\n        self.llm.load()\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The inputs for the task is a `text` column containing either a string or a\n        list of dictionaries in OpenAI chat-like format.\"\"\"\n        return [\"text\"]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The outputs for the task is an `embedding` column containing the embedding of\n        the `text` input.\"\"\"\n        return [\"embedding\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n        \"\"\"Formats the input to be used by the LLM to generate the embeddings. The input\n        can be in `ChatType` format or a string. If a string, it will be converted to a\n        list of dictionaries in OpenAI chat-like format.\n\n        Args:\n            input: The input to format.\n\n        Returns:\n            The OpenAI chat-like format of the input.\n        \"\"\"\n        text = input[\"text\"] = input[\"text\"]\n\n        # input is in `ChatType` format\n        if isinstance(text, str):\n            return [{\"role\": \"user\", \"content\": text}]\n\n        if is_openai_format(text):\n            return text\n\n        raise ValueError(\n            f\"Couldn't format input for step {self.name}. The `text` input column has to\"\n            \" be a string or a list of dictionaries in OpenAI chat-like format.\"\n        )\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Generates an embedding for each input using the last hidden state of the `LLM`.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Yields:\n            A list of Python dictionaries with the outputs of the task.\n        \"\"\"\n        formatted_inputs = [self.format_input(input) for input in inputs]\n        last_hidden_states = self.llm.get_last_hidden_states(formatted_inputs)\n        for input, hidden_state in zip(inputs, last_hidden_states):\n            input[\"embedding\"] = hidden_state[-1].tolist()\n        yield inputs\n</code></pre>"},{"location":"api/steps/tasks/embeddings/#distilabel.steps.tasks.generate_embeddings.GenerateEmbeddings.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The inputs for the task is a <code>text</code> column containing either a string or a list of dictionaries in OpenAI chat-like format.</p>"},{"location":"api/steps/tasks/embeddings/#distilabel.steps.tasks.generate_embeddings.GenerateEmbeddings.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The outputs for the task is an <code>embedding</code> column containing the embedding of the <code>text</code> input.</p>"},{"location":"api/steps/tasks/embeddings/#distilabel.steps.tasks.generate_embeddings.GenerateEmbeddings.format_input","title":"<code>format_input(input)</code>","text":"<p>Formats the input to be used by the LLM to generate the embeddings. The input can be in <code>ChatType</code> format or a string. If a string, it will be converted to a list of dictionaries in OpenAI chat-like format.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Dict[str, Any]</code> <p>The input to format.</p> required <p>Returns:</p> Type Description <code>ChatType</code> <p>The OpenAI chat-like format of the input.</p> Source code in <code>src/distilabel/steps/tasks/generate_embeddings.py</code> <pre><code>def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n    \"\"\"Formats the input to be used by the LLM to generate the embeddings. The input\n    can be in `ChatType` format or a string. If a string, it will be converted to a\n    list of dictionaries in OpenAI chat-like format.\n\n    Args:\n        input: The input to format.\n\n    Returns:\n        The OpenAI chat-like format of the input.\n    \"\"\"\n    text = input[\"text\"] = input[\"text\"]\n\n    # input is in `ChatType` format\n    if isinstance(text, str):\n        return [{\"role\": \"user\", \"content\": text}]\n\n    if is_openai_format(text):\n        return text\n\n    raise ValueError(\n        f\"Couldn't format input for step {self.name}. The `text` input column has to\"\n        \" be a string or a list of dictionaries in OpenAI chat-like format.\"\n    )\n</code></pre>"},{"location":"api/steps/tasks/embeddings/#distilabel.steps.tasks.generate_embeddings.GenerateEmbeddings.load","title":"<code>load()</code>","text":"<p>Loads the <code>LLM</code> used to generate the embeddings.</p> Source code in <code>src/distilabel/steps/tasks/generate_embeddings.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `LLM` used to generate the embeddings.\"\"\"\n    super().load()\n    self.llm.load()\n</code></pre>"},{"location":"api/steps/tasks/embeddings/#distilabel.steps.tasks.generate_embeddings.GenerateEmbeddings.process","title":"<code>process(inputs)</code>","text":"<p>Generates an embedding for each input using the last hidden state of the <code>LLM</code>.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>A list of Python dictionaries with the inputs of the task.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>A list of Python dictionaries with the outputs of the task.</p> Source code in <code>src/distilabel/steps/tasks/generate_embeddings.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Generates an embedding for each input using the last hidden state of the `LLM`.\n\n    Args:\n        inputs: A list of Python dictionaries with the inputs of the task.\n\n    Yields:\n        A list of Python dictionaries with the outputs of the task.\n    \"\"\"\n    formatted_inputs = [self.format_input(input) for input in inputs]\n    last_hidden_states = self.llm.get_last_hidden_states(formatted_inputs)\n    for input, hidden_state in zip(inputs, last_hidden_states):\n        input[\"embedding\"] = hidden_state[-1].tolist()\n    yield inputs\n</code></pre>"},{"location":"api/steps/tasks/preference_tasks/","title":"Preference tasks","text":""},{"location":"api/steps/tasks/preference_tasks/#distilabel.steps.tasks.ultrafeedback.UltraFeedback","title":"<code>UltraFeedback</code>","text":"<p>             Bases: <code>Task</code></p> <p>UltraFeedback: Boosting Language Models with High-quality Feedback.</p> <p>Attributes:</p> Name Type Description <code>aspect</code> <code>Literal['helpfulness', 'honesty', 'instruction-following', 'truthfulness', 'overall-rating']</code> <p>The aspect to perform with the <code>UltraFeedback</code> model. The available aspects are: - <code>helpfulness</code>: Evaluate text outputs based on helpfulness. - <code>honesty</code>: Evaluate text outputs based on honesty. - <code>instruction-following</code>: Evaluate text outputs based on given instructions. - <code>truthfulness</code>: Evaluate text outputs based on truthfulness. Additionally, a custom aspect has been defined by Argilla, so as to evaluate the overall assessment of the text outputs within a single prompt. The custom aspect is: - <code>overall-rating</code>: Evaluate text outputs based on an overall assessment.</p> Input columns <ul> <li>instruction (<code>str</code>): The reference instruction to evaluate the text outputs.</li> <li>generations (<code>List[str]</code>): The text outputs to evaluate for the given instruction.</li> </ul> Output columns <ul> <li>ratings (<code>List[float]</code>): The ratings for each of the provided text outputs.</li> <li>rationales (<code>List[str]</code>): The rationales for each of the provided text outputs.</li> <li>model_name (<code>str</code>): The name of the model used to generate the ratings and rationales.</li> </ul> References <ul> <li><code>UltraFeedback: Boosting Language Models with High-quality Feedback</code></li> <li><code>UltraFeedback - GitHub Repository</code></li> </ul> Source code in <code>src/distilabel/steps/tasks/ultrafeedback.py</code> <pre><code>class UltraFeedback(Task):\n    \"\"\"UltraFeedback: Boosting Language Models with High-quality Feedback.\n\n    Attributes:\n        aspect: The aspect to perform with the `UltraFeedback` model. The available aspects are:\n            - `helpfulness`: Evaluate text outputs based on helpfulness.\n            - `honesty`: Evaluate text outputs based on honesty.\n            - `instruction-following`: Evaluate text outputs based on given instructions.\n            - `truthfulness`: Evaluate text outputs based on truthfulness.\n            Additionally, a custom aspect has been defined by Argilla, so as to evaluate the overall\n            assessment of the text outputs within a single prompt. The custom aspect is:\n            - `overall-rating`: Evaluate text outputs based on an overall assessment.\n\n    Input columns:\n        - instruction (`str`): The reference instruction to evaluate the text outputs.\n        - generations (`List[str]`): The text outputs to evaluate for the given instruction.\n\n    Output columns:\n        - ratings (`List[float]`): The ratings for each of the provided text outputs.\n        - rationales (`List[str]`): The rationales for each of the provided text outputs.\n        - model_name (`str`): The name of the model used to generate the ratings and rationales.\n\n    References:\n        - [`UltraFeedback: Boosting Language Models with High-quality Feedback`](https://arxiv.org/abs/2310.01377)\n        - [`UltraFeedback - GitHub Repository`](https://github.com/OpenBMB/UltraFeedback)\n    \"\"\"\n\n    aspect: Literal[\n        \"helpfulness\",\n        \"honesty\",\n        \"instruction-following\",\n        \"truthfulness\",\n        # Custom aspects\n        \"overall-rating\",\n    ]\n\n    _system_prompt: str = PrivateAttr(\n        default=(\n            \"Your role is to evaluate text quality based on given criteria.\\n\"\n            'You\\'ll receive an instructional description (\"Instruction\") and {no_texts} text outputs (\"Text\").\\n'\n            \"Understand and interpret instructions to evaluate effectively.\\n\"\n            \"Provide annotations for each text with a rating and rationale.\\n\"\n            \"The {no_texts} texts given are independent, and should be evaluated separately.\\n\"\n        )\n    )\n    _template: Optional[\"Template\"] = PrivateAttr(default=...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the Jinja2 template for the given `aspect`.\"\"\"\n        super().load()\n\n        _path = str(\n            importlib_resources.files(\"distilabel\")\n            / \"steps\"\n            / \"tasks\"\n            / \"templates\"\n            / \"ultrafeedback\"\n            / f\"{self.aspect}.jinja2\"\n        )\n\n        self._template = Template(open(_path).read())\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input for the task is the `instruction`, and the `generations` for it.\"\"\"\n        return [\"instruction\", \"generations\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; ChatType:\n        \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n        is the first interaction from the user within a conversation.\"\"\"\n        return [\n            {\n                \"role\": \"system\",\n                \"content\": self._system_prompt.format(\n                    no_texts=len(input[\"generations\"])\n                ),\n            },\n            {\n                \"role\": \"user\",\n                \"content\": self._template.render(  # type: ignore\n                    instruction=input[\"instruction\"], generations=input[\"generations\"]\n                ),\n            },\n        ]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The output for the task is the `generation` and the `model_name`.\"\"\"\n        columns = []\n        if self.aspect in [\"honesty\", \"instruction-following\", \"overall-rating\"]:\n            columns = [\"ratings\", \"rationales\"]\n        elif self.aspect in [\"helpfulness\", \"truthfulness\"]:\n            columns = [\"types\", \"rationales\", \"ratings\", \"rationales-for-ratings\"]\n        return columns + [\"model_name\"]\n\n    def format_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, Any]:\n        \"\"\"The output is formatted as a dictionary with the `ratings` and `rationales` for\n        each of the provided `generations` for the given `instruction`. The `model_name`\n        will be automatically included within the `process` method of `Task`.\n\n        Args:\n            output: a string representing the output of the LLM via the `process` method.\n            input: the input to the task, as required by some tasks to format the output.\n\n        Returns:\n            A dictionary containing either the `ratings` and `rationales` for each of the provided\n            `generations` for the given `instruction` if the provided aspect is either `honesty`,\n            `instruction-following`, or `overall-rating`; or the `types`, `rationales`,\n            `ratings`, and `rationales-for-ratings` for each of the provided `generations` for the\n            given `instruction` if the provided aspect is either `helpfulness` or `truthfulness`.\n        \"\"\"\n        if self.aspect in [\n            \"honesty\",\n            \"instruction-following\",\n            \"overall-rating\",\n        ]:\n            return self._format_ratings_rationales_output(output, input)\n        else:\n            return self._format_types_ratings_rationales_output(output, input)\n\n    def _format_ratings_rationales_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, List[Any]]:\n        \"\"\"Formats the output when the aspect is either `honesty`, `instruction-following`, or `overall-rating`.\"\"\"\n        if output is None:\n            return {\n                \"ratings\": [None] * len(input[\"generations\"]),\n                \"rationales\": [None] * len(input[\"generations\"]),\n            }\n\n        pattern = r\"Rating: (.+?)\\nRationale: (.+)\"\n        sections = output.split(\"\\n\\n\")\n\n        formatted_outputs = []\n        for section in sections:\n            matches = None\n            if section is not None and section != \"\":\n                matches = re.search(pattern, section, re.DOTALL)\n            if not matches:\n                formatted_outputs.append({\"ratings\": None, \"rationales\": None})\n                continue\n\n            formatted_outputs.append(\n                {\n                    \"ratings\": int(re.findall(r\"\\b\\d+\\b\", matches.group(1))[0])\n                    if matches.group(1) not in [\"None\", \"N/A\"]\n                    else None,\n                    \"rationales\": matches.group(2),\n                }\n            )\n        return combine_dicts(*formatted_outputs)\n\n    def _format_types_ratings_rationales_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, List[Any]]:\n        \"\"\"Formats the output when the aspect is either `helpfulness` or `truthfulness`.\"\"\"\n        if output is None:\n            return {\n                \"types\": [None] * len(input[\"generations\"]),\n                \"rationales\": [None] * len(input[\"generations\"]),\n                \"ratings\": [None] * len(input[\"generations\"]),\n                \"rationales-for-ratings\": [None] * len(input[\"generations\"]),\n            }\n\n        pattern = r\"Type: (.+?)\\nRationale: (.+?)\\nRating: (.+?)\\nRationale: (.+)\"\n\n        sections = output.split(\"\\n\\n\")\n\n        formatted_outputs = []\n        for section in sections:\n            matches = None\n            if section is not None and section != \"\":\n                matches = re.search(pattern, section, re.DOTALL)\n            if not matches:\n                formatted_outputs.append(\n                    {\n                        \"types\": None,\n                        \"rationales\": None,\n                        \"ratings\": None,\n                        \"rationales-for-ratings\": None,\n                    }\n                )\n                continue\n\n            formatted_outputs.append(\n                {\n                    \"types\": int(re.findall(r\"\\b\\d+\\b\", matches.group(1))[0])\n                    if matches.group(1) not in [\"None\", \"N/A\"]\n                    else None,\n                    \"rationales\": matches.group(2),\n                    \"ratings\": int(re.findall(r\"\\b\\d+\\b\", matches.group(3))[0])\n                    if matches.group(3) not in [\"None\", \"N/A\"]\n                    else None,\n                    \"rationales-for-ratings\": matches.group(4),\n                }\n            )\n        return combine_dicts(*formatted_outputs)\n</code></pre>"},{"location":"api/steps/tasks/preference_tasks/#distilabel.steps.tasks.ultrafeedback.UltraFeedback.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input for the task is the <code>instruction</code>, and the <code>generations</code> for it.</p>"},{"location":"api/steps/tasks/preference_tasks/#distilabel.steps.tasks.ultrafeedback.UltraFeedback.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The output for the task is the <code>generation</code> and the <code>model_name</code>.</p>"},{"location":"api/steps/tasks/preference_tasks/#distilabel.steps.tasks.ultrafeedback.UltraFeedback.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is formatted as a <code>ChatType</code> assuming that the instruction is the first interaction from the user within a conversation.</p> Source code in <code>src/distilabel/steps/tasks/ultrafeedback.py</code> <pre><code>def format_input(self, input: Dict[str, Any]) -&gt; ChatType:\n    \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n    is the first interaction from the user within a conversation.\"\"\"\n    return [\n        {\n            \"role\": \"system\",\n            \"content\": self._system_prompt.format(\n                no_texts=len(input[\"generations\"])\n            ),\n        },\n        {\n            \"role\": \"user\",\n            \"content\": self._template.render(  # type: ignore\n                instruction=input[\"instruction\"], generations=input[\"generations\"]\n            ),\n        },\n    ]\n</code></pre>"},{"location":"api/steps/tasks/preference_tasks/#distilabel.steps.tasks.ultrafeedback.UltraFeedback.format_output","title":"<code>format_output(output, input)</code>","text":"<p>The output is formatted as a dictionary with the <code>ratings</code> and <code>rationales</code> for each of the provided <code>generations</code> for the given <code>instruction</code>. The <code>model_name</code> will be automatically included within the <code>process</code> method of <code>Task</code>.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>Union[str, None]</code> <p>a string representing the output of the LLM via the <code>process</code> method.</p> required <code>input</code> <code>Dict[str, Any]</code> <p>the input to the task, as required by some tasks to format the output.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary containing either the <code>ratings</code> and <code>rationales</code> for each of the provided</p> <code>Dict[str, Any]</code> <p><code>generations</code> for the given <code>instruction</code> if the provided aspect is either <code>honesty</code>,</p> <code>Dict[str, Any]</code> <p><code>instruction-following</code>, or <code>overall-rating</code>; or the <code>types</code>, <code>rationales</code>,</p> <code>Dict[str, Any]</code> <p><code>ratings</code>, and <code>rationales-for-ratings</code> for each of the provided <code>generations</code> for the</p> <code>Dict[str, Any]</code> <p>given <code>instruction</code> if the provided aspect is either <code>helpfulness</code> or <code>truthfulness</code>.</p> Source code in <code>src/distilabel/steps/tasks/ultrafeedback.py</code> <pre><code>def format_output(\n    self, output: Union[str, None], input: Dict[str, Any]\n) -&gt; Dict[str, Any]:\n    \"\"\"The output is formatted as a dictionary with the `ratings` and `rationales` for\n    each of the provided `generations` for the given `instruction`. The `model_name`\n    will be automatically included within the `process` method of `Task`.\n\n    Args:\n        output: a string representing the output of the LLM via the `process` method.\n        input: the input to the task, as required by some tasks to format the output.\n\n    Returns:\n        A dictionary containing either the `ratings` and `rationales` for each of the provided\n        `generations` for the given `instruction` if the provided aspect is either `honesty`,\n        `instruction-following`, or `overall-rating`; or the `types`, `rationales`,\n        `ratings`, and `rationales-for-ratings` for each of the provided `generations` for the\n        given `instruction` if the provided aspect is either `helpfulness` or `truthfulness`.\n    \"\"\"\n    if self.aspect in [\n        \"honesty\",\n        \"instruction-following\",\n        \"overall-rating\",\n    ]:\n        return self._format_ratings_rationales_output(output, input)\n    else:\n        return self._format_types_ratings_rationales_output(output, input)\n</code></pre>"},{"location":"api/steps/tasks/preference_tasks/#distilabel.steps.tasks.ultrafeedback.UltraFeedback.load","title":"<code>load()</code>","text":"<p>Loads the Jinja2 template for the given <code>aspect</code>.</p> Source code in <code>src/distilabel/steps/tasks/ultrafeedback.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the Jinja2 template for the given `aspect`.\"\"\"\n    super().load()\n\n    _path = str(\n        importlib_resources.files(\"distilabel\")\n        / \"steps\"\n        / \"tasks\"\n        / \"templates\"\n        / \"ultrafeedback\"\n        / f\"{self.aspect}.jinja2\"\n    )\n\n    self._template = Template(open(_path).read())\n</code></pre>"},{"location":"api/steps/tasks/text_generation/","title":"Tasks","text":""},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.base.GeneratorTask","title":"<code>GeneratorTask</code>","text":"<p>             Bases: <code>_Task</code>, <code>GeneratorStep</code></p> <p>GeneratorTask is a class that implements the <code>_Task</code> abstract class and adds the <code>GeneratorStep</code> interface to be used as a step in the pipeline.</p> <p>Attributes:</p> Name Type Description <code>llm</code> <p>the <code>LLM</code> to be used to generate the outputs of the task.</p> <code>group_generations</code> <p>whether to group the <code>num_generations</code> generated per input in a list or create a row per generation. Defaults to <code>False</code>.</p> <code>num_generations</code> <p>The number of generations to be produced per input.</p> Source code in <code>src/distilabel/steps/tasks/base.py</code> <pre><code>class GeneratorTask(_Task, GeneratorStep):\n    \"\"\"GeneratorTask is a class that implements the `_Task` abstract class and adds the\n    `GeneratorStep` interface to be used as a step in the pipeline.\n\n    Attributes:\n        llm: the `LLM` to be used to generate the outputs of the task.\n        group_generations: whether to group the `num_generations` generated per input in\n            a list or create a row per generation. Defaults to `False`.\n        num_generations: The number of generations to be produced per input.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.base.Task","title":"<code>Task</code>","text":"<p>             Bases: <code>_Task</code>, <code>Step</code></p> <p>Task is a class that implements the <code>_Task</code> abstract class and adds the <code>Step</code> interface to be used as a step in the pipeline.</p> <p>Attributes:</p> Name Type Description <code>llm</code> <p>the <code>LLM</code> to be used to generate the outputs of the task.</p> <code>group_generations</code> <p>whether to group the <code>num_generations</code> generated per input in a list or create a row per generation. Defaults to <code>False</code>.</p> <code>num_generations</code> <p>The number of generations to be produced per input.</p> Source code in <code>src/distilabel/steps/tasks/base.py</code> <pre><code>class Task(_Task, Step):\n    \"\"\"Task is a class that implements the `_Task` abstract class and adds the `Step`\n    interface to be used as a step in the pipeline.\n\n    Attributes:\n        llm: the `LLM` to be used to generate the outputs of the task.\n        group_generations: whether to group the `num_generations` generated per input in\n            a list or create a row per generation. Defaults to `False`.\n        num_generations: The number of generations to be produced per input.\n    \"\"\"\n\n    @abstractmethod\n    def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n        \"\"\"Abstract method to format the inputs of the task. It needs to receive an input\n        as a Python dictionary, and generates an OpenAI chat-like list of dicts.\"\"\"\n        pass\n\n    def _format_inputs(self, inputs: List[Dict[str, Any]]) -&gt; List[\"ChatType\"]:\n        \"\"\"Formats the inputs of the task using the `format_input` method.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Returns:\n            A list containing the formatted inputs, which are `ChatType`-like following\n            the OpenAI formatting.\n        \"\"\"\n        return [self.format_input(input) for input in inputs]\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Yields:\n            A list of Python dictionaries with the outputs of the task.\n        \"\"\"\n\n        formatted_inputs = self._format_inputs(inputs)\n        outputs = self.llm.generate(\n            inputs=formatted_inputs,\n            num_generations=self.num_generations,  # type: ignore\n            **self.llm.generation_kwargs,  # type: ignore\n        )\n\n        task_outputs = []\n        for input, input_outputs in zip(inputs, outputs):\n            formatted_outputs = self._format_outputs(input_outputs, inputs)\n\n            if self.group_generations:\n                combined = combine_dicts(*formatted_outputs)\n                task_outputs.append(\n                    {**input, \"model_name\": self.llm.model_name, **combined}\n                )\n                continue\n\n            # Create a row per generation\n            for formatted_output in formatted_outputs:\n                task_outputs.append(\n                    {**input, \"model_name\": self.llm.model_name, **formatted_output}\n                )\n\n        yield task_outputs\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.base.Task.format_input","title":"<code>format_input(input)</code>  <code>abstractmethod</code>","text":"<p>Abstract method to format the inputs of the task. It needs to receive an input as a Python dictionary, and generates an OpenAI chat-like list of dicts.</p> Source code in <code>src/distilabel/steps/tasks/base.py</code> <pre><code>@abstractmethod\ndef format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n    \"\"\"Abstract method to format the inputs of the task. It needs to receive an input\n    as a Python dictionary, and generates an OpenAI chat-like list of dicts.\"\"\"\n    pass\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.base.Task.process","title":"<code>process(inputs)</code>","text":"<p>Processes the inputs of the task and generates the outputs using the LLM.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>A list of Python dictionaries with the inputs of the task.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>A list of Python dictionaries with the outputs of the task.</p> Source code in <code>src/distilabel/steps/tasks/base.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n    Args:\n        inputs: A list of Python dictionaries with the inputs of the task.\n\n    Yields:\n        A list of Python dictionaries with the outputs of the task.\n    \"\"\"\n\n    formatted_inputs = self._format_inputs(inputs)\n    outputs = self.llm.generate(\n        inputs=formatted_inputs,\n        num_generations=self.num_generations,  # type: ignore\n        **self.llm.generation_kwargs,  # type: ignore\n    )\n\n    task_outputs = []\n    for input, input_outputs in zip(inputs, outputs):\n        formatted_outputs = self._format_outputs(input_outputs, inputs)\n\n        if self.group_generations:\n            combined = combine_dicts(*formatted_outputs)\n            task_outputs.append(\n                {**input, \"model_name\": self.llm.model_name, **combined}\n            )\n            continue\n\n        # Create a row per generation\n        for formatted_output in formatted_outputs:\n            task_outputs.append(\n                {**input, \"model_name\": self.llm.model_name, **formatted_output}\n            )\n\n    yield task_outputs\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#general-text-generation","title":"General Text Generation","text":""},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.text_generation.TextGeneration","title":"<code>TextGeneration</code>","text":"<p>             Bases: <code>Task</code></p> <p>TextGeneration is a pre-defined task that defines the <code>instruction</code> as the input and <code>generation</code> as the output. This task is used to generate text based on the input instruction. The model_name is also returned as part of the output in order to enhance it.</p> Input columns <ul> <li>instruction (<code>str</code>): The instruction to generate text from.</li> </ul> Output columns <ul> <li>generation (<code>str</code>): The generated text.</li> <li>model_name (<code>str</code>): The model name used to generate the text.</li> </ul> Source code in <code>src/distilabel/steps/tasks/text_generation.py</code> <pre><code>class TextGeneration(Task):\n    \"\"\"TextGeneration is a pre-defined task that defines the `instruction` as the input\n    and `generation` as the output. This task is used to generate text based on the input\n    instruction. The model_name is also returned as part of the output in order to enhance it.\n\n    Input columns:\n        - instruction (`str`): The instruction to generate text from.\n\n    Output columns:\n        - generation (`str`): The generated text.\n        - model_name (`str`): The model name used to generate the text.\n    \"\"\"\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input for the task is the `instruction`.\"\"\"\n        return [\"instruction\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; ChatType:\n        \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n        is the first interaction from the user within a conversation.\"\"\"\n        return [\n            {\"role\": \"user\", \"content\": input[\"instruction\"]},\n        ]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The output for the task is the `generation` and the `model_name`.\"\"\"\n        return [\"generation\", \"model_name\"]\n\n    def format_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, Any]:\n        \"\"\"The output is formatted as a dictionary with the `generation`. The `model_name`\n        will be automatically included within the `process` method of `Task`.\"\"\"\n        return {\"generation\": output}\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.text_generation.TextGeneration.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input for the task is the <code>instruction</code>.</p>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.text_generation.TextGeneration.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The output for the task is the <code>generation</code> and the <code>model_name</code>.</p>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.text_generation.TextGeneration.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is formatted as a <code>ChatType</code> assuming that the instruction is the first interaction from the user within a conversation.</p> Source code in <code>src/distilabel/steps/tasks/text_generation.py</code> <pre><code>def format_input(self, input: Dict[str, Any]) -&gt; ChatType:\n    \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n    is the first interaction from the user within a conversation.\"\"\"\n    return [\n        {\"role\": \"user\", \"content\": input[\"instruction\"]},\n    ]\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.text_generation.TextGeneration.format_output","title":"<code>format_output(output, input)</code>","text":"<p>The output is formatted as a dictionary with the <code>generation</code>. The <code>model_name</code> will be automatically included within the <code>process</code> method of <code>Task</code>.</p> Source code in <code>src/distilabel/steps/tasks/text_generation.py</code> <pre><code>def format_output(\n    self, output: Union[str, None], input: Dict[str, Any]\n) -&gt; Dict[str, Any]:\n    \"\"\"The output is formatted as a dictionary with the `generation`. The `model_name`\n    will be automatically included within the `process` method of `Task`.\"\"\"\n    return {\"generation\": output}\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#evol-instruct","title":"Evol Instruct","text":""},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_instruct.base.EvolInstruct","title":"<code>EvolInstruct</code>","text":"<p>             Bases: <code>Task</code></p> <p>WizardLM: Empowering Large Language Models to Follow Complex Instructions</p> <p>Attributes:</p> Name Type Description <code>num_evolutions</code> <code>int</code> <p>The number of evolutions to be performed.</p> <code>store_evolutions</code> <code>bool</code> <p>Whether to store all the evolutions or just the last one. Defaults to <code>False</code>.</p> <code>generate_answers</code> <code>bool</code> <p>Whether to generate answers for the evolved instructions. Defaults to <code>False</code>.</p> <code>include_original_instruction</code> <code>bool</code> <p>Whether to include the original instruction in the <code>evolved_instructions</code> output column. Defaults to <code>False</code>.</p> <code>mutation_templates</code> <code>Dict[str, str]</code> <p>The mutation templates to be used for evolving the instructions. Defaults to the ones provided in the <code>utils.py</code> file.</p> <code>seed</code> <code>RuntimeParameter[int]</code> <p>The seed to be set for <code>numpy</code> in order to randomly pick a mutation method. Defaults to <code>42</code>.</p> Runtime parameters <ul> <li><code>seed</code>: The seed to be set for <code>numpy</code> in order to randomly pick a mutation method.</li> </ul> Input columns <ul> <li>instruction (<code>str</code>): The instruction to evolve.</li> </ul> Output columns <ul> <li>evolved_instruction (<code>str</code>): The evolved instruction if <code>store_evolutions=False</code>.</li> <li>evolved_instructions (<code>List[str]</code>): The evolved instructions if <code>store_evolutions=True</code>.</li> <li>model_name (<code>str</code>): The name of the LLM used to evolve the instructions.</li> <li>answer (<code>str</code>): The answer to the evolved instruction if <code>generate_answers=True</code>     and <code>store_evolutions=False</code>.</li> <li>answers (<code>List[str]</code>): The answers to the evolved instructions if <code>generate_answers=True</code>     and <code>store_evolutions=True</code>.</li> </ul> References <ul> <li>WizardLM: Empowering Large Language Models to Follow Complex Instructions</li> <li>GitHub: h2oai/h2o-wizardlm</li> </ul> Source code in <code>src/distilabel/steps/tasks/evol_instruct/base.py</code> <pre><code>class EvolInstruct(Task):\n    \"\"\"WizardLM: Empowering Large Language Models to Follow Complex Instructions\n\n    Attributes:\n        num_evolutions: The number of evolutions to be performed.\n        store_evolutions: Whether to store all the evolutions or just the last one. Defaults\n            to `False`.\n        generate_answers: Whether to generate answers for the evolved instructions. Defaults\n            to `False`.\n        include_original_instruction: Whether to include the original instruction in the\n            `evolved_instructions` output column. Defaults to `False`.\n        mutation_templates: The mutation templates to be used for evolving the instructions.\n            Defaults to the ones provided in the `utils.py` file.\n        seed: The seed to be set for `numpy` in order to randomly pick a mutation method.\n            Defaults to `42`.\n\n    Runtime parameters:\n        - `seed`: The seed to be set for `numpy` in order to randomly pick a mutation method.\n\n    Input columns:\n        - instruction (`str`): The instruction to evolve.\n\n    Output columns:\n        - evolved_instruction (`str`): The evolved instruction if `store_evolutions=False`.\n        - evolved_instructions (`List[str]`): The evolved instructions if `store_evolutions=True`.\n        - model_name (`str`): The name of the LLM used to evolve the instructions.\n        - answer (`str`): The answer to the evolved instruction if `generate_answers=True`\n            and `store_evolutions=False`.\n        - answers (`List[str]`): The answers to the evolved instructions if `generate_answers=True`\n            and `store_evolutions=True`.\n\n    References:\n        - [WizardLM: Empowering Large Language Models to Follow Complex Instructions](https://arxiv.org/abs/2304.12244)\n        - [GitHub: h2oai/h2o-wizardlm](https://github.com/h2oai/h2o-wizardlm)\n    \"\"\"\n\n    num_evolutions: int\n    store_evolutions: bool = False\n    generate_answers: bool = False\n    include_original_instruction: bool = False\n    mutation_templates: Dict[str, str] = MUTATION_TEMPLATES\n\n    seed: RuntimeParameter[int] = Field(\n        default=42,\n        description=\"As `numpy` is being used in order to randomly pick a mutation method, then is nice to seed a random seed.\",\n    )\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input for the task is the `instruction`.\"\"\"\n        return [\"instruction\"]\n\n    def format_input(self, input: str) -&gt; ChatType:  # type: ignore\n        \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n        is the first interaction from the user within a conversation. And the\n        `system_prompt` is added as the first message if it exists.\"\"\"\n        return [{\"role\": \"user\", \"content\": input}]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The output for the task are the `evolved_instruction/s`, the `answer` if `generate_answers=True`\n        and the `model_name`.\"\"\"\n        # TODO: having to define a `model_name` column every time as the `Task.outputs` is not ideal,\n        # this could be handled always and the value could be included within the DAG validation when\n        # a `Task` is used, since all the `Task` subclasses will have an `llm` with a `model_name` attr.\n        _outputs = [\n            (\n                \"evolved_instruction\"\n                if not self.store_evolutions\n                else \"evolved_instructions\"\n            ),\n            \"model_name\",\n        ]\n        if self.generate_answers:\n            _outputs.append(\"answer\" if not self.store_evolutions else \"answers\")\n        return _outputs\n\n    @override\n    def format_output(  # type: ignore\n        self, instructions: Union[str, List[str]], answers: Optional[List[str]] = None\n    ) -&gt; Dict[str, Any]:  # type: ignore\n        \"\"\"The output for the task is a dict with: `evolved_instruction` or `evolved_instructions`,\n        depending whether the value is either `False` or `True` for `store_evolutions`, respectively;\n        `answer` if `generate_answers=True`; and, finally, the `model_name`.\n\n        Args:\n            instructions: The instructions to be included within the output.\n            answers: The answers to be included within the output if `generate_answers=True`.\n\n        Returns:\n            If `store_evolutions=False` and `generate_answers=True` return {\"evolved_instruction\": ..., \"model_name\": ..., \"answer\": ...};\n            if `store_evolutions=True` and `generate_answers=True` return {\"evolved_instructions\": ..., \"model_name\": ..., \"answer\": ...};\n            if `store_evolutions=False` and `generate_answers=False` return {\"evolved_instruction\": ..., \"model_name\": ...};\n            if `store_evolutions=True` and `generate_answers=False` return {\"evolved_instructions\": ..., \"model_name\": ...}.\n        \"\"\"\n        _output = {}\n        if not self.store_evolutions:\n            _output[\"evolved_instruction\"] = instructions[-1]\n        else:\n            _output[\"evolved_instructions\"] = instructions\n\n        if self.generate_answers and answers:\n            if not self.store_evolutions:\n                _output[\"answer\"] = answers[-1]\n            else:\n                _output[\"answers\"] = answers\n\n        _output[\"model_name\"] = self.llm.model_name\n        return _output\n\n    @property\n    def mutation_templates_names(self) -&gt; List[str]:\n        \"\"\"Returns the names i.e. keys of the provided `mutation_templates`.\"\"\"\n        return list(self.mutation_templates.keys())\n\n    def _apply_random_mutation(self, instruction: str) -&gt; str:\n        \"\"\"Applies a random mutation from the ones provided as part of the `mutation_templates`\n        enum, and returns the provided instruction within the mutation prompt.\n\n        Args:\n            instruction: The instruction to be included within the mutation prompt.\n\n        Returns:\n            A random mutation prompt with the provided instruction.\n        \"\"\"\n        mutation = np.random.choice(self.mutation_templates_names)\n        return self.mutation_templates[mutation].replace(\"&lt;PROMPT&gt;\", instruction)  # type: ignore\n\n    def _evolve_instructions(self, inputs: \"StepInput\") -&gt; List[List[str]]:\n        \"\"\"Evolves the instructions provided as part of the inputs of the task.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Returns:\n            A list where each item is a list with either the last evolved instruction if\n            `store_evolutions=False` or all the evolved instructions if `store_evolutions=True`.\n        \"\"\"\n\n        instructions: List[List[str]] = [[input[\"instruction\"]] for input in inputs]\n\n        for iter_no in range(self.num_evolutions):\n            formatted_prompts = []\n            for instruction in instructions:\n                formatted_prompts.append(self._apply_random_mutation(instruction[-1]))\n\n            formatted_prompts = [\n                self.format_input(prompt) for prompt in formatted_prompts\n            ]\n            generated_prompts = flatten_responses(\n                self.llm.generate(\n                    formatted_prompts,\n                    **self.llm.generation_kwargs,  # type: ignore\n                )\n            )\n\n            evolved_instructions = []\n            for generated_prompt in generated_prompts:\n                generated_prompt = generated_prompt.split(\"Prompt#:\")[-1].strip()\n                evolved_instructions.append(generated_prompt)\n\n            if self.store_evolutions:\n                instructions = [\n                    instruction + [evolved_instruction]\n                    for instruction, evolved_instruction in zip(\n                        instructions, evolved_instructions\n                    )\n                ]\n            else:\n                instructions = [\n                    [evolved_instruction]\n                    for evolved_instruction in evolved_instructions\n                ]\n\n            self._logger.info(\n                f\"\ud83d\udd04 Ran iteration {iter_no} evolving {len(instructions)} instructions!\"\n            )\n\n        return instructions\n\n    def _generate_answers(\n        self, evolved_instructions: List[List[str]]\n    ) -&gt; List[List[str]]:\n        \"\"\"Generates the answer for the instructions in `instructions`.\n\n        Args:\n            evolved_instructions: A list of lists where each item is a list with either the last\n                evolved instruction if `store_evolutions=False` or all the evolved instructions\n                if `store_evolutions=True`.\n\n        Returns:\n            A list of answers for each instruction.\n        \"\"\"\n        formatted_instructions = [\n            self.format_input(instruction)\n            for instructions in evolved_instructions\n            for instruction in instructions\n        ]\n\n        responses = self.llm.generate(\n            formatted_instructions,\n            num_generations=1,\n            **self.llm.generation_kwargs,  # type: ignore\n        )\n\n        step = (\n            self.num_evolutions\n            if not self.include_original_instruction\n            else self.num_evolutions + 1\n        )\n        return [\n            flatten_responses(responses[i : i + step])\n            for i in range(0, len(responses), step)\n        ]\n\n    @override\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Yields:\n            A list of Python dictionaries with the outputs of the task.\n        \"\"\"\n\n        evolved_instructions = self._evolve_instructions(inputs)\n\n        if self.store_evolutions:\n            # Remove the input instruction from the `evolved_instructions` list\n            from_ = 1 if not self.include_original_instruction else 0\n            evolved_instructions = [\n                instruction[from_:] for instruction in evolved_instructions\n            ]\n\n        if not self.generate_answers:\n            for input, instruction in zip(inputs, evolved_instructions):\n                input.update(self.format_output(instruction))\n            yield inputs\n\n        self._logger.info(\n            f\"\ud83c\udf89 Finished evolving {len(evolved_instructions)} instructions!\"\n        )\n\n        if self.generate_answers:\n            self._logger.info(\n                f\"\ud83e\udde0 Generating answers for the {len(evolved_instructions)} evolved instructions!\"\n            )\n\n            answers = self._generate_answers(evolved_instructions)\n\n            self._logger.info(\n                f\"\ud83c\udf89 Finished generating answers for the {len(evolved_instructions)} evolved\"\n                \" instructions!\"\n            )\n\n            for idx, (input, instruction) in enumerate(\n                zip(inputs, evolved_instructions)\n            ):\n                input.update(self.format_output(instruction, answers[idx]))\n            yield inputs\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_instruct.base.EvolInstruct.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input for the task is the <code>instruction</code>.</p>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_instruct.base.EvolInstruct.mutation_templates_names","title":"<code>mutation_templates_names: List[str]</code>  <code>property</code>","text":"<p>Returns the names i.e. keys of the provided <code>mutation_templates</code>.</p>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_instruct.base.EvolInstruct.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The output for the task are the <code>evolved_instruction/s</code>, the <code>answer</code> if <code>generate_answers=True</code> and the <code>model_name</code>.</p>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_instruct.base.EvolInstruct.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is formatted as a <code>ChatType</code> assuming that the instruction is the first interaction from the user within a conversation. And the <code>system_prompt</code> is added as the first message if it exists.</p> Source code in <code>src/distilabel/steps/tasks/evol_instruct/base.py</code> <pre><code>def format_input(self, input: str) -&gt; ChatType:  # type: ignore\n    \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n    is the first interaction from the user within a conversation. And the\n    `system_prompt` is added as the first message if it exists.\"\"\"\n    return [{\"role\": \"user\", \"content\": input}]\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_instruct.base.EvolInstruct.format_output","title":"<code>format_output(instructions, answers=None)</code>","text":"<p>The output for the task is a dict with: <code>evolved_instruction</code> or <code>evolved_instructions</code>, depending whether the value is either <code>False</code> or <code>True</code> for <code>store_evolutions</code>, respectively; <code>answer</code> if <code>generate_answers=True</code>; and, finally, the <code>model_name</code>.</p> <p>Parameters:</p> Name Type Description Default <code>instructions</code> <code>Union[str, List[str]]</code> <p>The instructions to be included within the output.</p> required <code>answers</code> <code>Optional[List[str]]</code> <p>The answers to be included within the output if <code>generate_answers=True</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>If <code>store_evolutions=False</code> and <code>generate_answers=True</code> return {\"evolved_instruction\": ..., \"model_name\": ..., \"answer\": ...};</p> <code>Dict[str, Any]</code> <p>if <code>store_evolutions=True</code> and <code>generate_answers=True</code> return {\"evolved_instructions\": ..., \"model_name\": ..., \"answer\": ...};</p> <code>Dict[str, Any]</code> <p>if <code>store_evolutions=False</code> and <code>generate_answers=False</code> return {\"evolved_instruction\": ..., \"model_name\": ...};</p> <code>Dict[str, Any]</code> <p>if <code>store_evolutions=True</code> and <code>generate_answers=False</code> return {\"evolved_instructions\": ..., \"model_name\": ...}.</p> Source code in <code>src/distilabel/steps/tasks/evol_instruct/base.py</code> <pre><code>@override\ndef format_output(  # type: ignore\n    self, instructions: Union[str, List[str]], answers: Optional[List[str]] = None\n) -&gt; Dict[str, Any]:  # type: ignore\n    \"\"\"The output for the task is a dict with: `evolved_instruction` or `evolved_instructions`,\n    depending whether the value is either `False` or `True` for `store_evolutions`, respectively;\n    `answer` if `generate_answers=True`; and, finally, the `model_name`.\n\n    Args:\n        instructions: The instructions to be included within the output.\n        answers: The answers to be included within the output if `generate_answers=True`.\n\n    Returns:\n        If `store_evolutions=False` and `generate_answers=True` return {\"evolved_instruction\": ..., \"model_name\": ..., \"answer\": ...};\n        if `store_evolutions=True` and `generate_answers=True` return {\"evolved_instructions\": ..., \"model_name\": ..., \"answer\": ...};\n        if `store_evolutions=False` and `generate_answers=False` return {\"evolved_instruction\": ..., \"model_name\": ...};\n        if `store_evolutions=True` and `generate_answers=False` return {\"evolved_instructions\": ..., \"model_name\": ...}.\n    \"\"\"\n    _output = {}\n    if not self.store_evolutions:\n        _output[\"evolved_instruction\"] = instructions[-1]\n    else:\n        _output[\"evolved_instructions\"] = instructions\n\n    if self.generate_answers and answers:\n        if not self.store_evolutions:\n            _output[\"answer\"] = answers[-1]\n        else:\n            _output[\"answers\"] = answers\n\n    _output[\"model_name\"] = self.llm.model_name\n    return _output\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_instruct.base.EvolInstruct.process","title":"<code>process(inputs)</code>","text":"<p>Processes the inputs of the task and generates the outputs using the LLM.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>A list of Python dictionaries with the inputs of the task.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>A list of Python dictionaries with the outputs of the task.</p> Source code in <code>src/distilabel/steps/tasks/evol_instruct/base.py</code> <pre><code>@override\ndef process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n    Args:\n        inputs: A list of Python dictionaries with the inputs of the task.\n\n    Yields:\n        A list of Python dictionaries with the outputs of the task.\n    \"\"\"\n\n    evolved_instructions = self._evolve_instructions(inputs)\n\n    if self.store_evolutions:\n        # Remove the input instruction from the `evolved_instructions` list\n        from_ = 1 if not self.include_original_instruction else 0\n        evolved_instructions = [\n            instruction[from_:] for instruction in evolved_instructions\n        ]\n\n    if not self.generate_answers:\n        for input, instruction in zip(inputs, evolved_instructions):\n            input.update(self.format_output(instruction))\n        yield inputs\n\n    self._logger.info(\n        f\"\ud83c\udf89 Finished evolving {len(evolved_instructions)} instructions!\"\n    )\n\n    if self.generate_answers:\n        self._logger.info(\n            f\"\ud83e\udde0 Generating answers for the {len(evolved_instructions)} evolved instructions!\"\n        )\n\n        answers = self._generate_answers(evolved_instructions)\n\n        self._logger.info(\n            f\"\ud83c\udf89 Finished generating answers for the {len(evolved_instructions)} evolved\"\n            \" instructions!\"\n        )\n\n        for idx, (input, instruction) in enumerate(\n            zip(inputs, evolved_instructions)\n        ):\n            input.update(self.format_output(instruction, answers[idx]))\n        yield inputs\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_instruct.generator.EvolInstructGenerator","title":"<code>EvolInstructGenerator</code>","text":"<p>             Bases: <code>GeneratorTask</code></p> <p>WizardLM: Empowering Large Language Models to Follow Complex Instructions</p> <p>Attributes:</p> Name Type Description <code>num_instructions</code> <code>int</code> <p>The number of instructions to be generated.</p> <code>generate_answers</code> <code>bool</code> <p>Whether to generate answers for the instructions or not. Defaults to <code>False</code>.</p> <code>mutation_templates</code> <code>Dict[str, str]</code> <p>The mutation templates to be used for the generation of the instructions.</p> <code>min_length</code> <code>RuntimeParameter[int]</code> <p>Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid. Defaults to <code>512</code>.</p> <code>max_length</code> <code>RuntimeParameter[int]</code> <p>Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid. Defaults to <code>1024</code>.</p> <code>seed</code> <code>RuntimeParameter[int]</code> <p>The seed to be set for <code>numpy</code> in order to randomly pick a mutation method. Defaults to <code>42</code>.</p> Runtime parameters <ul> <li><code>min_length</code>: Defines the length (in bytes) that the generated instruction needs     to be higher than, to be considered valid.</li> <li><code>max_length</code>: Defines the length (in bytes) that the generated instruction needs     to be lower than, to be considered valid.</li> <li><code>seed</code>: The seed to be set for <code>numpy</code> in order to randomly pick a mutation method.</li> </ul> Output columns <ul> <li>instruction (<code>str</code>): The generated instruction if <code>generate_answers=False</code>.</li> <li>answer (<code>str</code>): The generated answer if <code>generate_answers=True</code>.</li> <li>instructions (<code>List[str]</code>): The generated instructions if <code>generate_answers=True</code>.</li> <li>model_name (<code>str</code>): The name of the LLM used to generate and evolve the instructions.</li> </ul> References <ul> <li>WizardLM: Empowering Large Language Models to Follow Complex Instructions</li> <li>GitHub: h2oai/h2o-wizardlm</li> </ul> Source code in <code>src/distilabel/steps/tasks/evol_instruct/generator.py</code> <pre><code>class EvolInstructGenerator(GeneratorTask):\n    \"\"\"WizardLM: Empowering Large Language Models to Follow Complex Instructions\n\n    Attributes:\n        num_instructions: The number of instructions to be generated.\n        generate_answers: Whether to generate answers for the instructions or not. Defaults\n            to `False`.\n        mutation_templates: The mutation templates to be used for the generation of the\n            instructions.\n        min_length: Defines the length (in bytes) that the generated instruction needs to\n            be higher than, to be considered valid. Defaults to `512`.\n        max_length: Defines the length (in bytes) that the generated instruction needs to\n            be lower than, to be considered valid. Defaults to `1024`.\n        seed: The seed to be set for `numpy` in order to randomly pick a mutation method.\n            Defaults to `42`.\n\n    Runtime parameters:\n        - `min_length`: Defines the length (in bytes) that the generated instruction needs\n            to be higher than, to be considered valid.\n        - `max_length`: Defines the length (in bytes) that the generated instruction needs\n            to be lower than, to be considered valid.\n        - `seed`: The seed to be set for `numpy` in order to randomly pick a mutation method.\n\n    Output columns:\n        - instruction (`str`): The generated instruction if `generate_answers=False`.\n        - answer (`str`): The generated answer if `generate_answers=True`.\n        - instructions (`List[str]`): The generated instructions if `generate_answers=True`.\n        - model_name (`str`): The name of the LLM used to generate and evolve the instructions.\n\n    References:\n        - [WizardLM: Empowering Large Language Models to Follow Complex Instructions](https://arxiv.org/abs/2304.12244)\n        - [GitHub: h2oai/h2o-wizardlm](https://github.com/h2oai/h2o-wizardlm)\n    \"\"\"\n\n    num_instructions: int\n    generate_answers: bool = False\n    mutation_templates: Dict[str, str] = GENERATION_MUTATION_TEMPLATES\n\n    min_length: RuntimeParameter[int] = Field(\n        default=512,\n        description=\"Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid.\",\n    )\n    max_length: RuntimeParameter[int] = Field(\n        default=1024,\n        description=\"Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid.\",\n    )\n\n    seed: RuntimeParameter[int] = Field(\n        default=42,\n        description=\"As `numpy` is being used in order to randomly pick a mutation method, then is nice to seed a random seed.\",\n    )\n    _seed_texts: Optional[List[str]] = PrivateAttr(default_factory=list)\n    _prompts: Optional[List[str]] = PrivateAttr(default_factory=list)\n\n    def _generate_seed_texts(self) -&gt; List[str]:\n        \"\"\"Generates a list of seed texts to be used as part of the starting prompts for the task.\n\n        It will use the `FRESH_START` mutation template, as it needs to generate text from scratch; and\n        a list of English words will be used to generate the seed texts that will be provided to the\n        mutation method and included within the prompt.\n\n        Returns:\n            A list of seed texts to be used as part of the starting prompts for the task.\n        \"\"\"\n        seed_texts = []\n        for _ in range(self.num_instructions * 10):\n            num_words = np.random.choice([1, 2, 3, 4])\n            seed_texts.append(\n                self.mutation_templates[\"FRESH_START\"].replace(  # type: ignore\n                    \"&lt;PROMPT&gt;\",\n                    \", \".join(\n                        [\n                            np.random.choice(self._english_nouns).strip()\n                            for _ in range(num_words)\n                        ]\n                    ),\n                )\n            )\n        return seed_texts\n\n    @override\n    def model_post_init(self, __context: Any) -&gt; None:\n        \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n        This is useful if you want to do some validation that requires the entire model to be initialized.\n        \"\"\"\n        super().model_post_init(__context)\n\n        np.random.seed(self.seed)\n\n        self._seed_texts = self._generate_seed_texts()\n        self._prompts = [\n            np.random.choice(self._seed_texts) for _ in range(self.num_instructions)\n        ]\n\n    @cached_property\n    def _english_nouns(self) -&gt; List[str]:\n        \"\"\"A list of English nouns to be used as part of the starting prompts for the task.\n\n        References:\n            - https://github.com/h2oai/h2o-wizardlm\n        \"\"\"\n        _path = str(\n            importlib_resources.files(\"distilabel\")\n            / \"steps/tasks/evol_instruct/english_nouns.txt\"\n        )\n        with open(_path, mode=\"r\") as f:\n            return [line.strip() for line in f.readlines()]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The output for the task are the `instruction`, the `answer` if `generate_answers=True`\n        and the `model_name`.\"\"\"\n        _outputs = [\"instruction\", \"model_name\"]\n        if self.generate_answers:\n            _outputs.append(\"answer\")\n        return _outputs\n\n    def format_output(  # type: ignore\n        self, instruction: str, answer: Optional[str] = None\n    ) -&gt; Dict[str, Any]:\n        \"\"\"The output for the task is a dict with: `instruction`; `answer` if `generate_answers=True`;\n        and, finally, the `model_name`.\n\n        Args:\n            instruction: The instruction to be included within the output.\n            answer: The answer to be included within the output if `generate_answers=True`.\n\n        Returns:\n            If `generate_answers=True` return {\"instruction\": ..., \"answer\": ..., \"model_name\": ...};\n            if `generate_answers=False` return {\"instruction\": ..., \"model_name\": ...};\n        \"\"\"\n        _output = {\n            \"instruction\": instruction,\n            \"model_name\": self.llm.model_name,\n        }\n        if self.generate_answers and answer is not None:\n            _output[\"answer\"] = answer\n        return _output\n\n    @property\n    def mutation_templates_names(self) -&gt; List[str]:\n        \"\"\"Returns the names i.e. keys of the provided `mutation_templates`.\"\"\"\n        return list(self.mutation_templates.keys())\n\n    def _apply_random_mutation(self, iter_no: int) -&gt; List[\"ChatType\"]:\n        \"\"\"Applies a random mutation from the ones provided as part of the `mutation_templates`\n        enum, and returns the provided instruction within the mutation prompt.\n\n        Args:\n            iter_no: The iteration number to be used to check whether the iteration is the\n                first one i.e. FRESH_START, or not.\n\n        Returns:\n            A random mutation prompt with the provided instruction formatted as an OpenAI conversation.\n        \"\"\"\n        prompts = []\n        for idx in range(self.num_instructions):\n            if (\n                iter_no == 0\n                or \"Write one question or request containing\" in self._prompts[idx]  # type: ignore\n            ):\n                mutation = \"FRESH_START\"\n            else:\n                mutation = np.random.choice(self.mutation_templates_names)\n                if mutation == \"FRESH_START\":\n                    self._prompts[idx] = np.random.choice(self._seed_texts)  # type: ignore\n\n            prompt_with_template = (\n                self.mutation_templates[mutation].replace(  # type: ignore\n                    \"&lt;PROMPT&gt;\",\n                    self._prompts[idx],  # type: ignore\n                )  # type: ignore\n                if iter_no != 0\n                else self._prompts[idx]  # type: ignore\n            )\n            prompts.append([{\"role\": \"user\", \"content\": prompt_with_template}])\n        return prompts\n\n    def _generate_answers(self, instructions: List[List[str]]) -&gt; List[str]:\n        \"\"\"Generates the answer for the last instruction in `instructions`.\n\n        Args:\n            instructions: A list of lists where each item is a list with either the last\n                evolved instruction if `store_evolutions=False` or all the evolved instructions\n                if `store_evolutions=True`.\n\n        Returns:\n            A list of answers for the last instruction in `instructions`.\n        \"\"\"\n        # TODO: update to generate answers for all the instructions\n        _formatted_instructions = [\n            [{\"role\": \"user\", \"content\": instruction[-1]}]\n            for instruction in instructions\n        ]\n        responses = self.llm.generate(\n            _formatted_instructions,\n            **self.llm.generation_kwargs,  # type: ignore\n        )\n        return flatten_responses(responses)\n\n    @override\n    def process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":  # type: ignore\n        \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n        Args:\n            offset: The offset to start the generation from. Defaults to 0.\n\n        Yields:\n            A list of Python dictionaries with the outputs of the task, and a boolean\n            flag indicating whether the task has finished or not i.e. is the last batch.\n        \"\"\"\n        instructions = []\n        mutation_no = 0\n\n        iter_no = 0\n        while len(instructions) &lt; self.num_instructions:\n            prompts = self._apply_random_mutation(iter_no=iter_no)\n\n            generated_prompts = flatten_responses(\n                self.llm.generate(prompts, **self.llm.generation_kwargs)  # type: ignore\n            )\n            for idx, generated_prompt in enumerate(generated_prompts):\n                generated_prompt = generated_prompt.split(\"Prompt#:\")[-1].strip()\n                if self.max_length &gt;= len(generated_prompt) &gt;= self.min_length:  # type: ignore\n                    instructions.append(generated_prompt)\n                    self._prompts[idx] = np.random.choice(self._seed_texts)  # type: ignore\n                else:\n                    self._prompts[idx] = generated_prompt  # type: ignore\n\n            self._logger.info(\n                f\"\ud83d\udd04 Ran iteration {iter_no} with {len(instructions)} instructions already evolved!\"\n            )\n            iter_no += 1\n\n            if len(instructions) &gt; self.num_instructions:\n                instructions = instructions[: self.num_instructions]\n            if len(instructions) &gt; mutation_no:\n                mutation_no = len(instructions) - mutation_no\n\n            if not self.generate_answers and len(instructions[-mutation_no:]) &gt; 0:\n                yield (\n                    [\n                        self.format_output(mutated_instruction)\n                        for mutated_instruction in instructions[-mutation_no:]\n                    ],\n                    len(instructions) &gt;= self.num_instructions,\n                )\n\n        self._logger.info(f\"\ud83c\udf89 Finished evolving {len(instructions)} instructions!\")\n\n        if self.generate_answers:\n            self._logger.info(\n                f\"\ud83e\udde0 Generating answers for the {len(instructions)} evolved instructions!\"\n            )\n\n            answers = self._generate_answers(instructions)\n\n            self._logger.info(\n                f\"\ud83c\udf89 Finished generating answers for the {len(instructions)} evolved instructions!\"\n            )\n\n            yield (\n                [\n                    self.format_output(instruction, answer)\n                    for instruction, answer in zip(instructions, answers)\n                ],\n                True,\n            )\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_instruct.generator.EvolInstructGenerator.mutation_templates_names","title":"<code>mutation_templates_names: List[str]</code>  <code>property</code>","text":"<p>Returns the names i.e. keys of the provided <code>mutation_templates</code>.</p>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_instruct.generator.EvolInstructGenerator.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The output for the task are the <code>instruction</code>, the <code>answer</code> if <code>generate_answers=True</code> and the <code>model_name</code>.</p>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_instruct.generator.EvolInstructGenerator.format_output","title":"<code>format_output(instruction, answer=None)</code>","text":"<p>The output for the task is a dict with: <code>instruction</code>; <code>answer</code> if <code>generate_answers=True</code>; and, finally, the <code>model_name</code>.</p> <p>Parameters:</p> Name Type Description Default <code>instruction</code> <code>str</code> <p>The instruction to be included within the output.</p> required <code>answer</code> <code>Optional[str]</code> <p>The answer to be included within the output if <code>generate_answers=True</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>If <code>generate_answers=True</code> return {\"instruction\": ..., \"answer\": ..., \"model_name\": ...};</p> <code>Dict[str, Any]</code> <p>if <code>generate_answers=False</code> return {\"instruction\": ..., \"model_name\": ...};</p> Source code in <code>src/distilabel/steps/tasks/evol_instruct/generator.py</code> <pre><code>def format_output(  # type: ignore\n    self, instruction: str, answer: Optional[str] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"The output for the task is a dict with: `instruction`; `answer` if `generate_answers=True`;\n    and, finally, the `model_name`.\n\n    Args:\n        instruction: The instruction to be included within the output.\n        answer: The answer to be included within the output if `generate_answers=True`.\n\n    Returns:\n        If `generate_answers=True` return {\"instruction\": ..., \"answer\": ..., \"model_name\": ...};\n        if `generate_answers=False` return {\"instruction\": ..., \"model_name\": ...};\n    \"\"\"\n    _output = {\n        \"instruction\": instruction,\n        \"model_name\": self.llm.model_name,\n    }\n    if self.generate_answers and answer is not None:\n        _output[\"answer\"] = answer\n    return _output\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_instruct.generator.EvolInstructGenerator.model_post_init","title":"<code>model_post_init(__context)</code>","text":"<p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>src/distilabel/steps/tasks/evol_instruct/generator.py</code> <pre><code>@override\ndef model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n    super().model_post_init(__context)\n\n    np.random.seed(self.seed)\n\n    self._seed_texts = self._generate_seed_texts()\n    self._prompts = [\n        np.random.choice(self._seed_texts) for _ in range(self.num_instructions)\n    ]\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_instruct.generator.EvolInstructGenerator.process","title":"<code>process(offset=0)</code>","text":"<p>Processes the inputs of the task and generates the outputs using the LLM.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The offset to start the generation from. Defaults to 0.</p> <code>0</code> <p>Yields:</p> Type Description <code>GeneratorStepOutput</code> <p>A list of Python dictionaries with the outputs of the task, and a boolean</p> <code>GeneratorStepOutput</code> <p>flag indicating whether the task has finished or not i.e. is the last batch.</p> Source code in <code>src/distilabel/steps/tasks/evol_instruct/generator.py</code> <pre><code>@override\ndef process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":  # type: ignore\n    \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n    Args:\n        offset: The offset to start the generation from. Defaults to 0.\n\n    Yields:\n        A list of Python dictionaries with the outputs of the task, and a boolean\n        flag indicating whether the task has finished or not i.e. is the last batch.\n    \"\"\"\n    instructions = []\n    mutation_no = 0\n\n    iter_no = 0\n    while len(instructions) &lt; self.num_instructions:\n        prompts = self._apply_random_mutation(iter_no=iter_no)\n\n        generated_prompts = flatten_responses(\n            self.llm.generate(prompts, **self.llm.generation_kwargs)  # type: ignore\n        )\n        for idx, generated_prompt in enumerate(generated_prompts):\n            generated_prompt = generated_prompt.split(\"Prompt#:\")[-1].strip()\n            if self.max_length &gt;= len(generated_prompt) &gt;= self.min_length:  # type: ignore\n                instructions.append(generated_prompt)\n                self._prompts[idx] = np.random.choice(self._seed_texts)  # type: ignore\n            else:\n                self._prompts[idx] = generated_prompt  # type: ignore\n\n        self._logger.info(\n            f\"\ud83d\udd04 Ran iteration {iter_no} with {len(instructions)} instructions already evolved!\"\n        )\n        iter_no += 1\n\n        if len(instructions) &gt; self.num_instructions:\n            instructions = instructions[: self.num_instructions]\n        if len(instructions) &gt; mutation_no:\n            mutation_no = len(instructions) - mutation_no\n\n        if not self.generate_answers and len(instructions[-mutation_no:]) &gt; 0:\n            yield (\n                [\n                    self.format_output(mutated_instruction)\n                    for mutated_instruction in instructions[-mutation_no:]\n                ],\n                len(instructions) &gt;= self.num_instructions,\n            )\n\n    self._logger.info(f\"\ud83c\udf89 Finished evolving {len(instructions)} instructions!\")\n\n    if self.generate_answers:\n        self._logger.info(\n            f\"\ud83e\udde0 Generating answers for the {len(instructions)} evolved instructions!\"\n        )\n\n        answers = self._generate_answers(instructions)\n\n        self._logger.info(\n            f\"\ud83c\udf89 Finished generating answers for the {len(instructions)} evolved instructions!\"\n        )\n\n        yield (\n            [\n                self.format_output(instruction, answer)\n                for instruction, answer in zip(instructions, answers)\n            ],\n            True,\n        )\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#evol-complexity","title":"Evol Complexity","text":""},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_instruct.evol_complexity.base.EvolComplexity","title":"<code>EvolComplexity</code>","text":"<p>             Bases: <code>EvolInstruct</code></p> <p>EvolComplexity is a task that evolves instructions to make them more complex, and it is based in the EvolInstruct task, but using slight different prompts, but the exact same evolutionary approach.</p> <p>Attributes:</p> Name Type Description <code>num_instructions</code> <p>The number of instructions to be generated.</p> <code>generate_answers</code> <p>Whether to generate answers for the instructions or not. Defaults to <code>False</code>.</p> <code>mutation_templates</code> <code>Dict[str, str]</code> <p>The mutation templates to be used for the generation of the instructions.</p> <code>min_length</code> <code>Dict[str, str]</code> <p>Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid. Defaults to <code>512</code>.</p> <code>max_length</code> <code>Dict[str, str]</code> <p>Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid. Defaults to <code>1024</code>.</p> <code>seed</code> <code>Dict[str, str]</code> <p>The seed to be set for <code>numpy</code> in order to randomly pick a mutation method. Defaults to <code>42</code>.</p> Runtime parameters <ul> <li><code>min_length</code>: Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid.</li> <li><code>max_length</code>: Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid.</li> <li><code>seed</code>: The number of evolutions to be run.</li> </ul> Input columns <ul> <li>instruction (<code>str</code>): The instruction to evolve.</li> </ul> Output columns <ul> <li>evolved_instruction (<code>str</code>): The evolved instruction.</li> <li>answer (<code>str</code>, optional): The answer to the instruction if <code>generate_answers=True</code>.</li> <li>model_name (<code>str</code>): The name of the LLM used to evolve the instructions.</li> </ul> References <ul> <li>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</li> <li>WizardLM: Empowering Large Language Models to Follow Complex Instructions</li> </ul> Source code in <code>src/distilabel/steps/tasks/evol_instruct/evol_complexity/base.py</code> <pre><code>class EvolComplexity(EvolInstruct):\n    \"\"\"EvolComplexity is a task that evolves instructions to make them more complex,\n    and it is based in the EvolInstruct task, but using slight different prompts, but the\n    exact same evolutionary approach.\n\n    Attributes:\n        num_instructions: The number of instructions to be generated.\n        generate_answers: Whether to generate answers for the instructions or not. Defaults\n            to `False`.\n        mutation_templates: The mutation templates to be used for the generation of the\n            instructions.\n        min_length: Defines the length (in bytes) that the generated instruction needs to\n            be higher than, to be considered valid. Defaults to `512`.\n        max_length: Defines the length (in bytes) that the generated instruction needs to\n            be lower than, to be considered valid. Defaults to `1024`.\n        seed: The seed to be set for `numpy` in order to randomly pick a mutation method.\n            Defaults to `42`.\n\n    Runtime parameters:\n        - `min_length`: Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid.\n        - `max_length`: Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid.\n        - `seed`: The number of evolutions to be run.\n\n    Input columns:\n        - instruction (`str`): The instruction to evolve.\n\n    Output columns:\n        - evolved_instruction (`str`): The evolved instruction.\n        - answer (`str`, optional): The answer to the instruction if `generate_answers=True`.\n        - model_name (`str`): The name of the LLM used to evolve the instructions.\n\n    References:\n        - [What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning](https://arxiv.org/abs/2312.15685)\n        - [WizardLM: Empowering Large Language Models to Follow Complex Instructions](https://arxiv.org/abs/2304.12244)\n    \"\"\"\n\n    mutation_templates: Dict[str, str] = MUTATION_TEMPLATES\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_instruct.evol_complexity.generator.EvolComplexityGenerator","title":"<code>EvolComplexityGenerator</code>","text":"<p>             Bases: <code>EvolInstructGenerator</code></p> <p>EvolComplexity is a task that evolves instructions to make them more complex, and it is based in the EvolInstruct task, but using slight different prompts, but the exact same evolutionary approach.</p> <p>Attributes:</p> Name Type Description <code>num_instructions</code> <p>The number of instructions to be generated.</p> <code>generate_answers</code> <p>Whether to generate answers for the instructions or not. Defaults to <code>False</code>.</p> <code>mutation_templates</code> <code>Dict[str, str]</code> <p>The mutation templates to be used for the generation of the instructions.</p> <code>min_length</code> <code>Dict[str, str]</code> <p>Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid. Defaults to <code>512</code>.</p> <code>max_length</code> <code>Dict[str, str]</code> <p>Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid. Defaults to <code>1024</code>.</p> <code>seed</code> <code>Dict[str, str]</code> <p>The seed to be set for <code>numpy</code> in order to randomly pick a mutation method. Defaults to <code>42</code>.</p> Runtime parameters <ul> <li><code>min_length</code>: Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid.</li> <li><code>max_length</code>: Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid.</li> <li><code>seed</code>: The number of evolutions to be run.</li> </ul> Input columns <ul> <li>instruction (<code>str</code>): The instruction to evolve.</li> </ul> Output columns <ul> <li>instruction (<code>str</code>): The evolved instruction.</li> <li>answer (<code>str</code>, optional): The answer to the instruction if <code>generate_answers=True</code>.</li> <li>model_name (<code>str</code>): The name of the LLM used to evolve the instructions.</li> </ul> References <ul> <li>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</li> <li>WizardLM: Empowering Large Language Models to Follow Complex Instructions</li> </ul> Source code in <code>src/distilabel/steps/tasks/evol_instruct/evol_complexity/generator.py</code> <pre><code>class EvolComplexityGenerator(EvolInstructGenerator):\n    \"\"\"EvolComplexity is a task that evolves instructions to make them more complex,\n    and it is based in the EvolInstruct task, but using slight different prompts, but the\n    exact same evolutionary approach.\n\n    Attributes:\n        num_instructions: The number of instructions to be generated.\n        generate_answers: Whether to generate answers for the instructions or not. Defaults\n            to `False`.\n        mutation_templates: The mutation templates to be used for the generation of the\n            instructions.\n        min_length: Defines the length (in bytes) that the generated instruction needs to\n            be higher than, to be considered valid. Defaults to `512`.\n        max_length: Defines the length (in bytes) that the generated instruction needs to\n            be lower than, to be considered valid. Defaults to `1024`.\n        seed: The seed to be set for `numpy` in order to randomly pick a mutation method.\n            Defaults to `42`.\n\n    Runtime parameters:\n        - `min_length`: Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid.\n        - `max_length`: Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid.\n        - `seed`: The number of evolutions to be run.\n\n    Input columns:\n        - instruction (`str`): The instruction to evolve.\n\n    Output columns:\n        - instruction (`str`): The evolved instruction.\n        - answer (`str`, optional): The answer to the instruction if `generate_answers=True`.\n        - model_name (`str`): The name of the LLM used to evolve the instructions.\n\n    References:\n        - [What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning](https://arxiv.org/abs/2312.15685)\n        - [WizardLM: Empowering Large Language Models to Follow Complex Instructions](https://arxiv.org/abs/2304.12244)\n    \"\"\"\n\n    mutation_templates: Dict[str, str] = GENERATION_MUTATION_TEMPLATES\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#evol-quality","title":"Evol Quality","text":""},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_quality.base.EvolQuality","title":"<code>EvolQuality</code>","text":"<p>             Bases: <code>Task</code></p> <p>The <code>EvolQuality</code> task is used to evolve the quality of the responses given a prompt, by generating a new response with a language model. This step implements the evolution quality task from the paper 'What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.</p> <p>Attributes:</p> Name Type Description <code>num_evolutions</code> <code>int</code> <p>The number of evolutions to be performed on the responses.</p> <code>store_evolutions</code> <code>bool</code> <p>Whether to store all the evolved responses or just the last one. Defaults to <code>False</code>.</p> <code>include_original_response</code> <code>bool</code> <p>Whether to include the original response within the evolved responses. Defaults to <code>False</code>.</p> <code>mutation_templates</code> <code>Dict[str, str]</code> <p>The mutation templates to be used to evolve the responses.</p> <code>seed</code> <code>RuntimeParameter[int]</code> <p>The seed to be set for <code>numpy</code> in order to randomly pick a mutation method. Defaults to <code>42</code>.</p> Runtime parameters <ul> <li><code>seed</code>: The seed to be set for <code>numpy</code> in order to randomly pick a mutation method.</li> </ul> Input columns <ul> <li>instruction (<code>str</code>): The instruction that was used to generate the <code>responses</code>.</li> <li>responses (<code>List[str]</code>): The responses to be scored. Each response forms a pair with the instruction.</li> </ul> Output columns <ul> <li>evolved_response (<code>str</code>): The evolved response if <code>store_evolutions=False</code>.</li> <li>evolved_responses (<code>List[str]</code>): The evolved responses if <code>store_evolutions=True</code>.</li> <li>model_name (<code>str</code>): The name of the LLM used to evolve the responses.</li> </ul> References <ul> <li><code>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</code></li> </ul> Source code in <code>src/distilabel/steps/tasks/evol_quality/base.py</code> <pre><code>class EvolQuality(Task):\n    \"\"\"The `EvolQuality` task is used to evolve the quality of the responses given a prompt,\n    by generating a new response with a language model. This step implements the evolution\n    quality task from the paper 'What Makes Good Data for Alignment? A Comprehensive Study of\n    Automatic Data Selection in Instruction Tuning'.\n\n    Attributes:\n        num_evolutions: The number of evolutions to be performed on the responses.\n        store_evolutions: Whether to store all the evolved responses or just the last one.\n            Defaults to `False`.\n        include_original_response: Whether to include the original response within the evolved\n            responses. Defaults to `False`.\n        mutation_templates: The mutation templates to be used to evolve the responses.\n        seed: The seed to be set for `numpy` in order to randomly pick a mutation method.\n            Defaults to `42`.\n\n    Runtime parameters:\n        - `seed`: The seed to be set for `numpy` in order to randomly pick a mutation method.\n\n    Input columns:\n        - instruction (`str`): The instruction that was used to generate the `responses`.\n        - responses (`List[str]`): The responses to be scored. Each response forms a pair with the instruction.\n\n    Output columns:\n        - evolved_response (`str`): The evolved response if `store_evolutions=False`.\n        - evolved_responses (`List[str]`): The evolved responses if `store_evolutions=True`.\n        - model_name (`str`): The name of the LLM used to evolve the responses.\n\n    References:\n        - [`What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning`](https://arxiv.org/abs/2312.15685)\n    \"\"\"\n\n    num_evolutions: int\n    store_evolutions: bool = False\n    include_original_response: bool = False\n    mutation_templates: Dict[str, str] = MUTATION_TEMPLATES\n\n    seed: RuntimeParameter[int] = Field(\n        default=42,\n        description=\"As `numpy` is being used in order to randomly pick a mutation method, then is nice to set a random seed.\",\n    )\n\n    @override\n    def model_post_init(self, __context: Any) -&gt; None:\n        \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n        This is useful if you want to do some validation that requires the entire model to be initialized.\n        \"\"\"\n        super().model_post_init(__context)\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input for the task are the `instruction` and `response`.\"\"\"\n        return [\"instruction\", \"response\"]\n\n    def format_input(self, input: str) -&gt; ChatType:  # type: ignore\n        \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n        is the first interaction from the user within a conversation. And the\n        `system_prompt` is added as the first message if it exists.\"\"\"\n        return [{\"role\": \"user\", \"content\": input}]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The output for the task are the `evolved_response/s` and the `model_name`.\"\"\"\n        # TODO: having to define a `model_name` column every time as the `Task.outputs` is not ideal,\n        # this could be handled always and the value could be included within the DAG validation when\n        # a `Task` is used, since all the `Task` subclasses will have an `llm` with a `model_name` attr.\n        _outputs = [\n            (\"evolved_response\" if not self.store_evolutions else \"evolved_responses\"),\n            \"model_name\",\n        ]\n\n        return _outputs\n\n    def format_output(self, responses: Union[str, List[str]]) -&gt; Dict[str, Any]:  # type: ignore\n        \"\"\"The output for the task is a dict with: `evolved_response` or `evolved_responses`,\n        depending whether the value is either `False` or `True` for `store_evolutions`, respectively;\n        and, finally, the `model_name`.\n\n        Args:\n            responses: The responses to be included within the output.\n\n        Returns:\n            if `store_evolutions=False` return {\"evolved_response\": ..., \"model_name\": ...};\n            if `store_evolutions=True` return {\"evolved_responses\": ..., \"model_name\": ...}.\n        \"\"\"\n        _output = {}\n\n        if not self.store_evolutions:\n            _output[\"evolved_response\"] = responses[-1]\n        else:\n            _output[\"evolved_responses\"] = responses\n\n        _output[\"model_name\"] = self.llm.model_name\n        return _output\n\n    @property\n    def mutation_templates_names(self) -&gt; List[str]:\n        \"\"\"Returns the names i.e. keys of the provided `mutation_templates` enum.\"\"\"\n        return list(self.mutation_templates.keys())\n\n    def _apply_random_mutation(self, instruction: str, response: str) -&gt; str:\n        \"\"\"Applies a random mutation from the ones provided as part of the `mutation_templates`\n        enum, and returns the provided instruction within the mutation prompt.\n\n        Args:\n            instruction: The instruction to be included within the mutation prompt.\n\n        Returns:\n            A random mutation prompt with the provided instruction.\n        \"\"\"\n        mutation = np.random.choice(self.mutation_templates_names)\n        return (\n            self.mutation_templates[mutation]\n            .replace(\"&lt;PROMPT&gt;\", instruction)\n            .replace(\"&lt;RESPONSE&gt;\", response[-1])\n        )\n\n    def _evolve_reponses(self, inputs: \"StepInput\") -&gt; List[List[str]]:\n        \"\"\"Evolves the instructions provided as part of the inputs of the task.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Returns:\n            A list where each item is a list with either the last evolved instruction if\n            `store_evolutions=False` or all the evolved instructions if `store_evolutions=True`.\n        \"\"\"\n        np.random.seed(self.seed)\n        instructions: List[List[str]] = [[input[\"instruction\"]] for input in inputs]\n        responses: List[List[str]] = [[input[\"response\"]] for input in inputs]\n\n        for iter_no in range(self.num_evolutions):\n            formatted_prompts = []\n            for instruction, response in zip(instructions, responses):\n                formatted_prompts.append(\n                    self._apply_random_mutation(instruction[-1], response[-1])\n                )\n\n            formatted_prompts = [\n                self.format_input(prompt) for prompt in formatted_prompts\n            ]\n\n            generated_responses = self.llm.generate(\n                formatted_prompts,\n                **self.llm.generation_kwargs,  # type: ignore\n            )\n\n            if self.store_evolutions:\n                responses = [\n                    response + [evolved_response[0]]\n                    for response, evolved_response in zip(\n                        responses, generated_responses\n                    )\n                ]\n            else:\n                responses = [\n                    [evolved_response[0]] for evolved_response in generated_responses\n                ]\n\n            self._logger.info(\n                f\"\ud83d\udd04 Ran iteration {iter_no} evolving {len(responses)} responses!\"\n            )\n\n        return responses\n\n    @override\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Returns:\n            A list of Python dictionaries with the outputs of the task.\n        \"\"\"\n\n        responses = self._evolve_reponses(inputs)\n\n        if self.store_evolutions:\n            # Remove the input instruction from the `evolved_responses` list\n            from_ = 1 if not self.include_original_response else 0\n            responses = [response[from_:] for response in responses]\n\n        for input, response in zip(inputs, responses):\n            input.update(self.format_output(response))\n        yield inputs\n\n        self._logger.info(f\"\ud83c\udf89 Finished evolving {len(responses)} instructions!\")\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_quality.base.EvolQuality.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input for the task are the <code>instruction</code> and <code>response</code>.</p>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_quality.base.EvolQuality.mutation_templates_names","title":"<code>mutation_templates_names: List[str]</code>  <code>property</code>","text":"<p>Returns the names i.e. keys of the provided <code>mutation_templates</code> enum.</p>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_quality.base.EvolQuality.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The output for the task are the <code>evolved_response/s</code> and the <code>model_name</code>.</p>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_quality.base.EvolQuality.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is formatted as a <code>ChatType</code> assuming that the instruction is the first interaction from the user within a conversation. And the <code>system_prompt</code> is added as the first message if it exists.</p> Source code in <code>src/distilabel/steps/tasks/evol_quality/base.py</code> <pre><code>def format_input(self, input: str) -&gt; ChatType:  # type: ignore\n    \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n    is the first interaction from the user within a conversation. And the\n    `system_prompt` is added as the first message if it exists.\"\"\"\n    return [{\"role\": \"user\", \"content\": input}]\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_quality.base.EvolQuality.format_output","title":"<code>format_output(responses)</code>","text":"<p>The output for the task is a dict with: <code>evolved_response</code> or <code>evolved_responses</code>, depending whether the value is either <code>False</code> or <code>True</code> for <code>store_evolutions</code>, respectively; and, finally, the <code>model_name</code>.</p> <p>Parameters:</p> Name Type Description Default <code>responses</code> <code>Union[str, List[str]]</code> <p>The responses to be included within the output.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>if <code>store_evolutions=False</code> return {\"evolved_response\": ..., \"model_name\": ...};</p> <code>Dict[str, Any]</code> <p>if <code>store_evolutions=True</code> return {\"evolved_responses\": ..., \"model_name\": ...}.</p> Source code in <code>src/distilabel/steps/tasks/evol_quality/base.py</code> <pre><code>def format_output(self, responses: Union[str, List[str]]) -&gt; Dict[str, Any]:  # type: ignore\n    \"\"\"The output for the task is a dict with: `evolved_response` or `evolved_responses`,\n    depending whether the value is either `False` or `True` for `store_evolutions`, respectively;\n    and, finally, the `model_name`.\n\n    Args:\n        responses: The responses to be included within the output.\n\n    Returns:\n        if `store_evolutions=False` return {\"evolved_response\": ..., \"model_name\": ...};\n        if `store_evolutions=True` return {\"evolved_responses\": ..., \"model_name\": ...}.\n    \"\"\"\n    _output = {}\n\n    if not self.store_evolutions:\n        _output[\"evolved_response\"] = responses[-1]\n    else:\n        _output[\"evolved_responses\"] = responses\n\n    _output[\"model_name\"] = self.llm.model_name\n    return _output\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_quality.base.EvolQuality.model_post_init","title":"<code>model_post_init(__context)</code>","text":"<p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>src/distilabel/steps/tasks/evol_quality/base.py</code> <pre><code>@override\ndef model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n    super().model_post_init(__context)\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.evol_quality.base.EvolQuality.process","title":"<code>process(inputs)</code>","text":"<p>Processes the inputs of the task and generates the outputs using the LLM.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>A list of Python dictionaries with the inputs of the task.</p> required <p>Returns:</p> Type Description <code>StepOutput</code> <p>A list of Python dictionaries with the outputs of the task.</p> Source code in <code>src/distilabel/steps/tasks/evol_quality/base.py</code> <pre><code>@override\ndef process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n    Args:\n        inputs: A list of Python dictionaries with the inputs of the task.\n\n    Returns:\n        A list of Python dictionaries with the outputs of the task.\n    \"\"\"\n\n    responses = self._evolve_reponses(inputs)\n\n    if self.store_evolutions:\n        # Remove the input instruction from the `evolved_responses` list\n        from_ = 1 if not self.include_original_response else 0\n        responses = [response[from_:] for response in responses]\n\n    for input, response in zip(inputs, responses):\n        input.update(self.format_output(response))\n    yield inputs\n\n    self._logger.info(f\"\ud83c\udf89 Finished evolving {len(responses)} instructions!\")\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#deita-scorers","title":"DEITA Scorers","text":""},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.complexity_scorer.ComplexityScorer","title":"<code>ComplexityScorer</code>","text":"<p>             Bases: <code>Task</code></p> <p>This task is used to rank a list of instructions based on their complexity. It's an implementation of the complexity score task from the paper 'What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.</p> <p>Attributes:</p> Name Type Description <code>_template</code> <code>Union[Template, None]</code> <p>The Jinja2 template used to format the input data.</p> Input columns <ul> <li>instructions (<code>List[str]</code>): The list of instructions to be scored.</li> </ul> Output columns <ul> <li>complexity_score (<code>List[float]</code>): The complexity score for each instruction.</li> </ul> References <ul> <li><code>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</code></li> </ul> Source code in <code>src/distilabel/steps/tasks/complexity_scorer.py</code> <pre><code>class ComplexityScorer(Task):\n    \"\"\"This task is used to rank a list of instructions based on their complexity. It's\n    an implementation of the complexity score task from the paper 'What Makes Good Data\n    for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.\n\n    Attributes:\n        _template: The Jinja2 template used to format the input data.\n\n    Input columns:\n        - instructions (`List[str]`): The list of instructions to be scored.\n\n    Output columns:\n        - complexity_score (`List[float]`): The complexity score for each instruction.\n\n    References:\n        - [`What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning`](https://arxiv.org/abs/2312.15685)\n    \"\"\"\n\n    _template: Union[Template, None] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        super().load()\n        self._template = Template(_COMPLEXITY_SCORER_TEMPLATE)\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        return [\"instructions\"]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        return [\"scores\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n        return [{\"role\": \"user\", \"content\": self._template.render(**input)}]  # type: ignore\n\n    def format_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, Any]:\n        if output is None:\n            return {\"scores\": [None] * len(input[\"instructions\"])}\n\n        scores = []\n        score_lines = output.split(\"\\n\")\n        for i, line in enumerate(score_lines):\n            match = _PARSE_SCORE_LINE_REGEX.match(line)\n            score = float(match.group(1)) if match else None\n            scores.append(score)\n            if i == len(input[\"instructions\"]) - 1:\n                break\n\n        return {\"scores\": scores}\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.quality_scorer.QualityScorer","title":"<code>QualityScorer</code>","text":"<p>             Bases: <code>Task</code></p> <p>QualityScorer is a pre-defined task that defines the <code>instruction</code> as the input and <code>score</code> as the output. This task is used to rate the quality of instructions and responses. It's an implementation of the quality score task from the paper 'What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'. The task follows the same scheme as the Complexity Scorer, but the instruction-response pairs are scored in terms of quality, obtaining a quality score for each instruction.</p> <p>Attributes:</p> Name Type Description <code>_template</code> <code>Union[Template, None]</code> <p>a Jinja2 template used to format the input for the LLM.</p> Input columns <ul> <li>instruction (<code>str</code>): The instruction that was used to generate the <code>responses</code>.</li> <li>responses (<code>List[str]</code>): The responses to be scored. Each response forms a pair with the instruction.</li> </ul> Output columns <ul> <li>quality_score (<code>List[float]</code>): The quality score for each instruction.</li> </ul> References <ul> <li><code>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</code></li> </ul> Source code in <code>src/distilabel/steps/tasks/quality_scorer.py</code> <pre><code>class QualityScorer(Task):\n    \"\"\"QualityScorer is a pre-defined task that defines the `instruction` as the input\n    and `score` as the output. This task is used to rate the quality of instructions and responses.\n    It's an implementation of the quality score task from the paper 'What Makes Good Data\n    for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.\n    The task follows the same scheme as the Complexity Scorer, but the instruction-response pairs\n    are scored in terms of quality, obtaining a quality score for each instruction.\n\n    Attributes:\n        _template: a Jinja2 template used to format the input for the LLM.\n\n    Input columns:\n        - instruction (`str`): The instruction that was used to generate the `responses`.\n        - responses (`List[str]`): The responses to be scored. Each response forms a pair with the instruction.\n\n    Output columns:\n        - quality_score (`List[float]`): The quality score for each instruction.\n\n    References:\n        - [`What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning`](https://arxiv.org/abs/2312.15685)\n    \"\"\"\n\n    _template: Union[Template, None] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        super().load()\n        self._template = Template(_QUALITY_SCORER_TEMPLATE)\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input for the task are `instruction` and `responses`.\"\"\"\n        return [\"instruction\", \"responses\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; ChatType:  # type: ignore\n        \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n        is the first interaction from the user within a conversation.\"\"\"\n        return [{\"role\": \"user\", \"content\": self._template.render(**input)}]  # type: ignore\n\n    @property\n    def outputs(self):\n        \"\"\"The output for the task is a list of `quality_scores` containing the quality score for each\n        response in `responses`.\"\"\"\n        return [\"scores\"]\n\n    def format_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, Any]:\n        \"\"\"The output is formatted as a list with the score of each instruction-response pair.\n\n        Args:\n            output: the raw output of the LLM.\n            input: the input to the task. Used for obtaining the number of responses.\n\n        Returns:\n            A dict with containing the scores for each instruction-response pair.\n        \"\"\"\n\n        if output is None:\n            return {self.outputs[0]: [None] * len(input[\"responses\"])}\n\n        scores = []\n        score_lines = output.split(\"\\n\")\n\n        for i, line in enumerate(score_lines):\n            match = _PARSE_SCORE_LINE_REGEX.match(line)\n            score = float(match.group(1)) if match else None\n            scores.append(score)\n            if i == len(input[\"responses\"]) - 1:\n                break\n\n        return {self.outputs[0]: scores}\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.quality_scorer.QualityScorer.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input for the task are <code>instruction</code> and <code>responses</code>.</p>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.quality_scorer.QualityScorer.outputs","title":"<code>outputs</code>  <code>property</code>","text":"<p>The output for the task is a list of <code>quality_scores</code> containing the quality score for each response in <code>responses</code>.</p>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.quality_scorer.QualityScorer.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is formatted as a <code>ChatType</code> assuming that the instruction is the first interaction from the user within a conversation.</p> Source code in <code>src/distilabel/steps/tasks/quality_scorer.py</code> <pre><code>def format_input(self, input: Dict[str, Any]) -&gt; ChatType:  # type: ignore\n    \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n    is the first interaction from the user within a conversation.\"\"\"\n    return [{\"role\": \"user\", \"content\": self._template.render(**input)}]  # type: ignore\n</code></pre>"},{"location":"api/steps/tasks/text_generation/#distilabel.steps.tasks.quality_scorer.QualityScorer.format_output","title":"<code>format_output(output, input)</code>","text":"<p>The output is formatted as a list with the score of each instruction-response pair.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>Union[str, None]</code> <p>the raw output of the LLM.</p> required <code>input</code> <code>Dict[str, Any]</code> <p>the input to the task. Used for obtaining the number of responses.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dict with containing the scores for each instruction-response pair.</p> Source code in <code>src/distilabel/steps/tasks/quality_scorer.py</code> <pre><code>def format_output(\n    self, output: Union[str, None], input: Dict[str, Any]\n) -&gt; Dict[str, Any]:\n    \"\"\"The output is formatted as a list with the score of each instruction-response pair.\n\n    Args:\n        output: the raw output of the LLM.\n        input: the input to the task. Used for obtaining the number of responses.\n\n    Returns:\n        A dict with containing the scores for each instruction-response pair.\n    \"\"\"\n\n    if output is None:\n        return {self.outputs[0]: [None] * len(input[\"responses\"])}\n\n    scores = []\n    score_lines = output.split(\"\\n\")\n\n    for i, line in enumerate(score_lines):\n        match = _PARSE_SCORE_LINE_REGEX.match(line)\n        score = float(match.group(1)) if match else None\n        scores.append(score)\n        if i == len(input[\"responses\"]) - 1:\n            break\n\n    return {self.outputs[0]: scores}\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>distilabel<ul> <li>cli<ul> <li>app</li> <li>pipeline<ul> <li>app</li> <li>utils</li> </ul> </li> </ul> </li> <li>distiset</li> <li>llms<ul> <li>anthropic</li> <li>anyscale</li> <li>azure</li> <li>base</li> <li>chat_templates</li> <li>cohere</li> <li>huggingface<ul> <li>inference_endpoints</li> <li>transformers</li> </ul> </li> <li>litellm</li> <li>llamacpp</li> <li>mistral</li> <li>mixins</li> <li>ollama</li> <li>openai</li> <li>together</li> <li>typing</li> <li>vertexai</li> <li>vllm</li> </ul> </li> <li>mixins<ul> <li>runtime_parameters</li> </ul> </li> <li>pipeline<ul> <li>_dag</li> <li>base</li> <li>local</li> <li>utils</li> </ul> </li> <li>steps<ul> <li>argilla<ul> <li>base</li> <li>preference</li> <li>text_generation</li> </ul> </li> <li>base</li> <li>combine</li> <li>conversation</li> <li>decorator</li> <li>deita</li> <li>expand</li> <li>generators<ul> <li>data</li> <li>huggingface</li> </ul> </li> <li>globals<ul> <li>huggingface</li> </ul> </li> <li>keep</li> <li>tasks<ul> <li>base</li> <li>complexity_scorer</li> <li>evol_instruct<ul> <li>base</li> <li>evol_complexity<ul> <li>base</li> <li>generator</li> <li>utils</li> </ul> </li> <li>generator</li> <li>utils</li> </ul> </li> <li>evol_quality<ul> <li>base</li> <li>utils</li> </ul> </li> <li>generate_embeddings</li> <li>instruction_backtranslation</li> <li>pair_rm</li> <li>quality_scorer</li> <li>self_instruct</li> <li>text_generation</li> <li>typing</li> <li>ultrafeedback</li> </ul> </li> <li>typing</li> </ul> </li> <li>utils<ul> <li>card<ul> <li>dataset_card</li> </ul> </li> <li>chat</li> <li>dicts</li> <li>docstring</li> <li>files</li> <li>itertools</li> <li>lists</li> <li>logging</li> <li>notebook</li> <li>serialization</li> <li>typing_</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/distilabel/","title":"Index","text":""},{"location":"reference/distilabel/distiset/","title":"Distiset","text":""},{"location":"reference/distilabel/distiset/#distilabel.distiset.Distiset","title":"<code>Distiset</code>","text":"<p>             Bases: <code>dict</code></p> <p>Convenient wrapper around <code>datasets.Dataset</code> to push to the Hugging Face Hub.</p> <p>It's a dictionary where the keys correspond to the different leaf_steps from the internal <code>DAG</code> and the values are <code>datasets.Dataset</code>.</p> <p>Attributes:</p> Name Type Description <code>pipeline_path</code> <code>Optional[Path]</code> <p>Optional path to the pipeline.yaml file that generated the dataset.</p> Source code in <code>src/distilabel/distiset.py</code> <pre><code>class Distiset(dict):\n    \"\"\"Convenient wrapper around `datasets.Dataset` to push to the Hugging Face Hub.\n\n    It's a dictionary where the keys correspond to the different leaf_steps from the internal\n    `DAG` and the values are `datasets.Dataset`.\n\n    Attributes:\n        pipeline_path: Optional path to the pipeline.yaml file that generated the dataset.\n    \"\"\"\n\n    pipeline_path: Optional[Path] = None\n\n    def push_to_hub(\n        self,\n        repo_id: str,\n        private: bool = False,\n        token: Optional[str] = None,\n        generate_card: bool = True,\n    ) -&gt; None:\n        \"\"\"Pushes the `Distiset` to the Hugging Face Hub, each dataset will be pushed as a different configuration\n        corresponding to the leaf step that generated it.\n\n        Args:\n            repo_id:\n                The ID of the repository to push to in the following format: `&lt;user&gt;/&lt;dataset_name&gt;` or\n                `&lt;org&gt;/&lt;dataset_name&gt;`. Also accepts `&lt;dataset_name&gt;`, which will default to the namespace\n                of the logged-in user.\n            private:\n                Whether the dataset repository should be set to private or not. Only affects repository creation:\n                a repository that already exists will not be affected by that parameter.\n            token:\n                An optional authentication token for the Hugging Face Hub. If no token is passed, will default\n                to the token saved locally when logging in with `huggingface-cli login`. Will raise an error\n                if no token is passed and the user is not logged-in.\n            generate_card:\n                Whether to generate a dataset card or not. Defaults to True.\n        \"\"\"\n        for name, dataset in self.items():\n            dataset.push_to_hub(\n                repo_id=repo_id,\n                config_name=name,\n                private=private,\n                token=token,\n            )\n\n        if generate_card:\n            self._generate_card(repo_id, token)\n\n    def _generate_card(self, repo_id: str, token: Optional[str]) -&gt; None:\n        \"\"\"Generates a dataset card and pushes it to the Hugging Face Hub, and\n        if the `pipeline.yaml` path is available in the `Distiset`, uploads that\n        to the same repository.\n\n        Args:\n            repo_id: The ID of the repository to push to, from the `push_to_hub` method.\n            token: The token to authenticate with the Hugging Face Hub, from the `push_to_hub` method.\n        \"\"\"\n        sample_records = {}\n        for name, dataset in self.items():\n            sample_records[name] = (\n                dataset[0] if not isinstance(dataset, dict) else dataset[\"train\"][0]\n            )\n\n        card = DistilabelDatasetCard.from_template(\n            card_data=DatasetCardData(\n                config_names=sorted(self.keys()),\n                size_categories=size_categories_parser(\n                    max(len(dataset) for dataset in self.values())\n                ),\n                tags=[\"synthetic\", \"distilabel\", \"rlaif\"],\n            ),\n            repo_id=repo_id,\n            sample_records=sample_records,\n        )\n        card.push_to_hub(\n            repo_id,\n            repo_type=\"dataset\",\n            token=token,\n        )\n        if self.pipeline_path:\n            # If the pipeline.yaml is available, upload it to the hub as well.\n            HfApi().upload_file(\n                path_or_fileobj=self.pipeline_path,\n                path_in_repo=\"pipeline.yaml\",\n                repo_id=repo_id,\n                repo_type=\"dataset\",\n                token=token,\n            )\n\n    def train_test_split(\n        self,\n        train_size: float,\n        shuffle: bool = True,\n        seed: Optional[int] = None,\n    ) -&gt; \"Distiset\":\n        \"\"\"Return a `Distiset` whose values will be a `datasets.DatasetDict` with two random train and test subsets.\n        Splits are created from the dataset according to `train_size` and `shuffle`.\n\n        Args:\n            train_size:\n                Float between `0.0` and `1.0` representing the proportion of the dataset to include in the test split.\n                It will be applied to all the datasets in the `Distiset`.\n            shuffle: Whether or not to shuffle the data before splitting\n            seed:\n                A seed to initialize the default BitGenerator, passed to the underlying method.\n\n        Returns:\n            The `Distiset` with the train-test split applied to all the datasets.\n        \"\"\"\n        assert 0 &lt; train_size &lt; 1, \"train_size must be a float between 0 and 1\"\n        for name, dataset in self.items():\n            self[name] = dataset.train_test_split(\n                train_size=train_size,\n                shuffle=shuffle,\n                seed=seed,\n            )\n        return self\n\n    def __repr__(self):\n        # Copy from `datasets.DatasetDict.__repr__`.\n        repr = \"\\n\".join([f\"{k}: {v}\" for k, v in self.items()])\n        repr = re.sub(r\"^\", \" \" * 4, repr, count=0, flags=re.M)\n        return f\"Distiset({{\\n{repr}\\n}})\"\n</code></pre>"},{"location":"reference/distilabel/distiset/#distilabel.distiset.Distiset.push_to_hub","title":"<code>push_to_hub(repo_id, private=False, token=None, generate_card=True)</code>","text":"<p>Pushes the <code>Distiset</code> to the Hugging Face Hub, each dataset will be pushed as a different configuration corresponding to the leaf step that generated it.</p> <p>Parameters:</p> Name Type Description Default <code>repo_id</code> <code>str</code> <p>The ID of the repository to push to in the following format: <code>&lt;user&gt;/&lt;dataset_name&gt;</code> or <code>&lt;org&gt;/&lt;dataset_name&gt;</code>. Also accepts <code>&lt;dataset_name&gt;</code>, which will default to the namespace of the logged-in user.</p> required <code>private</code> <code>bool</code> <p>Whether the dataset repository should be set to private or not. Only affects repository creation: a repository that already exists will not be affected by that parameter.</p> <code>False</code> <code>token</code> <code>Optional[str]</code> <p>An optional authentication token for the Hugging Face Hub. If no token is passed, will default to the token saved locally when logging in with <code>huggingface-cli login</code>. Will raise an error if no token is passed and the user is not logged-in.</p> <code>None</code> <code>generate_card</code> <code>bool</code> <p>Whether to generate a dataset card or not. Defaults to True.</p> <code>True</code> Source code in <code>src/distilabel/distiset.py</code> <pre><code>def push_to_hub(\n    self,\n    repo_id: str,\n    private: bool = False,\n    token: Optional[str] = None,\n    generate_card: bool = True,\n) -&gt; None:\n    \"\"\"Pushes the `Distiset` to the Hugging Face Hub, each dataset will be pushed as a different configuration\n    corresponding to the leaf step that generated it.\n\n    Args:\n        repo_id:\n            The ID of the repository to push to in the following format: `&lt;user&gt;/&lt;dataset_name&gt;` or\n            `&lt;org&gt;/&lt;dataset_name&gt;`. Also accepts `&lt;dataset_name&gt;`, which will default to the namespace\n            of the logged-in user.\n        private:\n            Whether the dataset repository should be set to private or not. Only affects repository creation:\n            a repository that already exists will not be affected by that parameter.\n        token:\n            An optional authentication token for the Hugging Face Hub. If no token is passed, will default\n            to the token saved locally when logging in with `huggingface-cli login`. Will raise an error\n            if no token is passed and the user is not logged-in.\n        generate_card:\n            Whether to generate a dataset card or not. Defaults to True.\n    \"\"\"\n    for name, dataset in self.items():\n        dataset.push_to_hub(\n            repo_id=repo_id,\n            config_name=name,\n            private=private,\n            token=token,\n        )\n\n    if generate_card:\n        self._generate_card(repo_id, token)\n</code></pre>"},{"location":"reference/distilabel/distiset/#distilabel.distiset.Distiset.train_test_split","title":"<code>train_test_split(train_size, shuffle=True, seed=None)</code>","text":"<p>Return a <code>Distiset</code> whose values will be a <code>datasets.DatasetDict</code> with two random train and test subsets. Splits are created from the dataset according to <code>train_size</code> and <code>shuffle</code>.</p> <p>Parameters:</p> Name Type Description Default <code>train_size</code> <code>float</code> <p>Float between <code>0.0</code> and <code>1.0</code> representing the proportion of the dataset to include in the test split. It will be applied to all the datasets in the <code>Distiset</code>.</p> required <code>shuffle</code> <code>bool</code> <p>Whether or not to shuffle the data before splitting</p> <code>True</code> <code>seed</code> <code>Optional[int]</code> <p>A seed to initialize the default BitGenerator, passed to the underlying method.</p> <code>None</code> <p>Returns:</p> Type Description <code>Distiset</code> <p>The <code>Distiset</code> with the train-test split applied to all the datasets.</p> Source code in <code>src/distilabel/distiset.py</code> <pre><code>def train_test_split(\n    self,\n    train_size: float,\n    shuffle: bool = True,\n    seed: Optional[int] = None,\n) -&gt; \"Distiset\":\n    \"\"\"Return a `Distiset` whose values will be a `datasets.DatasetDict` with two random train and test subsets.\n    Splits are created from the dataset according to `train_size` and `shuffle`.\n\n    Args:\n        train_size:\n            Float between `0.0` and `1.0` representing the proportion of the dataset to include in the test split.\n            It will be applied to all the datasets in the `Distiset`.\n        shuffle: Whether or not to shuffle the data before splitting\n        seed:\n            A seed to initialize the default BitGenerator, passed to the underlying method.\n\n    Returns:\n        The `Distiset` with the train-test split applied to all the datasets.\n    \"\"\"\n    assert 0 &lt; train_size &lt; 1, \"train_size must be a float between 0 and 1\"\n    for name, dataset in self.items():\n        self[name] = dataset.train_test_split(\n            train_size=train_size,\n            shuffle=shuffle,\n            seed=seed,\n        )\n    return self\n</code></pre>"},{"location":"reference/distilabel/distiset/#distilabel.distiset.create_distiset","title":"<code>create_distiset(data_dir, pipeline_path=None)</code>","text":"<p>Creates a <code>Distiset</code> from the buffer folder.</p> <p>Parameters:</p> Name Type Description Default <code>data_dir</code> <code>Path</code> <p>Folder where the data buffers were written by the <code>_WriteBuffer</code>. It should correspond to <code>CacheLocation.data</code>.</p> required <code>pipeline_path</code> <code>Optional[Path]</code> <p>Optional path to the pipeline.yaml file that generated the dataset. Internally this will be passed to the <code>Distiset</code> object on creation to allow uploading the <code>pipeline.yaml</code> file to the repo upon <code>Distiset.push_to_hub</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Distiset</code> <p>The dataset created from the buffer folder, where the different leaf steps will</p> <code>Distiset</code> <p>correspond to different configurations of the dataset.</p> Source code in <code>src/distilabel/distiset.py</code> <pre><code>def create_distiset(data_dir: Path, pipeline_path: Optional[Path] = None) -&gt; Distiset:\n    \"\"\"Creates a `Distiset` from the buffer folder.\n\n    Args:\n        data_dir: Folder where the data buffers were written by the `_WriteBuffer`.\n            It should correspond to `CacheLocation.data`.\n        pipeline_path: Optional path to the pipeline.yaml file that generated the dataset.\n            Internally this will be passed to the `Distiset` object on creation to allow\n            uploading the `pipeline.yaml` file to the repo upon `Distiset.push_to_hub`.\n\n    Returns:\n        The dataset created from the buffer folder, where the different leaf steps will\n        correspond to different configurations of the dataset.\n    \"\"\"\n    logger = logging.getLogger(\"distilabel.distiset\")\n\n    distiset = Distiset()\n    for file in data_dir.iterdir():\n        if file.is_file():\n            continue\n\n        try:\n            files = [str(file) for file in list_files_in_dir(file)]\n            if files:\n                distiset[file.stem] = load_dataset(\n                    \"parquet\", name=file.stem, data_files={\"train\": files}\n                )\n            else:\n                logger.warning(\n                    f\"No output files for step '{file.stem}', can't create a dataset.\"\n                    \" Did the step produce any data?\"\n                )\n        except ArrowInvalid:\n            logger.warning(f\"\u274c Failed to load the subset from '{file}' directory.\")\n            continue\n\n    if pipeline_path:\n        distiset.pipeline_path = pipeline_path\n\n    return distiset\n</code></pre>"},{"location":"reference/distilabel/cli/","title":"Index","text":""},{"location":"reference/distilabel/cli/app/","title":"App","text":""},{"location":"reference/distilabel/cli/pipeline/","title":"Index","text":""},{"location":"reference/distilabel/cli/pipeline/app/","title":"App","text":""},{"location":"reference/distilabel/cli/pipeline/utils/","title":"Utils","text":""},{"location":"reference/distilabel/cli/pipeline/utils/#distilabel.cli.pipeline.utils.display_pipeline_information","title":"<code>display_pipeline_information(pipeline)</code>","text":"<p>Displays the pipeline information to the console.</p> <p>Parameters:</p> Name Type Description Default <code>pipeline</code> <code>BasePipeline</code> <p>The pipeline.</p> required Source code in <code>src/distilabel/cli/pipeline/utils.py</code> <pre><code>def display_pipeline_information(pipeline: \"BasePipeline\") -&gt; None:\n    \"\"\"Displays the pipeline information to the console.\n\n    Args:\n        pipeline: The pipeline.\n    \"\"\"\n    from rich.console import Console\n\n    Console().print(_build_pipeline_panel(pipeline))\n</code></pre>"},{"location":"reference/distilabel/cli/pipeline/utils/#distilabel.cli.pipeline.utils.get_config_from_url","title":"<code>get_config_from_url(url)</code>","text":"<p>Loads the pipeline configuration from a URL pointing to a JSON or YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the pipeline configuration file.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The pipeline configuration as a dictionary.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file format is not supported.</p> Source code in <code>src/distilabel/cli/pipeline/utils.py</code> <pre><code>def get_config_from_url(url: str) -&gt; Dict[str, Any]:\n    \"\"\"Loads the pipeline configuration from a URL pointing to a JSON or YAML file.\n\n    Args:\n        url: The URL pointing to the pipeline configuration file.\n\n    Returns:\n        The pipeline configuration as a dictionary.\n\n    Raises:\n        ValueError: If the file format is not supported.\n    \"\"\"\n    if not url.endswith((\".json\", \".yaml\", \".yml\")):\n        raise ValueError(\n            f\"Unsupported file format for '{url}'. Only JSON and YAML are supported\"\n        )\n    if \"huggingface.co\" in url and \"HF_TOKEN\" in os.environ:\n        headers = {\"Authorization\": f\"Bearer {os.environ['HF_TOKEN']}\"}\n    else:\n        headers = None\n    response = requests.get(url, headers=headers)\n    response.raise_for_status()\n\n    if url.endswith((\".yaml\", \".yml\")):\n        content = response.content.decode(\"utf-8\")\n        return yaml.safe_load(content)\n\n    return response.json()\n</code></pre>"},{"location":"reference/distilabel/cli/pipeline/utils/#distilabel.cli.pipeline.utils.get_pipeline","title":"<code>get_pipeline(config)</code>","text":"<p>Get a pipeline from a configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>The path or URL to the pipeline configuration file.</p> required <p>Returns:</p> Type Description <code>BasePipeline</code> <p>The pipeline.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file format is not supported.</p> <code>FileNotFoundError</code> <p>If the configuration file does not exist.</p> Source code in <code>src/distilabel/cli/pipeline/utils.py</code> <pre><code>def get_pipeline(config: str) -&gt; \"BasePipeline\":\n    \"\"\"Get a pipeline from a configuration file.\n\n    Args:\n        config: The path or URL to the pipeline configuration file.\n\n    Returns:\n        The pipeline.\n\n    Raises:\n        ValueError: If the file format is not supported.\n        FileNotFoundError: If the configuration file does not exist.\n    \"\"\"\n    if valid_http_url(config):\n        return Pipeline.from_dict(get_config_from_url(config))\n\n    if Path(config).is_file():\n        return Pipeline.from_file(config)\n\n    raise FileNotFoundError(f\"Config file '{config}' does not exist.\")\n</code></pre>"},{"location":"reference/distilabel/cli/pipeline/utils/#distilabel.cli.pipeline.utils.parse_runtime_parameters","title":"<code>parse_runtime_parameters(params)</code>","text":"<p>Parses the runtime parameters from the CLI format to the format expected by the <code>Pipeline.run</code> method. The CLI format is a list of tuples, where the first element is a list of keys and the second element is the value.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>List[Tuple[List[str], str]]</code> <p>A list of tuples, where the first element is a list of keys and the second element is the value.</p> required <p>Returns:</p> Type Description <code>Dict[str, Dict[str, Any]]</code> <p>A dictionary with the runtime parameters in the format expected by the</p> <code>Dict[str, Dict[str, Any]]</code> <p><code>Pipeline.run</code> method.</p> Source code in <code>src/distilabel/cli/pipeline/utils.py</code> <pre><code>def parse_runtime_parameters(\n    params: List[Tuple[List[str], str]],\n) -&gt; Dict[str, Dict[str, Any]]:\n    \"\"\"Parses the runtime parameters from the CLI format to the format expected by the\n    `Pipeline.run` method. The CLI format is a list of tuples, where the first element is\n    a list of keys and the second element is the value.\n\n    Args:\n        params: A list of tuples, where the first element is a list of keys and the\n            second element is the value.\n\n    Returns:\n        A dictionary with the runtime parameters in the format expected by the\n        `Pipeline.run` method.\n    \"\"\"\n    runtime_params = {}\n    for keys, value in params:\n        current = runtime_params\n        for i, key in enumerate(keys):\n            if i == len(keys) - 1:\n                current[key] = value\n            else:\n                current = current.setdefault(key, {})\n    return runtime_params\n</code></pre>"},{"location":"reference/distilabel/cli/pipeline/utils/#distilabel.cli.pipeline.utils.valid_http_url","title":"<code>valid_http_url(url)</code>","text":"<p>Check if the URL is a valid HTTP URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code>, if the URL is a valid HTTP URL. <code>False</code>, otherwise.</p> Source code in <code>src/distilabel/cli/pipeline/utils.py</code> <pre><code>def valid_http_url(url: str) -&gt; bool:\n    \"\"\"Check if the URL is a valid HTTP URL.\n\n    Args:\n        url: The URL to check.\n\n    Returns:\n        `True`, if the URL is a valid HTTP URL. `False`, otherwise.\n    \"\"\"\n    try:\n        TypeAdapter(HttpUrl).validate_python(url)  # type: ignore\n    except ValidationError:\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/distilabel/llms/","title":"Index","text":""},{"location":"reference/distilabel/llms/#distilabel.llms.AnthropicLLM","title":"<code>AnthropicLLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>Anthropic LLM implementation running the Async API client.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the name of the model to use for the LLM e.g. \"claude-3-opus-20240229\", \"claude-3-sonnet-20240229\", etc. Available models can be checked here: Anthropic: Models overview.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Anthropic API. If not provided, it will be read from <code>ANTHROPIC_API_KEY</code> environment variable.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the Anthropic API. Defaults to <code>None</code> which means that <code>https://api.anthropic.com</code> will be used internally.</p> <code>timeout</code> <code>RuntimeParameter[float]</code> <p>the maximum time in seconds to wait for a response. Defaults to <code>600.0</code>.</p> <code>max_retries</code> <code>RuntimeParameter[int]</code> <p>The maximum number of times to retry the request before failing. Defaults to <code>6</code>.</p> <code>http_client</code> <code>Optional[AsyncClient]</code> <p>if provided, an alternative HTTP client to use for calling Anthropic API. Defaults to <code>None</code>.</p> <code>_api_key_env_var</code> <code>str</code> <p>the name of the environment variable to use for the API key. It is meant to be used internally.</p> <code>_aclient</code> <code>Optional[AsyncAnthropic]</code> <p>the <code>AsyncAnthropic</code> client to use for the Anthropic API. It is meant to be used internally. Set in the <code>load</code> method.</p> Runtime parameters <ul> <li><code>api_key</code>: the API key to authenticate the requests to the Anthropic API. If not     provided, it will be read from <code>ANTHROPIC_API_KEY</code> environment variable.</li> <li><code>base_url</code>: the base URL to use for the Anthropic API. Defaults to <code>\"https://api.anthropic.com\"</code>.</li> <li><code>timeout</code>: the maximum time in seconds to wait for a response. Defaults to <code>600.0</code>.</li> <li><code>max_retries</code>: the maximum number of times to retry the request before failing.     Defaults to <code>6</code>.</li> </ul> Source code in <code>src/distilabel/llms/anthropic.py</code> <pre><code>class AnthropicLLM(AsyncLLM):\n    \"\"\"Anthropic LLM implementation running the Async API client.\n\n    Attributes:\n        model: the name of the model to use for the LLM e.g. \"claude-3-opus-20240229\",\n            \"claude-3-sonnet-20240229\", etc. Available models can be checked here:\n            [Anthropic: Models overview](https://docs.anthropic.com/claude/docs/models-overview).\n        api_key: the API key to authenticate the requests to the Anthropic API. If not provided,\n            it will be read from `ANTHROPIC_API_KEY` environment variable.\n        base_url: the base URL to use for the Anthropic API. Defaults to `None` which means\n            that `https://api.anthropic.com` will be used internally.\n        timeout: the maximum time in seconds to wait for a response. Defaults to `600.0`.\n        max_retries: The maximum number of times to retry the request before failing. Defaults\n            to `6`.\n        http_client: if provided, an alternative HTTP client to use for calling Anthropic\n            API. Defaults to `None`.\n        _api_key_env_var: the name of the environment variable to use for the API key. It\n            is meant to be used internally.\n        _aclient: the `AsyncAnthropic` client to use for the Anthropic API. It is meant\n            to be used internally. Set in the `load` method.\n\n    Runtime parameters:\n        - `api_key`: the API key to authenticate the requests to the Anthropic API. If not\n            provided, it will be read from `ANTHROPIC_API_KEY` environment variable.\n        - `base_url`: the base URL to use for the Anthropic API. Defaults to `\"https://api.anthropic.com\"`.\n        - `timeout`: the maximum time in seconds to wait for a response. Defaults to `600.0`.\n        - `max_retries`: the maximum number of times to retry the request before failing.\n            Defaults to `6`.\n    \"\"\"\n\n    model: str\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(\n            \"ANTHROPIC_BASE_URL\", \"https://api.anthropic.com\"\n        ),\n        description=\"The base URL to use for the Anthropic API.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_ANTHROPIC_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Anthropic API.\",\n    )\n    timeout: RuntimeParameter[float] = Field(\n        default=600.0,\n        description=\"The maximum time in seconds to wait for a response from the API.\",\n    )\n    max_retries: RuntimeParameter[int] = Field(\n        default=6,\n        description=\"The maximum number of times to retry the request to the API before\"\n        \" failing.\",\n    )\n    http_client: Optional[AsyncClient] = Field(default=None, exclude=True)\n\n    _api_key_env_var: str = PrivateAttr(default=_ANTHROPIC_API_KEY_ENV_VAR_NAME)\n    _aclient: Optional[\"AsyncAnthropic\"] = PrivateAttr(...)\n\n    def _check_model_exists(self) -&gt; None:\n        \"\"\"Checks if the specified model exists in the available models.\"\"\"\n        from anthropic import AsyncAnthropic\n\n        annotation = get_type_hints(AsyncAnthropic().messages.create).get(\"model\", None)\n        models = [\n            value\n            for type_ in get_args(annotation)\n            if get_origin(type_) is Literal\n            for value in get_args(type_)\n        ]\n\n        if self.model not in models:\n            raise ValueError(\n                f\"Model {self.model} does not exist among available models. \"\n                f\"The available models are {', '.join(models)}\"\n            )\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `AsyncAnthropic` client to use the Anthropic async API.\"\"\"\n        super().load()\n\n        try:\n            from anthropic import AsyncAnthropic\n        except ImportError as ie:\n            raise ImportError(\n                \"Anthropic Python client is not installed. Please install it using\"\n                \" `pip install anthropic`.\"\n            ) from ie\n\n        if self.api_key is None:\n            raise ValueError(\n                f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n                f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n            )\n\n        self._check_model_exists()\n\n        self._aclient = AsyncAnthropic(\n            api_key=self.api_key.get_secret_value(),\n            base_url=self.base_url,\n            timeout=self.timeout,\n            http_client=self.http_client,\n            max_retries=self.max_retries,\n        )\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        max_tokens: int = 128,\n        stop_sequences: Union[List[str], None] = None,\n        temperature: float = 1.0,\n        top_p: Union[float, None] = None,\n        top_k: Union[int, None] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates a response asynchronously, using the [Anthropic Async API definition](https://github.com/anthropics/anthropic-sdk-python).\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            max_tokens: the maximum number of new tokens that the model will generate. Defaults to `128`.\n            stop_sequences: custom text sequences that will cause the model to stop generating. Defaults to `NOT_GIVEN`.\n            temperature: the temperature to use for the generation. Set only if top_p is None. Defaults to `1.0`.\n            top_p: the top-p value to use for the generation. Defaults to `NOT_GIVEN`.\n            top_k: the top-k value to use for the generation. Defaults to `NOT_GIVEN`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        from anthropic._types import NOT_GIVEN\n\n        completion = await self._aclient.messages.create(\n            model=self.model,\n            system=(\n                input.pop(0)[\"content\"]\n                if input and input[0][\"role\"] == \"system\"\n                else NOT_GIVEN\n            ),\n            messages=input,\n            max_tokens=max_tokens,\n            stream=False,\n            stop_sequences=NOT_GIVEN if stop_sequences is None else stop_sequences,\n            temperature=temperature,\n            top_p=NOT_GIVEN if top_p is None else top_p,\n            top_k=NOT_GIVEN if top_k is None else top_k,\n        )\n        generations = []\n        if (content := completion.content[0].text) is None:\n            self._logger.warning(\n                f\"Received no response using Anthropic client (model: '{self.model}').\"\n                f\" Finish reason was: {completion.stop_reason}\"\n            )\n        generations.append(content)\n        return generations\n\n    # TODO: remove this function once Anthropic client allows `n` parameter\n    @override\n    def generate(\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        **kwargs: Any,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Method to generate a list of responses asynchronously, returning the output\n        synchronously awaiting for the response of each input sent to `agenerate`.\n        \"\"\"\n\n        async def agenerate(\n            inputs: List[\"ChatType\"], **kwargs: Any\n        ) -&gt; \"GenerateOutput\":\n            \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n            tasks = [\n                asyncio.create_task(self.agenerate(input=input, **kwargs))\n                for input in inputs\n                for _ in range(num_generations)\n            ]\n            return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n        outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n        return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.AnthropicLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/#distilabel.llms.AnthropicLLM.agenerate","title":"<code>agenerate(input, max_tokens=128, stop_sequences=None, temperature=1.0, top_p=None, top_k=None)</code>  <code>async</code>","text":"<p>Generates a response asynchronously, using the Anthropic Async API definition.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>max_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>stop_sequences</code> <code>Union[List[str], None]</code> <p>custom text sequences that will cause the model to stop generating. Defaults to <code>NOT_GIVEN</code>.</p> <code>None</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Set only if top_p is None. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>top_p</code> <code>Union[float, None]</code> <p>the top-p value to use for the generation. Defaults to <code>NOT_GIVEN</code>.</p> <code>None</code> <code>top_k</code> <code>Union[int, None]</code> <p>the top-k value to use for the generation. Defaults to <code>NOT_GIVEN</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>GenerateOutput</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/anthropic.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    max_tokens: int = 128,\n    stop_sequences: Union[List[str], None] = None,\n    temperature: float = 1.0,\n    top_p: Union[float, None] = None,\n    top_k: Union[int, None] = None,\n) -&gt; \"GenerateOutput\":\n    \"\"\"Generates a response asynchronously, using the [Anthropic Async API definition](https://github.com/anthropics/anthropic-sdk-python).\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        max_tokens: the maximum number of new tokens that the model will generate. Defaults to `128`.\n        stop_sequences: custom text sequences that will cause the model to stop generating. Defaults to `NOT_GIVEN`.\n        temperature: the temperature to use for the generation. Set only if top_p is None. Defaults to `1.0`.\n        top_p: the top-p value to use for the generation. Defaults to `NOT_GIVEN`.\n        top_k: the top-k value to use for the generation. Defaults to `NOT_GIVEN`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    from anthropic._types import NOT_GIVEN\n\n    completion = await self._aclient.messages.create(\n        model=self.model,\n        system=(\n            input.pop(0)[\"content\"]\n            if input and input[0][\"role\"] == \"system\"\n            else NOT_GIVEN\n        ),\n        messages=input,\n        max_tokens=max_tokens,\n        stream=False,\n        stop_sequences=NOT_GIVEN if stop_sequences is None else stop_sequences,\n        temperature=temperature,\n        top_p=NOT_GIVEN if top_p is None else top_p,\n        top_k=NOT_GIVEN if top_k is None else top_k,\n    )\n    generations = []\n    if (content := completion.content[0].text) is None:\n        self._logger.warning(\n            f\"Received no response using Anthropic client (model: '{self.model}').\"\n            f\" Finish reason was: {completion.stop_reason}\"\n        )\n    generations.append(content)\n    return generations\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.AnthropicLLM.generate","title":"<code>generate(inputs, num_generations=1, **kwargs)</code>","text":"<p>Method to generate a list of responses asynchronously, returning the output synchronously awaiting for the response of each input sent to <code>agenerate</code>.</p> Source code in <code>src/distilabel/llms/anthropic.py</code> <pre><code>@override\ndef generate(\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    **kwargs: Any,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Method to generate a list of responses asynchronously, returning the output\n    synchronously awaiting for the response of each input sent to `agenerate`.\n    \"\"\"\n\n    async def agenerate(\n        inputs: List[\"ChatType\"], **kwargs: Any\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n        tasks = [\n            asyncio.create_task(self.agenerate(input=input, **kwargs))\n            for input in inputs\n            for _ in range(num_generations)\n        ]\n        return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n    outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n    return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.AnthropicLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>AsyncAnthropic</code> client to use the Anthropic async API.</p> Source code in <code>src/distilabel/llms/anthropic.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `AsyncAnthropic` client to use the Anthropic async API.\"\"\"\n    super().load()\n\n    try:\n        from anthropic import AsyncAnthropic\n    except ImportError as ie:\n        raise ImportError(\n            \"Anthropic Python client is not installed. Please install it using\"\n            \" `pip install anthropic`.\"\n        ) from ie\n\n    if self.api_key is None:\n        raise ValueError(\n            f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n            f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n        )\n\n    self._check_model_exists()\n\n    self._aclient = AsyncAnthropic(\n        api_key=self.api_key.get_secret_value(),\n        base_url=self.base_url,\n        timeout=self.timeout,\n        http_client=self.http_client,\n        max_retries=self.max_retries,\n    )\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.AnyscaleLLM","title":"<code>AnyscaleLLM</code>","text":"<p>             Bases: <code>OpenAILLM</code></p> <p>Anyscale LLM implementation running the async API client of OpenAI because of duplicate API behavior.</p> <p>Attributes:</p> Name Type Description <code>model</code> <p>the model name to use for the LLM, e.g., <code>google/gemma-7b-it</code>. See the supported models under the \"Text Generation -&gt; Supported Models\" section here.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the Anyscale API requests. Defaults to <code>None</code>, which means that the value set for the environment variable <code>ANYSCALE_BASE_URL</code> will be used, or \"https://api.endpoints.anyscale.com/v1\" if not set.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Anyscale API. Defaults to <code>None</code> which means that the value set for the environment variable <code>ANYSCALE_API_KEY</code> will be used, or <code>None</code> if not set.</p> <code>_api_key_env_var</code> <code>str</code> <p>the name of the environment variable to use for the API key. It is meant to be used internally.</p> Source code in <code>src/distilabel/llms/anyscale.py</code> <pre><code>class AnyscaleLLM(OpenAILLM):\n    \"\"\"Anyscale LLM implementation running the async API client of OpenAI because of\n    duplicate API behavior.\n\n    Attributes:\n        model: the model name to use for the LLM, e.g., `google/gemma-7b-it`. See the\n            supported models under the \"Text Generation -&gt; Supported Models\" section\n            [here](https://docs.endpoints.anyscale.com/).\n        base_url: the base URL to use for the Anyscale API requests. Defaults to `None`, which\n            means that the value set for the environment variable `ANYSCALE_BASE_URL` will be used, or\n            \"https://api.endpoints.anyscale.com/v1\" if not set.\n        api_key: the API key to authenticate the requests to the Anyscale API. Defaults to `None` which\n            means that the value set for the environment variable `ANYSCALE_API_KEY` will be used, or\n            `None` if not set.\n        _api_key_env_var: the name of the environment variable to use for the API key.\n            It is meant to be used internally.\n    \"\"\"\n\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(\n            \"ANYSCALE_BASE_URL\", \"https://api.endpoints.anyscale.com/v1\"\n        ),\n        description=\"The base URL to use for the Anyscale API requests.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_ANYSCALE_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Anyscale API.\",\n    )\n\n    _api_key_env_var: str = PrivateAttr(_ANYSCALE_API_KEY_ENV_VAR_NAME)\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.AsyncLLM","title":"<code>AsyncLLM</code>","text":"<p>             Bases: <code>LLM</code></p> <p>Abstract class for asynchronous LLMs, so as to benefit from the async capabilities of each LLM implementation. This class is meant to be subclassed by each LLM, and the method <code>agenerate</code> needs to be implemented to provide the asynchronous generation of responses.</p> <p>Attributes:</p> Name Type Description <code>_event_loop</code> <code>AbstractEventLoop</code> <p>the event loop to be used for the asynchronous generation of responses.</p> Source code in <code>src/distilabel/llms/base.py</code> <pre><code>class AsyncLLM(LLM):\n    \"\"\"Abstract class for asynchronous LLMs, so as to benefit from the async capabilities\n    of each LLM implementation. This class is meant to be subclassed by each LLM, and the\n    method `agenerate` needs to be implemented to provide the asynchronous generation of\n    responses.\n\n    Attributes:\n        _event_loop: the event loop to be used for the asynchronous generation of responses.\n    \"\"\"\n\n    _event_loop: \"asyncio.AbstractEventLoop\" = PrivateAttr(default=None)\n\n    @property\n    def generate_parameters(self) -&gt; List[inspect.Parameter]:\n        \"\"\"Returns the parameters of the `agenerate` method.\n\n        Returns:\n            A list containing the parameters of the `agenerate` method.\n        \"\"\"\n        return list(inspect.signature(self.agenerate).parameters.values())\n\n    @cached_property\n    def generate_parsed_docstring(self) -&gt; \"Docstring\":\n        \"\"\"Returns the parsed docstring of the `agenerate` method.\n\n        Returns:\n            The parsed docstring of the `agenerate` method.\n        \"\"\"\n        return parse_google_docstring(self.agenerate)\n\n    @property\n    def event_loop(self) -&gt; \"asyncio.AbstractEventLoop\":\n        if self._event_loop is None:\n            try:\n                self._event_loop = asyncio.get_running_loop()\n                if self._event_loop.is_closed():\n                    self._event_loop = asyncio.new_event_loop()  # type: ignore\n            except RuntimeError:\n                self._event_loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self._event_loop)\n        return self._event_loop\n\n    @abstractmethod\n    async def agenerate(\n        self, input: \"ChatType\", num_generations: int = 1, **kwargs: Any\n    ) -&gt; List[Union[str, None]]:\n        \"\"\"Method to generate a `num_generations` responses for a given input asynchronously,\n        and executed concurrently in `generate` method.\n        \"\"\"\n        pass\n\n    def generate(\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        **kwargs: Any,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Method to generate a list of responses asynchronously, returning the output\n        synchronously awaiting for the response of each input sent to `agenerate`.\n        \"\"\"\n\n        async def agenerate(\n            inputs: List[\"ChatType\"], **kwargs: Any\n        ) -&gt; List[List[Union[str, None]]]:\n            \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n            tasks = [\n                asyncio.create_task(\n                    self.agenerate(\n                        input=input, num_generations=num_generations, **kwargs\n                    )\n                )\n                for input in inputs\n            ]\n            return await asyncio.gather(*tasks)\n\n        return self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n\n    def __del__(self) -&gt; None:\n        \"\"\"Closes the event loop when the object is deleted.\"\"\"\n        if sys.meta_path is None:\n            return\n        if self.event_loop is not None:\n            self.event_loop.close()\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.AsyncLLM.generate_parameters","title":"<code>generate_parameters: List[inspect.Parameter]</code>  <code>property</code>","text":"<p>Returns the parameters of the <code>agenerate</code> method.</p> <p>Returns:</p> Type Description <code>List[Parameter]</code> <p>A list containing the parameters of the <code>agenerate</code> method.</p>"},{"location":"reference/distilabel/llms/#distilabel.llms.AsyncLLM.generate_parsed_docstring","title":"<code>generate_parsed_docstring: Docstring</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the parsed docstring of the <code>agenerate</code> method.</p> <p>Returns:</p> Type Description <code>Docstring</code> <p>The parsed docstring of the <code>agenerate</code> method.</p>"},{"location":"reference/distilabel/llms/#distilabel.llms.AsyncLLM.__del__","title":"<code>__del__()</code>","text":"<p>Closes the event loop when the object is deleted.</p> Source code in <code>src/distilabel/llms/base.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Closes the event loop when the object is deleted.\"\"\"\n    if sys.meta_path is None:\n        return\n    if self.event_loop is not None:\n        self.event_loop.close()\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.AsyncLLM.agenerate","title":"<code>agenerate(input, num_generations=1, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Method to generate a <code>num_generations</code> responses for a given input asynchronously, and executed concurrently in <code>generate</code> method.</p> Source code in <code>src/distilabel/llms/base.py</code> <pre><code>@abstractmethod\nasync def agenerate(\n    self, input: \"ChatType\", num_generations: int = 1, **kwargs: Any\n) -&gt; List[Union[str, None]]:\n    \"\"\"Method to generate a `num_generations` responses for a given input asynchronously,\n    and executed concurrently in `generate` method.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.AsyncLLM.generate","title":"<code>generate(inputs, num_generations=1, **kwargs)</code>","text":"<p>Method to generate a list of responses asynchronously, returning the output synchronously awaiting for the response of each input sent to <code>agenerate</code>.</p> Source code in <code>src/distilabel/llms/base.py</code> <pre><code>def generate(\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    **kwargs: Any,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Method to generate a list of responses asynchronously, returning the output\n    synchronously awaiting for the response of each input sent to `agenerate`.\n    \"\"\"\n\n    async def agenerate(\n        inputs: List[\"ChatType\"], **kwargs: Any\n    ) -&gt; List[List[Union[str, None]]]:\n        \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n        tasks = [\n            asyncio.create_task(\n                self.agenerate(\n                    input=input, num_generations=num_generations, **kwargs\n                )\n            )\n            for input in inputs\n        ]\n        return await asyncio.gather(*tasks)\n\n    return self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.AzureOpenAILLM","title":"<code>AzureOpenAILLM</code>","text":"<p>             Bases: <code>OpenAILLM</code></p> <p>Azure OpenAI LLM implementation running the async API client of OpenAI because of duplicate API behavior, but with Azure-specific parameters.</p> <p>Attributes:</p> Name Type Description <code>model</code> <p>the model name to use for the LLM i.e. the name of the Azure deployment.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the Azure OpenAI API can be set with <code>AZURE_OPENAI_ENDPOINT</code>. Defaults to <code>None</code> which means that the value set for the environment variable <code>AZURE_OPENAI_ENDPOINT</code> will be used, or <code>None</code> if not set.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Azure OpenAI API. Defaults to <code>None</code> which means that the value set for the environment variable <code>AZURE_OPENAI_API_KEY</code> will be used, or <code>None</code> if not set.</p> <code>api_version</code> <code>Optional[RuntimeParameter[str]]</code> <p>the API version to use for the Azure OpenAI API. Defaults to <code>None</code> which means that the value set for the environment variable <code>OPENAI_API_VERSION</code> will be used, or <code>None</code> if not set.</p> Source code in <code>src/distilabel/llms/azure.py</code> <pre><code>class AzureOpenAILLM(OpenAILLM):\n    \"\"\"Azure OpenAI LLM implementation running the async API client of OpenAI because of\n    duplicate API behavior, but with Azure-specific parameters.\n\n    Attributes:\n        model: the model name to use for the LLM i.e. the name of the Azure deployment.\n        base_url: the base URL to use for the Azure OpenAI API can be set with `AZURE_OPENAI_ENDPOINT`.\n            Defaults to `None` which means that the value set for the environment variable\n            `AZURE_OPENAI_ENDPOINT` will be used, or `None` if not set.\n        api_key: the API key to authenticate the requests to the Azure OpenAI API. Defaults to `None`\n            which means that the value set for the environment variable `AZURE_OPENAI_API_KEY` will be\n            used, or `None` if not set.\n        api_version: the API version to use for the Azure OpenAI API. Defaults to `None` which means\n            that the value set for the environment variable `OPENAI_API_VERSION` will be used, or\n            `None` if not set.\n    \"\"\"\n\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(_AZURE_OPENAI_ENDPOINT_ENV_VAR_NAME),\n        description=\"The base URL to use for the Azure OpenAI API requests i.e. the Azure OpenAI endpoint.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_AZURE_OPENAI_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Azure OpenAI API.\",\n    )\n\n    api_version: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(\"OPENAI_API_VERSION\"),\n        description=\"The API version to use for the Azure OpenAI API.\",\n    )\n\n    _base_url_env_var: str = PrivateAttr(_AZURE_OPENAI_ENDPOINT_ENV_VAR_NAME)\n    _api_key_env_var: str = PrivateAttr(_AZURE_OPENAI_API_KEY_ENV_VAR_NAME)\n    _aclient: Optional[\"AsyncAzureOpenAI\"] = PrivateAttr(...)  # type: ignore\n\n    @override\n    def load(self) -&gt; None:\n        \"\"\"Loads the `AsyncAzureOpenAI` client to benefit from async requests.\"\"\"\n        super().load()\n\n        try:\n            from openai import AsyncAzureOpenAI\n        except ImportError as ie:\n            raise ImportError(\n                \"OpenAI Python client is not installed. Please install it using\"\n                \" `pip install openai`.\"\n            ) from ie\n\n        if self.api_key is None:\n            raise ValueError(\n                f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n                f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n            )\n\n        # TODO: May be worth adding the AD auth too? Also the `organization`?\n        self._aclient = AsyncAzureOpenAI(  # type: ignore\n            azure_endpoint=self.base_url,  # type: ignore\n            azure_deployment=self.model,\n            api_version=self.api_version,\n            api_key=self.api_key.get_secret_value(),\n            max_retries=self.max_retries,  # type: ignore\n            timeout=self.timeout,\n        )\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.AzureOpenAILLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>AsyncAzureOpenAI</code> client to benefit from async requests.</p> Source code in <code>src/distilabel/llms/azure.py</code> <pre><code>@override\ndef load(self) -&gt; None:\n    \"\"\"Loads the `AsyncAzureOpenAI` client to benefit from async requests.\"\"\"\n    super().load()\n\n    try:\n        from openai import AsyncAzureOpenAI\n    except ImportError as ie:\n        raise ImportError(\n            \"OpenAI Python client is not installed. Please install it using\"\n            \" `pip install openai`.\"\n        ) from ie\n\n    if self.api_key is None:\n        raise ValueError(\n            f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n            f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n        )\n\n    # TODO: May be worth adding the AD auth too? Also the `organization`?\n    self._aclient = AsyncAzureOpenAI(  # type: ignore\n        azure_endpoint=self.base_url,  # type: ignore\n        azure_deployment=self.model,\n        api_version=self.api_version,\n        api_key=self.api_key.get_secret_value(),\n        max_retries=self.max_retries,  # type: ignore\n        timeout=self.timeout,\n    )\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.CohereLLM","title":"<code>CohereLLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>Cohere API implementation using the async client for concurrent text generation.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the name of the model from the Cohere API to use for the generation.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the Cohere API requests. Defaults to <code>\"https://api.cohere.ai/v1\"</code>.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Cohere API. Defaults to the value of the <code>COHERE_API_KEY</code> environment variable.</p> <code>timeout</code> <code>RuntimeParameter[int]</code> <p>the maximum time in seconds to wait for a response from the API. Defaults to <code>120</code>.</p> <code>client_name</code> <code>RuntimeParameter[str]</code> <p>the name of the client to use for the API requests. Defaults to <code>\"distilabel\"</code>.</p> <code>_ChatMessage</code> <code>Type[ChatMessage]</code> <p>the <code>ChatMessage</code> class from the <code>cohere</code> package.</p> <code>_aclient</code> <code>AsyncClient</code> <p>the <code>AsyncClient</code> client from the <code>cohere</code> package.</p> Runtime parameters <ul> <li><code>base_url</code>: the base URL to use for the Cohere API requests. Defaults to     <code>\"https://api.cohere.ai/v1\"</code>.</li> <li><code>api_key</code>: the API key to authenticate the requests to the Cohere API. Defaults     to the value of the <code>COHERE_API_KEY</code> environment variable.</li> <li><code>timeout</code>: the maximum time in seconds to wait for a response from the API. Defaults     to <code>120</code>.</li> <li><code>client_name</code>: the name of the client to use for the API requests. Defaults to     <code>\"distilabel\"</code>.</li> </ul> Source code in <code>src/distilabel/llms/cohere.py</code> <pre><code>class CohereLLM(AsyncLLM):\n    \"\"\"Cohere API implementation using the async client for concurrent text generation.\n\n\n    Attributes:\n        model: the name of the model from the Cohere API to use for the generation.\n        base_url: the base URL to use for the Cohere API requests. Defaults to\n            `\"https://api.cohere.ai/v1\"`.\n        api_key: the API key to authenticate the requests to the Cohere API. Defaults to\n            the value of the `COHERE_API_KEY` environment variable.\n        timeout: the maximum time in seconds to wait for a response from the API. Defaults\n            to `120`.\n        client_name: the name of the client to use for the API requests. Defaults to\n            `\"distilabel\"`.\n        _ChatMessage: the `ChatMessage` class from the `cohere` package.\n        _aclient: the `AsyncClient` client from the `cohere` package.\n\n    Runtime parameters:\n        - `base_url`: the base URL to use for the Cohere API requests. Defaults to\n            `\"https://api.cohere.ai/v1\"`.\n        - `api_key`: the API key to authenticate the requests to the Cohere API. Defaults\n            to the value of the `COHERE_API_KEY` environment variable.\n        - `timeout`: the maximum time in seconds to wait for a response from the API. Defaults\n            to `120`.\n        - `client_name`: the name of the client to use for the API requests. Defaults to\n            `\"distilabel\"`.\n    \"\"\"\n\n    model: str\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(\n            \"COHERE_BASE_URL\", \"https://api.cohere.ai/v1\"\n        ),\n        description=\"The base URL to use for the Cohere API requests.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_COHERE_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Cohere API.\",\n    )\n    timeout: RuntimeParameter[int] = Field(\n        default=120,\n        description=\"The maximum time in seconds to wait for a response from the API.\",\n    )\n    client_name: RuntimeParameter[str] = Field(\n        default=\"distilabel\",\n        description=\"The name of the client to use for the API requests.\",\n    )\n\n    _ChatMessage: Type[\"ChatMessage\"] = PrivateAttr(...)\n    _aclient: \"AsyncClient\" = PrivateAttr(...)\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `AsyncClient` client from the `cohere` package.\"\"\"\n\n        super().load()\n\n        try:\n            from cohere import AsyncClient, ChatMessage\n        except ImportError as ie:\n            raise ImportError(\n                \"The `cohere` package is required to use the `CohereLLM` class.\"\n            ) from ie\n\n        self._ChatMessage = ChatMessage\n\n        self._aclient = AsyncClient(\n            api_key=self.api_key.get_secret_value(),  # type: ignore\n            client_name=self.client_name,\n            base_url=self.base_url,\n            timeout=self.timeout,\n        )\n\n    def _format_chat_to_cohere(\n        self, input: \"ChatType\"\n    ) -&gt; Tuple[Union[str, None], List[\"ChatMessage\"], str]:\n        \"\"\"Formats the chat input to the Cohere Chat API conversational format.\n\n        Args:\n            input: The chat input to format.\n\n        Returns:\n            A tuple containing the system, chat history, and message.\n        \"\"\"\n        system = None\n        message = None\n        chat_history = []\n        for item in input:\n            role = item[\"role\"]\n            content = item[\"content\"]\n            if role == \"system\":\n                system = content\n            elif role == \"user\":\n                message = content\n            elif role == \"assistant\":\n                if message is None:\n                    raise ValueError(\n                        \"An assistant message but be preceded by a user message.\"\n                    )\n                chat_history.append(self._ChatMessage(role=\"USER\", message=message))  # type: ignore\n                chat_history.append(self._ChatMessage(role=\"CHATBOT\", message=content))\n                message = None\n\n        if message is None:\n            raise ValueError(\"The chat input must end with a user message.\")\n\n        return system, chat_history, message\n\n    @override\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        temperature: Optional[float] = None,\n        max_tokens: Optional[int] = None,\n        k: Optional[int] = None,\n        p: Optional[float] = None,\n        seed: Optional[float] = None,\n        stop_sequences: Optional[Sequence[str]] = None,\n        frequency_penalty: Optional[float] = None,\n        presence_penalty: Optional[float] = None,\n        raw_prompting: Optional[bool] = None,\n    ) -&gt; Union[str, None]:\n        \"\"\"Generates a response from the LLM given an input.\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            temperature: the temperature to use for the generation. Defaults to `None`.\n            max_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `None`.\n            k: the number of highest probability vocabulary tokens to keep for the generation.\n                Defaults to `None`.\n            p: the nucleus sampling probability to use for the generation. Defaults to\n                `None`.\n            seed: the seed to use for the generation. Defaults to `None`.\n            stop_sequences: a list of sequences to use as stopping criteria for the generation.\n                Defaults to `None`.\n            frequency_penalty: the frequency penalty to use for the generation. Defaults\n                to `None`.\n            presence_penalty: the presence penalty to use for the generation. Defaults to\n                `None`.\n            raw_prompting: a flag to use raw prompting for the generation. Defaults to\n                `None`.\n\n        Returns:\n            The generated response from the Cohere API model.\n        \"\"\"\n        system, chat_history, message = self._format_chat_to_cohere(input)\n\n        response = await self._aclient.chat(  # type: ignore\n            message=message,\n            model=self.model,\n            preamble=system,\n            chat_history=chat_history,\n            temperature=temperature,\n            max_tokens=max_tokens,\n            k=k,\n            p=p,\n            seed=seed,\n            stop_sequences=stop_sequences,\n            frequency_penalty=frequency_penalty,\n            presence_penalty=presence_penalty,\n            raw_prompting=raw_prompting,\n        )\n\n        if (text := response.text) == \"\":\n            self._logger.warning(\n                f\"Received no response using Cohere client (model: '{self.model}').\"\n                f\" Finish reason was: {response.finish_reason}\"\n            )\n            return None\n\n        return text\n\n    @override\n    def generate(\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        **kwargs: Any,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Method to generate a list of responses asynchronously, returning the output\n        synchronously awaiting for the response of each input sent to `agenerate`.\"\"\"\n\n        async def agenerate(\n            inputs: List[\"ChatType\"], **kwargs: Any\n        ) -&gt; \"GenerateOutput\":\n            \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n            tasks = [\n                asyncio.create_task(self.agenerate(input=input, **kwargs))\n                for input in inputs\n                for _ in range(num_generations)\n            ]\n            return await asyncio.gather(*tasks)\n\n        outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n        return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.CohereLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/#distilabel.llms.CohereLLM.agenerate","title":"<code>agenerate(input, temperature=None, max_tokens=None, k=None, p=None, seed=None, stop_sequences=None, frequency_penalty=None, presence_penalty=None, raw_prompting=None)</code>  <code>async</code>","text":"<p>Generates a response from the LLM given an input.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>temperature</code> <code>Optional[float]</code> <p>the temperature to use for the generation. Defaults to <code>None</code>.</p> <code>None</code> <code>max_tokens</code> <code>Optional[int]</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>None</code>.</p> <code>None</code> <code>k</code> <code>Optional[int]</code> <p>the number of highest probability vocabulary tokens to keep for the generation. Defaults to <code>None</code>.</p> <code>None</code> <code>p</code> <code>Optional[float]</code> <p>the nucleus sampling probability to use for the generation. Defaults to <code>None</code>.</p> <code>None</code> <code>seed</code> <code>Optional[float]</code> <p>the seed to use for the generation. Defaults to <code>None</code>.</p> <code>None</code> <code>stop_sequences</code> <code>Optional[Sequence[str]]</code> <p>a list of sequences to use as stopping criteria for the generation. Defaults to <code>None</code>.</p> <code>None</code> <code>frequency_penalty</code> <code>Optional[float]</code> <p>the frequency penalty to use for the generation. Defaults to <code>None</code>.</p> <code>None</code> <code>presence_penalty</code> <code>Optional[float]</code> <p>the presence penalty to use for the generation. Defaults to <code>None</code>.</p> <code>None</code> <code>raw_prompting</code> <code>Optional[bool]</code> <p>a flag to use raw prompting for the generation. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>The generated response from the Cohere API model.</p> Source code in <code>src/distilabel/llms/cohere.py</code> <pre><code>@override\nasync def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    temperature: Optional[float] = None,\n    max_tokens: Optional[int] = None,\n    k: Optional[int] = None,\n    p: Optional[float] = None,\n    seed: Optional[float] = None,\n    stop_sequences: Optional[Sequence[str]] = None,\n    frequency_penalty: Optional[float] = None,\n    presence_penalty: Optional[float] = None,\n    raw_prompting: Optional[bool] = None,\n) -&gt; Union[str, None]:\n    \"\"\"Generates a response from the LLM given an input.\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        temperature: the temperature to use for the generation. Defaults to `None`.\n        max_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `None`.\n        k: the number of highest probability vocabulary tokens to keep for the generation.\n            Defaults to `None`.\n        p: the nucleus sampling probability to use for the generation. Defaults to\n            `None`.\n        seed: the seed to use for the generation. Defaults to `None`.\n        stop_sequences: a list of sequences to use as stopping criteria for the generation.\n            Defaults to `None`.\n        frequency_penalty: the frequency penalty to use for the generation. Defaults\n            to `None`.\n        presence_penalty: the presence penalty to use for the generation. Defaults to\n            `None`.\n        raw_prompting: a flag to use raw prompting for the generation. Defaults to\n            `None`.\n\n    Returns:\n        The generated response from the Cohere API model.\n    \"\"\"\n    system, chat_history, message = self._format_chat_to_cohere(input)\n\n    response = await self._aclient.chat(  # type: ignore\n        message=message,\n        model=self.model,\n        preamble=system,\n        chat_history=chat_history,\n        temperature=temperature,\n        max_tokens=max_tokens,\n        k=k,\n        p=p,\n        seed=seed,\n        stop_sequences=stop_sequences,\n        frequency_penalty=frequency_penalty,\n        presence_penalty=presence_penalty,\n        raw_prompting=raw_prompting,\n    )\n\n    if (text := response.text) == \"\":\n        self._logger.warning(\n            f\"Received no response using Cohere client (model: '{self.model}').\"\n            f\" Finish reason was: {response.finish_reason}\"\n        )\n        return None\n\n    return text\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.CohereLLM.generate","title":"<code>generate(inputs, num_generations=1, **kwargs)</code>","text":"<p>Method to generate a list of responses asynchronously, returning the output synchronously awaiting for the response of each input sent to <code>agenerate</code>.</p> Source code in <code>src/distilabel/llms/cohere.py</code> <pre><code>@override\ndef generate(\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    **kwargs: Any,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Method to generate a list of responses asynchronously, returning the output\n    synchronously awaiting for the response of each input sent to `agenerate`.\"\"\"\n\n    async def agenerate(\n        inputs: List[\"ChatType\"], **kwargs: Any\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n        tasks = [\n            asyncio.create_task(self.agenerate(input=input, **kwargs))\n            for input in inputs\n            for _ in range(num_generations)\n        ]\n        return await asyncio.gather(*tasks)\n\n    outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n    return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.CohereLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>AsyncClient</code> client from the <code>cohere</code> package.</p> Source code in <code>src/distilabel/llms/cohere.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `AsyncClient` client from the `cohere` package.\"\"\"\n\n    super().load()\n\n    try:\n        from cohere import AsyncClient, ChatMessage\n    except ImportError as ie:\n        raise ImportError(\n            \"The `cohere` package is required to use the `CohereLLM` class.\"\n        ) from ie\n\n    self._ChatMessage = ChatMessage\n\n    self._aclient = AsyncClient(\n        api_key=self.api_key.get_secret_value(),  # type: ignore\n        client_name=self.client_name,\n        base_url=self.base_url,\n        timeout=self.timeout,\n    )\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.CudaDevicePlacementMixin","title":"<code>CudaDevicePlacementMixin</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Mixin class to assign CUDA devices to the <code>LLM</code> based on the <code>cuda_devices</code> attribute and the device placement information provided in <code>_device_llm_placement_map</code>. Providing the device placement information is optional, but if it is provided, it will be used to assign CUDA devices to the <code>LLM</code>s, trying to avoid using the same device for different <code>LLM</code>s.</p> <p>Attributes:</p> Name Type Description <code>cuda_devices</code> <code>Union[List[int], Literal['auto']]</code> <p>a list with the ID of the CUDA devices to be used by the <code>LLM</code>. If set to \"auto\", the devices will be automatically assigned based on the device placement information provided in <code>_device_llm_placement_map</code>. If set to a list of devices, it will be checked if the devices are available to be used by the <code>LLM</code>. If not, a warning will be logged.</p> <code>_llm_identifier</code> <code>Union[str, None]</code> <p>the identifier of the <code>LLM</code> to be used as key in <code>_device_llm_placement_map</code>.</p> <code>_device_llm_placement_map</code> <code>Union[DictProxy[str, Any], None]</code> <p>a dictionary with the device placement information for each <code>LLM</code>.</p> Source code in <code>src/distilabel/llms/mixins.py</code> <pre><code>class CudaDevicePlacementMixin(BaseModel):\n    \"\"\"Mixin class to assign CUDA devices to the `LLM` based on the `cuda_devices` attribute\n    and the device placement information provided in `_device_llm_placement_map`. Providing\n    the device placement information is optional, but if it is provided, it will be used to\n    assign CUDA devices to the `LLM`s, trying to avoid using the same device for different\n    `LLM`s.\n\n    Attributes:\n        cuda_devices: a list with the ID of the CUDA devices to be used by the `LLM`. If set\n            to \"auto\", the devices will be automatically assigned based on the device\n            placement information provided in `_device_llm_placement_map`. If set to a list\n            of devices, it will be checked if the devices are available to be used by the\n            `LLM`. If not, a warning will be logged.\n        _llm_identifier: the identifier of the `LLM` to be used as key in `_device_llm_placement_map`.\n        _device_llm_placement_map: a dictionary with the device placement information for each\n            `LLM`.\n    \"\"\"\n\n    # TODO: this should be a runtime parameter\n    cuda_devices: Union[List[int], Literal[\"auto\"]] = Field(default=\"auto\")\n\n    _llm_identifier: Union[str, None] = PrivateAttr(default=None)\n    _device_llm_placement_map: Union[\"DictProxy[str, Any]\", None] = PrivateAttr(\n        default=None\n    )\n    _device_llm_placement_lock: Union[\"Lock\", None] = PrivateAttr(default=None)\n    _available_cuda_devices: Union[List[int], None] = PrivateAttr(default=None)\n    _can_check_cuda_devices: bool = PrivateAttr(default=False)\n\n    def load(self) -&gt; None:\n        \"\"\"Assign CUDA devices to the LLM based on the device placement information provided\n        in `_device_llm_placement_map`.\"\"\"\n\n        try:\n            import pynvml\n\n            pynvml.nvmlInit()\n            device_count = pynvml.nvmlDeviceGetCount()\n            self._available_cuda_devices = list(range(device_count))\n            self._can_check_cuda_devices = True\n        except ImportError as ie:\n            if self.cuda_devices == \"auto\":\n                raise ImportError(\n                    \"The 'pynvml' library is not installed. It is required to automatically\"\n                    \" assign CUDA devices to the `LLM`s. Please, install it and try again.\"\n                ) from ie\n\n            if self.cuda_devices:\n                self._logger.warning(  # type: ignore\n                    \"The 'pynvml' library is not installed. It is recommended to install it\"\n                    \" to check if the CUDA devices assigned to the LLM are available.\"\n                )\n\n        self._assign_cuda_devices()\n\n    def set_device_placement_info(\n        self,\n        llm_identifier: str,\n        device_llm_placement_map: \"DictProxy[str, Any]\",\n        device_llm_placement_lock: \"Lock\",\n    ) -&gt; None:\n        \"\"\"Sets the value of `_device_llm_placement_map` to be used to assign CUDA devices\n        to the LLM.\n\n        Args:\n            llm_identifier: the identifier of the LLM to be used as key in the device\n                placement information.\n            device_llm_placement_map: a dictionary with the device placement information for\n                each LLM. It should have two keys. The first key is \"lock\" and its value is\n                a lock object to be used to synchronize the access to the device placement\n                information. The second key is \"value\" and its value is a dictionary with the\n                device placement information for each LLM.\n            device_llm_placement_lock: a lock object to be used to synchronize the access to\n                `_device_llm_placement_map`.\n        \"\"\"\n        self._llm_identifier = llm_identifier\n        self._device_llm_placement_map = device_llm_placement_map\n        self._device_llm_placement_lock = device_llm_placement_lock\n\n    def _assign_cuda_devices(self) -&gt; None:\n        \"\"\"Assigns CUDA devices to the LLM based on the device placement information provided\n        in `_device_llm_placement_map`. If the `cuda_devices` attribute is set to \"auto\", it\n        will be set to the first available CUDA device that is not going to be used by any\n        other LLM. If the `cuda_devices` attribute is set to a list of devices, it will be\n        checked if the devices are available to be used by the LLM. If not, a warning will be\n        logged.\"\"\"\n\n        if self._device_llm_placement_map is not None:\n            with self._device_llm_placement_lock:  # type: ignore\n                if self.cuda_devices == \"auto\":\n                    self.cuda_devices = [\n                        self._get_cuda_device(self._device_llm_placement_map)\n                    ]\n                else:\n                    self._check_cuda_devices(self._device_llm_placement_map)\n\n                self._device_llm_placement_map[self._llm_identifier] = self.cuda_devices  # type: ignore\n\n        # `_device_llm_placement_map` was not provided and user didn't set the `cuda_devices`\n        # attribute. In this case, the `cuda_devices` attribute will be set to an empty list.\n        if self.cuda_devices == \"auto\":\n            self.cuda_devices = []\n\n        self._set_cuda_visible_devices()\n\n    def _check_cuda_devices(self, device_map: Dict[str, List[int]]) -&gt; None:\n        \"\"\"Checks if the CUDA devices assigned to the LLM are also assigned to other LLMs.\n\n        Args:\n            device_map: a dictionary with the device placement information for each LLM.\n        \"\"\"\n        for device in self.cuda_devices:\n            for llm, devices in device_map.items():\n                if device in devices:\n                    self._logger.warning(\n                        f\"LLM with identifier '{llm}' is also going to use CUDA device \"\n                        f\"'{device}'. This may lead to performance issues or running out\"\n                        \" of memory depending on the device capabilities and the loaded\"\n                        \" models.\"\n                    )\n\n    def _get_cuda_device(self, device_map: Dict[str, List[int]]) -&gt; int:\n        \"\"\"Returns the first available CUDA device to be used by the LLM that is not going\n        to be used by any other LLM.\n\n        Args:\n            device_map: a dictionary with the device placement information for each LLM.\n\n        Returns:\n            The first available CUDA device to be used by the LLM.\n\n        Raises:\n            RuntimeError: if there is no available CUDA device to be used by the LLM.\n        \"\"\"\n        for device in self._available_cuda_devices:\n            if all(device not in devices for devices in device_map.values()):\n                return device\n\n        raise RuntimeError(\n            \"Couldn't find an available CUDA device automatically to be used by the LLM\"\n            f\" '{self._llm_identifier}'. For forcing the use of a specific device, set the\"\n            \" `cuda_devices` attribute to a list with the desired device(s).\"\n        )\n\n    def _set_cuda_visible_devices(self) -&gt; None:\n        \"\"\"Sets the `CUDA_VISIBLE_DEVICES` environment variable to the list of CUDA devices\n        to be used by the LLM.\n        \"\"\"\n        if not self.cuda_devices:\n            return\n\n        if self._can_check_cuda_devices and not all(\n            device in self._available_cuda_devices for device in self.cuda_devices\n        ):\n            raise RuntimeError(\n                f\"Invalid CUDA devices for LLM '{self._llm_identifier}': {self.cuda_devices}.\"\n                f\" The available devices are: {self._available_cuda_devices}. Please, review\"\n                \" the 'cuda_devices' attribute and try again.\"\n            )\n\n        cuda_devices = \",\".join([str(device) for device in self.cuda_devices])\n        self._logger.info(\n            f\"\ud83c\udfae LLM '{self._llm_identifier}' is going to use the following CUDA devices:\"\n            f\" {self.cuda_devices}.\"\n        )\n        os.environ[\"CUDA_VISIBLE_DEVICES\"] = cuda_devices\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.CudaDevicePlacementMixin.load","title":"<code>load()</code>","text":"<p>Assign CUDA devices to the LLM based on the device placement information provided in <code>_device_llm_placement_map</code>.</p> Source code in <code>src/distilabel/llms/mixins.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Assign CUDA devices to the LLM based on the device placement information provided\n    in `_device_llm_placement_map`.\"\"\"\n\n    try:\n        import pynvml\n\n        pynvml.nvmlInit()\n        device_count = pynvml.nvmlDeviceGetCount()\n        self._available_cuda_devices = list(range(device_count))\n        self._can_check_cuda_devices = True\n    except ImportError as ie:\n        if self.cuda_devices == \"auto\":\n            raise ImportError(\n                \"The 'pynvml' library is not installed. It is required to automatically\"\n                \" assign CUDA devices to the `LLM`s. Please, install it and try again.\"\n            ) from ie\n\n        if self.cuda_devices:\n            self._logger.warning(  # type: ignore\n                \"The 'pynvml' library is not installed. It is recommended to install it\"\n                \" to check if the CUDA devices assigned to the LLM are available.\"\n            )\n\n    self._assign_cuda_devices()\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.CudaDevicePlacementMixin.set_device_placement_info","title":"<code>set_device_placement_info(llm_identifier, device_llm_placement_map, device_llm_placement_lock)</code>","text":"<p>Sets the value of <code>_device_llm_placement_map</code> to be used to assign CUDA devices to the LLM.</p> <p>Parameters:</p> Name Type Description Default <code>llm_identifier</code> <code>str</code> <p>the identifier of the LLM to be used as key in the device placement information.</p> required <code>device_llm_placement_map</code> <code>DictProxy[str, Any]</code> <p>a dictionary with the device placement information for each LLM. It should have two keys. The first key is \"lock\" and its value is a lock object to be used to synchronize the access to the device placement information. The second key is \"value\" and its value is a dictionary with the device placement information for each LLM.</p> required <code>device_llm_placement_lock</code> <code>Lock</code> <p>a lock object to be used to synchronize the access to <code>_device_llm_placement_map</code>.</p> required Source code in <code>src/distilabel/llms/mixins.py</code> <pre><code>def set_device_placement_info(\n    self,\n    llm_identifier: str,\n    device_llm_placement_map: \"DictProxy[str, Any]\",\n    device_llm_placement_lock: \"Lock\",\n) -&gt; None:\n    \"\"\"Sets the value of `_device_llm_placement_map` to be used to assign CUDA devices\n    to the LLM.\n\n    Args:\n        llm_identifier: the identifier of the LLM to be used as key in the device\n            placement information.\n        device_llm_placement_map: a dictionary with the device placement information for\n            each LLM. It should have two keys. The first key is \"lock\" and its value is\n            a lock object to be used to synchronize the access to the device placement\n            information. The second key is \"value\" and its value is a dictionary with the\n            device placement information for each LLM.\n        device_llm_placement_lock: a lock object to be used to synchronize the access to\n            `_device_llm_placement_map`.\n    \"\"\"\n    self._llm_identifier = llm_identifier\n    self._device_llm_placement_map = device_llm_placement_map\n    self._device_llm_placement_lock = device_llm_placement_lock\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.InferenceEndpointsLLM","title":"<code>InferenceEndpointsLLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>InferenceEndpoints LLM implementation running the async API client via either the <code>huggingface_hub.AsyncInferenceClient</code> or via <code>openai.AsyncOpenAI</code>.</p> <p>Attributes:</p> Name Type Description <code>model_id</code> <code>Optional[str]</code> <p>the model ID to use for the LLM as available in the Hugging Face Hub, which will be used to resolve the base URL for the serverless Inference Endpoints API requests. Defaults to <code>None</code>.</p> <code>endpoint_name</code> <code>Optional[RuntimeParameter[str]]</code> <p>the name of the Inference Endpoint to use for the LLM. Defaults to <code>None</code>.</p> <code>endpoint_namespace</code> <code>Optional[RuntimeParameter[str]]</code> <p>the namespace of the Inference Endpoint to use for the LLM. Defaults to <code>None</code>.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the Inference Endpoints API requests.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Inference Endpoints API.</p> <code>tokenizer_id</code> <code>Optional[str]</code> <p>the tokenizer ID to use for the LLM as available in the Hugging Face Hub. Defaults to <code>None</code>, but defining one is recommended to properly format the prompt.</p> <code>model_display_name</code> <code>Optional[str]</code> <p>the model display name to use for the LLM. Defaults to <code>None</code>.</p> <code>use_openai_client</code> <code>bool</code> <p>whether to use the OpenAI client instead of the Hugging Face client.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from distilabel.llms.huggingface import AsyncInferenceEndpointsLLM\n&gt;&gt;&gt; llm = AsyncInferenceEndpointsLLM(model_id=\"model-id\")\n&gt;&gt;&gt; llm.load()\n&gt;&gt;&gt; output = await llm.agenerate([{\"role\": \"user\", \"content\": \"Hello world!\"}])\n</code></pre> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>class InferenceEndpointsLLM(AsyncLLM):\n    \"\"\"InferenceEndpoints LLM implementation running the async API client via either\n    the `huggingface_hub.AsyncInferenceClient` or via `openai.AsyncOpenAI`.\n\n    Attributes:\n        model_id: the model ID to use for the LLM as available in the Hugging Face Hub, which\n            will be used to resolve the base URL for the serverless Inference Endpoints API requests.\n            Defaults to `None`.\n        endpoint_name: the name of the Inference Endpoint to use for the LLM. Defaults to `None`.\n        endpoint_namespace: the namespace of the Inference Endpoint to use for the LLM. Defaults to `None`.\n        base_url: the base URL to use for the Inference Endpoints API requests.\n        api_key: the API key to authenticate the requests to the Inference Endpoints API.\n        tokenizer_id: the tokenizer ID to use for the LLM as available in the Hugging Face Hub.\n            Defaults to `None`, but defining one is recommended to properly format the prompt.\n        model_display_name: the model display name to use for the LLM. Defaults to `None`.\n        use_openai_client: whether to use the OpenAI client instead of the Hugging Face client.\n\n    Examples:\n        &gt;&gt;&gt; from distilabel.llms.huggingface import AsyncInferenceEndpointsLLM\n        &gt;&gt;&gt; llm = AsyncInferenceEndpointsLLM(model_id=\"model-id\")\n        &gt;&gt;&gt; llm.load()\n        &gt;&gt;&gt; output = await llm.agenerate([{\"role\": \"user\", \"content\": \"Hello world!\"}])\n    \"\"\"\n\n    model_id: Optional[str] = None\n\n    endpoint_name: Optional[RuntimeParameter[str]] = Field(\n        default=None,\n        description=\"The name of the Inference Endpoint to use for the LLM.\",\n    )\n    endpoint_namespace: Optional[RuntimeParameter[str]] = Field(\n        default=None,\n        description=\"The namespace of the Inference Endpoint to use for the LLM.\",\n    )\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default=None,\n        description=\"The base URL to use for the Inference Endpoints API requests.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default=os.getenv(_INFERENCE_ENDPOINTS_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Inference Endpoints API.\",\n    )\n\n    tokenizer_id: Optional[str] = None\n    model_display_name: Optional[str] = None\n    use_openai_client: bool = False\n\n    _model_name: Optional[str] = PrivateAttr(default=None)\n    _tokenizer: Optional[\"PreTrainedTokenizer\"] = PrivateAttr(default=None)\n    _api_key_env_var: str = PrivateAttr(_INFERENCE_ENDPOINTS_API_KEY_ENV_VAR_NAME)\n    _aclient: Optional[Union[\"AsyncInferenceClient\", \"AsyncOpenAI\"]] = PrivateAttr(...)\n\n    @model_validator(mode=\"after\")  # type: ignore\n    def only_one_of_model_id_endpoint_name_or_base_url_provided(\n        self,\n    ) -&gt; \"InferenceEndpointsLLM\":\n        \"\"\"Validates that only one of `model_id`, `endpoint_name`, or `base_url` is provided.\"\"\"\n\n        if self.model_id and (not self.endpoint_name and not self.base_url):\n            return self\n\n        if self.endpoint_name and (not self.model_id and not self.base_url):\n            return self\n\n        if self.base_url and (not self.model_id and not self.endpoint_name):\n            return self\n\n        raise ValidationError(\n            \"Only one of `model_id`, `endpoint_name`, or `base_url` must be provided. Found\"\n            f\" `model_id`={self.model_id}, `endpoint_name`={self.endpoint_name}, and\"\n            f\" `base_url`={self.base_url}.\"\n        )\n\n    def load(self) -&gt; None:  # noqa: C901\n        \"\"\"Loads the either the `AsyncInferenceClient` or the `AsyncOpenAI` client to benefit\n        from async requests, running the Hugging Face Inference Endpoint underneath via the\n        `/v1/chat/completions` endpoint, exposed for the models running on TGI using the\n        `text-generation` task.\n\n        Raises:\n            ImportError: if the `openai` Python client is not installed.\n            ImportError: if the `huggingface-hub` Python client is not installed.\n            ValueError: if the model is not currently deployed or is not running the TGI framework.\n            ImportError: if the `transformers` Python client is not installed.\n        \"\"\"\n        super().load()\n\n        try:\n            from huggingface_hub import (\n                AsyncInferenceClient,\n                InferenceClient,\n                get_inference_endpoint,\n            )\n        except ImportError as ie:\n            raise ImportError(\n                \"Hugging Face Hub Python client is not installed. Please install it using\"\n                \" `pip install huggingface-hub`.\"\n            ) from ie\n\n        if self.api_key is None:\n            raise ValueError(\n                f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n                f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n            )\n\n        if self.model_id is not None:\n            client = InferenceClient()\n            status = client.get_model_status(self.model_id)\n\n            if (\n                status.state not in {\"Loadable\", \"Loaded\"}\n                and status.framework != \"text-generation-inference\"\n            ):\n                raise ValueError(\n                    f\"Model {self.model_id} is not currently deployed or is not running the TGI framework\"\n                )\n\n            self.base_url = client._resolve_url(\n                model=self.model_id, task=\"text-generation\"\n            )\n\n        if self.endpoint_name is not None:\n            client = get_inference_endpoint(\n                name=self.endpoint_name,\n                namespace=self.endpoint_namespace,\n                token=self.api_key.get_secret_value(),\n            )\n            if client.status in [\"paused\", \"scaledToZero\"]:\n                client.resume().wait(timeout=300)\n            elif client.status in [\"initializing\"]:\n                client.wait(timeout=300)\n\n            self.base_url = client.url\n            self._model_name = client.repository\n\n        if self.use_openai_client:\n            try:\n                from openai import AsyncOpenAI\n            except ImportError as ie:\n                raise ImportError(\n                    \"OpenAI Python client is not installed. Please install it using\"\n                    \" `pip install openai`.\"\n                ) from ie\n\n            self._aclient = AsyncOpenAI(\n                base_url=self.base_url,\n                api_key=self.api_key.get_secret_value(),\n                max_retries=6,\n            )\n        else:\n            self._aclient = AsyncInferenceClient(\n                model=self.base_url,\n                token=self.api_key.get_secret_value(),\n            )\n\n        if self.tokenizer_id:\n            try:\n                from transformers import AutoTokenizer\n            except ImportError as ie:\n                raise ImportError(\n                    \"Transformers Python client is not installed. Please install it using\"\n                    \" `pip install transformers`.\"\n                ) from ie\n\n            self._tokenizer = AutoTokenizer.from_pretrained(self.tokenizer_id)\n\n    @property\n    @override\n    def model_name(self) -&gt; Union[str, None]:  # type: ignore\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return (\n            self.model_display_name\n            or self._model_name\n            or self.model_id\n            or self.endpoint_name\n            or self.base_url\n        )\n\n    async def _openai_agenerate(\n        self,\n        input: \"ChatType\",\n        max_new_tokens: int = 128,\n        frequency_penalty: float = 0.0,\n        presence_penalty: float = 0.0,\n        temperature: float = 1.0,\n        top_p: Optional[float] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates completions for the given input using the OpenAI async client.\"\"\"\n        completion = await self._aclient.chat.completions.create(  # type: ignore\n            messages=input,  # type: ignore\n            model=\"tgi\",\n            max_tokens=max_new_tokens,\n            n=1,\n            frequency_penalty=frequency_penalty,\n            presence_penalty=presence_penalty,\n            temperature=temperature,\n            top_p=top_p,\n            timeout=50,\n        )\n        if completion.choices[0].message.content is None:\n            self._logger.warning(\n                f\"\u26a0\ufe0f Received no response using OpenAI client (model: '{self.model_name}').\"\n                f\" Finish reason was: {completion.choices[0].finish_reason}\"\n            )\n        return [completion.choices[0].message.content]\n\n    # TODO: add `num_generations` parameter once either TGI or `AsyncInferenceClient` allows `n` parameter\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        max_new_tokens: int = 128,\n        frequency_penalty: float = 0.0,\n        presence_penalty: float = 0.0,\n        repetition_penalty: Optional[float] = None,\n        temperature: float = 1.0,\n        do_sample: bool = False,\n        top_k: Optional[int] = None,\n        top_p: Optional[float] = None,\n        typical_p: Optional[float] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates completions for the given input using the OpenAI async client.\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            frequency_penalty: the repetition penalty to use for the generation. Defaults\n                to `0.0`. Only applies if `use_openai_client=True`.\n            presence_penalty: the presence penalty to use for the generation. Defaults to\n                `0.0`. Only applies if `use_openai_client=True`.\n            repetition_penalty: the repetition penalty to use for the generation. Defaults\n                to `None`. Only applies if `use_openai_client=False`.\n            temperature: the temperature to use for the generation. Defaults to `1.0`.\n            do_sample: whether to use sampling for the generation. Defaults to `False`.\n                Only applies if `use_openai_client=False`.\n            top_k: the top-k value to use for the generation. Defaults to `0.8`, since neither\n                `0.0` nor `1.0` are valid values in TGI.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n            typical_p: the typical-p value to use for the generation. Defaults to `0.5`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n\n        if self.use_openai_client:\n            return await self._openai_agenerate(\n                input=input,\n                max_new_tokens=max_new_tokens,\n                frequency_penalty=frequency_penalty,\n                presence_penalty=presence_penalty,\n                temperature=temperature,\n                top_p=top_p,\n            )\n\n        if self._tokenizer is not None:\n            prompt = self._tokenizer.apply_chat_template(  # type: ignore\n                conversation=input,  # type: ignore\n                tokenize=False,\n                add_generation_prompt=True,\n            )\n        else:\n            prompt = \"\\n\".join([message[\"content\"] for message in input])\n\n        try:\n            completion = await self._aclient.text_generation(  # type: ignore\n                prompt=prompt,  # type: ignore\n                max_new_tokens=max_new_tokens,\n                do_sample=do_sample,\n                typical_p=typical_p,\n                repetition_penalty=repetition_penalty,\n                temperature=temperature,\n                top_p=top_p,\n                top_k=top_k,\n            )\n            return [completion]\n        except Exception as e:\n            self._logger.warning(\n                f\"\u26a0\ufe0f Received no response using Inference Client (model: '{self.model_name}').\"\n                f\" Finish reason was: {e}\"\n            )\n            return [None]\n\n    # TODO: remove this function once `AsyncInferenceClient` allows `n` parameter\n    @override\n    def generate(\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        **kwargs: Any,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Method to generate a list of responses asynchronously, returning the output\n        synchronously awaiting for the response of each input sent to `agenerate`.\n        \"\"\"\n\n        async def agenerate(\n            inputs: List[\"ChatType\"], **kwargs: Any\n        ) -&gt; \"GenerateOutput\":\n            \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n            tasks = [\n                asyncio.create_task(self.agenerate(input=input, **kwargs))\n                for input in inputs\n                for _ in range(num_generations)\n            ]\n            return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n        outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n        return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.InferenceEndpointsLLM.model_name","title":"<code>model_name: Union[str, None]</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/#distilabel.llms.InferenceEndpointsLLM.agenerate","title":"<code>agenerate(input, max_new_tokens=128, frequency_penalty=0.0, presence_penalty=0.0, repetition_penalty=None, temperature=1.0, do_sample=False, top_k=None, top_p=None, typical_p=None)</code>  <code>async</code>","text":"<p>Generates completions for the given input using the OpenAI async client.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>max_new_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>frequency_penalty</code> <code>float</code> <p>the repetition penalty to use for the generation. Defaults to <code>0.0</code>. Only applies if <code>use_openai_client=True</code>.</p> <code>0.0</code> <code>presence_penalty</code> <code>float</code> <p>the presence penalty to use for the generation. Defaults to <code>0.0</code>. Only applies if <code>use_openai_client=True</code>.</p> <code>0.0</code> <code>repetition_penalty</code> <code>Optional[float]</code> <p>the repetition penalty to use for the generation. Defaults to <code>None</code>. Only applies if <code>use_openai_client=False</code>.</p> <code>None</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>do_sample</code> <code>bool</code> <p>whether to use sampling for the generation. Defaults to <code>False</code>. Only applies if <code>use_openai_client=False</code>.</p> <code>False</code> <code>top_k</code> <code>Optional[int]</code> <p>the top-k value to use for the generation. Defaults to <code>0.8</code>, since neither <code>0.0</code> nor <code>1.0</code> are valid values in TGI.</p> <code>None</code> <code>top_p</code> <code>Optional[float]</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>None</code> <code>typical_p</code> <code>Optional[float]</code> <p>the typical-p value to use for the generation. Defaults to <code>0.5</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>GenerateOutput</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    max_new_tokens: int = 128,\n    frequency_penalty: float = 0.0,\n    presence_penalty: float = 0.0,\n    repetition_penalty: Optional[float] = None,\n    temperature: float = 1.0,\n    do_sample: bool = False,\n    top_k: Optional[int] = None,\n    top_p: Optional[float] = None,\n    typical_p: Optional[float] = None,\n) -&gt; \"GenerateOutput\":\n    \"\"\"Generates completions for the given input using the OpenAI async client.\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        frequency_penalty: the repetition penalty to use for the generation. Defaults\n            to `0.0`. Only applies if `use_openai_client=True`.\n        presence_penalty: the presence penalty to use for the generation. Defaults to\n            `0.0`. Only applies if `use_openai_client=True`.\n        repetition_penalty: the repetition penalty to use for the generation. Defaults\n            to `None`. Only applies if `use_openai_client=False`.\n        temperature: the temperature to use for the generation. Defaults to `1.0`.\n        do_sample: whether to use sampling for the generation. Defaults to `False`.\n            Only applies if `use_openai_client=False`.\n        top_k: the top-k value to use for the generation. Defaults to `0.8`, since neither\n            `0.0` nor `1.0` are valid values in TGI.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n        typical_p: the typical-p value to use for the generation. Defaults to `0.5`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n\n    if self.use_openai_client:\n        return await self._openai_agenerate(\n            input=input,\n            max_new_tokens=max_new_tokens,\n            frequency_penalty=frequency_penalty,\n            presence_penalty=presence_penalty,\n            temperature=temperature,\n            top_p=top_p,\n        )\n\n    if self._tokenizer is not None:\n        prompt = self._tokenizer.apply_chat_template(  # type: ignore\n            conversation=input,  # type: ignore\n            tokenize=False,\n            add_generation_prompt=True,\n        )\n    else:\n        prompt = \"\\n\".join([message[\"content\"] for message in input])\n\n    try:\n        completion = await self._aclient.text_generation(  # type: ignore\n            prompt=prompt,  # type: ignore\n            max_new_tokens=max_new_tokens,\n            do_sample=do_sample,\n            typical_p=typical_p,\n            repetition_penalty=repetition_penalty,\n            temperature=temperature,\n            top_p=top_p,\n            top_k=top_k,\n        )\n        return [completion]\n    except Exception as e:\n        self._logger.warning(\n            f\"\u26a0\ufe0f Received no response using Inference Client (model: '{self.model_name}').\"\n            f\" Finish reason was: {e}\"\n        )\n        return [None]\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.InferenceEndpointsLLM.generate","title":"<code>generate(inputs, num_generations=1, **kwargs)</code>","text":"<p>Method to generate a list of responses asynchronously, returning the output synchronously awaiting for the response of each input sent to <code>agenerate</code>.</p> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>@override\ndef generate(\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    **kwargs: Any,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Method to generate a list of responses asynchronously, returning the output\n    synchronously awaiting for the response of each input sent to `agenerate`.\n    \"\"\"\n\n    async def agenerate(\n        inputs: List[\"ChatType\"], **kwargs: Any\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n        tasks = [\n            asyncio.create_task(self.agenerate(input=input, **kwargs))\n            for input in inputs\n            for _ in range(num_generations)\n        ]\n        return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n    outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n    return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.InferenceEndpointsLLM.load","title":"<code>load()</code>","text":"<p>Loads the either the <code>AsyncInferenceClient</code> or the <code>AsyncOpenAI</code> client to benefit from async requests, running the Hugging Face Inference Endpoint underneath via the <code>/v1/chat/completions</code> endpoint, exposed for the models running on TGI using the <code>text-generation</code> task.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>if the <code>openai</code> Python client is not installed.</p> <code>ImportError</code> <p>if the <code>huggingface-hub</code> Python client is not installed.</p> <code>ValueError</code> <p>if the model is not currently deployed or is not running the TGI framework.</p> <code>ImportError</code> <p>if the <code>transformers</code> Python client is not installed.</p> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>def load(self) -&gt; None:  # noqa: C901\n    \"\"\"Loads the either the `AsyncInferenceClient` or the `AsyncOpenAI` client to benefit\n    from async requests, running the Hugging Face Inference Endpoint underneath via the\n    `/v1/chat/completions` endpoint, exposed for the models running on TGI using the\n    `text-generation` task.\n\n    Raises:\n        ImportError: if the `openai` Python client is not installed.\n        ImportError: if the `huggingface-hub` Python client is not installed.\n        ValueError: if the model is not currently deployed or is not running the TGI framework.\n        ImportError: if the `transformers` Python client is not installed.\n    \"\"\"\n    super().load()\n\n    try:\n        from huggingface_hub import (\n            AsyncInferenceClient,\n            InferenceClient,\n            get_inference_endpoint,\n        )\n    except ImportError as ie:\n        raise ImportError(\n            \"Hugging Face Hub Python client is not installed. Please install it using\"\n            \" `pip install huggingface-hub`.\"\n        ) from ie\n\n    if self.api_key is None:\n        raise ValueError(\n            f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n            f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n        )\n\n    if self.model_id is not None:\n        client = InferenceClient()\n        status = client.get_model_status(self.model_id)\n\n        if (\n            status.state not in {\"Loadable\", \"Loaded\"}\n            and status.framework != \"text-generation-inference\"\n        ):\n            raise ValueError(\n                f\"Model {self.model_id} is not currently deployed or is not running the TGI framework\"\n            )\n\n        self.base_url = client._resolve_url(\n            model=self.model_id, task=\"text-generation\"\n        )\n\n    if self.endpoint_name is not None:\n        client = get_inference_endpoint(\n            name=self.endpoint_name,\n            namespace=self.endpoint_namespace,\n            token=self.api_key.get_secret_value(),\n        )\n        if client.status in [\"paused\", \"scaledToZero\"]:\n            client.resume().wait(timeout=300)\n        elif client.status in [\"initializing\"]:\n            client.wait(timeout=300)\n\n        self.base_url = client.url\n        self._model_name = client.repository\n\n    if self.use_openai_client:\n        try:\n            from openai import AsyncOpenAI\n        except ImportError as ie:\n            raise ImportError(\n                \"OpenAI Python client is not installed. Please install it using\"\n                \" `pip install openai`.\"\n            ) from ie\n\n        self._aclient = AsyncOpenAI(\n            base_url=self.base_url,\n            api_key=self.api_key.get_secret_value(),\n            max_retries=6,\n        )\n    else:\n        self._aclient = AsyncInferenceClient(\n            model=self.base_url,\n            token=self.api_key.get_secret_value(),\n        )\n\n    if self.tokenizer_id:\n        try:\n            from transformers import AutoTokenizer\n        except ImportError as ie:\n            raise ImportError(\n                \"Transformers Python client is not installed. Please install it using\"\n                \" `pip install transformers`.\"\n            ) from ie\n\n        self._tokenizer = AutoTokenizer.from_pretrained(self.tokenizer_id)\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.InferenceEndpointsLLM.only_one_of_model_id_endpoint_name_or_base_url_provided","title":"<code>only_one_of_model_id_endpoint_name_or_base_url_provided()</code>","text":"<p>Validates that only one of <code>model_id</code>, <code>endpoint_name</code>, or <code>base_url</code> is provided.</p> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>@model_validator(mode=\"after\")  # type: ignore\ndef only_one_of_model_id_endpoint_name_or_base_url_provided(\n    self,\n) -&gt; \"InferenceEndpointsLLM\":\n    \"\"\"Validates that only one of `model_id`, `endpoint_name`, or `base_url` is provided.\"\"\"\n\n    if self.model_id and (not self.endpoint_name and not self.base_url):\n        return self\n\n    if self.endpoint_name and (not self.model_id and not self.base_url):\n        return self\n\n    if self.base_url and (not self.model_id and not self.endpoint_name):\n        return self\n\n    raise ValidationError(\n        \"Only one of `model_id`, `endpoint_name`, or `base_url` must be provided. Found\"\n        f\" `model_id`={self.model_id}, `endpoint_name`={self.endpoint_name}, and\"\n        f\" `base_url`={self.base_url}.\"\n    )\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.LLM","title":"<code>LLM</code>","text":"<p>             Bases: <code>RuntimeParametersMixin</code>, <code>BaseModel</code>, <code>_Serializable</code>, <code>ABC</code></p> <p>Base class for <code>LLM</code>s to be used in <code>distilabel</code> framework.</p> <p>To implement an <code>LLM</code> subclass, you need to subclass this class and implement:     - <code>load</code> method to load the <code>LLM</code> if needed. Don't forget to call <code>super().load()</code>,         so the <code>_logger</code> attribute is initialized.     - <code>model_name</code> property to return the model name used for the LLM.     - <code>generate</code> method to generate <code>num_generations</code> per input in <code>inputs</code>.</p> <p>Attributes:</p> Name Type Description <code>generation_kwargs</code> <code>Optional[RuntimeParameter[Dict[str, Any]]]</code> <p>the kwargs to be propagated to either <code>generate</code> or <code>agenerate</code> methods within each <code>LLM</code>.</p> <code>_logger</code> <code>Union[Logger, None]</code> <p>the logger to be used for the <code>LLM</code>. It will be initialized when the <code>load</code> method is called.</p> Source code in <code>src/distilabel/llms/base.py</code> <pre><code>class LLM(RuntimeParametersMixin, BaseModel, _Serializable, ABC):\n    \"\"\"Base class for `LLM`s to be used in `distilabel` framework.\n\n    To implement an `LLM` subclass, you need to subclass this class and implement:\n        - `load` method to load the `LLM` if needed. Don't forget to call `super().load()`,\n            so the `_logger` attribute is initialized.\n        - `model_name` property to return the model name used for the LLM.\n        - `generate` method to generate `num_generations` per input in `inputs`.\n\n    Attributes:\n        generation_kwargs: the kwargs to be propagated to either `generate` or `agenerate`\n            methods within each `LLM`.\n        _logger: the logger to be used for the `LLM`. It will be initialized when the `load`\n            method is called.\n    \"\"\"\n\n    model_config = ConfigDict(\n        arbitrary_types_allowed=True, protected_namespaces=(), validate_default=True\n    )\n\n    generation_kwargs: Optional[RuntimeParameter[Dict[str, Any]]] = Field(\n        default_factory=dict,\n        description=\"The kwargs to be propagated to either `generate` or `agenerate`\"\n        \" methods within each `LLM`.\",\n    )\n\n    _logger: Union[logging.Logger, None] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Method to be called to initialize the `LLM` and its logger.\"\"\"\n        self._logger = logging.getLogger(f\"distilabel.llm.{self.model_name}\")\n\n    @property\n    @abstractmethod\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        pass\n\n    @abstractmethod\n    def generate(\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        **kwargs: Any,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Abstract method to be implemented by each LLM to generate `num_generations`\n        per input in `inputs`.\n\n        Args:\n            inputs: the list of inputs to generate responses for which follows OpenAI's\n                API format:\n\n                ```python\n                [\n                    {\"role\": \"system\", \"content\": \"You're a helpful assistant...\"},\n                    {\"role\": \"user\", \"content\": \"Give a template email for B2B communications...\"},\n                    {\"role\": \"assistant\", \"content\": \"Sure, here's a template you can use...\"},\n                    {\"role\": \"user\", \"content\": \"Modify the second paragraph...\"}\n                ]\n                ```\n            num_generations: the number of generations to generate per input.\n            **kwargs: the additional kwargs to be used for the generation.\n        \"\"\"\n        pass\n\n    @property\n    def generate_parameters(self) -&gt; List[\"inspect.Parameter\"]:\n        \"\"\"Returns the parameters of the `generate` method.\n\n        Returns:\n            A list containing the parameters of the `generate` method.\n        \"\"\"\n        return list(inspect.signature(self.generate).parameters.values())\n\n    @property\n    def runtime_parameters_names(self) -&gt; \"RuntimeParametersNames\":\n        \"\"\"Returns the runtime parameters of the `LLM`, which are combination of the\n        attributes of the `LLM` type hinted with `RuntimeParameter` and the parameters\n        of the `generate` method that are not `input` and `num_generations`.\n\n        Returns:\n            A dictionary with the name of the runtime parameters as keys and a boolean\n            indicating if the parameter is optional or not.\n        \"\"\"\n        runtime_parameters = super().runtime_parameters_names\n        runtime_parameters[\"generation_kwargs\"] = {}\n\n        # runtime parameters from the `generate` method\n        for param in self.generate_parameters:\n            if param.name in [\"input\", \"inputs\", \"num_generations\"]:\n                continue\n            is_optional = param.default != inspect.Parameter.empty\n            runtime_parameters[\"generation_kwargs\"][param.name] = is_optional\n\n        return runtime_parameters\n\n    def get_runtime_parameters_info(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Gets the information of the runtime parameters of the `LLM` such as the name\n        and the description. This function is meant to include the information of the runtime\n        parameters in the serialized data of the `LLM`.\n\n        Returns:\n            A list containing the information for each runtime parameter of the `LLM`.\n        \"\"\"\n        runtime_parameters_info = super().get_runtime_parameters_info()\n\n        generation_kwargs_info = next(\n            runtime_parameter_info\n            for runtime_parameter_info in runtime_parameters_info\n            if runtime_parameter_info[\"name\"] == \"generation_kwargs\"\n        )\n\n        generate_docstring_args = self.generate_parsed_docstring[\"args\"]\n\n        generation_kwargs_info[\"keys\"] = []\n        for key, value in generation_kwargs_info[\"optional\"].items():\n            info = {\"name\": key, \"optional\": value}\n            if description := generate_docstring_args.get(key):\n                info[\"description\"] = description\n            generation_kwargs_info[\"keys\"].append(info)\n\n        generation_kwargs_info.pop(\"optional\")\n\n        return runtime_parameters_info\n\n    @cached_property\n    def generate_parsed_docstring(self) -&gt; \"Docstring\":\n        \"\"\"Returns the parsed docstring of the `generate` method.\n\n        Returns:\n            The parsed docstring of the `generate` method.\n        \"\"\"\n        return parse_google_docstring(self.generate)\n\n    def get_last_hidden_states(self, inputs: List[\"ChatType\"]) -&gt; List[\"HiddenState\"]:\n        \"\"\"Method to get the last hidden states of the model for a list of inputs.\n\n        Args:\n            inputs: the list of inputs to get the last hidden states from.\n\n        Returns:\n            A list containing the last hidden state for each sequence using a NumPy array\n                with shape [num_tokens, hidden_size].\n        \"\"\"\n        raise NotImplementedError(\n            f\"Method `get_last_hidden_states` is not implemented for `{self.__class__.__name__}`\"\n        )\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.LLM.generate_parameters","title":"<code>generate_parameters: List[inspect.Parameter]</code>  <code>property</code>","text":"<p>Returns the parameters of the <code>generate</code> method.</p> <p>Returns:</p> Type Description <code>List[Parameter]</code> <p>A list containing the parameters of the <code>generate</code> method.</p>"},{"location":"reference/distilabel/llms/#distilabel.llms.LLM.generate_parsed_docstring","title":"<code>generate_parsed_docstring: Docstring</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the parsed docstring of the <code>generate</code> method.</p> <p>Returns:</p> Type Description <code>Docstring</code> <p>The parsed docstring of the <code>generate</code> method.</p>"},{"location":"reference/distilabel/llms/#distilabel.llms.LLM.model_name","title":"<code>model_name: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/#distilabel.llms.LLM.runtime_parameters_names","title":"<code>runtime_parameters_names: RuntimeParametersNames</code>  <code>property</code>","text":"<p>Returns the runtime parameters of the <code>LLM</code>, which are combination of the attributes of the <code>LLM</code> type hinted with <code>RuntimeParameter</code> and the parameters of the <code>generate</code> method that are not <code>input</code> and <code>num_generations</code>.</p> <p>Returns:</p> Type Description <code>RuntimeParametersNames</code> <p>A dictionary with the name of the runtime parameters as keys and a boolean</p> <code>RuntimeParametersNames</code> <p>indicating if the parameter is optional or not.</p>"},{"location":"reference/distilabel/llms/#distilabel.llms.LLM.generate","title":"<code>generate(inputs, num_generations=1, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Abstract method to be implemented by each LLM to generate <code>num_generations</code> per input in <code>inputs</code>.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>List[ChatType]</code> <p>the list of inputs to generate responses for which follows OpenAI's API format:</p> <pre><code>[\n    {\"role\": \"system\", \"content\": \"You're a helpful assistant...\"},\n    {\"role\": \"user\", \"content\": \"Give a template email for B2B communications...\"},\n    {\"role\": \"assistant\", \"content\": \"Sure, here's a template you can use...\"},\n    {\"role\": \"user\", \"content\": \"Modify the second paragraph...\"}\n]\n</code></pre> required <code>num_generations</code> <code>int</code> <p>the number of generations to generate per input.</p> <code>1</code> <code>**kwargs</code> <code>Any</code> <p>the additional kwargs to be used for the generation.</p> <code>{}</code> Source code in <code>src/distilabel/llms/base.py</code> <pre><code>@abstractmethod\ndef generate(\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    **kwargs: Any,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Abstract method to be implemented by each LLM to generate `num_generations`\n    per input in `inputs`.\n\n    Args:\n        inputs: the list of inputs to generate responses for which follows OpenAI's\n            API format:\n\n            ```python\n            [\n                {\"role\": \"system\", \"content\": \"You're a helpful assistant...\"},\n                {\"role\": \"user\", \"content\": \"Give a template email for B2B communications...\"},\n                {\"role\": \"assistant\", \"content\": \"Sure, here's a template you can use...\"},\n                {\"role\": \"user\", \"content\": \"Modify the second paragraph...\"}\n            ]\n            ```\n        num_generations: the number of generations to generate per input.\n        **kwargs: the additional kwargs to be used for the generation.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.LLM.get_last_hidden_states","title":"<code>get_last_hidden_states(inputs)</code>","text":"<p>Method to get the last hidden states of the model for a list of inputs.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>List[ChatType]</code> <p>the list of inputs to get the last hidden states from.</p> required <p>Returns:</p> Type Description <code>List[HiddenState]</code> <p>A list containing the last hidden state for each sequence using a NumPy array with shape [num_tokens, hidden_size].</p> Source code in <code>src/distilabel/llms/base.py</code> <pre><code>def get_last_hidden_states(self, inputs: List[\"ChatType\"]) -&gt; List[\"HiddenState\"]:\n    \"\"\"Method to get the last hidden states of the model for a list of inputs.\n\n    Args:\n        inputs: the list of inputs to get the last hidden states from.\n\n    Returns:\n        A list containing the last hidden state for each sequence using a NumPy array\n            with shape [num_tokens, hidden_size].\n    \"\"\"\n    raise NotImplementedError(\n        f\"Method `get_last_hidden_states` is not implemented for `{self.__class__.__name__}`\"\n    )\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.LLM.get_runtime_parameters_info","title":"<code>get_runtime_parameters_info()</code>","text":"<p>Gets the information of the runtime parameters of the <code>LLM</code> such as the name and the description. This function is meant to include the information of the runtime parameters in the serialized data of the <code>LLM</code>.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>A list containing the information for each runtime parameter of the <code>LLM</code>.</p> Source code in <code>src/distilabel/llms/base.py</code> <pre><code>def get_runtime_parameters_info(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"Gets the information of the runtime parameters of the `LLM` such as the name\n    and the description. This function is meant to include the information of the runtime\n    parameters in the serialized data of the `LLM`.\n\n    Returns:\n        A list containing the information for each runtime parameter of the `LLM`.\n    \"\"\"\n    runtime_parameters_info = super().get_runtime_parameters_info()\n\n    generation_kwargs_info = next(\n        runtime_parameter_info\n        for runtime_parameter_info in runtime_parameters_info\n        if runtime_parameter_info[\"name\"] == \"generation_kwargs\"\n    )\n\n    generate_docstring_args = self.generate_parsed_docstring[\"args\"]\n\n    generation_kwargs_info[\"keys\"] = []\n    for key, value in generation_kwargs_info[\"optional\"].items():\n        info = {\"name\": key, \"optional\": value}\n        if description := generate_docstring_args.get(key):\n            info[\"description\"] = description\n        generation_kwargs_info[\"keys\"].append(info)\n\n    generation_kwargs_info.pop(\"optional\")\n\n    return runtime_parameters_info\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.LLM.load","title":"<code>load()</code>","text":"<p>Method to be called to initialize the <code>LLM</code> and its logger.</p> Source code in <code>src/distilabel/llms/base.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Method to be called to initialize the `LLM` and its logger.\"\"\"\n    self._logger = logging.getLogger(f\"distilabel.llm.{self.model_name}\")\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.LiteLLM","title":"<code>LiteLLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>LiteLLM implementation running the async API client.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model name to use for the LLM e.g. \"gpt-3.5-turbo\" or \"mistral/mistral-large\", etc.</p> <code>verbose</code> <code>RuntimeParameter[bool]</code> <p>whether to log the LiteLLM client's logs. Defaults to <code>False</code>.</p> Runtime parameters <ul> <li><code>verbose</code>: whether to log the LiteLLM client's logs. Defaults to <code>False</code>.</li> </ul> Source code in <code>src/distilabel/llms/litellm.py</code> <pre><code>class LiteLLM(AsyncLLM):\n    \"\"\"LiteLLM implementation running the async API client.\n\n    Attributes:\n        model: the model name to use for the LLM e.g. \"gpt-3.5-turbo\" or \"mistral/mistral-large\", etc.\n        verbose: whether to log the LiteLLM client's logs. Defaults to `False`.\n\n    Runtime parameters:\n        - `verbose`: whether to log the LiteLLM client's logs. Defaults to `False`.\n    \"\"\"\n\n    model: str\n    verbose: RuntimeParameter[bool] = Field(\n        default=False, description=\"Whether to log the LiteLLM client's logs.\"\n    )\n\n    _aclient: Optional[Callable] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"\n        Loads the `acompletion` LiteLLM client to benefit from async requests.\n        \"\"\"\n        super().load()\n\n        try:\n            import litellm\n\n            litellm.telemetry = False\n        except ImportError as e:\n            raise ImportError(\n                \"LiteLLM Python client is not installed. Please install it using\"\n                \" `pip install litellm`.\"\n            ) from e\n        self._aclient = litellm.acompletion\n\n        if not self.verbose:\n            litellm.suppress_debug_info = True\n            for key in logging.Logger.manager.loggerDict.keys():\n                if \"litellm\" not in key.lower():\n                    continue\n                logging.getLogger(key).setLevel(logging.CRITICAL)\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        num_generations: int = 1,\n        functions: Optional[List] = None,\n        function_call: Optional[str] = None,\n        temperature: Optional[float] = 1.0,\n        top_p: Optional[float] = 1.0,\n        stop: Optional[Union[str, list]] = None,\n        max_tokens: Optional[int] = None,\n        presence_penalty: Optional[float] = None,\n        frequency_penalty: Optional[float] = None,\n        logit_bias: Optional[dict] = None,\n        user: Optional[str] = None,\n        metadata: Optional[dict] = None,\n        api_base: Optional[str] = None,\n        api_version: Optional[str] = None,\n        api_key: Optional[str] = None,\n        model_list: Optional[list] = None,\n        mock_response: Optional[str] = None,\n        force_timeout: Optional[int] = 600,\n        custom_llm_provider: Optional[str] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates `num_generations` responses for the given input using the [LiteLLM async client](https://github.com/BerriAI/litellm).\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            num_generations: the number of generations to create per input. Defaults to\n                `1`.\n            functions: a list of functions to apply to the conversation messages. Defaults to\n                `None`.\n            function_call: the name of the function to call within the conversation. Defaults\n                to `None`.\n            temperature: the temperature to use for the generation. Defaults to `1.0`.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n            stop: Up to 4 sequences where the LLM API will stop generating further tokens.\n                Defaults to `None`.\n            max_tokens: The maximum number of tokens in the generated completion. Defaults to\n                `None`.\n            presence_penalty: It is used to penalize new tokens based on their existence in the\n                text so far. Defaults to `None`.\n            frequency_penalty: It is used to penalize new tokens based on their frequency in the\n                text so far. Defaults to `None`.\n            logit_bias: Used to modify the probability of specific tokens appearing in the\n                completion. Defaults to `None`.\n            user: A unique identifier representing your end-user. This can help the LLM provider\n                to monitor and detect abuse. Defaults to `None`.\n            metadata: Pass in additional metadata to tag your completion calls - eg. prompt\n                version, details, etc. Defaults to `None`.\n            api_base: Base URL for the API. Defaults to `None`.\n            api_version: API version. Defaults to `None`.\n            api_key: API key. Defaults to `None`.\n            model_list: List of api base, version, keys. Defaults to `None`.\n            mock_response: If provided, return a mock completion response for testing or debugging\n                purposes. Defaults to `None`.\n            force_timeout: The maximum execution time in seconds for the completion request.\n                Defaults to `600`.\n            custom_llm_provider: Used for Non-OpenAI LLMs, Example usage for bedrock, set(iterable)\n                model=\"amazon.titan-tg1-large\" and custom_llm_provider=\"bedrock\". Defaults to\n                `None`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        import litellm\n\n        async def _call_aclient_until_n_choices() -&gt; List[\"Choices\"]:\n            choices = []\n            while len(choices) &lt; num_generations:\n                completion = await self._aclient(  # type: ignore\n                    model=self.model,\n                    messages=input,\n                    n=num_generations,\n                    functions=functions,\n                    function_call=function_call,\n                    temperature=temperature,\n                    top_p=top_p,\n                    stream=False,\n                    stop=stop,\n                    max_tokens=max_tokens,\n                    presence_penalty=presence_penalty,\n                    frequency_penalty=frequency_penalty,\n                    logit_bias=logit_bias,\n                    user=user,\n                    metadata=metadata,\n                    api_base=api_base,\n                    api_version=api_version,\n                    api_key=api_key,\n                    model_list=model_list,\n                    mock_response=mock_response,\n                    force_timeout=force_timeout,\n                    custom_llm_provider=custom_llm_provider,\n                )\n                choices.extend(completion.choices)\n            return choices\n\n        # litellm.drop_params is used to en/disable sending **kwargs parameters to the API if they cannot be used\n        try:\n            litellm.drop_params = False\n            choices = await _call_aclient_until_n_choices()\n        except litellm.exceptions.APIError as e:\n            if \"does not support parameters\" in str(e):\n                litellm.drop_params = True\n                choices = await _call_aclient_until_n_choices()\n            else:\n                raise e\n\n        generations = []\n        for choice in choices:\n            if (content := choice.message.content) is None:\n                self._logger.warning(\n                    f\"Received no response using LiteLLM client (model: '{self.model}').\"\n                    f\" Finish reason was: {choice.finish_reason}\"\n                )\n            generations.append(content)\n        return generations\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.LiteLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/#distilabel.llms.LiteLLM.agenerate","title":"<code>agenerate(input, num_generations=1, functions=None, function_call=None, temperature=1.0, top_p=1.0, stop=None, max_tokens=None, presence_penalty=None, frequency_penalty=None, logit_bias=None, user=None, metadata=None, api_base=None, api_version=None, api_key=None, model_list=None, mock_response=None, force_timeout=600, custom_llm_provider=None)</code>  <code>async</code>","text":"<p>Generates <code>num_generations</code> responses for the given input using the LiteLLM async client.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to create per input. Defaults to <code>1</code>.</p> <code>1</code> <code>functions</code> <code>Optional[List]</code> <p>a list of functions to apply to the conversation messages. Defaults to <code>None</code>.</p> <code>None</code> <code>function_call</code> <code>Optional[str]</code> <p>the name of the function to call within the conversation. Defaults to <code>None</code>.</p> <code>None</code> <code>temperature</code> <code>Optional[float]</code> <p>the temperature to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>top_p</code> <code>Optional[float]</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>stop</code> <code>Optional[Union[str, list]]</code> <p>Up to 4 sequences where the LLM API will stop generating further tokens. Defaults to <code>None</code>.</p> <code>None</code> <code>max_tokens</code> <code>Optional[int]</code> <p>The maximum number of tokens in the generated completion. Defaults to <code>None</code>.</p> <code>None</code> <code>presence_penalty</code> <code>Optional[float]</code> <p>It is used to penalize new tokens based on their existence in the text so far. Defaults to <code>None</code>.</p> <code>None</code> <code>frequency_penalty</code> <code>Optional[float]</code> <p>It is used to penalize new tokens based on their frequency in the text so far. Defaults to <code>None</code>.</p> <code>None</code> <code>logit_bias</code> <code>Optional[dict]</code> <p>Used to modify the probability of specific tokens appearing in the completion. Defaults to <code>None</code>.</p> <code>None</code> <code>user</code> <code>Optional[str]</code> <p>A unique identifier representing your end-user. This can help the LLM provider to monitor and detect abuse. Defaults to <code>None</code>.</p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>Pass in additional metadata to tag your completion calls - eg. prompt version, details, etc. Defaults to <code>None</code>.</p> <code>None</code> <code>api_base</code> <code>Optional[str]</code> <p>Base URL for the API. Defaults to <code>None</code>.</p> <code>None</code> <code>api_version</code> <code>Optional[str]</code> <p>API version. Defaults to <code>None</code>.</p> <code>None</code> <code>api_key</code> <code>Optional[str]</code> <p>API key. Defaults to <code>None</code>.</p> <code>None</code> <code>model_list</code> <code>Optional[list]</code> <p>List of api base, version, keys. Defaults to <code>None</code>.</p> <code>None</code> <code>mock_response</code> <code>Optional[str]</code> <p>If provided, return a mock completion response for testing or debugging purposes. Defaults to <code>None</code>.</p> <code>None</code> <code>force_timeout</code> <code>Optional[int]</code> <p>The maximum execution time in seconds for the completion request. Defaults to <code>600</code>.</p> <code>600</code> <code>custom_llm_provider</code> <code>Optional[str]</code> <p>Used for Non-OpenAI LLMs, Example usage for bedrock, set(iterable) model=\"amazon.titan-tg1-large\" and custom_llm_provider=\"bedrock\". Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>GenerateOutput</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/litellm.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    num_generations: int = 1,\n    functions: Optional[List] = None,\n    function_call: Optional[str] = None,\n    temperature: Optional[float] = 1.0,\n    top_p: Optional[float] = 1.0,\n    stop: Optional[Union[str, list]] = None,\n    max_tokens: Optional[int] = None,\n    presence_penalty: Optional[float] = None,\n    frequency_penalty: Optional[float] = None,\n    logit_bias: Optional[dict] = None,\n    user: Optional[str] = None,\n    metadata: Optional[dict] = None,\n    api_base: Optional[str] = None,\n    api_version: Optional[str] = None,\n    api_key: Optional[str] = None,\n    model_list: Optional[list] = None,\n    mock_response: Optional[str] = None,\n    force_timeout: Optional[int] = 600,\n    custom_llm_provider: Optional[str] = None,\n) -&gt; \"GenerateOutput\":\n    \"\"\"Generates `num_generations` responses for the given input using the [LiteLLM async client](https://github.com/BerriAI/litellm).\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        num_generations: the number of generations to create per input. Defaults to\n            `1`.\n        functions: a list of functions to apply to the conversation messages. Defaults to\n            `None`.\n        function_call: the name of the function to call within the conversation. Defaults\n            to `None`.\n        temperature: the temperature to use for the generation. Defaults to `1.0`.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n        stop: Up to 4 sequences where the LLM API will stop generating further tokens.\n            Defaults to `None`.\n        max_tokens: The maximum number of tokens in the generated completion. Defaults to\n            `None`.\n        presence_penalty: It is used to penalize new tokens based on their existence in the\n            text so far. Defaults to `None`.\n        frequency_penalty: It is used to penalize new tokens based on their frequency in the\n            text so far. Defaults to `None`.\n        logit_bias: Used to modify the probability of specific tokens appearing in the\n            completion. Defaults to `None`.\n        user: A unique identifier representing your end-user. This can help the LLM provider\n            to monitor and detect abuse. Defaults to `None`.\n        metadata: Pass in additional metadata to tag your completion calls - eg. prompt\n            version, details, etc. Defaults to `None`.\n        api_base: Base URL for the API. Defaults to `None`.\n        api_version: API version. Defaults to `None`.\n        api_key: API key. Defaults to `None`.\n        model_list: List of api base, version, keys. Defaults to `None`.\n        mock_response: If provided, return a mock completion response for testing or debugging\n            purposes. Defaults to `None`.\n        force_timeout: The maximum execution time in seconds for the completion request.\n            Defaults to `600`.\n        custom_llm_provider: Used for Non-OpenAI LLMs, Example usage for bedrock, set(iterable)\n            model=\"amazon.titan-tg1-large\" and custom_llm_provider=\"bedrock\". Defaults to\n            `None`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    import litellm\n\n    async def _call_aclient_until_n_choices() -&gt; List[\"Choices\"]:\n        choices = []\n        while len(choices) &lt; num_generations:\n            completion = await self._aclient(  # type: ignore\n                model=self.model,\n                messages=input,\n                n=num_generations,\n                functions=functions,\n                function_call=function_call,\n                temperature=temperature,\n                top_p=top_p,\n                stream=False,\n                stop=stop,\n                max_tokens=max_tokens,\n                presence_penalty=presence_penalty,\n                frequency_penalty=frequency_penalty,\n                logit_bias=logit_bias,\n                user=user,\n                metadata=metadata,\n                api_base=api_base,\n                api_version=api_version,\n                api_key=api_key,\n                model_list=model_list,\n                mock_response=mock_response,\n                force_timeout=force_timeout,\n                custom_llm_provider=custom_llm_provider,\n            )\n            choices.extend(completion.choices)\n        return choices\n\n    # litellm.drop_params is used to en/disable sending **kwargs parameters to the API if they cannot be used\n    try:\n        litellm.drop_params = False\n        choices = await _call_aclient_until_n_choices()\n    except litellm.exceptions.APIError as e:\n        if \"does not support parameters\" in str(e):\n            litellm.drop_params = True\n            choices = await _call_aclient_until_n_choices()\n        else:\n            raise e\n\n    generations = []\n    for choice in choices:\n        if (content := choice.message.content) is None:\n            self._logger.warning(\n                f\"Received no response using LiteLLM client (model: '{self.model}').\"\n                f\" Finish reason was: {choice.finish_reason}\"\n            )\n        generations.append(content)\n    return generations\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.LiteLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>acompletion</code> LiteLLM client to benefit from async requests.</p> Source code in <code>src/distilabel/llms/litellm.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"\n    Loads the `acompletion` LiteLLM client to benefit from async requests.\n    \"\"\"\n    super().load()\n\n    try:\n        import litellm\n\n        litellm.telemetry = False\n    except ImportError as e:\n        raise ImportError(\n            \"LiteLLM Python client is not installed. Please install it using\"\n            \" `pip install litellm`.\"\n        ) from e\n    self._aclient = litellm.acompletion\n\n    if not self.verbose:\n        litellm.suppress_debug_info = True\n        for key in logging.Logger.manager.loggerDict.keys():\n            if \"litellm\" not in key.lower():\n                continue\n            logging.getLogger(key).setLevel(logging.CRITICAL)\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.LlamaCppLLM","title":"<code>LlamaCppLLM</code>","text":"<p>             Bases: <code>LLM</code></p> <p>llama.cpp LLM implementation running the Python bindings for the C++ code.</p> <p>Attributes:</p> Name Type Description <code>chat_format</code> <code>str</code> <p>the chat format to use for the model. Defaults to <code>chatml</code>.</p> <code>model_path</code> <code>RuntimeParameter[FilePath]</code> <p>contains the path to the GGUF quantized model, compatible with the installed version of the <code>llama.cpp</code> Python bindings.</p> <code>n_gpu_layers</code> <code>RuntimeParameter[int]</code> <p>the number of layers to use for the GPU. Defaults to <code>-1</code>, meaning that the available GPU device will be used.</p> <code>verbose</code> <code>RuntimeParameter[bool]</code> <p>whether to print verbose output. Defaults to <code>False</code>.</p> <code>_model</code> <code>Optional[Llama]</code> <p>the Llama model instance. This attribute is meant to be used internally and should not be accessed directly. It will be set in the <code>load</code> method.</p> Runtime parameters <ul> <li><code>model_path</code>: the path to the GGUF quantized model.</li> <li><code>n_gpu_layers</code>: the number of layers to use for the GPU. Defaults to <code>-1</code>.</li> <li><code>verbose</code>: whether to print verbose output. Defaults to <code>False</code>.</li> </ul> Source code in <code>src/distilabel/llms/llamacpp.py</code> <pre><code>class LlamaCppLLM(LLM):\n    \"\"\"llama.cpp LLM implementation running the Python bindings for the C++ code.\n\n    Attributes:\n        chat_format: the chat format to use for the model. Defaults to `chatml`.\n        model_path: contains the path to the GGUF quantized model, compatible with the\n            installed version of the `llama.cpp` Python bindings.\n        n_gpu_layers: the number of layers to use for the GPU. Defaults to `-1`, meaning that\n            the available GPU device will be used.\n        verbose: whether to print verbose output. Defaults to `False`.\n        _model: the Llama model instance. This attribute is meant to be used internally and\n            should not be accessed directly. It will be set in the `load` method.\n\n    Runtime parameters:\n        - `model_path`: the path to the GGUF quantized model.\n        - `n_gpu_layers`: the number of layers to use for the GPU. Defaults to `-1`.\n        - `verbose`: whether to print verbose output. Defaults to `False`.\n    \"\"\"\n\n    chat_format: str = \"chatml\"\n    model_path: RuntimeParameter[FilePath] = Field(\n        default=None, description=\"The path to the GGUF quantized model.\"\n    )\n    n_gpu_layers: RuntimeParameter[int] = Field(\n        default=-1,\n        description=\"The number of layers that will be loaded in the GPU.\",\n    )\n    verbose: RuntimeParameter[bool] = Field(\n        default=False,\n        description=\"Whether to print verbose output from llama.cpp library.\",\n    )\n\n    _model: Optional[\"Llama\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `Llama` model from the `model_path`.\"\"\"\n\n        try:\n            from llama_cpp import Llama\n        except ImportError as ie:\n            raise ImportError(\n                \"The `llama_cpp` package is required to use the `LlamaCppLLM` class.\"\n            ) from ie\n\n        self._model = Llama(\n            model_path=self.model_path.as_posix(),\n            chat_format=self.chat_format,\n            n_gpu_layers=self.n_gpu_layers,\n            verbose=self.verbose,\n        )\n\n        super().load()\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self._model.model_path  # type: ignore\n\n    def generate(  # type: ignore\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        max_new_tokens: int = 128,\n        frequency_penalty: float = 0.0,\n        presence_penalty: float = 0.0,\n        temperature: float = 1.0,\n        top_p: float = 1.0,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Generates `num_generations` responses for the given input using the Llama model.\n\n        Args:\n            inputs: a list of inputs in chat format to generate responses for.\n            num_generations: the number of generations to create per input. Defaults to\n                `1`.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            frequency_penalty: the repetition penalty to use for the generation. Defaults\n                to `0.0`.\n            presence_penalty: the presence penalty to use for the generation. Defaults to\n                `0.0`.\n            temperature: the temperature to use for the generation. Defaults to `0.1`.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        batch_outputs = []\n        for input in inputs:\n            outputs = []\n            for _ in range(num_generations):\n                chat_completions: \"CreateChatCompletionResponse\" = (\n                    self._model.create_chat_completion(  # type: ignore\n                        messages=input,  # type: ignore\n                        max_tokens=max_new_tokens,\n                        frequency_penalty=frequency_penalty,\n                        presence_penalty=presence_penalty,\n                        temperature=temperature,\n                        top_p=top_p,\n                    )\n                )\n                outputs.append(chat_completions[\"choices\"][0][\"message\"][\"content\"])\n            batch_outputs.append(outputs)\n        return batch_outputs\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.LlamaCppLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/#distilabel.llms.LlamaCppLLM.generate","title":"<code>generate(inputs, num_generations=1, max_new_tokens=128, frequency_penalty=0.0, presence_penalty=0.0, temperature=1.0, top_p=1.0)</code>","text":"<p>Generates <code>num_generations</code> responses for the given input using the Llama model.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>List[ChatType]</code> <p>a list of inputs in chat format to generate responses for.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to create per input. Defaults to <code>1</code>.</p> <code>1</code> <code>max_new_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>frequency_penalty</code> <code>float</code> <p>the repetition penalty to use for the generation. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>presence_penalty</code> <code>float</code> <p>the presence penalty to use for the generation. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Defaults to <code>0.1</code>.</p> <code>1.0</code> <code>top_p</code> <code>float</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>List[GenerateOutput]</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/llamacpp.py</code> <pre><code>def generate(  # type: ignore\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    max_new_tokens: int = 128,\n    frequency_penalty: float = 0.0,\n    presence_penalty: float = 0.0,\n    temperature: float = 1.0,\n    top_p: float = 1.0,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Generates `num_generations` responses for the given input using the Llama model.\n\n    Args:\n        inputs: a list of inputs in chat format to generate responses for.\n        num_generations: the number of generations to create per input. Defaults to\n            `1`.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        frequency_penalty: the repetition penalty to use for the generation. Defaults\n            to `0.0`.\n        presence_penalty: the presence penalty to use for the generation. Defaults to\n            `0.0`.\n        temperature: the temperature to use for the generation. Defaults to `0.1`.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    batch_outputs = []\n    for input in inputs:\n        outputs = []\n        for _ in range(num_generations):\n            chat_completions: \"CreateChatCompletionResponse\" = (\n                self._model.create_chat_completion(  # type: ignore\n                    messages=input,  # type: ignore\n                    max_tokens=max_new_tokens,\n                    frequency_penalty=frequency_penalty,\n                    presence_penalty=presence_penalty,\n                    temperature=temperature,\n                    top_p=top_p,\n                )\n            )\n            outputs.append(chat_completions[\"choices\"][0][\"message\"][\"content\"])\n        batch_outputs.append(outputs)\n    return batch_outputs\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.LlamaCppLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>Llama</code> model from the <code>model_path</code>.</p> Source code in <code>src/distilabel/llms/llamacpp.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `Llama` model from the `model_path`.\"\"\"\n\n    try:\n        from llama_cpp import Llama\n    except ImportError as ie:\n        raise ImportError(\n            \"The `llama_cpp` package is required to use the `LlamaCppLLM` class.\"\n        ) from ie\n\n    self._model = Llama(\n        model_path=self.model_path.as_posix(),\n        chat_format=self.chat_format,\n        n_gpu_layers=self.n_gpu_layers,\n        verbose=self.verbose,\n    )\n\n    super().load()\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.MistralLLM","title":"<code>MistralLLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>Mistral LLM implementation running the async API client.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model name to use for the LLM e.g. \"mistral-tiny\", \"mistral-large\", etc.</p> <code>endpoint</code> <code>str</code> <p>the endpoint to use for the Mistral API. Defaults to \"https://api.mistral.ai\".</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Mistral API. Defaults to <code>None</code> which means that the value set for the environment variable <code>OPENAI_API_KEY</code> will be used, or <code>None</code> if not set.</p> <code>max_retries</code> <code>RuntimeParameter[int]</code> <p>the maximum number of retries to attempt when a request fails. Defaults to <code>5</code>.</p> <code>timeout</code> <code>RuntimeParameter[int]</code> <p>the maximum time in seconds to wait for a response. Defaults to <code>120</code>.</p> <code>max_concurrent_requests</code> <code>RuntimeParameter[int]</code> <p>the maximum number of concurrent requests to send. Defaults to <code>64</code>.</p> <code>_api_key_env_var</code> <code>str</code> <p>the name of the environment variable to use for the API key. It is meant to be used internally.</p> <code>_aclient</code> <code>Optional[MistralAsyncClient]</code> <p>the <code>MistralAsyncClient</code> to use for the Mistral API. It is meant to be used internally. Set in the <code>load</code> method.</p> Runtime parameters <ul> <li><code>api_key</code>: the API key to authenticate the requests to the Mistral API.</li> <li><code>max_retries</code>: the maximum number of retries to attempt when a request fails.     Defaults to <code>5</code>.</li> <li><code>timeout</code>: the maximum time in seconds to wait for a response. Defaults to <code>120</code>.</li> <li><code>max_concurrent_requests</code>: the maximum number of concurrent requests to send.     Defaults to <code>64</code>.</li> </ul> Source code in <code>src/distilabel/llms/mistral.py</code> <pre><code>class MistralLLM(AsyncLLM):\n    \"\"\"Mistral LLM implementation running the async API client.\n\n    Attributes:\n        model: the model name to use for the LLM e.g. \"mistral-tiny\", \"mistral-large\", etc.\n        endpoint: the endpoint to use for the Mistral API. Defaults to \"https://api.mistral.ai\".\n        api_key: the API key to authenticate the requests to the Mistral API. Defaults to `None` which\n            means that the value set for the environment variable `OPENAI_API_KEY` will be used, or\n            `None` if not set.\n        max_retries: the maximum number of retries to attempt when a request fails. Defaults to `5`.\n        timeout: the maximum time in seconds to wait for a response. Defaults to `120`.\n        max_concurrent_requests: the maximum number of concurrent requests to send. Defaults\n            to `64`.\n        _api_key_env_var: the name of the environment variable to use for the API key. It is meant to\n            be used internally.\n        _aclient: the `MistralAsyncClient` to use for the Mistral API. It is meant to be used internally.\n            Set in the `load` method.\n\n    Runtime parameters:\n        - `api_key`: the API key to authenticate the requests to the Mistral API.\n        - `max_retries`: the maximum number of retries to attempt when a request fails.\n            Defaults to `5`.\n        - `timeout`: the maximum time in seconds to wait for a response. Defaults to `120`.\n        - `max_concurrent_requests`: the maximum number of concurrent requests to send.\n            Defaults to `64`.\n    \"\"\"\n\n    model: str\n    endpoint: str = \"https://api.mistral.ai\"\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_MISTRALAI_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Mistral API.\",\n    )\n    max_retries: RuntimeParameter[int] = Field(\n        default=6,\n        description=\"The maximum number of times to retry the request to the API before\"\n        \" failing.\",\n    )\n    timeout: RuntimeParameter[int] = Field(\n        default=120,\n        description=\"The maximum time in seconds to wait for a response from the API.\",\n    )\n    max_concurrent_requests: RuntimeParameter[int] = Field(\n        default=64, description=\"The maximum number of concurrent requests to send.\"\n    )\n\n    _api_key_env_var: str = PrivateAttr(_MISTRALAI_API_KEY_ENV_VAR_NAME)\n    _aclient: Optional[\"MistralAsyncClient\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `MistralAsyncClient` client to benefit from async requests.\"\"\"\n        super().load()\n\n        try:\n            from mistralai.async_client import MistralAsyncClient\n        except ImportError as ie:\n            raise ImportError(\n                \"MistralAI Python client is not installed. Please install it using\"\n                \" `pip install mistralai`.\"\n            ) from ie\n\n        if self.api_key is None:\n            raise ValueError(\n                f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n                f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n            )\n\n        self._aclient = MistralAsyncClient(\n            api_key=self.api_key.get_secret_value(),\n            endpoint=self.endpoint,\n            max_retries=self.max_retries,\n            timeout=self.timeout,\n            max_concurrent_requests=self.max_concurrent_requests,\n        )\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    # TODO: add `num_generations` parameter once Mistral client allows `n` parameter\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        max_new_tokens: Optional[int] = None,\n        temperature: Optional[float] = None,\n        top_p: Optional[float] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates `num_generations` responses for the given input using the MistralAI async\n        client.\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            temperature: the temperature to use for the generation. Defaults to `0.1`.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        completion = await self._aclient.chat(  # type: ignore\n            messages=input,\n            model=self.model,\n            temperature=temperature,\n            max_tokens=max_new_tokens,\n            top_p=top_p,\n        )\n        generations = []\n        for choice in completion.choices:\n            if (content := choice.message.content) is None:\n                self._logger.warning(\n                    f\"Received no response using MistralAI client (model: '{self.model}').\"\n                    f\" Finish reason was: {choice.finish_reason}\"\n                )\n            generations.append(content)\n        return generations\n\n    # TODO: remove this function once Mistral client allows `n` parameter\n    @override\n    def generate(\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        **kwargs: Any,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Method to generate a list of responses asynchronously, returning the output\n        synchronously awaiting for the response of each input sent to `agenerate`.\n        \"\"\"\n\n        async def agenerate(\n            inputs: List[\"ChatType\"], **kwargs: Any\n        ) -&gt; \"GenerateOutput\":\n            \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n            tasks = [\n                asyncio.create_task(self.agenerate(input=input, **kwargs))\n                for input in inputs\n                for _ in range(num_generations)\n            ]\n            return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n        outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n        return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.MistralLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/#distilabel.llms.MistralLLM.agenerate","title":"<code>agenerate(input, max_new_tokens=None, temperature=None, top_p=None)</code>  <code>async</code>","text":"<p>Generates <code>num_generations</code> responses for the given input using the MistralAI async client.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>max_new_tokens</code> <code>Optional[int]</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>None</code> <code>temperature</code> <code>Optional[float]</code> <p>the temperature to use for the generation. Defaults to <code>0.1</code>.</p> <code>None</code> <code>top_p</code> <code>Optional[float]</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>GenerateOutput</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/mistral.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    max_new_tokens: Optional[int] = None,\n    temperature: Optional[float] = None,\n    top_p: Optional[float] = None,\n) -&gt; \"GenerateOutput\":\n    \"\"\"Generates `num_generations` responses for the given input using the MistralAI async\n    client.\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        temperature: the temperature to use for the generation. Defaults to `0.1`.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    completion = await self._aclient.chat(  # type: ignore\n        messages=input,\n        model=self.model,\n        temperature=temperature,\n        max_tokens=max_new_tokens,\n        top_p=top_p,\n    )\n    generations = []\n    for choice in completion.choices:\n        if (content := choice.message.content) is None:\n            self._logger.warning(\n                f\"Received no response using MistralAI client (model: '{self.model}').\"\n                f\" Finish reason was: {choice.finish_reason}\"\n            )\n        generations.append(content)\n    return generations\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.MistralLLM.generate","title":"<code>generate(inputs, num_generations=1, **kwargs)</code>","text":"<p>Method to generate a list of responses asynchronously, returning the output synchronously awaiting for the response of each input sent to <code>agenerate</code>.</p> Source code in <code>src/distilabel/llms/mistral.py</code> <pre><code>@override\ndef generate(\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    **kwargs: Any,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Method to generate a list of responses asynchronously, returning the output\n    synchronously awaiting for the response of each input sent to `agenerate`.\n    \"\"\"\n\n    async def agenerate(\n        inputs: List[\"ChatType\"], **kwargs: Any\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n        tasks = [\n            asyncio.create_task(self.agenerate(input=input, **kwargs))\n            for input in inputs\n            for _ in range(num_generations)\n        ]\n        return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n    outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n    return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.MistralLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>MistralAsyncClient</code> client to benefit from async requests.</p> Source code in <code>src/distilabel/llms/mistral.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `MistralAsyncClient` client to benefit from async requests.\"\"\"\n    super().load()\n\n    try:\n        from mistralai.async_client import MistralAsyncClient\n    except ImportError as ie:\n        raise ImportError(\n            \"MistralAI Python client is not installed. Please install it using\"\n            \" `pip install mistralai`.\"\n        ) from ie\n\n    if self.api_key is None:\n        raise ValueError(\n            f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n            f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n        )\n\n    self._aclient = MistralAsyncClient(\n        api_key=self.api_key.get_secret_value(),\n        endpoint=self.endpoint,\n        max_retries=self.max_retries,\n        timeout=self.timeout,\n        max_concurrent_requests=self.max_concurrent_requests,\n    )\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.OllamaLLM","title":"<code>OllamaLLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>Ollama LLM implementation running the Async API client.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model name to use for the LLM e.g. \"notus\".</p> <code>host</code> <code>Optional[RuntimeParameter[str]]</code> <p>the Ollama server host.</p> <code>timeout</code> <code>RuntimeParameter[int]</code> <p>the timeout for the LLM. Defaults to <code>120</code>.</p> <code>_aclient</code> <code>Optional[AsyncClient]</code> <p>the <code>AsyncClient</code> to use for the Ollama API. It is meant to be used internally. Set in the <code>load</code> method.</p> Runtime parameters <ul> <li><code>host</code>: the Ollama server host.</li> <li><code>timeout</code>: the client timeout for the Ollama API. Defaults to <code>120</code>.</li> </ul> Source code in <code>src/distilabel/llms/ollama.py</code> <pre><code>class OllamaLLM(AsyncLLM):\n    \"\"\"Ollama LLM implementation running the Async API client.\n\n    Attributes:\n        model: the model name to use for the LLM e.g. \"notus\".\n        host: the Ollama server host.\n        timeout: the timeout for the LLM. Defaults to `120`.\n        _aclient: the `AsyncClient` to use for the Ollama API. It is meant to be used internally.\n            Set in the `load` method.\n\n    Runtime parameters:\n        - `host`: the Ollama server host.\n        - `timeout`: the client timeout for the Ollama API. Defaults to `120`.\n    \"\"\"\n\n    model: str\n    host: Optional[RuntimeParameter[str]] = Field(\n        default=None, description=\"The host of the Ollama API.\"\n    )\n    timeout: RuntimeParameter[int] = Field(\n        default=120, description=\"The timeout for the Ollama API.\"\n    )\n    follow_redirects: bool = True\n\n    _aclient: Optional[\"AsyncClient\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `AsyncClient` to use Ollama async API.\"\"\"\n        super().load()\n\n        try:\n            from ollama import AsyncClient\n\n            self._aclient = AsyncClient(\n                host=self.host,\n                timeout=self.timeout,\n                follow_redirects=self.follow_redirects,\n            )\n        except ImportError as e:\n            raise ImportError(\n                \"Ollama Python client is not installed. Please install it using\"\n                \" `pip install ollama`.\"\n            ) from e\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        num_generations: int = 1,\n        format: Literal[\"\", \"json\"] = \"\",\n        options: Union[\"Options\", None] = None,\n        keep_alive: Union[bool, None] = None,\n    ) -&gt; List[str]:\n        \"\"\"\n        Generates a response asynchronously, using the [Ollama Async API definition](https://github.com/ollama/ollama-python).\n\n        Args:\n            input: the input to use for the generation.\n            num_generations: the number of generations to produce. Defaults to `1`.\n            format: the format to use for the generation. Defaults to `\"\"`.\n            options: the options to use for the generation. Defaults to `None`.\n            keep_alive: whether to keep the connection alive. Defaults to `None`.\n\n        Returns:\n            A list of strings as completion for the given input.\n        \"\"\"\n        generations = []\n        # TODO: remove this for-loop and override the `generate` method\n        for _ in range(num_generations):\n            completion = await self._aclient.chat(  # type: ignore\n                model=self.model,\n                messages=input,  # type: ignore\n                stream=False,\n                format=format,\n                options=options,\n                keep_alive=keep_alive,\n            )\n            # TODO: improve error handling\n            generations.append(completion[\"message\"][\"content\"])\n\n        return generations\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.OllamaLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/#distilabel.llms.OllamaLLM.agenerate","title":"<code>agenerate(input, num_generations=1, format='', options=None, keep_alive=None)</code>  <code>async</code>","text":"<p>Generates a response asynchronously, using the Ollama Async API definition.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>the input to use for the generation.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to produce. Defaults to <code>1</code>.</p> <code>1</code> <code>format</code> <code>Literal['', 'json']</code> <p>the format to use for the generation. Defaults to <code>\"\"</code>.</p> <code>''</code> <code>options</code> <code>Union[Options, None]</code> <p>the options to use for the generation. Defaults to <code>None</code>.</p> <code>None</code> <code>keep_alive</code> <code>Union[bool, None]</code> <p>whether to keep the connection alive. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of strings as completion for the given input.</p> Source code in <code>src/distilabel/llms/ollama.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    num_generations: int = 1,\n    format: Literal[\"\", \"json\"] = \"\",\n    options: Union[\"Options\", None] = None,\n    keep_alive: Union[bool, None] = None,\n) -&gt; List[str]:\n    \"\"\"\n    Generates a response asynchronously, using the [Ollama Async API definition](https://github.com/ollama/ollama-python).\n\n    Args:\n        input: the input to use for the generation.\n        num_generations: the number of generations to produce. Defaults to `1`.\n        format: the format to use for the generation. Defaults to `\"\"`.\n        options: the options to use for the generation. Defaults to `None`.\n        keep_alive: whether to keep the connection alive. Defaults to `None`.\n\n    Returns:\n        A list of strings as completion for the given input.\n    \"\"\"\n    generations = []\n    # TODO: remove this for-loop and override the `generate` method\n    for _ in range(num_generations):\n        completion = await self._aclient.chat(  # type: ignore\n            model=self.model,\n            messages=input,  # type: ignore\n            stream=False,\n            format=format,\n            options=options,\n            keep_alive=keep_alive,\n        )\n        # TODO: improve error handling\n        generations.append(completion[\"message\"][\"content\"])\n\n    return generations\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.OllamaLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>AsyncClient</code> to use Ollama async API.</p> Source code in <code>src/distilabel/llms/ollama.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `AsyncClient` to use Ollama async API.\"\"\"\n    super().load()\n\n    try:\n        from ollama import AsyncClient\n\n        self._aclient = AsyncClient(\n            host=self.host,\n            timeout=self.timeout,\n            follow_redirects=self.follow_redirects,\n        )\n    except ImportError as e:\n        raise ImportError(\n            \"Ollama Python client is not installed. Please install it using\"\n            \" `pip install ollama`.\"\n        ) from e\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.OpenAILLM","title":"<code>OpenAILLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>OpenAI LLM implementation running the async API client.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model name to use for the LLM e.g. \"gpt-3.5-turbo\", \"gpt-4\", etc. Supported models can be found here.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the OpenAI API requests. Defaults to <code>None</code>, which means that the value set for the environment variable <code>OPENAI_BASE_URL</code> will be used, or \"https://api.openai.com/v1\" if not set.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the OpenAI API. Defaults to <code>None</code> which means that the value set for the environment variable <code>OPENAI_API_KEY</code> will be used, or <code>None</code> if not set.</p> <code>max_retries</code> <code>RuntimeParameter[int]</code> <p>the maximum number of times to retry the request to the API before failing. Defaults to <code>6</code>.</p> <code>timeout</code> <code>RuntimeParameter[int]</code> <p>the maximum time in seconds to wait for a response from the API. Defaults to <code>120</code>.</p> Runtime parameters <ul> <li><code>base_url</code>: the base URL to use for the OpenAI API requests. Defaults to <code>None</code>.</li> <li><code>api_key</code>: the API key to authenticate the requests to the OpenAI API. Defaults     to <code>None</code>.</li> <li><code>max_retries</code>: the maximum number of times to retry the request to the API before     failing. Defaults to <code>6</code>.</li> <li><code>timeout</code>: the maximum time in seconds to wait for a response from the API. Defaults     to <code>120</code>.</li> </ul> Source code in <code>src/distilabel/llms/openai.py</code> <pre><code>class OpenAILLM(AsyncLLM):\n    \"\"\"OpenAI LLM implementation running the async API client.\n\n    Attributes:\n        model: the model name to use for the LLM e.g. \"gpt-3.5-turbo\", \"gpt-4\", etc.\n            Supported models can be found [here](https://platform.openai.com/docs/guides/text-generation).\n        base_url: the base URL to use for the OpenAI API requests. Defaults to `None`, which\n            means that the value set for the environment variable `OPENAI_BASE_URL` will\n            be used, or \"https://api.openai.com/v1\" if not set.\n        api_key: the API key to authenticate the requests to the OpenAI API. Defaults to\n            `None` which means that the value set for the environment variable `OPENAI_API_KEY`\n            will be used, or `None` if not set.\n        max_retries: the maximum number of times to retry the request to the API before\n            failing. Defaults to `6`.\n        timeout: the maximum time in seconds to wait for a response from the API. Defaults\n            to `120`.\n\n    Runtime parameters:\n        - `base_url`: the base URL to use for the OpenAI API requests. Defaults to `None`.\n        - `api_key`: the API key to authenticate the requests to the OpenAI API. Defaults\n            to `None`.\n        - `max_retries`: the maximum number of times to retry the request to the API before\n            failing. Defaults to `6`.\n        - `timeout`: the maximum time in seconds to wait for a response from the API. Defaults\n            to `120`.\n    \"\"\"\n\n    model: str\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(\n            \"OPENAI_BASE_URL\", \"https://api.openai.com/v1\"\n        ),\n        description=\"The base URL to use for the OpenAI API requests.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_OPENAI_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the OpenAI API.\",\n    )\n    max_retries: RuntimeParameter[int] = Field(\n        default=6,\n        description=\"The maximum number of times to retry the request to the API before\"\n        \" failing.\",\n    )\n    timeout: RuntimeParameter[int] = Field(\n        default=120,\n        description=\"The maximum time in seconds to wait for a response from the API.\",\n    )\n\n    _api_key_env_var: str = PrivateAttr(_OPENAI_API_KEY_ENV_VAR_NAME)\n    _aclient: Optional[\"AsyncOpenAI\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `AsyncOpenAI` client to benefit from async requests.\"\"\"\n        super().load()\n\n        try:\n            from openai import AsyncOpenAI\n        except ImportError as ie:\n            raise ImportError(\n                \"OpenAI Python client is not installed. Please install it using\"\n                \" `pip install openai`.\"\n            ) from ie\n\n        if self.api_key is None:\n            raise ValueError(\n                f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n                f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n            )\n\n        self._aclient = AsyncOpenAI(\n            base_url=self.base_url,\n            api_key=self.api_key.get_secret_value(),\n            max_retries=self.max_retries,\n            timeout=self.timeout,\n        )\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        num_generations: int = 1,\n        max_new_tokens: int = 128,\n        frequency_penalty: float = 0.0,\n        presence_penalty: float = 0.0,\n        temperature: float = 1.0,\n        top_p: float = 1.0,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates `num_generations` responses for the given input using the OpenAI async\n        client.\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            num_generations: the number of generations to create per input. Defaults to\n                `1`.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            frequency_penalty: the repetition penalty to use for the generation. Defaults\n                to `0.0`.\n            presence_penalty: the presence penalty to use for the generation. Defaults to\n                `0.0`.\n            temperature: the temperature to use for the generation. Defaults to `0.1`.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        completion = await self._aclient.chat.completions.create(  # type: ignore\n            messages=input,  # type: ignore\n            model=self.model,\n            max_tokens=max_new_tokens,\n            n=num_generations,\n            frequency_penalty=frequency_penalty,\n            presence_penalty=presence_penalty,\n            temperature=temperature,\n            top_p=top_p,\n            timeout=50,\n        )\n        generations = []\n        for choice in completion.choices:\n            if (content := choice.message.content) is None:\n                self._logger.warning(\n                    f\"Received no response using OpenAI client (model: '{self.model}').\"\n                    f\" Finish reason was: {choice.finish_reason}\"\n                )\n            generations.append(content)\n        return generations\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.OpenAILLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/#distilabel.llms.OpenAILLM.agenerate","title":"<code>agenerate(input, num_generations=1, max_new_tokens=128, frequency_penalty=0.0, presence_penalty=0.0, temperature=1.0, top_p=1.0)</code>  <code>async</code>","text":"<p>Generates <code>num_generations</code> responses for the given input using the OpenAI async client.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to create per input. Defaults to <code>1</code>.</p> <code>1</code> <code>max_new_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>frequency_penalty</code> <code>float</code> <p>the repetition penalty to use for the generation. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>presence_penalty</code> <code>float</code> <p>the presence penalty to use for the generation. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Defaults to <code>0.1</code>.</p> <code>1.0</code> <code>top_p</code> <code>float</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>GenerateOutput</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/openai.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    num_generations: int = 1,\n    max_new_tokens: int = 128,\n    frequency_penalty: float = 0.0,\n    presence_penalty: float = 0.0,\n    temperature: float = 1.0,\n    top_p: float = 1.0,\n) -&gt; \"GenerateOutput\":\n    \"\"\"Generates `num_generations` responses for the given input using the OpenAI async\n    client.\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        num_generations: the number of generations to create per input. Defaults to\n            `1`.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        frequency_penalty: the repetition penalty to use for the generation. Defaults\n            to `0.0`.\n        presence_penalty: the presence penalty to use for the generation. Defaults to\n            `0.0`.\n        temperature: the temperature to use for the generation. Defaults to `0.1`.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    completion = await self._aclient.chat.completions.create(  # type: ignore\n        messages=input,  # type: ignore\n        model=self.model,\n        max_tokens=max_new_tokens,\n        n=num_generations,\n        frequency_penalty=frequency_penalty,\n        presence_penalty=presence_penalty,\n        temperature=temperature,\n        top_p=top_p,\n        timeout=50,\n    )\n    generations = []\n    for choice in completion.choices:\n        if (content := choice.message.content) is None:\n            self._logger.warning(\n                f\"Received no response using OpenAI client (model: '{self.model}').\"\n                f\" Finish reason was: {choice.finish_reason}\"\n            )\n        generations.append(content)\n    return generations\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.OpenAILLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>AsyncOpenAI</code> client to benefit from async requests.</p> Source code in <code>src/distilabel/llms/openai.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `AsyncOpenAI` client to benefit from async requests.\"\"\"\n    super().load()\n\n    try:\n        from openai import AsyncOpenAI\n    except ImportError as ie:\n        raise ImportError(\n            \"OpenAI Python client is not installed. Please install it using\"\n            \" `pip install openai`.\"\n        ) from ie\n\n    if self.api_key is None:\n        raise ValueError(\n            f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n            f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n        )\n\n    self._aclient = AsyncOpenAI(\n        base_url=self.base_url,\n        api_key=self.api_key.get_secret_value(),\n        max_retries=self.max_retries,\n        timeout=self.timeout,\n    )\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.TogetherLLM","title":"<code>TogetherLLM</code>","text":"<p>             Bases: <code>OpenAILLM</code></p> <p>TogetherLLM LLM implementation running the async API client of OpenAI because of duplicate API behavior.</p> <p>Attributes:</p> Name Type Description <code>model</code> <p>the model name to use for the LLM e.g. \"mistralai/Mixtral-8x7B-Instruct-v0.1\". Supported models can be found here.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the Together API can be set with <code>TOGETHER_BASE_URL</code>. Defaults to <code>None</code> which means that the value set for the environment variable <code>TOGETHER_BASE_URL</code> will be used, or \"https://api.together.xyz/v1\" if not set.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Together API. Defaults to <code>None</code> which means that the value set for the environment variable <code>TOGETHER_API_KEY</code> will be used, or <code>None</code> if not set.</p> <code>_api_key_env_var</code> <code>str</code> <p>the name of the environment variable to use for the API key. It is meant to be used internally.</p> Source code in <code>src/distilabel/llms/together.py</code> <pre><code>class TogetherLLM(OpenAILLM):\n    \"\"\"TogetherLLM LLM implementation running the async API client of OpenAI because of\n    duplicate API behavior.\n\n    Attributes:\n        model: the model name to use for the LLM e.g. \"mistralai/Mixtral-8x7B-Instruct-v0.1\".\n            Supported models can be found [here](https://api.together.xyz/models).\n        base_url: the base URL to use for the Together API can be set with `TOGETHER_BASE_URL`.\n            Defaults to `None` which means that the value set for the environment variable\n            `TOGETHER_BASE_URL` will be used, or \"https://api.together.xyz/v1\" if not set.\n        api_key: the API key to authenticate the requests to the Together API. Defaults to `None`\n            which means that the value set for the environment variable `TOGETHER_API_KEY` will be\n            used, or `None` if not set.\n        _api_key_env_var: the name of the environment variable to use for the API key. It\n            is meant to be used internally.\n    \"\"\"\n\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(\n            \"TOGETHER_BASE_URL\", \"https://api.together.xyz/v1\"\n        ),\n        description=\"The base URL to use for the Together API requests.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_TOGETHER_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Together API.\",\n    )\n\n    _api_key_env_var: str = PrivateAttr(_TOGETHER_API_KEY_ENV_VAR_NAME)\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.TransformersLLM","title":"<code>TransformersLLM</code>","text":"<p>             Bases: <code>LLM</code>, <code>CudaDevicePlacementMixin</code></p> <p>Hugging Face <code>transformers</code> library LLM implementation using the text generation pipeline.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model Hugging Face Hub repo id or a path to a directory containing the model weights and configuration files.</p> <code>revision</code> <code>str</code> <p>if <code>model</code> refers to a Hugging Face Hub repository, then the revision (e.g. a branch name or a commit id) to use. Defaults to <code>\"main\"</code>.</p> <code>torch_dtype</code> <code>str</code> <p>the torch dtype to use for the model e.g. \"float16\", \"float32\", etc. Defaults to <code>\"auto\"</code>.</p> <code>trust_remote_code</code> <code>bool</code> <p>whether to trust or not remote (code in the Hugging Face Hub repository) code to load the model. Defaults to <code>False</code>.</p> <code>model_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>additional dictionary of keyword arguments that will be passed to the <code>from_pretrained</code> method of the model.</p> <code>tokenizer</code> <code>Optional[str]</code> <p>the tokenizer Hugging Face Hub repo id or a path to a directory containing the tokenizer config files. If not provided, the one associated to the <code>model</code> will be used. Defaults to <code>None</code>.</p> <code>use_fast</code> <code>bool</code> <p>whether to use a fast tokenizer or not. Defaults to <code>True</code>.</p> <code>chat_template</code> <code>Optional[str]</code> <p>a chat template that will be used to build the prompts before sending them to the model. If not provided, the chat template defined in the tokenizer config will be used. If not provided and the tokenizer doesn't have a chat template, then ChatML template will be used. Defaults to <code>None</code>.</p> <code>device</code> <code>Optional[Union[str, int]]</code> <p>the name or index of the device where the model will be loaded. Defaults to <code>None</code>.</p> <code>device_map</code> <code>Optional[Union[str, Dict[str, Any]]]</code> <p>a dictionary mapping each layer of the model to a device, or a mode like <code>\"sequential\"</code> or <code>\"auto\"</code>. Defaults to <code>None</code>.</p> <code>token</code> <code>Optional[str]</code> <p>the Hugging Face Hub token that will be used to authenticate to the Hugging Face Hub. If not provided, the <code>HF_TOKEN</code> environment or <code>huggingface_hub</code> package local configuration will be used. Defaults to <code>None</code>.</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>class TransformersLLM(LLM, CudaDevicePlacementMixin):\n    \"\"\"Hugging Face `transformers` library LLM implementation using the text generation\n    pipeline.\n\n    Attributes:\n        model: the model Hugging Face Hub repo id or a path to a directory containing the\n            model weights and configuration files.\n        revision: if `model` refers to a Hugging Face Hub repository, then the revision\n            (e.g. a branch name or a commit id) to use. Defaults to `\"main\"`.\n        torch_dtype: the torch dtype to use for the model e.g. \"float16\", \"float32\", etc.\n            Defaults to `\"auto\"`.\n        trust_remote_code: whether to trust or not remote (code in the Hugging Face Hub\n            repository) code to load the model. Defaults to `False`.\n        model_kwargs: additional dictionary of keyword arguments that will be passed to\n            the `from_pretrained` method of the model.\n        tokenizer: the tokenizer Hugging Face Hub repo id or a path to a directory containing\n            the tokenizer config files. If not provided, the one associated to the `model`\n            will be used. Defaults to `None`.\n        use_fast: whether to use a fast tokenizer or not. Defaults to `True`.\n        chat_template: a chat template that will be used to build the prompts before\n            sending them to the model. If not provided, the chat template defined in the\n            tokenizer config will be used. If not provided and the tokenizer doesn't have\n            a chat template, then ChatML template will be used. Defaults to `None`.\n        device: the name or index of the device where the model will be loaded. Defaults\n            to `None`.\n        device_map: a dictionary mapping each layer of the model to a device, or a mode\n            like `\"sequential\"` or `\"auto\"`. Defaults to `None`.\n        token: the Hugging Face Hub token that will be used to authenticate to the Hugging\n            Face Hub. If not provided, the `HF_TOKEN` environment or `huggingface_hub` package\n            local configuration will be used. Defaults to `None`.\n    \"\"\"\n\n    model: str\n    revision: str = \"main\"\n    torch_dtype: str = \"auto\"\n    trust_remote_code: bool = False\n    model_kwargs: Optional[Dict[str, Any]] = None\n    tokenizer: Optional[str] = None\n    use_fast: bool = True\n    chat_template: Optional[str] = None\n    device: Optional[Union[str, int]] = None\n    device_map: Optional[Union[str, Dict[str, Any]]] = None\n    token: Optional[str] = None\n\n    _pipeline: Optional[\"Pipeline\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the model and tokenizer and creates the text generation pipeline. In addition,\n        it will configure the tokenizer chat template.\"\"\"\n        super().load()\n\n        if self.device == \"cuda\":\n            CudaDevicePlacementMixin.load(self)\n\n        try:\n            from transformers import pipeline\n        except ImportError as ie:\n            raise ImportError(\n                \"Transformers is not installed. Please install it using `pip install transformers`.\"\n            ) from ie\n\n        self._pipeline = pipeline(\n            \"text-generation\",\n            model=self.model,\n            revision=self.revision,\n            torch_dtype=self.torch_dtype,\n            trust_remote_code=self.trust_remote_code,\n            model_kwargs=self.model_kwargs or {},\n            tokenizer=self.tokenizer or self.model,\n            use_fast=self.use_fast,\n            device=self.device,\n            device_map=self.device_map,\n            token=self.token or os.getenv(\"HF_TOKEN\"),\n            return_full_text=False,\n        )\n\n        if self.chat_template is not None:\n            self._pipeline.tokenizer.chat_template = self.chat_template  # type: ignore\n        elif (\n            self._pipeline.tokenizer.chat_template is None  # type: ignore\n            and self._pipeline.tokenizer.default_chat_template is None  # type: ignore\n        ):\n            self._pipeline.tokenizer.chat_template = CHATML_TEMPLATE  # type: ignore\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    def prepare_input(self, input: \"ChatType\") -&gt; str:\n        \"\"\"Prepares the input by applying the chat template to the input, which is formatted\n        as an OpenAI conversation, and adding the generation prompt.\n        \"\"\"\n        return self._pipeline.tokenizer.apply_chat_template(  # type: ignore\n            input,  # type: ignore\n            tokenize=False,\n            add_generation_prompt=True,\n        )\n\n    def generate(  # type: ignore\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        max_new_tokens: int = 128,\n        temperature: float = 0.1,\n        repetition_penalty: float = 1.1,\n        top_p: float = 1.0,\n        top_k: int = 0,\n        do_sample: bool = True,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Generates `num_generations` responses for each input using the text generation\n        pipeline.\n\n        Args:\n            inputs: a list of inputs in chat format to generate responses for.\n            num_generations: the number of generations to create per input. Defaults to\n                `1`.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            temperature: the temperature to use for the generation. Defaults to `0.1`.\n            repetition_penalty: the repetition penalty to use for the generation. Defaults\n                to `1.1`.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n            top_k: the top-k value to use for the generation. Defaults to `0`.\n            do_sample: whether to use sampling or not. Defaults to `True`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        outputs: List[List[Dict[str, str]]] = self._pipeline(  # type: ignore\n            [self.prepare_input(input=input) for input in inputs],\n            max_new_tokens=max_new_tokens,\n            temperature=temperature,\n            repetition_penalty=repetition_penalty,\n            top_p=top_p,\n            top_k=top_k,\n            do_sample=do_sample,\n            num_return_sequences=num_generations,\n        )\n        return [\n            [generation[\"generated_text\"] for generation in output]\n            for output in outputs\n        ]\n\n    def get_last_hidden_states(self, inputs: List[\"ChatType\"]) -&gt; List[\"HiddenState\"]:\n        \"\"\"Gets the last `hidden_states` of the model for the given inputs. It doesn't\n        execute the task head.\n\n        Args:\n            inputs: a list of inputs in chat format to generate the embeddings for.\n\n        Returns:\n            A list containing the last hidden state for each sequence using a NumPy array\n            with shape [num_tokens, hidden_size].\n        \"\"\"\n        model: \"PreTrainedModel\" = (\n            self._pipeline.model.model  # type: ignore\n            if hasattr(self._pipeline.model, \"model\")  # type: ignore\n            else next(self._pipeline.model.children())  # type: ignore\n        )\n        tokenizer: \"PreTrainedTokenizer\" = self._pipeline.tokenizer  # type: ignore\n        input_ids = tokenizer(\n            [self.prepare_input(input) for input in inputs],  # type: ignore\n            return_tensors=\"pt\",\n            padding=True,\n        ).to(model.device)\n        last_hidden_states = model(**input_ids)[\"last_hidden_state\"]\n\n        return [\n            seq_last_hidden_state[attention_mask.bool(), :].detach().cpu().numpy()\n            for seq_last_hidden_state, attention_mask in zip(\n                last_hidden_states,\n                input_ids[\"attention_mask\"],  # type: ignore\n            )\n        ]\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.TransformersLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/#distilabel.llms.TransformersLLM.generate","title":"<code>generate(inputs, num_generations=1, max_new_tokens=128, temperature=0.1, repetition_penalty=1.1, top_p=1.0, top_k=0, do_sample=True)</code>","text":"<p>Generates <code>num_generations</code> responses for each input using the text generation pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>List[ChatType]</code> <p>a list of inputs in chat format to generate responses for.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to create per input. Defaults to <code>1</code>.</p> <code>1</code> <code>max_new_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Defaults to <code>0.1</code>.</p> <code>0.1</code> <code>repetition_penalty</code> <code>float</code> <p>the repetition penalty to use for the generation. Defaults to <code>1.1</code>.</p> <code>1.1</code> <code>top_p</code> <code>float</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>top_k</code> <code>int</code> <p>the top-k value to use for the generation. Defaults to <code>0</code>.</p> <code>0</code> <code>do_sample</code> <code>bool</code> <p>whether to use sampling or not. Defaults to <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>List[GenerateOutput]</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>def generate(  # type: ignore\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    max_new_tokens: int = 128,\n    temperature: float = 0.1,\n    repetition_penalty: float = 1.1,\n    top_p: float = 1.0,\n    top_k: int = 0,\n    do_sample: bool = True,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Generates `num_generations` responses for each input using the text generation\n    pipeline.\n\n    Args:\n        inputs: a list of inputs in chat format to generate responses for.\n        num_generations: the number of generations to create per input. Defaults to\n            `1`.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        temperature: the temperature to use for the generation. Defaults to `0.1`.\n        repetition_penalty: the repetition penalty to use for the generation. Defaults\n            to `1.1`.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n        top_k: the top-k value to use for the generation. Defaults to `0`.\n        do_sample: whether to use sampling or not. Defaults to `True`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    outputs: List[List[Dict[str, str]]] = self._pipeline(  # type: ignore\n        [self.prepare_input(input=input) for input in inputs],\n        max_new_tokens=max_new_tokens,\n        temperature=temperature,\n        repetition_penalty=repetition_penalty,\n        top_p=top_p,\n        top_k=top_k,\n        do_sample=do_sample,\n        num_return_sequences=num_generations,\n    )\n    return [\n        [generation[\"generated_text\"] for generation in output]\n        for output in outputs\n    ]\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.TransformersLLM.get_last_hidden_states","title":"<code>get_last_hidden_states(inputs)</code>","text":"<p>Gets the last <code>hidden_states</code> of the model for the given inputs. It doesn't execute the task head.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>List[ChatType]</code> <p>a list of inputs in chat format to generate the embeddings for.</p> required <p>Returns:</p> Type Description <code>List[HiddenState]</code> <p>A list containing the last hidden state for each sequence using a NumPy array</p> <code>List[HiddenState]</code> <p>with shape [num_tokens, hidden_size].</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>def get_last_hidden_states(self, inputs: List[\"ChatType\"]) -&gt; List[\"HiddenState\"]:\n    \"\"\"Gets the last `hidden_states` of the model for the given inputs. It doesn't\n    execute the task head.\n\n    Args:\n        inputs: a list of inputs in chat format to generate the embeddings for.\n\n    Returns:\n        A list containing the last hidden state for each sequence using a NumPy array\n        with shape [num_tokens, hidden_size].\n    \"\"\"\n    model: \"PreTrainedModel\" = (\n        self._pipeline.model.model  # type: ignore\n        if hasattr(self._pipeline.model, \"model\")  # type: ignore\n        else next(self._pipeline.model.children())  # type: ignore\n    )\n    tokenizer: \"PreTrainedTokenizer\" = self._pipeline.tokenizer  # type: ignore\n    input_ids = tokenizer(\n        [self.prepare_input(input) for input in inputs],  # type: ignore\n        return_tensors=\"pt\",\n        padding=True,\n    ).to(model.device)\n    last_hidden_states = model(**input_ids)[\"last_hidden_state\"]\n\n    return [\n        seq_last_hidden_state[attention_mask.bool(), :].detach().cpu().numpy()\n        for seq_last_hidden_state, attention_mask in zip(\n            last_hidden_states,\n            input_ids[\"attention_mask\"],  # type: ignore\n        )\n    ]\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.TransformersLLM.load","title":"<code>load()</code>","text":"<p>Loads the model and tokenizer and creates the text generation pipeline. In addition, it will configure the tokenizer chat template.</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the model and tokenizer and creates the text generation pipeline. In addition,\n    it will configure the tokenizer chat template.\"\"\"\n    super().load()\n\n    if self.device == \"cuda\":\n        CudaDevicePlacementMixin.load(self)\n\n    try:\n        from transformers import pipeline\n    except ImportError as ie:\n        raise ImportError(\n            \"Transformers is not installed. Please install it using `pip install transformers`.\"\n        ) from ie\n\n    self._pipeline = pipeline(\n        \"text-generation\",\n        model=self.model,\n        revision=self.revision,\n        torch_dtype=self.torch_dtype,\n        trust_remote_code=self.trust_remote_code,\n        model_kwargs=self.model_kwargs or {},\n        tokenizer=self.tokenizer or self.model,\n        use_fast=self.use_fast,\n        device=self.device,\n        device_map=self.device_map,\n        token=self.token or os.getenv(\"HF_TOKEN\"),\n        return_full_text=False,\n    )\n\n    if self.chat_template is not None:\n        self._pipeline.tokenizer.chat_template = self.chat_template  # type: ignore\n    elif (\n        self._pipeline.tokenizer.chat_template is None  # type: ignore\n        and self._pipeline.tokenizer.default_chat_template is None  # type: ignore\n    ):\n        self._pipeline.tokenizer.chat_template = CHATML_TEMPLATE  # type: ignore\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.TransformersLLM.prepare_input","title":"<code>prepare_input(input)</code>","text":"<p>Prepares the input by applying the chat template to the input, which is formatted as an OpenAI conversation, and adding the generation prompt.</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>def prepare_input(self, input: \"ChatType\") -&gt; str:\n    \"\"\"Prepares the input by applying the chat template to the input, which is formatted\n    as an OpenAI conversation, and adding the generation prompt.\n    \"\"\"\n    return self._pipeline.tokenizer.apply_chat_template(  # type: ignore\n        input,  # type: ignore\n        tokenize=False,\n        add_generation_prompt=True,\n    )\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.VertexAILLM","title":"<code>VertexAILLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>VertexAI LLM implementation running the async API clients for Gemini.</p> <ul> <li>Gemini API: https://cloud.google.com/vertex-ai/docs/generative-ai/model-reference/gemini</li> </ul> <p>To use the <code>VertexAILLM</code> is necessary to have configured the Google Cloud authentication using one of these methods:</p> <ul> <li>Setting <code>GOOGLE_CLOUD_CREDENTIALS</code> environment variable</li> <li>Using <code>gcloud auth application-default login</code> command</li> <li>Using <code>vertexai.init</code> function from the <code>google-cloud-aiplatform</code> library</li> </ul> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model name to use for the LLM e.g. \"gemini-1.0-pro\". Supported models.</p> <code>_aclient</code> <code>Optional[GenerativeModel]</code> <p>the <code>GenerativeModel</code> to use for the Vertex AI Gemini API. It is meant to be used internally. Set in the <code>load</code> method.</p> Source code in <code>src/distilabel/llms/vertexai.py</code> <pre><code>class VertexAILLM(AsyncLLM):\n    \"\"\"VertexAI LLM implementation running the async API clients for Gemini.\n\n    - Gemini API: https://cloud.google.com/vertex-ai/docs/generative-ai/model-reference/gemini\n\n    To use the `VertexAILLM` is necessary to have configured the Google Cloud authentication\n    using one of these methods:\n\n    - Setting `GOOGLE_CLOUD_CREDENTIALS` environment variable\n    - Using `gcloud auth application-default login` command\n    - Using `vertexai.init` function from the `google-cloud-aiplatform` library\n\n    Attributes:\n        model: the model name to use for the LLM e.g. \"gemini-1.0-pro\". [Supported models](https://cloud.google.com/vertex-ai/generative-ai/docs/learn/models).\n        _aclient: the `GenerativeModel` to use for the Vertex AI Gemini API. It is meant\n            to be used internally. Set in the `load` method.\n    \"\"\"\n\n    model: str\n    _aclient: Optional[\"GenerativeModel\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `GenerativeModel` class which has access to `generate_content_async` to benefit from async requests.\"\"\"\n        super().load()\n\n        try:\n            from vertexai.generative_models import GenerationConfig, GenerativeModel\n\n            self._generation_config_class = GenerationConfig\n        except ImportError as e:\n            raise ImportError(\n                \"vertexai is not installed. Please install it using\"\n                \" `pip install google-cloud-aiplatform`.\"\n            ) from e\n\n        if _is_gemini_model(self.model):\n            self._aclient = GenerativeModel(model_name=self.model)\n        else:\n            raise NotImplementedError(\n                \"`VertexAILLM` is only implemented for `gemini` models that allow for `ChatType` data.\"\n            )\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    def _chattype_to_content(self, input: \"ChatType\") -&gt; List[\"Content\"]:\n        \"\"\"Converts a chat type to a list of content items expected by the API.\n\n        Args:\n            input: the chat type to be converted.\n\n        Returns:\n            List[str]: a list of content items expected by the API.\n        \"\"\"\n        from vertexai.generative_models import Content, Part\n\n        contents = []\n        for message in input:\n            if message[\"role\"] not in [\"user\", \"model\"]:\n                raise ValueError(\n                    \"`VertexAILLM only supports the roles 'user' or 'model'.\"\n                )\n            contents.append(\n                Content(\n                    role=message[\"role\"], parts=[Part.from_text(message[\"content\"])]\n                )\n            )\n        return contents\n\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        num_generations: int = 1,\n        temperature: Optional[float] = None,\n        top_p: Optional[float] = None,\n        top_k: Optional[int] = None,\n        max_output_tokens: Optional[int] = None,\n        stop_sequences: Optional[List[str]] = None,\n        safety_settings: Optional[\"SafetySettingsType\"] = None,\n        tools: Optional[List[\"Tool\"]] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates `num_generations` responses for the given input using the [VertexAI async client definition](https://cloud.google.com/vertex-ai/docs/generative-ai/model-reference/gemini).\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            num_generations: the number of generations to create per input. Defaults to\n                `1`.\n            temperature: Controls the randomness of predictions. Range: [0.0, 1.0]. Defaults to `None`.\n            top_p: If specified, nucleus sampling will be used. Range: (0.0, 1.0]. Defaults to `None`.\n            top_k: If specified, top-k sampling will be used. Defaults to `None`.\n            max_output_tokens: The maximum number of output tokens to generate per message. Defaults to `None`.\n            stop_sequences: A list of stop sequences. Defaults to `None`.\n            safety_settings: Safety configuration for returned content from the API. Defaults to `None`.\n            tools: A potential list of tools that can be used by the API. Defaults to `None`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        from vertexai.generative_models import GenerationConfig\n\n        contents = self._chattype_to_content(input)\n        generations = []\n        # TODO: remove this for-loop and override `generate`\n        for _ in range(num_generations):\n            content = await self._aclient.generate_content_async(  # type: ignore\n                contents=contents,\n                generation_config=GenerationConfig(\n                    candidate_count=1,  # only one candidate allowed per call\n                    temperature=temperature,\n                    top_k=top_k,\n                    top_p=top_p,\n                    max_output_tokens=max_output_tokens,\n                    stop_sequences=stop_sequences,\n                ),\n                safety_settings=safety_settings,\n                tools=tools,\n                stream=False,\n            )\n\n            text = None\n            try:\n                text = content.candidates[0].text\n            except ValueError:\n                self._logger.warning(\n                    f\"Received no response using VertexAI client (model: '{self.model}').\"\n                    f\" Finish reason was: '{content.candidates[0].finish_reason}'.\"\n                )\n            generations.append(text)\n\n        return generations\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.VertexAILLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/#distilabel.llms.VertexAILLM.agenerate","title":"<code>agenerate(input, num_generations=1, temperature=None, top_p=None, top_k=None, max_output_tokens=None, stop_sequences=None, safety_settings=None, tools=None)</code>  <code>async</code>","text":"<p>Generates <code>num_generations</code> responses for the given input using the VertexAI async client definition.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to create per input. Defaults to <code>1</code>.</p> <code>1</code> <code>temperature</code> <code>Optional[float]</code> <p>Controls the randomness of predictions. Range: [0.0, 1.0]. Defaults to <code>None</code>.</p> <code>None</code> <code>top_p</code> <code>Optional[float]</code> <p>If specified, nucleus sampling will be used. Range: (0.0, 1.0]. Defaults to <code>None</code>.</p> <code>None</code> <code>top_k</code> <code>Optional[int]</code> <p>If specified, top-k sampling will be used. Defaults to <code>None</code>.</p> <code>None</code> <code>max_output_tokens</code> <code>Optional[int]</code> <p>The maximum number of output tokens to generate per message. Defaults to <code>None</code>.</p> <code>None</code> <code>stop_sequences</code> <code>Optional[List[str]]</code> <p>A list of stop sequences. Defaults to <code>None</code>.</p> <code>None</code> <code>safety_settings</code> <code>Optional[SafetySettingsType]</code> <p>Safety configuration for returned content from the API. Defaults to <code>None</code>.</p> <code>None</code> <code>tools</code> <code>Optional[List[Tool]]</code> <p>A potential list of tools that can be used by the API. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>GenerateOutput</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/vertexai.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    num_generations: int = 1,\n    temperature: Optional[float] = None,\n    top_p: Optional[float] = None,\n    top_k: Optional[int] = None,\n    max_output_tokens: Optional[int] = None,\n    stop_sequences: Optional[List[str]] = None,\n    safety_settings: Optional[\"SafetySettingsType\"] = None,\n    tools: Optional[List[\"Tool\"]] = None,\n) -&gt; \"GenerateOutput\":\n    \"\"\"Generates `num_generations` responses for the given input using the [VertexAI async client definition](https://cloud.google.com/vertex-ai/docs/generative-ai/model-reference/gemini).\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        num_generations: the number of generations to create per input. Defaults to\n            `1`.\n        temperature: Controls the randomness of predictions. Range: [0.0, 1.0]. Defaults to `None`.\n        top_p: If specified, nucleus sampling will be used. Range: (0.0, 1.0]. Defaults to `None`.\n        top_k: If specified, top-k sampling will be used. Defaults to `None`.\n        max_output_tokens: The maximum number of output tokens to generate per message. Defaults to `None`.\n        stop_sequences: A list of stop sequences. Defaults to `None`.\n        safety_settings: Safety configuration for returned content from the API. Defaults to `None`.\n        tools: A potential list of tools that can be used by the API. Defaults to `None`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    from vertexai.generative_models import GenerationConfig\n\n    contents = self._chattype_to_content(input)\n    generations = []\n    # TODO: remove this for-loop and override `generate`\n    for _ in range(num_generations):\n        content = await self._aclient.generate_content_async(  # type: ignore\n            contents=contents,\n            generation_config=GenerationConfig(\n                candidate_count=1,  # only one candidate allowed per call\n                temperature=temperature,\n                top_k=top_k,\n                top_p=top_p,\n                max_output_tokens=max_output_tokens,\n                stop_sequences=stop_sequences,\n            ),\n            safety_settings=safety_settings,\n            tools=tools,\n            stream=False,\n        )\n\n        text = None\n        try:\n            text = content.candidates[0].text\n        except ValueError:\n            self._logger.warning(\n                f\"Received no response using VertexAI client (model: '{self.model}').\"\n                f\" Finish reason was: '{content.candidates[0].finish_reason}'.\"\n            )\n        generations.append(text)\n\n    return generations\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.VertexAILLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>GenerativeModel</code> class which has access to <code>generate_content_async</code> to benefit from async requests.</p> Source code in <code>src/distilabel/llms/vertexai.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `GenerativeModel` class which has access to `generate_content_async` to benefit from async requests.\"\"\"\n    super().load()\n\n    try:\n        from vertexai.generative_models import GenerationConfig, GenerativeModel\n\n        self._generation_config_class = GenerationConfig\n    except ImportError as e:\n        raise ImportError(\n            \"vertexai is not installed. Please install it using\"\n            \" `pip install google-cloud-aiplatform`.\"\n        ) from e\n\n    if _is_gemini_model(self.model):\n        self._aclient = GenerativeModel(model_name=self.model)\n    else:\n        raise NotImplementedError(\n            \"`VertexAILLM` is only implemented for `gemini` models that allow for `ChatType` data.\"\n        )\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.vLLM","title":"<code>vLLM</code>","text":"<p>             Bases: <code>LLM</code>, <code>CudaDevicePlacementMixin</code></p> <p><code>vLLM</code> library LLM implementation.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model Hugging Face Hub repo id or a path to a directory containing the model weights and configuration files.</p> <code>model_kwargs</code> <code>Optional[RuntimeParameter[Dict[str, Any]]]</code> <p>additional dictionary of keyword arguments that will be passed to the <code>LLM</code> class of <code>vllm</code> library.</p> <code>chat_template</code> <code>Optional[str]</code> <p>a chat template that will be used to build the prompts before sending them to the model. If not provided, the chat template defined in the tokenizer config will be used. If not provided and the tokenizer doesn't have a chat template, then ChatML template will be used. Defaults to <code>None</code>.</p> <code>_model</code> <code>Optional[LLM]</code> <p>the <code>vLLM</code> model instance. This attribute is meant to be used internally and should not be accessed directly. It will be set in the <code>load</code> method.</p> <code>_tokenizer</code> <code>Optional[PreTrainedTokenizer]</code> <p>the tokenizer instance used to format the prompt before passing it to the <code>LLM</code>. This attribute is meant to be used internally and should not be accessed directly. It will be set in the <code>load</code> method.</p> Runtime parameters <ul> <li><code>model_kwargs</code>: additional dictionary of keyword arguments that will be passed to     the <code>LLM</code> class of <code>vllm</code> library.</li> </ul> Source code in <code>src/distilabel/llms/vllm.py</code> <pre><code>class vLLM(LLM, CudaDevicePlacementMixin):\n    \"\"\"`vLLM` library LLM implementation.\n\n    Attributes:\n        model: the model Hugging Face Hub repo id or a path to a directory containing the\n            model weights and configuration files.\n        model_kwargs: additional dictionary of keyword arguments that will be passed to\n            the `LLM` class of `vllm` library.\n        chat_template: a chat template that will be used to build the prompts before\n            sending them to the model. If not provided, the chat template defined in the\n            tokenizer config will be used. If not provided and the tokenizer doesn't have\n            a chat template, then ChatML template will be used. Defaults to `None`.\n        _model: the `vLLM` model instance. This attribute is meant to be used internally\n            and should not be accessed directly. It will be set in the `load` method.\n        _tokenizer: the tokenizer instance used to format the prompt before passing it to\n            the `LLM`. This attribute is meant to be used internally and should not be\n            accessed directly. It will be set in the `load` method.\n\n    Runtime parameters:\n        - `model_kwargs`: additional dictionary of keyword arguments that will be passed to\n            the `LLM` class of `vllm` library.\n    \"\"\"\n\n    model: str\n    model_kwargs: Optional[RuntimeParameter[Dict[str, Any]]] = Field(\n        default_factory=dict,\n        description=\"Additional dictionary of keyword arguments that will be passed to the\"\n        \" `LLM` class of `vllm` library.\",\n    )\n    chat_template: Optional[str] = None\n\n    _model: Optional[\"_vLLM\"] = PrivateAttr(...)\n    _tokenizer: Optional[\"PreTrainedTokenizer\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `vLLM` model using either the path or the Hugging Face Hub repository id.\n        Additionally, this method also sets the `chat_template` for the tokenizer, so as to properly\n        parse the list of OpenAI formatted inputs using the expected format by the model, otherwise, the\n        default value is ChatML format, unless explicitly provided.\n        \"\"\"\n        super().load()\n\n        CudaDevicePlacementMixin.load(self)\n\n        try:\n            from vllm import LLM as _vLLM\n            from vllm import SamplingParams as _SamplingParams\n\n            global SamplingParams\n            SamplingParams = _SamplingParams\n        except ImportError as ie:\n            raise ImportError(\n                \"vLLM is not installed. Please install it using `pip install vllm`.\"\n            ) from ie\n\n        self._model = _vLLM(self.model, **self.model_kwargs)  # type: ignore\n        self._tokenizer = self._model.get_tokenizer()  # type: ignore\n\n        if self.chat_template is not None:\n            self._tokenizer.chat_template = self.chat_template  # type: ignore\n        elif (\n            self._tokenizer.chat_template is None  # type: ignore\n            and self._tokenizer.default_chat_template is None  # type: ignore\n        ):\n            self._tokenizer.chat_template = CHATML_TEMPLATE\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    def prepare_input(self, input: \"ChatType\") -&gt; str:\n        \"\"\"Prepares the input by applying the chat template to the input, which is formatted\n        as an OpenAI conversation, and adding the generation prompt.\n        \"\"\"\n        return self._tokenizer.apply_chat_template(  # type: ignore\n            input,  # type: ignore\n            tokenize=False,\n            add_generation_prompt=True,  # type: ignore\n        )\n\n    def generate(\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        max_new_tokens: int = 128,\n        frequency_penalty: float = 0.0,\n        presence_penalty: float = 0.0,\n        temperature: float = 1.0,\n        top_p: float = 1.0,\n        top_k: int = -1,\n        extra_sampling_params: Optional[Dict[str, Any]] = None,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Generates `num_generations` responses for each input using the text generation\n        pipeline.\n\n        Args:\n            inputs: a list of inputs in chat format to generate responses for.\n            num_generations: the number of generations to create per input. Defaults to\n                `1`.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            frequency_penalty: the repetition penalty to use for the generation. Defaults\n                to `0.0`.\n            presence_penalty: the presence penalty to use for the generation. Defaults to\n                `0.0`.\n            temperature: the temperature to use for the generation. Defaults to `0.1`.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n            top_k: the top-k value to use for the generation. Defaults to `0`.\n            extra_sampling_params: dictionary with additional arguments to be passed to\n                the `SamplingParams` class from `vllm`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        if extra_sampling_params is None:\n            extra_sampling_params = {}\n        sampling_params = SamplingParams(  # type: ignore\n            n=num_generations,\n            presence_penalty=presence_penalty,\n            frequency_penalty=frequency_penalty,\n            temperature=temperature,\n            top_p=top_p,\n            top_k=top_k,\n            max_tokens=max_new_tokens,\n            **extra_sampling_params,\n        )\n\n        prepared_inputs = [self.prepare_input(input) for input in inputs]\n        batch_outputs = self._model.generate(  # type: ignore\n            prepared_inputs,\n            sampling_params,\n            use_tqdm=False,  # type: ignore\n        )\n        return [\n            [output.text for output in outputs.outputs] for outputs in batch_outputs\n        ]\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.vLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/#distilabel.llms.vLLM.generate","title":"<code>generate(inputs, num_generations=1, max_new_tokens=128, frequency_penalty=0.0, presence_penalty=0.0, temperature=1.0, top_p=1.0, top_k=-1, extra_sampling_params=None)</code>","text":"<p>Generates <code>num_generations</code> responses for each input using the text generation pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>List[ChatType]</code> <p>a list of inputs in chat format to generate responses for.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to create per input. Defaults to <code>1</code>.</p> <code>1</code> <code>max_new_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>frequency_penalty</code> <code>float</code> <p>the repetition penalty to use for the generation. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>presence_penalty</code> <code>float</code> <p>the presence penalty to use for the generation. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Defaults to <code>0.1</code>.</p> <code>1.0</code> <code>top_p</code> <code>float</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>top_k</code> <code>int</code> <p>the top-k value to use for the generation. Defaults to <code>0</code>.</p> <code>-1</code> <code>extra_sampling_params</code> <code>Optional[Dict[str, Any]]</code> <p>dictionary with additional arguments to be passed to the <code>SamplingParams</code> class from <code>vllm</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[GenerateOutput]</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/vllm.py</code> <pre><code>def generate(\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    max_new_tokens: int = 128,\n    frequency_penalty: float = 0.0,\n    presence_penalty: float = 0.0,\n    temperature: float = 1.0,\n    top_p: float = 1.0,\n    top_k: int = -1,\n    extra_sampling_params: Optional[Dict[str, Any]] = None,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Generates `num_generations` responses for each input using the text generation\n    pipeline.\n\n    Args:\n        inputs: a list of inputs in chat format to generate responses for.\n        num_generations: the number of generations to create per input. Defaults to\n            `1`.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        frequency_penalty: the repetition penalty to use for the generation. Defaults\n            to `0.0`.\n        presence_penalty: the presence penalty to use for the generation. Defaults to\n            `0.0`.\n        temperature: the temperature to use for the generation. Defaults to `0.1`.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n        top_k: the top-k value to use for the generation. Defaults to `0`.\n        extra_sampling_params: dictionary with additional arguments to be passed to\n            the `SamplingParams` class from `vllm`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    if extra_sampling_params is None:\n        extra_sampling_params = {}\n    sampling_params = SamplingParams(  # type: ignore\n        n=num_generations,\n        presence_penalty=presence_penalty,\n        frequency_penalty=frequency_penalty,\n        temperature=temperature,\n        top_p=top_p,\n        top_k=top_k,\n        max_tokens=max_new_tokens,\n        **extra_sampling_params,\n    )\n\n    prepared_inputs = [self.prepare_input(input) for input in inputs]\n    batch_outputs = self._model.generate(  # type: ignore\n        prepared_inputs,\n        sampling_params,\n        use_tqdm=False,  # type: ignore\n    )\n    return [\n        [output.text for output in outputs.outputs] for outputs in batch_outputs\n    ]\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.vLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>vLLM</code> model using either the path or the Hugging Face Hub repository id. Additionally, this method also sets the <code>chat_template</code> for the tokenizer, so as to properly parse the list of OpenAI formatted inputs using the expected format by the model, otherwise, the default value is ChatML format, unless explicitly provided.</p> Source code in <code>src/distilabel/llms/vllm.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `vLLM` model using either the path or the Hugging Face Hub repository id.\n    Additionally, this method also sets the `chat_template` for the tokenizer, so as to properly\n    parse the list of OpenAI formatted inputs using the expected format by the model, otherwise, the\n    default value is ChatML format, unless explicitly provided.\n    \"\"\"\n    super().load()\n\n    CudaDevicePlacementMixin.load(self)\n\n    try:\n        from vllm import LLM as _vLLM\n        from vllm import SamplingParams as _SamplingParams\n\n        global SamplingParams\n        SamplingParams = _SamplingParams\n    except ImportError as ie:\n        raise ImportError(\n            \"vLLM is not installed. Please install it using `pip install vllm`.\"\n        ) from ie\n\n    self._model = _vLLM(self.model, **self.model_kwargs)  # type: ignore\n    self._tokenizer = self._model.get_tokenizer()  # type: ignore\n\n    if self.chat_template is not None:\n        self._tokenizer.chat_template = self.chat_template  # type: ignore\n    elif (\n        self._tokenizer.chat_template is None  # type: ignore\n        and self._tokenizer.default_chat_template is None  # type: ignore\n    ):\n        self._tokenizer.chat_template = CHATML_TEMPLATE\n</code></pre>"},{"location":"reference/distilabel/llms/#distilabel.llms.vLLM.prepare_input","title":"<code>prepare_input(input)</code>","text":"<p>Prepares the input by applying the chat template to the input, which is formatted as an OpenAI conversation, and adding the generation prompt.</p> Source code in <code>src/distilabel/llms/vllm.py</code> <pre><code>def prepare_input(self, input: \"ChatType\") -&gt; str:\n    \"\"\"Prepares the input by applying the chat template to the input, which is formatted\n    as an OpenAI conversation, and adding the generation prompt.\n    \"\"\"\n    return self._tokenizer.apply_chat_template(  # type: ignore\n        input,  # type: ignore\n        tokenize=False,\n        add_generation_prompt=True,  # type: ignore\n    )\n</code></pre>"},{"location":"reference/distilabel/llms/anthropic/","title":"Anthropic","text":""},{"location":"reference/distilabel/llms/anthropic/#distilabel.llms.anthropic.AnthropicLLM","title":"<code>AnthropicLLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>Anthropic LLM implementation running the Async API client.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the name of the model to use for the LLM e.g. \"claude-3-opus-20240229\", \"claude-3-sonnet-20240229\", etc. Available models can be checked here: Anthropic: Models overview.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Anthropic API. If not provided, it will be read from <code>ANTHROPIC_API_KEY</code> environment variable.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the Anthropic API. Defaults to <code>None</code> which means that <code>https://api.anthropic.com</code> will be used internally.</p> <code>timeout</code> <code>RuntimeParameter[float]</code> <p>the maximum time in seconds to wait for a response. Defaults to <code>600.0</code>.</p> <code>max_retries</code> <code>RuntimeParameter[int]</code> <p>The maximum number of times to retry the request before failing. Defaults to <code>6</code>.</p> <code>http_client</code> <code>Optional[AsyncClient]</code> <p>if provided, an alternative HTTP client to use for calling Anthropic API. Defaults to <code>None</code>.</p> <code>_api_key_env_var</code> <code>str</code> <p>the name of the environment variable to use for the API key. It is meant to be used internally.</p> <code>_aclient</code> <code>Optional[AsyncAnthropic]</code> <p>the <code>AsyncAnthropic</code> client to use for the Anthropic API. It is meant to be used internally. Set in the <code>load</code> method.</p> Runtime parameters <ul> <li><code>api_key</code>: the API key to authenticate the requests to the Anthropic API. If not     provided, it will be read from <code>ANTHROPIC_API_KEY</code> environment variable.</li> <li><code>base_url</code>: the base URL to use for the Anthropic API. Defaults to <code>\"https://api.anthropic.com\"</code>.</li> <li><code>timeout</code>: the maximum time in seconds to wait for a response. Defaults to <code>600.0</code>.</li> <li><code>max_retries</code>: the maximum number of times to retry the request before failing.     Defaults to <code>6</code>.</li> </ul> Source code in <code>src/distilabel/llms/anthropic.py</code> <pre><code>class AnthropicLLM(AsyncLLM):\n    \"\"\"Anthropic LLM implementation running the Async API client.\n\n    Attributes:\n        model: the name of the model to use for the LLM e.g. \"claude-3-opus-20240229\",\n            \"claude-3-sonnet-20240229\", etc. Available models can be checked here:\n            [Anthropic: Models overview](https://docs.anthropic.com/claude/docs/models-overview).\n        api_key: the API key to authenticate the requests to the Anthropic API. If not provided,\n            it will be read from `ANTHROPIC_API_KEY` environment variable.\n        base_url: the base URL to use for the Anthropic API. Defaults to `None` which means\n            that `https://api.anthropic.com` will be used internally.\n        timeout: the maximum time in seconds to wait for a response. Defaults to `600.0`.\n        max_retries: The maximum number of times to retry the request before failing. Defaults\n            to `6`.\n        http_client: if provided, an alternative HTTP client to use for calling Anthropic\n            API. Defaults to `None`.\n        _api_key_env_var: the name of the environment variable to use for the API key. It\n            is meant to be used internally.\n        _aclient: the `AsyncAnthropic` client to use for the Anthropic API. It is meant\n            to be used internally. Set in the `load` method.\n\n    Runtime parameters:\n        - `api_key`: the API key to authenticate the requests to the Anthropic API. If not\n            provided, it will be read from `ANTHROPIC_API_KEY` environment variable.\n        - `base_url`: the base URL to use for the Anthropic API. Defaults to `\"https://api.anthropic.com\"`.\n        - `timeout`: the maximum time in seconds to wait for a response. Defaults to `600.0`.\n        - `max_retries`: the maximum number of times to retry the request before failing.\n            Defaults to `6`.\n    \"\"\"\n\n    model: str\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(\n            \"ANTHROPIC_BASE_URL\", \"https://api.anthropic.com\"\n        ),\n        description=\"The base URL to use for the Anthropic API.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_ANTHROPIC_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Anthropic API.\",\n    )\n    timeout: RuntimeParameter[float] = Field(\n        default=600.0,\n        description=\"The maximum time in seconds to wait for a response from the API.\",\n    )\n    max_retries: RuntimeParameter[int] = Field(\n        default=6,\n        description=\"The maximum number of times to retry the request to the API before\"\n        \" failing.\",\n    )\n    http_client: Optional[AsyncClient] = Field(default=None, exclude=True)\n\n    _api_key_env_var: str = PrivateAttr(default=_ANTHROPIC_API_KEY_ENV_VAR_NAME)\n    _aclient: Optional[\"AsyncAnthropic\"] = PrivateAttr(...)\n\n    def _check_model_exists(self) -&gt; None:\n        \"\"\"Checks if the specified model exists in the available models.\"\"\"\n        from anthropic import AsyncAnthropic\n\n        annotation = get_type_hints(AsyncAnthropic().messages.create).get(\"model\", None)\n        models = [\n            value\n            for type_ in get_args(annotation)\n            if get_origin(type_) is Literal\n            for value in get_args(type_)\n        ]\n\n        if self.model not in models:\n            raise ValueError(\n                f\"Model {self.model} does not exist among available models. \"\n                f\"The available models are {', '.join(models)}\"\n            )\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `AsyncAnthropic` client to use the Anthropic async API.\"\"\"\n        super().load()\n\n        try:\n            from anthropic import AsyncAnthropic\n        except ImportError as ie:\n            raise ImportError(\n                \"Anthropic Python client is not installed. Please install it using\"\n                \" `pip install anthropic`.\"\n            ) from ie\n\n        if self.api_key is None:\n            raise ValueError(\n                f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n                f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n            )\n\n        self._check_model_exists()\n\n        self._aclient = AsyncAnthropic(\n            api_key=self.api_key.get_secret_value(),\n            base_url=self.base_url,\n            timeout=self.timeout,\n            http_client=self.http_client,\n            max_retries=self.max_retries,\n        )\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        max_tokens: int = 128,\n        stop_sequences: Union[List[str], None] = None,\n        temperature: float = 1.0,\n        top_p: Union[float, None] = None,\n        top_k: Union[int, None] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates a response asynchronously, using the [Anthropic Async API definition](https://github.com/anthropics/anthropic-sdk-python).\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            max_tokens: the maximum number of new tokens that the model will generate. Defaults to `128`.\n            stop_sequences: custom text sequences that will cause the model to stop generating. Defaults to `NOT_GIVEN`.\n            temperature: the temperature to use for the generation. Set only if top_p is None. Defaults to `1.0`.\n            top_p: the top-p value to use for the generation. Defaults to `NOT_GIVEN`.\n            top_k: the top-k value to use for the generation. Defaults to `NOT_GIVEN`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        from anthropic._types import NOT_GIVEN\n\n        completion = await self._aclient.messages.create(\n            model=self.model,\n            system=(\n                input.pop(0)[\"content\"]\n                if input and input[0][\"role\"] == \"system\"\n                else NOT_GIVEN\n            ),\n            messages=input,\n            max_tokens=max_tokens,\n            stream=False,\n            stop_sequences=NOT_GIVEN if stop_sequences is None else stop_sequences,\n            temperature=temperature,\n            top_p=NOT_GIVEN if top_p is None else top_p,\n            top_k=NOT_GIVEN if top_k is None else top_k,\n        )\n        generations = []\n        if (content := completion.content[0].text) is None:\n            self._logger.warning(\n                f\"Received no response using Anthropic client (model: '{self.model}').\"\n                f\" Finish reason was: {completion.stop_reason}\"\n            )\n        generations.append(content)\n        return generations\n\n    # TODO: remove this function once Anthropic client allows `n` parameter\n    @override\n    def generate(\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        **kwargs: Any,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Method to generate a list of responses asynchronously, returning the output\n        synchronously awaiting for the response of each input sent to `agenerate`.\n        \"\"\"\n\n        async def agenerate(\n            inputs: List[\"ChatType\"], **kwargs: Any\n        ) -&gt; \"GenerateOutput\":\n            \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n            tasks = [\n                asyncio.create_task(self.agenerate(input=input, **kwargs))\n                for input in inputs\n                for _ in range(num_generations)\n            ]\n            return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n        outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n        return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"reference/distilabel/llms/anthropic/#distilabel.llms.anthropic.AnthropicLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/anthropic/#distilabel.llms.anthropic.AnthropicLLM.agenerate","title":"<code>agenerate(input, max_tokens=128, stop_sequences=None, temperature=1.0, top_p=None, top_k=None)</code>  <code>async</code>","text":"<p>Generates a response asynchronously, using the Anthropic Async API definition.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>max_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>stop_sequences</code> <code>Union[List[str], None]</code> <p>custom text sequences that will cause the model to stop generating. Defaults to <code>NOT_GIVEN</code>.</p> <code>None</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Set only if top_p is None. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>top_p</code> <code>Union[float, None]</code> <p>the top-p value to use for the generation. Defaults to <code>NOT_GIVEN</code>.</p> <code>None</code> <code>top_k</code> <code>Union[int, None]</code> <p>the top-k value to use for the generation. Defaults to <code>NOT_GIVEN</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>GenerateOutput</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/anthropic.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    max_tokens: int = 128,\n    stop_sequences: Union[List[str], None] = None,\n    temperature: float = 1.0,\n    top_p: Union[float, None] = None,\n    top_k: Union[int, None] = None,\n) -&gt; \"GenerateOutput\":\n    \"\"\"Generates a response asynchronously, using the [Anthropic Async API definition](https://github.com/anthropics/anthropic-sdk-python).\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        max_tokens: the maximum number of new tokens that the model will generate. Defaults to `128`.\n        stop_sequences: custom text sequences that will cause the model to stop generating. Defaults to `NOT_GIVEN`.\n        temperature: the temperature to use for the generation. Set only if top_p is None. Defaults to `1.0`.\n        top_p: the top-p value to use for the generation. Defaults to `NOT_GIVEN`.\n        top_k: the top-k value to use for the generation. Defaults to `NOT_GIVEN`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    from anthropic._types import NOT_GIVEN\n\n    completion = await self._aclient.messages.create(\n        model=self.model,\n        system=(\n            input.pop(0)[\"content\"]\n            if input and input[0][\"role\"] == \"system\"\n            else NOT_GIVEN\n        ),\n        messages=input,\n        max_tokens=max_tokens,\n        stream=False,\n        stop_sequences=NOT_GIVEN if stop_sequences is None else stop_sequences,\n        temperature=temperature,\n        top_p=NOT_GIVEN if top_p is None else top_p,\n        top_k=NOT_GIVEN if top_k is None else top_k,\n    )\n    generations = []\n    if (content := completion.content[0].text) is None:\n        self._logger.warning(\n            f\"Received no response using Anthropic client (model: '{self.model}').\"\n            f\" Finish reason was: {completion.stop_reason}\"\n        )\n    generations.append(content)\n    return generations\n</code></pre>"},{"location":"reference/distilabel/llms/anthropic/#distilabel.llms.anthropic.AnthropicLLM.generate","title":"<code>generate(inputs, num_generations=1, **kwargs)</code>","text":"<p>Method to generate a list of responses asynchronously, returning the output synchronously awaiting for the response of each input sent to <code>agenerate</code>.</p> Source code in <code>src/distilabel/llms/anthropic.py</code> <pre><code>@override\ndef generate(\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    **kwargs: Any,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Method to generate a list of responses asynchronously, returning the output\n    synchronously awaiting for the response of each input sent to `agenerate`.\n    \"\"\"\n\n    async def agenerate(\n        inputs: List[\"ChatType\"], **kwargs: Any\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n        tasks = [\n            asyncio.create_task(self.agenerate(input=input, **kwargs))\n            for input in inputs\n            for _ in range(num_generations)\n        ]\n        return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n    outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n    return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"reference/distilabel/llms/anthropic/#distilabel.llms.anthropic.AnthropicLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>AsyncAnthropic</code> client to use the Anthropic async API.</p> Source code in <code>src/distilabel/llms/anthropic.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `AsyncAnthropic` client to use the Anthropic async API.\"\"\"\n    super().load()\n\n    try:\n        from anthropic import AsyncAnthropic\n    except ImportError as ie:\n        raise ImportError(\n            \"Anthropic Python client is not installed. Please install it using\"\n            \" `pip install anthropic`.\"\n        ) from ie\n\n    if self.api_key is None:\n        raise ValueError(\n            f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n            f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n        )\n\n    self._check_model_exists()\n\n    self._aclient = AsyncAnthropic(\n        api_key=self.api_key.get_secret_value(),\n        base_url=self.base_url,\n        timeout=self.timeout,\n        http_client=self.http_client,\n        max_retries=self.max_retries,\n    )\n</code></pre>"},{"location":"reference/distilabel/llms/anyscale/","title":"Anyscale","text":""},{"location":"reference/distilabel/llms/anyscale/#distilabel.llms.anyscale.AnyscaleLLM","title":"<code>AnyscaleLLM</code>","text":"<p>             Bases: <code>OpenAILLM</code></p> <p>Anyscale LLM implementation running the async API client of OpenAI because of duplicate API behavior.</p> <p>Attributes:</p> Name Type Description <code>model</code> <p>the model name to use for the LLM, e.g., <code>google/gemma-7b-it</code>. See the supported models under the \"Text Generation -&gt; Supported Models\" section here.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the Anyscale API requests. Defaults to <code>None</code>, which means that the value set for the environment variable <code>ANYSCALE_BASE_URL</code> will be used, or \"https://api.endpoints.anyscale.com/v1\" if not set.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Anyscale API. Defaults to <code>None</code> which means that the value set for the environment variable <code>ANYSCALE_API_KEY</code> will be used, or <code>None</code> if not set.</p> <code>_api_key_env_var</code> <code>str</code> <p>the name of the environment variable to use for the API key. It is meant to be used internally.</p> Source code in <code>src/distilabel/llms/anyscale.py</code> <pre><code>class AnyscaleLLM(OpenAILLM):\n    \"\"\"Anyscale LLM implementation running the async API client of OpenAI because of\n    duplicate API behavior.\n\n    Attributes:\n        model: the model name to use for the LLM, e.g., `google/gemma-7b-it`. See the\n            supported models under the \"Text Generation -&gt; Supported Models\" section\n            [here](https://docs.endpoints.anyscale.com/).\n        base_url: the base URL to use for the Anyscale API requests. Defaults to `None`, which\n            means that the value set for the environment variable `ANYSCALE_BASE_URL` will be used, or\n            \"https://api.endpoints.anyscale.com/v1\" if not set.\n        api_key: the API key to authenticate the requests to the Anyscale API. Defaults to `None` which\n            means that the value set for the environment variable `ANYSCALE_API_KEY` will be used, or\n            `None` if not set.\n        _api_key_env_var: the name of the environment variable to use for the API key.\n            It is meant to be used internally.\n    \"\"\"\n\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(\n            \"ANYSCALE_BASE_URL\", \"https://api.endpoints.anyscale.com/v1\"\n        ),\n        description=\"The base URL to use for the Anyscale API requests.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_ANYSCALE_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Anyscale API.\",\n    )\n\n    _api_key_env_var: str = PrivateAttr(_ANYSCALE_API_KEY_ENV_VAR_NAME)\n</code></pre>"},{"location":"reference/distilabel/llms/azure/","title":"Azure","text":""},{"location":"reference/distilabel/llms/azure/#distilabel.llms.azure.AzureOpenAILLM","title":"<code>AzureOpenAILLM</code>","text":"<p>             Bases: <code>OpenAILLM</code></p> <p>Azure OpenAI LLM implementation running the async API client of OpenAI because of duplicate API behavior, but with Azure-specific parameters.</p> <p>Attributes:</p> Name Type Description <code>model</code> <p>the model name to use for the LLM i.e. the name of the Azure deployment.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the Azure OpenAI API can be set with <code>AZURE_OPENAI_ENDPOINT</code>. Defaults to <code>None</code> which means that the value set for the environment variable <code>AZURE_OPENAI_ENDPOINT</code> will be used, or <code>None</code> if not set.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Azure OpenAI API. Defaults to <code>None</code> which means that the value set for the environment variable <code>AZURE_OPENAI_API_KEY</code> will be used, or <code>None</code> if not set.</p> <code>api_version</code> <code>Optional[RuntimeParameter[str]]</code> <p>the API version to use for the Azure OpenAI API. Defaults to <code>None</code> which means that the value set for the environment variable <code>OPENAI_API_VERSION</code> will be used, or <code>None</code> if not set.</p> Source code in <code>src/distilabel/llms/azure.py</code> <pre><code>class AzureOpenAILLM(OpenAILLM):\n    \"\"\"Azure OpenAI LLM implementation running the async API client of OpenAI because of\n    duplicate API behavior, but with Azure-specific parameters.\n\n    Attributes:\n        model: the model name to use for the LLM i.e. the name of the Azure deployment.\n        base_url: the base URL to use for the Azure OpenAI API can be set with `AZURE_OPENAI_ENDPOINT`.\n            Defaults to `None` which means that the value set for the environment variable\n            `AZURE_OPENAI_ENDPOINT` will be used, or `None` if not set.\n        api_key: the API key to authenticate the requests to the Azure OpenAI API. Defaults to `None`\n            which means that the value set for the environment variable `AZURE_OPENAI_API_KEY` will be\n            used, or `None` if not set.\n        api_version: the API version to use for the Azure OpenAI API. Defaults to `None` which means\n            that the value set for the environment variable `OPENAI_API_VERSION` will be used, or\n            `None` if not set.\n    \"\"\"\n\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(_AZURE_OPENAI_ENDPOINT_ENV_VAR_NAME),\n        description=\"The base URL to use for the Azure OpenAI API requests i.e. the Azure OpenAI endpoint.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_AZURE_OPENAI_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Azure OpenAI API.\",\n    )\n\n    api_version: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(\"OPENAI_API_VERSION\"),\n        description=\"The API version to use for the Azure OpenAI API.\",\n    )\n\n    _base_url_env_var: str = PrivateAttr(_AZURE_OPENAI_ENDPOINT_ENV_VAR_NAME)\n    _api_key_env_var: str = PrivateAttr(_AZURE_OPENAI_API_KEY_ENV_VAR_NAME)\n    _aclient: Optional[\"AsyncAzureOpenAI\"] = PrivateAttr(...)  # type: ignore\n\n    @override\n    def load(self) -&gt; None:\n        \"\"\"Loads the `AsyncAzureOpenAI` client to benefit from async requests.\"\"\"\n        super().load()\n\n        try:\n            from openai import AsyncAzureOpenAI\n        except ImportError as ie:\n            raise ImportError(\n                \"OpenAI Python client is not installed. Please install it using\"\n                \" `pip install openai`.\"\n            ) from ie\n\n        if self.api_key is None:\n            raise ValueError(\n                f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n                f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n            )\n\n        # TODO: May be worth adding the AD auth too? Also the `organization`?\n        self._aclient = AsyncAzureOpenAI(  # type: ignore\n            azure_endpoint=self.base_url,  # type: ignore\n            azure_deployment=self.model,\n            api_version=self.api_version,\n            api_key=self.api_key.get_secret_value(),\n            max_retries=self.max_retries,  # type: ignore\n            timeout=self.timeout,\n        )\n</code></pre>"},{"location":"reference/distilabel/llms/azure/#distilabel.llms.azure.AzureOpenAILLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>AsyncAzureOpenAI</code> client to benefit from async requests.</p> Source code in <code>src/distilabel/llms/azure.py</code> <pre><code>@override\ndef load(self) -&gt; None:\n    \"\"\"Loads the `AsyncAzureOpenAI` client to benefit from async requests.\"\"\"\n    super().load()\n\n    try:\n        from openai import AsyncAzureOpenAI\n    except ImportError as ie:\n        raise ImportError(\n            \"OpenAI Python client is not installed. Please install it using\"\n            \" `pip install openai`.\"\n        ) from ie\n\n    if self.api_key is None:\n        raise ValueError(\n            f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n            f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n        )\n\n    # TODO: May be worth adding the AD auth too? Also the `organization`?\n    self._aclient = AsyncAzureOpenAI(  # type: ignore\n        azure_endpoint=self.base_url,  # type: ignore\n        azure_deployment=self.model,\n        api_version=self.api_version,\n        api_key=self.api_key.get_secret_value(),\n        max_retries=self.max_retries,  # type: ignore\n        timeout=self.timeout,\n    )\n</code></pre>"},{"location":"reference/distilabel/llms/base/","title":"Base","text":""},{"location":"reference/distilabel/llms/base/#distilabel.llms.base.AsyncLLM","title":"<code>AsyncLLM</code>","text":"<p>             Bases: <code>LLM</code></p> <p>Abstract class for asynchronous LLMs, so as to benefit from the async capabilities of each LLM implementation. This class is meant to be subclassed by each LLM, and the method <code>agenerate</code> needs to be implemented to provide the asynchronous generation of responses.</p> <p>Attributes:</p> Name Type Description <code>_event_loop</code> <code>AbstractEventLoop</code> <p>the event loop to be used for the asynchronous generation of responses.</p> Source code in <code>src/distilabel/llms/base.py</code> <pre><code>class AsyncLLM(LLM):\n    \"\"\"Abstract class for asynchronous LLMs, so as to benefit from the async capabilities\n    of each LLM implementation. This class is meant to be subclassed by each LLM, and the\n    method `agenerate` needs to be implemented to provide the asynchronous generation of\n    responses.\n\n    Attributes:\n        _event_loop: the event loop to be used for the asynchronous generation of responses.\n    \"\"\"\n\n    _event_loop: \"asyncio.AbstractEventLoop\" = PrivateAttr(default=None)\n\n    @property\n    def generate_parameters(self) -&gt; List[inspect.Parameter]:\n        \"\"\"Returns the parameters of the `agenerate` method.\n\n        Returns:\n            A list containing the parameters of the `agenerate` method.\n        \"\"\"\n        return list(inspect.signature(self.agenerate).parameters.values())\n\n    @cached_property\n    def generate_parsed_docstring(self) -&gt; \"Docstring\":\n        \"\"\"Returns the parsed docstring of the `agenerate` method.\n\n        Returns:\n            The parsed docstring of the `agenerate` method.\n        \"\"\"\n        return parse_google_docstring(self.agenerate)\n\n    @property\n    def event_loop(self) -&gt; \"asyncio.AbstractEventLoop\":\n        if self._event_loop is None:\n            try:\n                self._event_loop = asyncio.get_running_loop()\n                if self._event_loop.is_closed():\n                    self._event_loop = asyncio.new_event_loop()  # type: ignore\n            except RuntimeError:\n                self._event_loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self._event_loop)\n        return self._event_loop\n\n    @abstractmethod\n    async def agenerate(\n        self, input: \"ChatType\", num_generations: int = 1, **kwargs: Any\n    ) -&gt; List[Union[str, None]]:\n        \"\"\"Method to generate a `num_generations` responses for a given input asynchronously,\n        and executed concurrently in `generate` method.\n        \"\"\"\n        pass\n\n    def generate(\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        **kwargs: Any,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Method to generate a list of responses asynchronously, returning the output\n        synchronously awaiting for the response of each input sent to `agenerate`.\n        \"\"\"\n\n        async def agenerate(\n            inputs: List[\"ChatType\"], **kwargs: Any\n        ) -&gt; List[List[Union[str, None]]]:\n            \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n            tasks = [\n                asyncio.create_task(\n                    self.agenerate(\n                        input=input, num_generations=num_generations, **kwargs\n                    )\n                )\n                for input in inputs\n            ]\n            return await asyncio.gather(*tasks)\n\n        return self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n\n    def __del__(self) -&gt; None:\n        \"\"\"Closes the event loop when the object is deleted.\"\"\"\n        if sys.meta_path is None:\n            return\n        if self.event_loop is not None:\n            self.event_loop.close()\n</code></pre>"},{"location":"reference/distilabel/llms/base/#distilabel.llms.base.AsyncLLM.generate_parameters","title":"<code>generate_parameters: List[inspect.Parameter]</code>  <code>property</code>","text":"<p>Returns the parameters of the <code>agenerate</code> method.</p> <p>Returns:</p> Type Description <code>List[Parameter]</code> <p>A list containing the parameters of the <code>agenerate</code> method.</p>"},{"location":"reference/distilabel/llms/base/#distilabel.llms.base.AsyncLLM.generate_parsed_docstring","title":"<code>generate_parsed_docstring: Docstring</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the parsed docstring of the <code>agenerate</code> method.</p> <p>Returns:</p> Type Description <code>Docstring</code> <p>The parsed docstring of the <code>agenerate</code> method.</p>"},{"location":"reference/distilabel/llms/base/#distilabel.llms.base.AsyncLLM.__del__","title":"<code>__del__()</code>","text":"<p>Closes the event loop when the object is deleted.</p> Source code in <code>src/distilabel/llms/base.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Closes the event loop when the object is deleted.\"\"\"\n    if sys.meta_path is None:\n        return\n    if self.event_loop is not None:\n        self.event_loop.close()\n</code></pre>"},{"location":"reference/distilabel/llms/base/#distilabel.llms.base.AsyncLLM.agenerate","title":"<code>agenerate(input, num_generations=1, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Method to generate a <code>num_generations</code> responses for a given input asynchronously, and executed concurrently in <code>generate</code> method.</p> Source code in <code>src/distilabel/llms/base.py</code> <pre><code>@abstractmethod\nasync def agenerate(\n    self, input: \"ChatType\", num_generations: int = 1, **kwargs: Any\n) -&gt; List[Union[str, None]]:\n    \"\"\"Method to generate a `num_generations` responses for a given input asynchronously,\n    and executed concurrently in `generate` method.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/distilabel/llms/base/#distilabel.llms.base.AsyncLLM.generate","title":"<code>generate(inputs, num_generations=1, **kwargs)</code>","text":"<p>Method to generate a list of responses asynchronously, returning the output synchronously awaiting for the response of each input sent to <code>agenerate</code>.</p> Source code in <code>src/distilabel/llms/base.py</code> <pre><code>def generate(\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    **kwargs: Any,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Method to generate a list of responses asynchronously, returning the output\n    synchronously awaiting for the response of each input sent to `agenerate`.\n    \"\"\"\n\n    async def agenerate(\n        inputs: List[\"ChatType\"], **kwargs: Any\n    ) -&gt; List[List[Union[str, None]]]:\n        \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n        tasks = [\n            asyncio.create_task(\n                self.agenerate(\n                    input=input, num_generations=num_generations, **kwargs\n                )\n            )\n            for input in inputs\n        ]\n        return await asyncio.gather(*tasks)\n\n    return self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n</code></pre>"},{"location":"reference/distilabel/llms/base/#distilabel.llms.base.LLM","title":"<code>LLM</code>","text":"<p>             Bases: <code>RuntimeParametersMixin</code>, <code>BaseModel</code>, <code>_Serializable</code>, <code>ABC</code></p> <p>Base class for <code>LLM</code>s to be used in <code>distilabel</code> framework.</p> <p>To implement an <code>LLM</code> subclass, you need to subclass this class and implement:     - <code>load</code> method to load the <code>LLM</code> if needed. Don't forget to call <code>super().load()</code>,         so the <code>_logger</code> attribute is initialized.     - <code>model_name</code> property to return the model name used for the LLM.     - <code>generate</code> method to generate <code>num_generations</code> per input in <code>inputs</code>.</p> <p>Attributes:</p> Name Type Description <code>generation_kwargs</code> <code>Optional[RuntimeParameter[Dict[str, Any]]]</code> <p>the kwargs to be propagated to either <code>generate</code> or <code>agenerate</code> methods within each <code>LLM</code>.</p> <code>_logger</code> <code>Union[Logger, None]</code> <p>the logger to be used for the <code>LLM</code>. It will be initialized when the <code>load</code> method is called.</p> Source code in <code>src/distilabel/llms/base.py</code> <pre><code>class LLM(RuntimeParametersMixin, BaseModel, _Serializable, ABC):\n    \"\"\"Base class for `LLM`s to be used in `distilabel` framework.\n\n    To implement an `LLM` subclass, you need to subclass this class and implement:\n        - `load` method to load the `LLM` if needed. Don't forget to call `super().load()`,\n            so the `_logger` attribute is initialized.\n        - `model_name` property to return the model name used for the LLM.\n        - `generate` method to generate `num_generations` per input in `inputs`.\n\n    Attributes:\n        generation_kwargs: the kwargs to be propagated to either `generate` or `agenerate`\n            methods within each `LLM`.\n        _logger: the logger to be used for the `LLM`. It will be initialized when the `load`\n            method is called.\n    \"\"\"\n\n    model_config = ConfigDict(\n        arbitrary_types_allowed=True, protected_namespaces=(), validate_default=True\n    )\n\n    generation_kwargs: Optional[RuntimeParameter[Dict[str, Any]]] = Field(\n        default_factory=dict,\n        description=\"The kwargs to be propagated to either `generate` or `agenerate`\"\n        \" methods within each `LLM`.\",\n    )\n\n    _logger: Union[logging.Logger, None] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Method to be called to initialize the `LLM` and its logger.\"\"\"\n        self._logger = logging.getLogger(f\"distilabel.llm.{self.model_name}\")\n\n    @property\n    @abstractmethod\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        pass\n\n    @abstractmethod\n    def generate(\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        **kwargs: Any,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Abstract method to be implemented by each LLM to generate `num_generations`\n        per input in `inputs`.\n\n        Args:\n            inputs: the list of inputs to generate responses for which follows OpenAI's\n                API format:\n\n                ```python\n                [\n                    {\"role\": \"system\", \"content\": \"You're a helpful assistant...\"},\n                    {\"role\": \"user\", \"content\": \"Give a template email for B2B communications...\"},\n                    {\"role\": \"assistant\", \"content\": \"Sure, here's a template you can use...\"},\n                    {\"role\": \"user\", \"content\": \"Modify the second paragraph...\"}\n                ]\n                ```\n            num_generations: the number of generations to generate per input.\n            **kwargs: the additional kwargs to be used for the generation.\n        \"\"\"\n        pass\n\n    @property\n    def generate_parameters(self) -&gt; List[\"inspect.Parameter\"]:\n        \"\"\"Returns the parameters of the `generate` method.\n\n        Returns:\n            A list containing the parameters of the `generate` method.\n        \"\"\"\n        return list(inspect.signature(self.generate).parameters.values())\n\n    @property\n    def runtime_parameters_names(self) -&gt; \"RuntimeParametersNames\":\n        \"\"\"Returns the runtime parameters of the `LLM`, which are combination of the\n        attributes of the `LLM` type hinted with `RuntimeParameter` and the parameters\n        of the `generate` method that are not `input` and `num_generations`.\n\n        Returns:\n            A dictionary with the name of the runtime parameters as keys and a boolean\n            indicating if the parameter is optional or not.\n        \"\"\"\n        runtime_parameters = super().runtime_parameters_names\n        runtime_parameters[\"generation_kwargs\"] = {}\n\n        # runtime parameters from the `generate` method\n        for param in self.generate_parameters:\n            if param.name in [\"input\", \"inputs\", \"num_generations\"]:\n                continue\n            is_optional = param.default != inspect.Parameter.empty\n            runtime_parameters[\"generation_kwargs\"][param.name] = is_optional\n\n        return runtime_parameters\n\n    def get_runtime_parameters_info(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Gets the information of the runtime parameters of the `LLM` such as the name\n        and the description. This function is meant to include the information of the runtime\n        parameters in the serialized data of the `LLM`.\n\n        Returns:\n            A list containing the information for each runtime parameter of the `LLM`.\n        \"\"\"\n        runtime_parameters_info = super().get_runtime_parameters_info()\n\n        generation_kwargs_info = next(\n            runtime_parameter_info\n            for runtime_parameter_info in runtime_parameters_info\n            if runtime_parameter_info[\"name\"] == \"generation_kwargs\"\n        )\n\n        generate_docstring_args = self.generate_parsed_docstring[\"args\"]\n\n        generation_kwargs_info[\"keys\"] = []\n        for key, value in generation_kwargs_info[\"optional\"].items():\n            info = {\"name\": key, \"optional\": value}\n            if description := generate_docstring_args.get(key):\n                info[\"description\"] = description\n            generation_kwargs_info[\"keys\"].append(info)\n\n        generation_kwargs_info.pop(\"optional\")\n\n        return runtime_parameters_info\n\n    @cached_property\n    def generate_parsed_docstring(self) -&gt; \"Docstring\":\n        \"\"\"Returns the parsed docstring of the `generate` method.\n\n        Returns:\n            The parsed docstring of the `generate` method.\n        \"\"\"\n        return parse_google_docstring(self.generate)\n\n    def get_last_hidden_states(self, inputs: List[\"ChatType\"]) -&gt; List[\"HiddenState\"]:\n        \"\"\"Method to get the last hidden states of the model for a list of inputs.\n\n        Args:\n            inputs: the list of inputs to get the last hidden states from.\n\n        Returns:\n            A list containing the last hidden state for each sequence using a NumPy array\n                with shape [num_tokens, hidden_size].\n        \"\"\"\n        raise NotImplementedError(\n            f\"Method `get_last_hidden_states` is not implemented for `{self.__class__.__name__}`\"\n        )\n</code></pre>"},{"location":"reference/distilabel/llms/base/#distilabel.llms.base.LLM.generate_parameters","title":"<code>generate_parameters: List[inspect.Parameter]</code>  <code>property</code>","text":"<p>Returns the parameters of the <code>generate</code> method.</p> <p>Returns:</p> Type Description <code>List[Parameter]</code> <p>A list containing the parameters of the <code>generate</code> method.</p>"},{"location":"reference/distilabel/llms/base/#distilabel.llms.base.LLM.generate_parsed_docstring","title":"<code>generate_parsed_docstring: Docstring</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the parsed docstring of the <code>generate</code> method.</p> <p>Returns:</p> Type Description <code>Docstring</code> <p>The parsed docstring of the <code>generate</code> method.</p>"},{"location":"reference/distilabel/llms/base/#distilabel.llms.base.LLM.model_name","title":"<code>model_name: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/base/#distilabel.llms.base.LLM.runtime_parameters_names","title":"<code>runtime_parameters_names: RuntimeParametersNames</code>  <code>property</code>","text":"<p>Returns the runtime parameters of the <code>LLM</code>, which are combination of the attributes of the <code>LLM</code> type hinted with <code>RuntimeParameter</code> and the parameters of the <code>generate</code> method that are not <code>input</code> and <code>num_generations</code>.</p> <p>Returns:</p> Type Description <code>RuntimeParametersNames</code> <p>A dictionary with the name of the runtime parameters as keys and a boolean</p> <code>RuntimeParametersNames</code> <p>indicating if the parameter is optional or not.</p>"},{"location":"reference/distilabel/llms/base/#distilabel.llms.base.LLM.generate","title":"<code>generate(inputs, num_generations=1, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Abstract method to be implemented by each LLM to generate <code>num_generations</code> per input in <code>inputs</code>.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>List[ChatType]</code> <p>the list of inputs to generate responses for which follows OpenAI's API format:</p> <pre><code>[\n    {\"role\": \"system\", \"content\": \"You're a helpful assistant...\"},\n    {\"role\": \"user\", \"content\": \"Give a template email for B2B communications...\"},\n    {\"role\": \"assistant\", \"content\": \"Sure, here's a template you can use...\"},\n    {\"role\": \"user\", \"content\": \"Modify the second paragraph...\"}\n]\n</code></pre> required <code>num_generations</code> <code>int</code> <p>the number of generations to generate per input.</p> <code>1</code> <code>**kwargs</code> <code>Any</code> <p>the additional kwargs to be used for the generation.</p> <code>{}</code> Source code in <code>src/distilabel/llms/base.py</code> <pre><code>@abstractmethod\ndef generate(\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    **kwargs: Any,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Abstract method to be implemented by each LLM to generate `num_generations`\n    per input in `inputs`.\n\n    Args:\n        inputs: the list of inputs to generate responses for which follows OpenAI's\n            API format:\n\n            ```python\n            [\n                {\"role\": \"system\", \"content\": \"You're a helpful assistant...\"},\n                {\"role\": \"user\", \"content\": \"Give a template email for B2B communications...\"},\n                {\"role\": \"assistant\", \"content\": \"Sure, here's a template you can use...\"},\n                {\"role\": \"user\", \"content\": \"Modify the second paragraph...\"}\n            ]\n            ```\n        num_generations: the number of generations to generate per input.\n        **kwargs: the additional kwargs to be used for the generation.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/distilabel/llms/base/#distilabel.llms.base.LLM.get_last_hidden_states","title":"<code>get_last_hidden_states(inputs)</code>","text":"<p>Method to get the last hidden states of the model for a list of inputs.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>List[ChatType]</code> <p>the list of inputs to get the last hidden states from.</p> required <p>Returns:</p> Type Description <code>List[HiddenState]</code> <p>A list containing the last hidden state for each sequence using a NumPy array with shape [num_tokens, hidden_size].</p> Source code in <code>src/distilabel/llms/base.py</code> <pre><code>def get_last_hidden_states(self, inputs: List[\"ChatType\"]) -&gt; List[\"HiddenState\"]:\n    \"\"\"Method to get the last hidden states of the model for a list of inputs.\n\n    Args:\n        inputs: the list of inputs to get the last hidden states from.\n\n    Returns:\n        A list containing the last hidden state for each sequence using a NumPy array\n            with shape [num_tokens, hidden_size].\n    \"\"\"\n    raise NotImplementedError(\n        f\"Method `get_last_hidden_states` is not implemented for `{self.__class__.__name__}`\"\n    )\n</code></pre>"},{"location":"reference/distilabel/llms/base/#distilabel.llms.base.LLM.get_runtime_parameters_info","title":"<code>get_runtime_parameters_info()</code>","text":"<p>Gets the information of the runtime parameters of the <code>LLM</code> such as the name and the description. This function is meant to include the information of the runtime parameters in the serialized data of the <code>LLM</code>.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>A list containing the information for each runtime parameter of the <code>LLM</code>.</p> Source code in <code>src/distilabel/llms/base.py</code> <pre><code>def get_runtime_parameters_info(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"Gets the information of the runtime parameters of the `LLM` such as the name\n    and the description. This function is meant to include the information of the runtime\n    parameters in the serialized data of the `LLM`.\n\n    Returns:\n        A list containing the information for each runtime parameter of the `LLM`.\n    \"\"\"\n    runtime_parameters_info = super().get_runtime_parameters_info()\n\n    generation_kwargs_info = next(\n        runtime_parameter_info\n        for runtime_parameter_info in runtime_parameters_info\n        if runtime_parameter_info[\"name\"] == \"generation_kwargs\"\n    )\n\n    generate_docstring_args = self.generate_parsed_docstring[\"args\"]\n\n    generation_kwargs_info[\"keys\"] = []\n    for key, value in generation_kwargs_info[\"optional\"].items():\n        info = {\"name\": key, \"optional\": value}\n        if description := generate_docstring_args.get(key):\n            info[\"description\"] = description\n        generation_kwargs_info[\"keys\"].append(info)\n\n    generation_kwargs_info.pop(\"optional\")\n\n    return runtime_parameters_info\n</code></pre>"},{"location":"reference/distilabel/llms/base/#distilabel.llms.base.LLM.load","title":"<code>load()</code>","text":"<p>Method to be called to initialize the <code>LLM</code> and its logger.</p> Source code in <code>src/distilabel/llms/base.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Method to be called to initialize the `LLM` and its logger.\"\"\"\n    self._logger = logging.getLogger(f\"distilabel.llm.{self.model_name}\")\n</code></pre>"},{"location":"reference/distilabel/llms/chat_templates/","title":"Chat templates","text":""},{"location":"reference/distilabel/llms/cohere/","title":"Cohere","text":""},{"location":"reference/distilabel/llms/cohere/#distilabel.llms.cohere.CohereLLM","title":"<code>CohereLLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>Cohere API implementation using the async client for concurrent text generation.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the name of the model from the Cohere API to use for the generation.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the Cohere API requests. Defaults to <code>\"https://api.cohere.ai/v1\"</code>.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Cohere API. Defaults to the value of the <code>COHERE_API_KEY</code> environment variable.</p> <code>timeout</code> <code>RuntimeParameter[int]</code> <p>the maximum time in seconds to wait for a response from the API. Defaults to <code>120</code>.</p> <code>client_name</code> <code>RuntimeParameter[str]</code> <p>the name of the client to use for the API requests. Defaults to <code>\"distilabel\"</code>.</p> <code>_ChatMessage</code> <code>Type[ChatMessage]</code> <p>the <code>ChatMessage</code> class from the <code>cohere</code> package.</p> <code>_aclient</code> <code>AsyncClient</code> <p>the <code>AsyncClient</code> client from the <code>cohere</code> package.</p> Runtime parameters <ul> <li><code>base_url</code>: the base URL to use for the Cohere API requests. Defaults to     <code>\"https://api.cohere.ai/v1\"</code>.</li> <li><code>api_key</code>: the API key to authenticate the requests to the Cohere API. Defaults     to the value of the <code>COHERE_API_KEY</code> environment variable.</li> <li><code>timeout</code>: the maximum time in seconds to wait for a response from the API. Defaults     to <code>120</code>.</li> <li><code>client_name</code>: the name of the client to use for the API requests. Defaults to     <code>\"distilabel\"</code>.</li> </ul> Source code in <code>src/distilabel/llms/cohere.py</code> <pre><code>class CohereLLM(AsyncLLM):\n    \"\"\"Cohere API implementation using the async client for concurrent text generation.\n\n\n    Attributes:\n        model: the name of the model from the Cohere API to use for the generation.\n        base_url: the base URL to use for the Cohere API requests. Defaults to\n            `\"https://api.cohere.ai/v1\"`.\n        api_key: the API key to authenticate the requests to the Cohere API. Defaults to\n            the value of the `COHERE_API_KEY` environment variable.\n        timeout: the maximum time in seconds to wait for a response from the API. Defaults\n            to `120`.\n        client_name: the name of the client to use for the API requests. Defaults to\n            `\"distilabel\"`.\n        _ChatMessage: the `ChatMessage` class from the `cohere` package.\n        _aclient: the `AsyncClient` client from the `cohere` package.\n\n    Runtime parameters:\n        - `base_url`: the base URL to use for the Cohere API requests. Defaults to\n            `\"https://api.cohere.ai/v1\"`.\n        - `api_key`: the API key to authenticate the requests to the Cohere API. Defaults\n            to the value of the `COHERE_API_KEY` environment variable.\n        - `timeout`: the maximum time in seconds to wait for a response from the API. Defaults\n            to `120`.\n        - `client_name`: the name of the client to use for the API requests. Defaults to\n            `\"distilabel\"`.\n    \"\"\"\n\n    model: str\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(\n            \"COHERE_BASE_URL\", \"https://api.cohere.ai/v1\"\n        ),\n        description=\"The base URL to use for the Cohere API requests.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_COHERE_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Cohere API.\",\n    )\n    timeout: RuntimeParameter[int] = Field(\n        default=120,\n        description=\"The maximum time in seconds to wait for a response from the API.\",\n    )\n    client_name: RuntimeParameter[str] = Field(\n        default=\"distilabel\",\n        description=\"The name of the client to use for the API requests.\",\n    )\n\n    _ChatMessage: Type[\"ChatMessage\"] = PrivateAttr(...)\n    _aclient: \"AsyncClient\" = PrivateAttr(...)\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `AsyncClient` client from the `cohere` package.\"\"\"\n\n        super().load()\n\n        try:\n            from cohere import AsyncClient, ChatMessage\n        except ImportError as ie:\n            raise ImportError(\n                \"The `cohere` package is required to use the `CohereLLM` class.\"\n            ) from ie\n\n        self._ChatMessage = ChatMessage\n\n        self._aclient = AsyncClient(\n            api_key=self.api_key.get_secret_value(),  # type: ignore\n            client_name=self.client_name,\n            base_url=self.base_url,\n            timeout=self.timeout,\n        )\n\n    def _format_chat_to_cohere(\n        self, input: \"ChatType\"\n    ) -&gt; Tuple[Union[str, None], List[\"ChatMessage\"], str]:\n        \"\"\"Formats the chat input to the Cohere Chat API conversational format.\n\n        Args:\n            input: The chat input to format.\n\n        Returns:\n            A tuple containing the system, chat history, and message.\n        \"\"\"\n        system = None\n        message = None\n        chat_history = []\n        for item in input:\n            role = item[\"role\"]\n            content = item[\"content\"]\n            if role == \"system\":\n                system = content\n            elif role == \"user\":\n                message = content\n            elif role == \"assistant\":\n                if message is None:\n                    raise ValueError(\n                        \"An assistant message but be preceded by a user message.\"\n                    )\n                chat_history.append(self._ChatMessage(role=\"USER\", message=message))  # type: ignore\n                chat_history.append(self._ChatMessage(role=\"CHATBOT\", message=content))\n                message = None\n\n        if message is None:\n            raise ValueError(\"The chat input must end with a user message.\")\n\n        return system, chat_history, message\n\n    @override\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        temperature: Optional[float] = None,\n        max_tokens: Optional[int] = None,\n        k: Optional[int] = None,\n        p: Optional[float] = None,\n        seed: Optional[float] = None,\n        stop_sequences: Optional[Sequence[str]] = None,\n        frequency_penalty: Optional[float] = None,\n        presence_penalty: Optional[float] = None,\n        raw_prompting: Optional[bool] = None,\n    ) -&gt; Union[str, None]:\n        \"\"\"Generates a response from the LLM given an input.\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            temperature: the temperature to use for the generation. Defaults to `None`.\n            max_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `None`.\n            k: the number of highest probability vocabulary tokens to keep for the generation.\n                Defaults to `None`.\n            p: the nucleus sampling probability to use for the generation. Defaults to\n                `None`.\n            seed: the seed to use for the generation. Defaults to `None`.\n            stop_sequences: a list of sequences to use as stopping criteria for the generation.\n                Defaults to `None`.\n            frequency_penalty: the frequency penalty to use for the generation. Defaults\n                to `None`.\n            presence_penalty: the presence penalty to use for the generation. Defaults to\n                `None`.\n            raw_prompting: a flag to use raw prompting for the generation. Defaults to\n                `None`.\n\n        Returns:\n            The generated response from the Cohere API model.\n        \"\"\"\n        system, chat_history, message = self._format_chat_to_cohere(input)\n\n        response = await self._aclient.chat(  # type: ignore\n            message=message,\n            model=self.model,\n            preamble=system,\n            chat_history=chat_history,\n            temperature=temperature,\n            max_tokens=max_tokens,\n            k=k,\n            p=p,\n            seed=seed,\n            stop_sequences=stop_sequences,\n            frequency_penalty=frequency_penalty,\n            presence_penalty=presence_penalty,\n            raw_prompting=raw_prompting,\n        )\n\n        if (text := response.text) == \"\":\n            self._logger.warning(\n                f\"Received no response using Cohere client (model: '{self.model}').\"\n                f\" Finish reason was: {response.finish_reason}\"\n            )\n            return None\n\n        return text\n\n    @override\n    def generate(\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        **kwargs: Any,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Method to generate a list of responses asynchronously, returning the output\n        synchronously awaiting for the response of each input sent to `agenerate`.\"\"\"\n\n        async def agenerate(\n            inputs: List[\"ChatType\"], **kwargs: Any\n        ) -&gt; \"GenerateOutput\":\n            \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n            tasks = [\n                asyncio.create_task(self.agenerate(input=input, **kwargs))\n                for input in inputs\n                for _ in range(num_generations)\n            ]\n            return await asyncio.gather(*tasks)\n\n        outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n        return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"reference/distilabel/llms/cohere/#distilabel.llms.cohere.CohereLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/cohere/#distilabel.llms.cohere.CohereLLM.agenerate","title":"<code>agenerate(input, temperature=None, max_tokens=None, k=None, p=None, seed=None, stop_sequences=None, frequency_penalty=None, presence_penalty=None, raw_prompting=None)</code>  <code>async</code>","text":"<p>Generates a response from the LLM given an input.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>temperature</code> <code>Optional[float]</code> <p>the temperature to use for the generation. Defaults to <code>None</code>.</p> <code>None</code> <code>max_tokens</code> <code>Optional[int]</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>None</code>.</p> <code>None</code> <code>k</code> <code>Optional[int]</code> <p>the number of highest probability vocabulary tokens to keep for the generation. Defaults to <code>None</code>.</p> <code>None</code> <code>p</code> <code>Optional[float]</code> <p>the nucleus sampling probability to use for the generation. Defaults to <code>None</code>.</p> <code>None</code> <code>seed</code> <code>Optional[float]</code> <p>the seed to use for the generation. Defaults to <code>None</code>.</p> <code>None</code> <code>stop_sequences</code> <code>Optional[Sequence[str]]</code> <p>a list of sequences to use as stopping criteria for the generation. Defaults to <code>None</code>.</p> <code>None</code> <code>frequency_penalty</code> <code>Optional[float]</code> <p>the frequency penalty to use for the generation. Defaults to <code>None</code>.</p> <code>None</code> <code>presence_penalty</code> <code>Optional[float]</code> <p>the presence penalty to use for the generation. Defaults to <code>None</code>.</p> <code>None</code> <code>raw_prompting</code> <code>Optional[bool]</code> <p>a flag to use raw prompting for the generation. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>The generated response from the Cohere API model.</p> Source code in <code>src/distilabel/llms/cohere.py</code> <pre><code>@override\nasync def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    temperature: Optional[float] = None,\n    max_tokens: Optional[int] = None,\n    k: Optional[int] = None,\n    p: Optional[float] = None,\n    seed: Optional[float] = None,\n    stop_sequences: Optional[Sequence[str]] = None,\n    frequency_penalty: Optional[float] = None,\n    presence_penalty: Optional[float] = None,\n    raw_prompting: Optional[bool] = None,\n) -&gt; Union[str, None]:\n    \"\"\"Generates a response from the LLM given an input.\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        temperature: the temperature to use for the generation. Defaults to `None`.\n        max_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `None`.\n        k: the number of highest probability vocabulary tokens to keep for the generation.\n            Defaults to `None`.\n        p: the nucleus sampling probability to use for the generation. Defaults to\n            `None`.\n        seed: the seed to use for the generation. Defaults to `None`.\n        stop_sequences: a list of sequences to use as stopping criteria for the generation.\n            Defaults to `None`.\n        frequency_penalty: the frequency penalty to use for the generation. Defaults\n            to `None`.\n        presence_penalty: the presence penalty to use for the generation. Defaults to\n            `None`.\n        raw_prompting: a flag to use raw prompting for the generation. Defaults to\n            `None`.\n\n    Returns:\n        The generated response from the Cohere API model.\n    \"\"\"\n    system, chat_history, message = self._format_chat_to_cohere(input)\n\n    response = await self._aclient.chat(  # type: ignore\n        message=message,\n        model=self.model,\n        preamble=system,\n        chat_history=chat_history,\n        temperature=temperature,\n        max_tokens=max_tokens,\n        k=k,\n        p=p,\n        seed=seed,\n        stop_sequences=stop_sequences,\n        frequency_penalty=frequency_penalty,\n        presence_penalty=presence_penalty,\n        raw_prompting=raw_prompting,\n    )\n\n    if (text := response.text) == \"\":\n        self._logger.warning(\n            f\"Received no response using Cohere client (model: '{self.model}').\"\n            f\" Finish reason was: {response.finish_reason}\"\n        )\n        return None\n\n    return text\n</code></pre>"},{"location":"reference/distilabel/llms/cohere/#distilabel.llms.cohere.CohereLLM.generate","title":"<code>generate(inputs, num_generations=1, **kwargs)</code>","text":"<p>Method to generate a list of responses asynchronously, returning the output synchronously awaiting for the response of each input sent to <code>agenerate</code>.</p> Source code in <code>src/distilabel/llms/cohere.py</code> <pre><code>@override\ndef generate(\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    **kwargs: Any,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Method to generate a list of responses asynchronously, returning the output\n    synchronously awaiting for the response of each input sent to `agenerate`.\"\"\"\n\n    async def agenerate(\n        inputs: List[\"ChatType\"], **kwargs: Any\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n        tasks = [\n            asyncio.create_task(self.agenerate(input=input, **kwargs))\n            for input in inputs\n            for _ in range(num_generations)\n        ]\n        return await asyncio.gather(*tasks)\n\n    outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n    return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"reference/distilabel/llms/cohere/#distilabel.llms.cohere.CohereLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>AsyncClient</code> client from the <code>cohere</code> package.</p> Source code in <code>src/distilabel/llms/cohere.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `AsyncClient` client from the `cohere` package.\"\"\"\n\n    super().load()\n\n    try:\n        from cohere import AsyncClient, ChatMessage\n    except ImportError as ie:\n        raise ImportError(\n            \"The `cohere` package is required to use the `CohereLLM` class.\"\n        ) from ie\n\n    self._ChatMessage = ChatMessage\n\n    self._aclient = AsyncClient(\n        api_key=self.api_key.get_secret_value(),  # type: ignore\n        client_name=self.client_name,\n        base_url=self.base_url,\n        timeout=self.timeout,\n    )\n</code></pre>"},{"location":"reference/distilabel/llms/litellm/","title":"Litellm","text":""},{"location":"reference/distilabel/llms/litellm/#distilabel.llms.litellm.LiteLLM","title":"<code>LiteLLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>LiteLLM implementation running the async API client.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model name to use for the LLM e.g. \"gpt-3.5-turbo\" or \"mistral/mistral-large\", etc.</p> <code>verbose</code> <code>RuntimeParameter[bool]</code> <p>whether to log the LiteLLM client's logs. Defaults to <code>False</code>.</p> Runtime parameters <ul> <li><code>verbose</code>: whether to log the LiteLLM client's logs. Defaults to <code>False</code>.</li> </ul> Source code in <code>src/distilabel/llms/litellm.py</code> <pre><code>class LiteLLM(AsyncLLM):\n    \"\"\"LiteLLM implementation running the async API client.\n\n    Attributes:\n        model: the model name to use for the LLM e.g. \"gpt-3.5-turbo\" or \"mistral/mistral-large\", etc.\n        verbose: whether to log the LiteLLM client's logs. Defaults to `False`.\n\n    Runtime parameters:\n        - `verbose`: whether to log the LiteLLM client's logs. Defaults to `False`.\n    \"\"\"\n\n    model: str\n    verbose: RuntimeParameter[bool] = Field(\n        default=False, description=\"Whether to log the LiteLLM client's logs.\"\n    )\n\n    _aclient: Optional[Callable] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"\n        Loads the `acompletion` LiteLLM client to benefit from async requests.\n        \"\"\"\n        super().load()\n\n        try:\n            import litellm\n\n            litellm.telemetry = False\n        except ImportError as e:\n            raise ImportError(\n                \"LiteLLM Python client is not installed. Please install it using\"\n                \" `pip install litellm`.\"\n            ) from e\n        self._aclient = litellm.acompletion\n\n        if not self.verbose:\n            litellm.suppress_debug_info = True\n            for key in logging.Logger.manager.loggerDict.keys():\n                if \"litellm\" not in key.lower():\n                    continue\n                logging.getLogger(key).setLevel(logging.CRITICAL)\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        num_generations: int = 1,\n        functions: Optional[List] = None,\n        function_call: Optional[str] = None,\n        temperature: Optional[float] = 1.0,\n        top_p: Optional[float] = 1.0,\n        stop: Optional[Union[str, list]] = None,\n        max_tokens: Optional[int] = None,\n        presence_penalty: Optional[float] = None,\n        frequency_penalty: Optional[float] = None,\n        logit_bias: Optional[dict] = None,\n        user: Optional[str] = None,\n        metadata: Optional[dict] = None,\n        api_base: Optional[str] = None,\n        api_version: Optional[str] = None,\n        api_key: Optional[str] = None,\n        model_list: Optional[list] = None,\n        mock_response: Optional[str] = None,\n        force_timeout: Optional[int] = 600,\n        custom_llm_provider: Optional[str] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates `num_generations` responses for the given input using the [LiteLLM async client](https://github.com/BerriAI/litellm).\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            num_generations: the number of generations to create per input. Defaults to\n                `1`.\n            functions: a list of functions to apply to the conversation messages. Defaults to\n                `None`.\n            function_call: the name of the function to call within the conversation. Defaults\n                to `None`.\n            temperature: the temperature to use for the generation. Defaults to `1.0`.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n            stop: Up to 4 sequences where the LLM API will stop generating further tokens.\n                Defaults to `None`.\n            max_tokens: The maximum number of tokens in the generated completion. Defaults to\n                `None`.\n            presence_penalty: It is used to penalize new tokens based on their existence in the\n                text so far. Defaults to `None`.\n            frequency_penalty: It is used to penalize new tokens based on their frequency in the\n                text so far. Defaults to `None`.\n            logit_bias: Used to modify the probability of specific tokens appearing in the\n                completion. Defaults to `None`.\n            user: A unique identifier representing your end-user. This can help the LLM provider\n                to monitor and detect abuse. Defaults to `None`.\n            metadata: Pass in additional metadata to tag your completion calls - eg. prompt\n                version, details, etc. Defaults to `None`.\n            api_base: Base URL for the API. Defaults to `None`.\n            api_version: API version. Defaults to `None`.\n            api_key: API key. Defaults to `None`.\n            model_list: List of api base, version, keys. Defaults to `None`.\n            mock_response: If provided, return a mock completion response for testing or debugging\n                purposes. Defaults to `None`.\n            force_timeout: The maximum execution time in seconds for the completion request.\n                Defaults to `600`.\n            custom_llm_provider: Used for Non-OpenAI LLMs, Example usage for bedrock, set(iterable)\n                model=\"amazon.titan-tg1-large\" and custom_llm_provider=\"bedrock\". Defaults to\n                `None`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        import litellm\n\n        async def _call_aclient_until_n_choices() -&gt; List[\"Choices\"]:\n            choices = []\n            while len(choices) &lt; num_generations:\n                completion = await self._aclient(  # type: ignore\n                    model=self.model,\n                    messages=input,\n                    n=num_generations,\n                    functions=functions,\n                    function_call=function_call,\n                    temperature=temperature,\n                    top_p=top_p,\n                    stream=False,\n                    stop=stop,\n                    max_tokens=max_tokens,\n                    presence_penalty=presence_penalty,\n                    frequency_penalty=frequency_penalty,\n                    logit_bias=logit_bias,\n                    user=user,\n                    metadata=metadata,\n                    api_base=api_base,\n                    api_version=api_version,\n                    api_key=api_key,\n                    model_list=model_list,\n                    mock_response=mock_response,\n                    force_timeout=force_timeout,\n                    custom_llm_provider=custom_llm_provider,\n                )\n                choices.extend(completion.choices)\n            return choices\n\n        # litellm.drop_params is used to en/disable sending **kwargs parameters to the API if they cannot be used\n        try:\n            litellm.drop_params = False\n            choices = await _call_aclient_until_n_choices()\n        except litellm.exceptions.APIError as e:\n            if \"does not support parameters\" in str(e):\n                litellm.drop_params = True\n                choices = await _call_aclient_until_n_choices()\n            else:\n                raise e\n\n        generations = []\n        for choice in choices:\n            if (content := choice.message.content) is None:\n                self._logger.warning(\n                    f\"Received no response using LiteLLM client (model: '{self.model}').\"\n                    f\" Finish reason was: {choice.finish_reason}\"\n                )\n            generations.append(content)\n        return generations\n</code></pre>"},{"location":"reference/distilabel/llms/litellm/#distilabel.llms.litellm.LiteLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/litellm/#distilabel.llms.litellm.LiteLLM.agenerate","title":"<code>agenerate(input, num_generations=1, functions=None, function_call=None, temperature=1.0, top_p=1.0, stop=None, max_tokens=None, presence_penalty=None, frequency_penalty=None, logit_bias=None, user=None, metadata=None, api_base=None, api_version=None, api_key=None, model_list=None, mock_response=None, force_timeout=600, custom_llm_provider=None)</code>  <code>async</code>","text":"<p>Generates <code>num_generations</code> responses for the given input using the LiteLLM async client.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to create per input. Defaults to <code>1</code>.</p> <code>1</code> <code>functions</code> <code>Optional[List]</code> <p>a list of functions to apply to the conversation messages. Defaults to <code>None</code>.</p> <code>None</code> <code>function_call</code> <code>Optional[str]</code> <p>the name of the function to call within the conversation. Defaults to <code>None</code>.</p> <code>None</code> <code>temperature</code> <code>Optional[float]</code> <p>the temperature to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>top_p</code> <code>Optional[float]</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>stop</code> <code>Optional[Union[str, list]]</code> <p>Up to 4 sequences where the LLM API will stop generating further tokens. Defaults to <code>None</code>.</p> <code>None</code> <code>max_tokens</code> <code>Optional[int]</code> <p>The maximum number of tokens in the generated completion. Defaults to <code>None</code>.</p> <code>None</code> <code>presence_penalty</code> <code>Optional[float]</code> <p>It is used to penalize new tokens based on their existence in the text so far. Defaults to <code>None</code>.</p> <code>None</code> <code>frequency_penalty</code> <code>Optional[float]</code> <p>It is used to penalize new tokens based on their frequency in the text so far. Defaults to <code>None</code>.</p> <code>None</code> <code>logit_bias</code> <code>Optional[dict]</code> <p>Used to modify the probability of specific tokens appearing in the completion. Defaults to <code>None</code>.</p> <code>None</code> <code>user</code> <code>Optional[str]</code> <p>A unique identifier representing your end-user. This can help the LLM provider to monitor and detect abuse. Defaults to <code>None</code>.</p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>Pass in additional metadata to tag your completion calls - eg. prompt version, details, etc. Defaults to <code>None</code>.</p> <code>None</code> <code>api_base</code> <code>Optional[str]</code> <p>Base URL for the API. Defaults to <code>None</code>.</p> <code>None</code> <code>api_version</code> <code>Optional[str]</code> <p>API version. Defaults to <code>None</code>.</p> <code>None</code> <code>api_key</code> <code>Optional[str]</code> <p>API key. Defaults to <code>None</code>.</p> <code>None</code> <code>model_list</code> <code>Optional[list]</code> <p>List of api base, version, keys. Defaults to <code>None</code>.</p> <code>None</code> <code>mock_response</code> <code>Optional[str]</code> <p>If provided, return a mock completion response for testing or debugging purposes. Defaults to <code>None</code>.</p> <code>None</code> <code>force_timeout</code> <code>Optional[int]</code> <p>The maximum execution time in seconds for the completion request. Defaults to <code>600</code>.</p> <code>600</code> <code>custom_llm_provider</code> <code>Optional[str]</code> <p>Used for Non-OpenAI LLMs, Example usage for bedrock, set(iterable) model=\"amazon.titan-tg1-large\" and custom_llm_provider=\"bedrock\". Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>GenerateOutput</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/litellm.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    num_generations: int = 1,\n    functions: Optional[List] = None,\n    function_call: Optional[str] = None,\n    temperature: Optional[float] = 1.0,\n    top_p: Optional[float] = 1.0,\n    stop: Optional[Union[str, list]] = None,\n    max_tokens: Optional[int] = None,\n    presence_penalty: Optional[float] = None,\n    frequency_penalty: Optional[float] = None,\n    logit_bias: Optional[dict] = None,\n    user: Optional[str] = None,\n    metadata: Optional[dict] = None,\n    api_base: Optional[str] = None,\n    api_version: Optional[str] = None,\n    api_key: Optional[str] = None,\n    model_list: Optional[list] = None,\n    mock_response: Optional[str] = None,\n    force_timeout: Optional[int] = 600,\n    custom_llm_provider: Optional[str] = None,\n) -&gt; \"GenerateOutput\":\n    \"\"\"Generates `num_generations` responses for the given input using the [LiteLLM async client](https://github.com/BerriAI/litellm).\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        num_generations: the number of generations to create per input. Defaults to\n            `1`.\n        functions: a list of functions to apply to the conversation messages. Defaults to\n            `None`.\n        function_call: the name of the function to call within the conversation. Defaults\n            to `None`.\n        temperature: the temperature to use for the generation. Defaults to `1.0`.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n        stop: Up to 4 sequences where the LLM API will stop generating further tokens.\n            Defaults to `None`.\n        max_tokens: The maximum number of tokens in the generated completion. Defaults to\n            `None`.\n        presence_penalty: It is used to penalize new tokens based on their existence in the\n            text so far. Defaults to `None`.\n        frequency_penalty: It is used to penalize new tokens based on their frequency in the\n            text so far. Defaults to `None`.\n        logit_bias: Used to modify the probability of specific tokens appearing in the\n            completion. Defaults to `None`.\n        user: A unique identifier representing your end-user. This can help the LLM provider\n            to monitor and detect abuse. Defaults to `None`.\n        metadata: Pass in additional metadata to tag your completion calls - eg. prompt\n            version, details, etc. Defaults to `None`.\n        api_base: Base URL for the API. Defaults to `None`.\n        api_version: API version. Defaults to `None`.\n        api_key: API key. Defaults to `None`.\n        model_list: List of api base, version, keys. Defaults to `None`.\n        mock_response: If provided, return a mock completion response for testing or debugging\n            purposes. Defaults to `None`.\n        force_timeout: The maximum execution time in seconds for the completion request.\n            Defaults to `600`.\n        custom_llm_provider: Used for Non-OpenAI LLMs, Example usage for bedrock, set(iterable)\n            model=\"amazon.titan-tg1-large\" and custom_llm_provider=\"bedrock\". Defaults to\n            `None`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    import litellm\n\n    async def _call_aclient_until_n_choices() -&gt; List[\"Choices\"]:\n        choices = []\n        while len(choices) &lt; num_generations:\n            completion = await self._aclient(  # type: ignore\n                model=self.model,\n                messages=input,\n                n=num_generations,\n                functions=functions,\n                function_call=function_call,\n                temperature=temperature,\n                top_p=top_p,\n                stream=False,\n                stop=stop,\n                max_tokens=max_tokens,\n                presence_penalty=presence_penalty,\n                frequency_penalty=frequency_penalty,\n                logit_bias=logit_bias,\n                user=user,\n                metadata=metadata,\n                api_base=api_base,\n                api_version=api_version,\n                api_key=api_key,\n                model_list=model_list,\n                mock_response=mock_response,\n                force_timeout=force_timeout,\n                custom_llm_provider=custom_llm_provider,\n            )\n            choices.extend(completion.choices)\n        return choices\n\n    # litellm.drop_params is used to en/disable sending **kwargs parameters to the API if they cannot be used\n    try:\n        litellm.drop_params = False\n        choices = await _call_aclient_until_n_choices()\n    except litellm.exceptions.APIError as e:\n        if \"does not support parameters\" in str(e):\n            litellm.drop_params = True\n            choices = await _call_aclient_until_n_choices()\n        else:\n            raise e\n\n    generations = []\n    for choice in choices:\n        if (content := choice.message.content) is None:\n            self._logger.warning(\n                f\"Received no response using LiteLLM client (model: '{self.model}').\"\n                f\" Finish reason was: {choice.finish_reason}\"\n            )\n        generations.append(content)\n    return generations\n</code></pre>"},{"location":"reference/distilabel/llms/litellm/#distilabel.llms.litellm.LiteLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>acompletion</code> LiteLLM client to benefit from async requests.</p> Source code in <code>src/distilabel/llms/litellm.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"\n    Loads the `acompletion` LiteLLM client to benefit from async requests.\n    \"\"\"\n    super().load()\n\n    try:\n        import litellm\n\n        litellm.telemetry = False\n    except ImportError as e:\n        raise ImportError(\n            \"LiteLLM Python client is not installed. Please install it using\"\n            \" `pip install litellm`.\"\n        ) from e\n    self._aclient = litellm.acompletion\n\n    if not self.verbose:\n        litellm.suppress_debug_info = True\n        for key in logging.Logger.manager.loggerDict.keys():\n            if \"litellm\" not in key.lower():\n                continue\n            logging.getLogger(key).setLevel(logging.CRITICAL)\n</code></pre>"},{"location":"reference/distilabel/llms/llamacpp/","title":"Llamacpp","text":""},{"location":"reference/distilabel/llms/llamacpp/#distilabel.llms.llamacpp.LlamaCppLLM","title":"<code>LlamaCppLLM</code>","text":"<p>             Bases: <code>LLM</code></p> <p>llama.cpp LLM implementation running the Python bindings for the C++ code.</p> <p>Attributes:</p> Name Type Description <code>chat_format</code> <code>str</code> <p>the chat format to use for the model. Defaults to <code>chatml</code>.</p> <code>model_path</code> <code>RuntimeParameter[FilePath]</code> <p>contains the path to the GGUF quantized model, compatible with the installed version of the <code>llama.cpp</code> Python bindings.</p> <code>n_gpu_layers</code> <code>RuntimeParameter[int]</code> <p>the number of layers to use for the GPU. Defaults to <code>-1</code>, meaning that the available GPU device will be used.</p> <code>verbose</code> <code>RuntimeParameter[bool]</code> <p>whether to print verbose output. Defaults to <code>False</code>.</p> <code>_model</code> <code>Optional[Llama]</code> <p>the Llama model instance. This attribute is meant to be used internally and should not be accessed directly. It will be set in the <code>load</code> method.</p> Runtime parameters <ul> <li><code>model_path</code>: the path to the GGUF quantized model.</li> <li><code>n_gpu_layers</code>: the number of layers to use for the GPU. Defaults to <code>-1</code>.</li> <li><code>verbose</code>: whether to print verbose output. Defaults to <code>False</code>.</li> </ul> Source code in <code>src/distilabel/llms/llamacpp.py</code> <pre><code>class LlamaCppLLM(LLM):\n    \"\"\"llama.cpp LLM implementation running the Python bindings for the C++ code.\n\n    Attributes:\n        chat_format: the chat format to use for the model. Defaults to `chatml`.\n        model_path: contains the path to the GGUF quantized model, compatible with the\n            installed version of the `llama.cpp` Python bindings.\n        n_gpu_layers: the number of layers to use for the GPU. Defaults to `-1`, meaning that\n            the available GPU device will be used.\n        verbose: whether to print verbose output. Defaults to `False`.\n        _model: the Llama model instance. This attribute is meant to be used internally and\n            should not be accessed directly. It will be set in the `load` method.\n\n    Runtime parameters:\n        - `model_path`: the path to the GGUF quantized model.\n        - `n_gpu_layers`: the number of layers to use for the GPU. Defaults to `-1`.\n        - `verbose`: whether to print verbose output. Defaults to `False`.\n    \"\"\"\n\n    chat_format: str = \"chatml\"\n    model_path: RuntimeParameter[FilePath] = Field(\n        default=None, description=\"The path to the GGUF quantized model.\"\n    )\n    n_gpu_layers: RuntimeParameter[int] = Field(\n        default=-1,\n        description=\"The number of layers that will be loaded in the GPU.\",\n    )\n    verbose: RuntimeParameter[bool] = Field(\n        default=False,\n        description=\"Whether to print verbose output from llama.cpp library.\",\n    )\n\n    _model: Optional[\"Llama\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `Llama` model from the `model_path`.\"\"\"\n\n        try:\n            from llama_cpp import Llama\n        except ImportError as ie:\n            raise ImportError(\n                \"The `llama_cpp` package is required to use the `LlamaCppLLM` class.\"\n            ) from ie\n\n        self._model = Llama(\n            model_path=self.model_path.as_posix(),\n            chat_format=self.chat_format,\n            n_gpu_layers=self.n_gpu_layers,\n            verbose=self.verbose,\n        )\n\n        super().load()\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self._model.model_path  # type: ignore\n\n    def generate(  # type: ignore\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        max_new_tokens: int = 128,\n        frequency_penalty: float = 0.0,\n        presence_penalty: float = 0.0,\n        temperature: float = 1.0,\n        top_p: float = 1.0,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Generates `num_generations` responses for the given input using the Llama model.\n\n        Args:\n            inputs: a list of inputs in chat format to generate responses for.\n            num_generations: the number of generations to create per input. Defaults to\n                `1`.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            frequency_penalty: the repetition penalty to use for the generation. Defaults\n                to `0.0`.\n            presence_penalty: the presence penalty to use for the generation. Defaults to\n                `0.0`.\n            temperature: the temperature to use for the generation. Defaults to `0.1`.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        batch_outputs = []\n        for input in inputs:\n            outputs = []\n            for _ in range(num_generations):\n                chat_completions: \"CreateChatCompletionResponse\" = (\n                    self._model.create_chat_completion(  # type: ignore\n                        messages=input,  # type: ignore\n                        max_tokens=max_new_tokens,\n                        frequency_penalty=frequency_penalty,\n                        presence_penalty=presence_penalty,\n                        temperature=temperature,\n                        top_p=top_p,\n                    )\n                )\n                outputs.append(chat_completions[\"choices\"][0][\"message\"][\"content\"])\n            batch_outputs.append(outputs)\n        return batch_outputs\n</code></pre>"},{"location":"reference/distilabel/llms/llamacpp/#distilabel.llms.llamacpp.LlamaCppLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/llamacpp/#distilabel.llms.llamacpp.LlamaCppLLM.generate","title":"<code>generate(inputs, num_generations=1, max_new_tokens=128, frequency_penalty=0.0, presence_penalty=0.0, temperature=1.0, top_p=1.0)</code>","text":"<p>Generates <code>num_generations</code> responses for the given input using the Llama model.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>List[ChatType]</code> <p>a list of inputs in chat format to generate responses for.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to create per input. Defaults to <code>1</code>.</p> <code>1</code> <code>max_new_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>frequency_penalty</code> <code>float</code> <p>the repetition penalty to use for the generation. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>presence_penalty</code> <code>float</code> <p>the presence penalty to use for the generation. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Defaults to <code>0.1</code>.</p> <code>1.0</code> <code>top_p</code> <code>float</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>List[GenerateOutput]</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/llamacpp.py</code> <pre><code>def generate(  # type: ignore\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    max_new_tokens: int = 128,\n    frequency_penalty: float = 0.0,\n    presence_penalty: float = 0.0,\n    temperature: float = 1.0,\n    top_p: float = 1.0,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Generates `num_generations` responses for the given input using the Llama model.\n\n    Args:\n        inputs: a list of inputs in chat format to generate responses for.\n        num_generations: the number of generations to create per input. Defaults to\n            `1`.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        frequency_penalty: the repetition penalty to use for the generation. Defaults\n            to `0.0`.\n        presence_penalty: the presence penalty to use for the generation. Defaults to\n            `0.0`.\n        temperature: the temperature to use for the generation. Defaults to `0.1`.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    batch_outputs = []\n    for input in inputs:\n        outputs = []\n        for _ in range(num_generations):\n            chat_completions: \"CreateChatCompletionResponse\" = (\n                self._model.create_chat_completion(  # type: ignore\n                    messages=input,  # type: ignore\n                    max_tokens=max_new_tokens,\n                    frequency_penalty=frequency_penalty,\n                    presence_penalty=presence_penalty,\n                    temperature=temperature,\n                    top_p=top_p,\n                )\n            )\n            outputs.append(chat_completions[\"choices\"][0][\"message\"][\"content\"])\n        batch_outputs.append(outputs)\n    return batch_outputs\n</code></pre>"},{"location":"reference/distilabel/llms/llamacpp/#distilabel.llms.llamacpp.LlamaCppLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>Llama</code> model from the <code>model_path</code>.</p> Source code in <code>src/distilabel/llms/llamacpp.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `Llama` model from the `model_path`.\"\"\"\n\n    try:\n        from llama_cpp import Llama\n    except ImportError as ie:\n        raise ImportError(\n            \"The `llama_cpp` package is required to use the `LlamaCppLLM` class.\"\n        ) from ie\n\n    self._model = Llama(\n        model_path=self.model_path.as_posix(),\n        chat_format=self.chat_format,\n        n_gpu_layers=self.n_gpu_layers,\n        verbose=self.verbose,\n    )\n\n    super().load()\n</code></pre>"},{"location":"reference/distilabel/llms/mistral/","title":"Mistral","text":""},{"location":"reference/distilabel/llms/mistral/#distilabel.llms.mistral.MistralLLM","title":"<code>MistralLLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>Mistral LLM implementation running the async API client.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model name to use for the LLM e.g. \"mistral-tiny\", \"mistral-large\", etc.</p> <code>endpoint</code> <code>str</code> <p>the endpoint to use for the Mistral API. Defaults to \"https://api.mistral.ai\".</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Mistral API. Defaults to <code>None</code> which means that the value set for the environment variable <code>OPENAI_API_KEY</code> will be used, or <code>None</code> if not set.</p> <code>max_retries</code> <code>RuntimeParameter[int]</code> <p>the maximum number of retries to attempt when a request fails. Defaults to <code>5</code>.</p> <code>timeout</code> <code>RuntimeParameter[int]</code> <p>the maximum time in seconds to wait for a response. Defaults to <code>120</code>.</p> <code>max_concurrent_requests</code> <code>RuntimeParameter[int]</code> <p>the maximum number of concurrent requests to send. Defaults to <code>64</code>.</p> <code>_api_key_env_var</code> <code>str</code> <p>the name of the environment variable to use for the API key. It is meant to be used internally.</p> <code>_aclient</code> <code>Optional[MistralAsyncClient]</code> <p>the <code>MistralAsyncClient</code> to use for the Mistral API. It is meant to be used internally. Set in the <code>load</code> method.</p> Runtime parameters <ul> <li><code>api_key</code>: the API key to authenticate the requests to the Mistral API.</li> <li><code>max_retries</code>: the maximum number of retries to attempt when a request fails.     Defaults to <code>5</code>.</li> <li><code>timeout</code>: the maximum time in seconds to wait for a response. Defaults to <code>120</code>.</li> <li><code>max_concurrent_requests</code>: the maximum number of concurrent requests to send.     Defaults to <code>64</code>.</li> </ul> Source code in <code>src/distilabel/llms/mistral.py</code> <pre><code>class MistralLLM(AsyncLLM):\n    \"\"\"Mistral LLM implementation running the async API client.\n\n    Attributes:\n        model: the model name to use for the LLM e.g. \"mistral-tiny\", \"mistral-large\", etc.\n        endpoint: the endpoint to use for the Mistral API. Defaults to \"https://api.mistral.ai\".\n        api_key: the API key to authenticate the requests to the Mistral API. Defaults to `None` which\n            means that the value set for the environment variable `OPENAI_API_KEY` will be used, or\n            `None` if not set.\n        max_retries: the maximum number of retries to attempt when a request fails. Defaults to `5`.\n        timeout: the maximum time in seconds to wait for a response. Defaults to `120`.\n        max_concurrent_requests: the maximum number of concurrent requests to send. Defaults\n            to `64`.\n        _api_key_env_var: the name of the environment variable to use for the API key. It is meant to\n            be used internally.\n        _aclient: the `MistralAsyncClient` to use for the Mistral API. It is meant to be used internally.\n            Set in the `load` method.\n\n    Runtime parameters:\n        - `api_key`: the API key to authenticate the requests to the Mistral API.\n        - `max_retries`: the maximum number of retries to attempt when a request fails.\n            Defaults to `5`.\n        - `timeout`: the maximum time in seconds to wait for a response. Defaults to `120`.\n        - `max_concurrent_requests`: the maximum number of concurrent requests to send.\n            Defaults to `64`.\n    \"\"\"\n\n    model: str\n    endpoint: str = \"https://api.mistral.ai\"\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_MISTRALAI_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Mistral API.\",\n    )\n    max_retries: RuntimeParameter[int] = Field(\n        default=6,\n        description=\"The maximum number of times to retry the request to the API before\"\n        \" failing.\",\n    )\n    timeout: RuntimeParameter[int] = Field(\n        default=120,\n        description=\"The maximum time in seconds to wait for a response from the API.\",\n    )\n    max_concurrent_requests: RuntimeParameter[int] = Field(\n        default=64, description=\"The maximum number of concurrent requests to send.\"\n    )\n\n    _api_key_env_var: str = PrivateAttr(_MISTRALAI_API_KEY_ENV_VAR_NAME)\n    _aclient: Optional[\"MistralAsyncClient\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `MistralAsyncClient` client to benefit from async requests.\"\"\"\n        super().load()\n\n        try:\n            from mistralai.async_client import MistralAsyncClient\n        except ImportError as ie:\n            raise ImportError(\n                \"MistralAI Python client is not installed. Please install it using\"\n                \" `pip install mistralai`.\"\n            ) from ie\n\n        if self.api_key is None:\n            raise ValueError(\n                f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n                f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n            )\n\n        self._aclient = MistralAsyncClient(\n            api_key=self.api_key.get_secret_value(),\n            endpoint=self.endpoint,\n            max_retries=self.max_retries,\n            timeout=self.timeout,\n            max_concurrent_requests=self.max_concurrent_requests,\n        )\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    # TODO: add `num_generations` parameter once Mistral client allows `n` parameter\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        max_new_tokens: Optional[int] = None,\n        temperature: Optional[float] = None,\n        top_p: Optional[float] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates `num_generations` responses for the given input using the MistralAI async\n        client.\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            temperature: the temperature to use for the generation. Defaults to `0.1`.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        completion = await self._aclient.chat(  # type: ignore\n            messages=input,\n            model=self.model,\n            temperature=temperature,\n            max_tokens=max_new_tokens,\n            top_p=top_p,\n        )\n        generations = []\n        for choice in completion.choices:\n            if (content := choice.message.content) is None:\n                self._logger.warning(\n                    f\"Received no response using MistralAI client (model: '{self.model}').\"\n                    f\" Finish reason was: {choice.finish_reason}\"\n                )\n            generations.append(content)\n        return generations\n\n    # TODO: remove this function once Mistral client allows `n` parameter\n    @override\n    def generate(\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        **kwargs: Any,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Method to generate a list of responses asynchronously, returning the output\n        synchronously awaiting for the response of each input sent to `agenerate`.\n        \"\"\"\n\n        async def agenerate(\n            inputs: List[\"ChatType\"], **kwargs: Any\n        ) -&gt; \"GenerateOutput\":\n            \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n            tasks = [\n                asyncio.create_task(self.agenerate(input=input, **kwargs))\n                for input in inputs\n                for _ in range(num_generations)\n            ]\n            return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n        outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n        return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"reference/distilabel/llms/mistral/#distilabel.llms.mistral.MistralLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/mistral/#distilabel.llms.mistral.MistralLLM.agenerate","title":"<code>agenerate(input, max_new_tokens=None, temperature=None, top_p=None)</code>  <code>async</code>","text":"<p>Generates <code>num_generations</code> responses for the given input using the MistralAI async client.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>max_new_tokens</code> <code>Optional[int]</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>None</code> <code>temperature</code> <code>Optional[float]</code> <p>the temperature to use for the generation. Defaults to <code>0.1</code>.</p> <code>None</code> <code>top_p</code> <code>Optional[float]</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>GenerateOutput</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/mistral.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    max_new_tokens: Optional[int] = None,\n    temperature: Optional[float] = None,\n    top_p: Optional[float] = None,\n) -&gt; \"GenerateOutput\":\n    \"\"\"Generates `num_generations` responses for the given input using the MistralAI async\n    client.\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        temperature: the temperature to use for the generation. Defaults to `0.1`.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    completion = await self._aclient.chat(  # type: ignore\n        messages=input,\n        model=self.model,\n        temperature=temperature,\n        max_tokens=max_new_tokens,\n        top_p=top_p,\n    )\n    generations = []\n    for choice in completion.choices:\n        if (content := choice.message.content) is None:\n            self._logger.warning(\n                f\"Received no response using MistralAI client (model: '{self.model}').\"\n                f\" Finish reason was: {choice.finish_reason}\"\n            )\n        generations.append(content)\n    return generations\n</code></pre>"},{"location":"reference/distilabel/llms/mistral/#distilabel.llms.mistral.MistralLLM.generate","title":"<code>generate(inputs, num_generations=1, **kwargs)</code>","text":"<p>Method to generate a list of responses asynchronously, returning the output synchronously awaiting for the response of each input sent to <code>agenerate</code>.</p> Source code in <code>src/distilabel/llms/mistral.py</code> <pre><code>@override\ndef generate(\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    **kwargs: Any,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Method to generate a list of responses asynchronously, returning the output\n    synchronously awaiting for the response of each input sent to `agenerate`.\n    \"\"\"\n\n    async def agenerate(\n        inputs: List[\"ChatType\"], **kwargs: Any\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n        tasks = [\n            asyncio.create_task(self.agenerate(input=input, **kwargs))\n            for input in inputs\n            for _ in range(num_generations)\n        ]\n        return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n    outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n    return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"reference/distilabel/llms/mistral/#distilabel.llms.mistral.MistralLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>MistralAsyncClient</code> client to benefit from async requests.</p> Source code in <code>src/distilabel/llms/mistral.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `MistralAsyncClient` client to benefit from async requests.\"\"\"\n    super().load()\n\n    try:\n        from mistralai.async_client import MistralAsyncClient\n    except ImportError as ie:\n        raise ImportError(\n            \"MistralAI Python client is not installed. Please install it using\"\n            \" `pip install mistralai`.\"\n        ) from ie\n\n    if self.api_key is None:\n        raise ValueError(\n            f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n            f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n        )\n\n    self._aclient = MistralAsyncClient(\n        api_key=self.api_key.get_secret_value(),\n        endpoint=self.endpoint,\n        max_retries=self.max_retries,\n        timeout=self.timeout,\n        max_concurrent_requests=self.max_concurrent_requests,\n    )\n</code></pre>"},{"location":"reference/distilabel/llms/mixins/","title":"Mixins","text":""},{"location":"reference/distilabel/llms/mixins/#distilabel.llms.mixins.CudaDevicePlacementMixin","title":"<code>CudaDevicePlacementMixin</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Mixin class to assign CUDA devices to the <code>LLM</code> based on the <code>cuda_devices</code> attribute and the device placement information provided in <code>_device_llm_placement_map</code>. Providing the device placement information is optional, but if it is provided, it will be used to assign CUDA devices to the <code>LLM</code>s, trying to avoid using the same device for different <code>LLM</code>s.</p> <p>Attributes:</p> Name Type Description <code>cuda_devices</code> <code>Union[List[int], Literal['auto']]</code> <p>a list with the ID of the CUDA devices to be used by the <code>LLM</code>. If set to \"auto\", the devices will be automatically assigned based on the device placement information provided in <code>_device_llm_placement_map</code>. If set to a list of devices, it will be checked if the devices are available to be used by the <code>LLM</code>. If not, a warning will be logged.</p> <code>_llm_identifier</code> <code>Union[str, None]</code> <p>the identifier of the <code>LLM</code> to be used as key in <code>_device_llm_placement_map</code>.</p> <code>_device_llm_placement_map</code> <code>Union[DictProxy[str, Any], None]</code> <p>a dictionary with the device placement information for each <code>LLM</code>.</p> Source code in <code>src/distilabel/llms/mixins.py</code> <pre><code>class CudaDevicePlacementMixin(BaseModel):\n    \"\"\"Mixin class to assign CUDA devices to the `LLM` based on the `cuda_devices` attribute\n    and the device placement information provided in `_device_llm_placement_map`. Providing\n    the device placement information is optional, but if it is provided, it will be used to\n    assign CUDA devices to the `LLM`s, trying to avoid using the same device for different\n    `LLM`s.\n\n    Attributes:\n        cuda_devices: a list with the ID of the CUDA devices to be used by the `LLM`. If set\n            to \"auto\", the devices will be automatically assigned based on the device\n            placement information provided in `_device_llm_placement_map`. If set to a list\n            of devices, it will be checked if the devices are available to be used by the\n            `LLM`. If not, a warning will be logged.\n        _llm_identifier: the identifier of the `LLM` to be used as key in `_device_llm_placement_map`.\n        _device_llm_placement_map: a dictionary with the device placement information for each\n            `LLM`.\n    \"\"\"\n\n    # TODO: this should be a runtime parameter\n    cuda_devices: Union[List[int], Literal[\"auto\"]] = Field(default=\"auto\")\n\n    _llm_identifier: Union[str, None] = PrivateAttr(default=None)\n    _device_llm_placement_map: Union[\"DictProxy[str, Any]\", None] = PrivateAttr(\n        default=None\n    )\n    _device_llm_placement_lock: Union[\"Lock\", None] = PrivateAttr(default=None)\n    _available_cuda_devices: Union[List[int], None] = PrivateAttr(default=None)\n    _can_check_cuda_devices: bool = PrivateAttr(default=False)\n\n    def load(self) -&gt; None:\n        \"\"\"Assign CUDA devices to the LLM based on the device placement information provided\n        in `_device_llm_placement_map`.\"\"\"\n\n        try:\n            import pynvml\n\n            pynvml.nvmlInit()\n            device_count = pynvml.nvmlDeviceGetCount()\n            self._available_cuda_devices = list(range(device_count))\n            self._can_check_cuda_devices = True\n        except ImportError as ie:\n            if self.cuda_devices == \"auto\":\n                raise ImportError(\n                    \"The 'pynvml' library is not installed. It is required to automatically\"\n                    \" assign CUDA devices to the `LLM`s. Please, install it and try again.\"\n                ) from ie\n\n            if self.cuda_devices:\n                self._logger.warning(  # type: ignore\n                    \"The 'pynvml' library is not installed. It is recommended to install it\"\n                    \" to check if the CUDA devices assigned to the LLM are available.\"\n                )\n\n        self._assign_cuda_devices()\n\n    def set_device_placement_info(\n        self,\n        llm_identifier: str,\n        device_llm_placement_map: \"DictProxy[str, Any]\",\n        device_llm_placement_lock: \"Lock\",\n    ) -&gt; None:\n        \"\"\"Sets the value of `_device_llm_placement_map` to be used to assign CUDA devices\n        to the LLM.\n\n        Args:\n            llm_identifier: the identifier of the LLM to be used as key in the device\n                placement information.\n            device_llm_placement_map: a dictionary with the device placement information for\n                each LLM. It should have two keys. The first key is \"lock\" and its value is\n                a lock object to be used to synchronize the access to the device placement\n                information. The second key is \"value\" and its value is a dictionary with the\n                device placement information for each LLM.\n            device_llm_placement_lock: a lock object to be used to synchronize the access to\n                `_device_llm_placement_map`.\n        \"\"\"\n        self._llm_identifier = llm_identifier\n        self._device_llm_placement_map = device_llm_placement_map\n        self._device_llm_placement_lock = device_llm_placement_lock\n\n    def _assign_cuda_devices(self) -&gt; None:\n        \"\"\"Assigns CUDA devices to the LLM based on the device placement information provided\n        in `_device_llm_placement_map`. If the `cuda_devices` attribute is set to \"auto\", it\n        will be set to the first available CUDA device that is not going to be used by any\n        other LLM. If the `cuda_devices` attribute is set to a list of devices, it will be\n        checked if the devices are available to be used by the LLM. If not, a warning will be\n        logged.\"\"\"\n\n        if self._device_llm_placement_map is not None:\n            with self._device_llm_placement_lock:  # type: ignore\n                if self.cuda_devices == \"auto\":\n                    self.cuda_devices = [\n                        self._get_cuda_device(self._device_llm_placement_map)\n                    ]\n                else:\n                    self._check_cuda_devices(self._device_llm_placement_map)\n\n                self._device_llm_placement_map[self._llm_identifier] = self.cuda_devices  # type: ignore\n\n        # `_device_llm_placement_map` was not provided and user didn't set the `cuda_devices`\n        # attribute. In this case, the `cuda_devices` attribute will be set to an empty list.\n        if self.cuda_devices == \"auto\":\n            self.cuda_devices = []\n\n        self._set_cuda_visible_devices()\n\n    def _check_cuda_devices(self, device_map: Dict[str, List[int]]) -&gt; None:\n        \"\"\"Checks if the CUDA devices assigned to the LLM are also assigned to other LLMs.\n\n        Args:\n            device_map: a dictionary with the device placement information for each LLM.\n        \"\"\"\n        for device in self.cuda_devices:\n            for llm, devices in device_map.items():\n                if device in devices:\n                    self._logger.warning(\n                        f\"LLM with identifier '{llm}' is also going to use CUDA device \"\n                        f\"'{device}'. This may lead to performance issues or running out\"\n                        \" of memory depending on the device capabilities and the loaded\"\n                        \" models.\"\n                    )\n\n    def _get_cuda_device(self, device_map: Dict[str, List[int]]) -&gt; int:\n        \"\"\"Returns the first available CUDA device to be used by the LLM that is not going\n        to be used by any other LLM.\n\n        Args:\n            device_map: a dictionary with the device placement information for each LLM.\n\n        Returns:\n            The first available CUDA device to be used by the LLM.\n\n        Raises:\n            RuntimeError: if there is no available CUDA device to be used by the LLM.\n        \"\"\"\n        for device in self._available_cuda_devices:\n            if all(device not in devices for devices in device_map.values()):\n                return device\n\n        raise RuntimeError(\n            \"Couldn't find an available CUDA device automatically to be used by the LLM\"\n            f\" '{self._llm_identifier}'. For forcing the use of a specific device, set the\"\n            \" `cuda_devices` attribute to a list with the desired device(s).\"\n        )\n\n    def _set_cuda_visible_devices(self) -&gt; None:\n        \"\"\"Sets the `CUDA_VISIBLE_DEVICES` environment variable to the list of CUDA devices\n        to be used by the LLM.\n        \"\"\"\n        if not self.cuda_devices:\n            return\n\n        if self._can_check_cuda_devices and not all(\n            device in self._available_cuda_devices for device in self.cuda_devices\n        ):\n            raise RuntimeError(\n                f\"Invalid CUDA devices for LLM '{self._llm_identifier}': {self.cuda_devices}.\"\n                f\" The available devices are: {self._available_cuda_devices}. Please, review\"\n                \" the 'cuda_devices' attribute and try again.\"\n            )\n\n        cuda_devices = \",\".join([str(device) for device in self.cuda_devices])\n        self._logger.info(\n            f\"\ud83c\udfae LLM '{self._llm_identifier}' is going to use the following CUDA devices:\"\n            f\" {self.cuda_devices}.\"\n        )\n        os.environ[\"CUDA_VISIBLE_DEVICES\"] = cuda_devices\n</code></pre>"},{"location":"reference/distilabel/llms/mixins/#distilabel.llms.mixins.CudaDevicePlacementMixin.load","title":"<code>load()</code>","text":"<p>Assign CUDA devices to the LLM based on the device placement information provided in <code>_device_llm_placement_map</code>.</p> Source code in <code>src/distilabel/llms/mixins.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Assign CUDA devices to the LLM based on the device placement information provided\n    in `_device_llm_placement_map`.\"\"\"\n\n    try:\n        import pynvml\n\n        pynvml.nvmlInit()\n        device_count = pynvml.nvmlDeviceGetCount()\n        self._available_cuda_devices = list(range(device_count))\n        self._can_check_cuda_devices = True\n    except ImportError as ie:\n        if self.cuda_devices == \"auto\":\n            raise ImportError(\n                \"The 'pynvml' library is not installed. It is required to automatically\"\n                \" assign CUDA devices to the `LLM`s. Please, install it and try again.\"\n            ) from ie\n\n        if self.cuda_devices:\n            self._logger.warning(  # type: ignore\n                \"The 'pynvml' library is not installed. It is recommended to install it\"\n                \" to check if the CUDA devices assigned to the LLM are available.\"\n            )\n\n    self._assign_cuda_devices()\n</code></pre>"},{"location":"reference/distilabel/llms/mixins/#distilabel.llms.mixins.CudaDevicePlacementMixin.set_device_placement_info","title":"<code>set_device_placement_info(llm_identifier, device_llm_placement_map, device_llm_placement_lock)</code>","text":"<p>Sets the value of <code>_device_llm_placement_map</code> to be used to assign CUDA devices to the LLM.</p> <p>Parameters:</p> Name Type Description Default <code>llm_identifier</code> <code>str</code> <p>the identifier of the LLM to be used as key in the device placement information.</p> required <code>device_llm_placement_map</code> <code>DictProxy[str, Any]</code> <p>a dictionary with the device placement information for each LLM. It should have two keys. The first key is \"lock\" and its value is a lock object to be used to synchronize the access to the device placement information. The second key is \"value\" and its value is a dictionary with the device placement information for each LLM.</p> required <code>device_llm_placement_lock</code> <code>Lock</code> <p>a lock object to be used to synchronize the access to <code>_device_llm_placement_map</code>.</p> required Source code in <code>src/distilabel/llms/mixins.py</code> <pre><code>def set_device_placement_info(\n    self,\n    llm_identifier: str,\n    device_llm_placement_map: \"DictProxy[str, Any]\",\n    device_llm_placement_lock: \"Lock\",\n) -&gt; None:\n    \"\"\"Sets the value of `_device_llm_placement_map` to be used to assign CUDA devices\n    to the LLM.\n\n    Args:\n        llm_identifier: the identifier of the LLM to be used as key in the device\n            placement information.\n        device_llm_placement_map: a dictionary with the device placement information for\n            each LLM. It should have two keys. The first key is \"lock\" and its value is\n            a lock object to be used to synchronize the access to the device placement\n            information. The second key is \"value\" and its value is a dictionary with the\n            device placement information for each LLM.\n        device_llm_placement_lock: a lock object to be used to synchronize the access to\n            `_device_llm_placement_map`.\n    \"\"\"\n    self._llm_identifier = llm_identifier\n    self._device_llm_placement_map = device_llm_placement_map\n    self._device_llm_placement_lock = device_llm_placement_lock\n</code></pre>"},{"location":"reference/distilabel/llms/ollama/","title":"Ollama","text":""},{"location":"reference/distilabel/llms/ollama/#distilabel.llms.ollama.OllamaLLM","title":"<code>OllamaLLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>Ollama LLM implementation running the Async API client.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model name to use for the LLM e.g. \"notus\".</p> <code>host</code> <code>Optional[RuntimeParameter[str]]</code> <p>the Ollama server host.</p> <code>timeout</code> <code>RuntimeParameter[int]</code> <p>the timeout for the LLM. Defaults to <code>120</code>.</p> <code>_aclient</code> <code>Optional[AsyncClient]</code> <p>the <code>AsyncClient</code> to use for the Ollama API. It is meant to be used internally. Set in the <code>load</code> method.</p> Runtime parameters <ul> <li><code>host</code>: the Ollama server host.</li> <li><code>timeout</code>: the client timeout for the Ollama API. Defaults to <code>120</code>.</li> </ul> Source code in <code>src/distilabel/llms/ollama.py</code> <pre><code>class OllamaLLM(AsyncLLM):\n    \"\"\"Ollama LLM implementation running the Async API client.\n\n    Attributes:\n        model: the model name to use for the LLM e.g. \"notus\".\n        host: the Ollama server host.\n        timeout: the timeout for the LLM. Defaults to `120`.\n        _aclient: the `AsyncClient` to use for the Ollama API. It is meant to be used internally.\n            Set in the `load` method.\n\n    Runtime parameters:\n        - `host`: the Ollama server host.\n        - `timeout`: the client timeout for the Ollama API. Defaults to `120`.\n    \"\"\"\n\n    model: str\n    host: Optional[RuntimeParameter[str]] = Field(\n        default=None, description=\"The host of the Ollama API.\"\n    )\n    timeout: RuntimeParameter[int] = Field(\n        default=120, description=\"The timeout for the Ollama API.\"\n    )\n    follow_redirects: bool = True\n\n    _aclient: Optional[\"AsyncClient\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `AsyncClient` to use Ollama async API.\"\"\"\n        super().load()\n\n        try:\n            from ollama import AsyncClient\n\n            self._aclient = AsyncClient(\n                host=self.host,\n                timeout=self.timeout,\n                follow_redirects=self.follow_redirects,\n            )\n        except ImportError as e:\n            raise ImportError(\n                \"Ollama Python client is not installed. Please install it using\"\n                \" `pip install ollama`.\"\n            ) from e\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        num_generations: int = 1,\n        format: Literal[\"\", \"json\"] = \"\",\n        options: Union[\"Options\", None] = None,\n        keep_alive: Union[bool, None] = None,\n    ) -&gt; List[str]:\n        \"\"\"\n        Generates a response asynchronously, using the [Ollama Async API definition](https://github.com/ollama/ollama-python).\n\n        Args:\n            input: the input to use for the generation.\n            num_generations: the number of generations to produce. Defaults to `1`.\n            format: the format to use for the generation. Defaults to `\"\"`.\n            options: the options to use for the generation. Defaults to `None`.\n            keep_alive: whether to keep the connection alive. Defaults to `None`.\n\n        Returns:\n            A list of strings as completion for the given input.\n        \"\"\"\n        generations = []\n        # TODO: remove this for-loop and override the `generate` method\n        for _ in range(num_generations):\n            completion = await self._aclient.chat(  # type: ignore\n                model=self.model,\n                messages=input,  # type: ignore\n                stream=False,\n                format=format,\n                options=options,\n                keep_alive=keep_alive,\n            )\n            # TODO: improve error handling\n            generations.append(completion[\"message\"][\"content\"])\n\n        return generations\n</code></pre>"},{"location":"reference/distilabel/llms/ollama/#distilabel.llms.ollama.OllamaLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/ollama/#distilabel.llms.ollama.OllamaLLM.agenerate","title":"<code>agenerate(input, num_generations=1, format='', options=None, keep_alive=None)</code>  <code>async</code>","text":"<p>Generates a response asynchronously, using the Ollama Async API definition.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>the input to use for the generation.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to produce. Defaults to <code>1</code>.</p> <code>1</code> <code>format</code> <code>Literal['', 'json']</code> <p>the format to use for the generation. Defaults to <code>\"\"</code>.</p> <code>''</code> <code>options</code> <code>Union[Options, None]</code> <p>the options to use for the generation. Defaults to <code>None</code>.</p> <code>None</code> <code>keep_alive</code> <code>Union[bool, None]</code> <p>whether to keep the connection alive. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of strings as completion for the given input.</p> Source code in <code>src/distilabel/llms/ollama.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    num_generations: int = 1,\n    format: Literal[\"\", \"json\"] = \"\",\n    options: Union[\"Options\", None] = None,\n    keep_alive: Union[bool, None] = None,\n) -&gt; List[str]:\n    \"\"\"\n    Generates a response asynchronously, using the [Ollama Async API definition](https://github.com/ollama/ollama-python).\n\n    Args:\n        input: the input to use for the generation.\n        num_generations: the number of generations to produce. Defaults to `1`.\n        format: the format to use for the generation. Defaults to `\"\"`.\n        options: the options to use for the generation. Defaults to `None`.\n        keep_alive: whether to keep the connection alive. Defaults to `None`.\n\n    Returns:\n        A list of strings as completion for the given input.\n    \"\"\"\n    generations = []\n    # TODO: remove this for-loop and override the `generate` method\n    for _ in range(num_generations):\n        completion = await self._aclient.chat(  # type: ignore\n            model=self.model,\n            messages=input,  # type: ignore\n            stream=False,\n            format=format,\n            options=options,\n            keep_alive=keep_alive,\n        )\n        # TODO: improve error handling\n        generations.append(completion[\"message\"][\"content\"])\n\n    return generations\n</code></pre>"},{"location":"reference/distilabel/llms/ollama/#distilabel.llms.ollama.OllamaLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>AsyncClient</code> to use Ollama async API.</p> Source code in <code>src/distilabel/llms/ollama.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `AsyncClient` to use Ollama async API.\"\"\"\n    super().load()\n\n    try:\n        from ollama import AsyncClient\n\n        self._aclient = AsyncClient(\n            host=self.host,\n            timeout=self.timeout,\n            follow_redirects=self.follow_redirects,\n        )\n    except ImportError as e:\n        raise ImportError(\n            \"Ollama Python client is not installed. Please install it using\"\n            \" `pip install ollama`.\"\n        ) from e\n</code></pre>"},{"location":"reference/distilabel/llms/openai/","title":"Openai","text":""},{"location":"reference/distilabel/llms/openai/#distilabel.llms.openai.OpenAILLM","title":"<code>OpenAILLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>OpenAI LLM implementation running the async API client.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model name to use for the LLM e.g. \"gpt-3.5-turbo\", \"gpt-4\", etc. Supported models can be found here.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the OpenAI API requests. Defaults to <code>None</code>, which means that the value set for the environment variable <code>OPENAI_BASE_URL</code> will be used, or \"https://api.openai.com/v1\" if not set.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the OpenAI API. Defaults to <code>None</code> which means that the value set for the environment variable <code>OPENAI_API_KEY</code> will be used, or <code>None</code> if not set.</p> <code>max_retries</code> <code>RuntimeParameter[int]</code> <p>the maximum number of times to retry the request to the API before failing. Defaults to <code>6</code>.</p> <code>timeout</code> <code>RuntimeParameter[int]</code> <p>the maximum time in seconds to wait for a response from the API. Defaults to <code>120</code>.</p> Runtime parameters <ul> <li><code>base_url</code>: the base URL to use for the OpenAI API requests. Defaults to <code>None</code>.</li> <li><code>api_key</code>: the API key to authenticate the requests to the OpenAI API. Defaults     to <code>None</code>.</li> <li><code>max_retries</code>: the maximum number of times to retry the request to the API before     failing. Defaults to <code>6</code>.</li> <li><code>timeout</code>: the maximum time in seconds to wait for a response from the API. Defaults     to <code>120</code>.</li> </ul> Source code in <code>src/distilabel/llms/openai.py</code> <pre><code>class OpenAILLM(AsyncLLM):\n    \"\"\"OpenAI LLM implementation running the async API client.\n\n    Attributes:\n        model: the model name to use for the LLM e.g. \"gpt-3.5-turbo\", \"gpt-4\", etc.\n            Supported models can be found [here](https://platform.openai.com/docs/guides/text-generation).\n        base_url: the base URL to use for the OpenAI API requests. Defaults to `None`, which\n            means that the value set for the environment variable `OPENAI_BASE_URL` will\n            be used, or \"https://api.openai.com/v1\" if not set.\n        api_key: the API key to authenticate the requests to the OpenAI API. Defaults to\n            `None` which means that the value set for the environment variable `OPENAI_API_KEY`\n            will be used, or `None` if not set.\n        max_retries: the maximum number of times to retry the request to the API before\n            failing. Defaults to `6`.\n        timeout: the maximum time in seconds to wait for a response from the API. Defaults\n            to `120`.\n\n    Runtime parameters:\n        - `base_url`: the base URL to use for the OpenAI API requests. Defaults to `None`.\n        - `api_key`: the API key to authenticate the requests to the OpenAI API. Defaults\n            to `None`.\n        - `max_retries`: the maximum number of times to retry the request to the API before\n            failing. Defaults to `6`.\n        - `timeout`: the maximum time in seconds to wait for a response from the API. Defaults\n            to `120`.\n    \"\"\"\n\n    model: str\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(\n            \"OPENAI_BASE_URL\", \"https://api.openai.com/v1\"\n        ),\n        description=\"The base URL to use for the OpenAI API requests.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_OPENAI_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the OpenAI API.\",\n    )\n    max_retries: RuntimeParameter[int] = Field(\n        default=6,\n        description=\"The maximum number of times to retry the request to the API before\"\n        \" failing.\",\n    )\n    timeout: RuntimeParameter[int] = Field(\n        default=120,\n        description=\"The maximum time in seconds to wait for a response from the API.\",\n    )\n\n    _api_key_env_var: str = PrivateAttr(_OPENAI_API_KEY_ENV_VAR_NAME)\n    _aclient: Optional[\"AsyncOpenAI\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `AsyncOpenAI` client to benefit from async requests.\"\"\"\n        super().load()\n\n        try:\n            from openai import AsyncOpenAI\n        except ImportError as ie:\n            raise ImportError(\n                \"OpenAI Python client is not installed. Please install it using\"\n                \" `pip install openai`.\"\n            ) from ie\n\n        if self.api_key is None:\n            raise ValueError(\n                f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n                f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n            )\n\n        self._aclient = AsyncOpenAI(\n            base_url=self.base_url,\n            api_key=self.api_key.get_secret_value(),\n            max_retries=self.max_retries,\n            timeout=self.timeout,\n        )\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        num_generations: int = 1,\n        max_new_tokens: int = 128,\n        frequency_penalty: float = 0.0,\n        presence_penalty: float = 0.0,\n        temperature: float = 1.0,\n        top_p: float = 1.0,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates `num_generations` responses for the given input using the OpenAI async\n        client.\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            num_generations: the number of generations to create per input. Defaults to\n                `1`.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            frequency_penalty: the repetition penalty to use for the generation. Defaults\n                to `0.0`.\n            presence_penalty: the presence penalty to use for the generation. Defaults to\n                `0.0`.\n            temperature: the temperature to use for the generation. Defaults to `0.1`.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        completion = await self._aclient.chat.completions.create(  # type: ignore\n            messages=input,  # type: ignore\n            model=self.model,\n            max_tokens=max_new_tokens,\n            n=num_generations,\n            frequency_penalty=frequency_penalty,\n            presence_penalty=presence_penalty,\n            temperature=temperature,\n            top_p=top_p,\n            timeout=50,\n        )\n        generations = []\n        for choice in completion.choices:\n            if (content := choice.message.content) is None:\n                self._logger.warning(\n                    f\"Received no response using OpenAI client (model: '{self.model}').\"\n                    f\" Finish reason was: {choice.finish_reason}\"\n                )\n            generations.append(content)\n        return generations\n</code></pre>"},{"location":"reference/distilabel/llms/openai/#distilabel.llms.openai.OpenAILLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/openai/#distilabel.llms.openai.OpenAILLM.agenerate","title":"<code>agenerate(input, num_generations=1, max_new_tokens=128, frequency_penalty=0.0, presence_penalty=0.0, temperature=1.0, top_p=1.0)</code>  <code>async</code>","text":"<p>Generates <code>num_generations</code> responses for the given input using the OpenAI async client.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to create per input. Defaults to <code>1</code>.</p> <code>1</code> <code>max_new_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>frequency_penalty</code> <code>float</code> <p>the repetition penalty to use for the generation. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>presence_penalty</code> <code>float</code> <p>the presence penalty to use for the generation. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Defaults to <code>0.1</code>.</p> <code>1.0</code> <code>top_p</code> <code>float</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>GenerateOutput</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/openai.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    num_generations: int = 1,\n    max_new_tokens: int = 128,\n    frequency_penalty: float = 0.0,\n    presence_penalty: float = 0.0,\n    temperature: float = 1.0,\n    top_p: float = 1.0,\n) -&gt; \"GenerateOutput\":\n    \"\"\"Generates `num_generations` responses for the given input using the OpenAI async\n    client.\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        num_generations: the number of generations to create per input. Defaults to\n            `1`.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        frequency_penalty: the repetition penalty to use for the generation. Defaults\n            to `0.0`.\n        presence_penalty: the presence penalty to use for the generation. Defaults to\n            `0.0`.\n        temperature: the temperature to use for the generation. Defaults to `0.1`.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    completion = await self._aclient.chat.completions.create(  # type: ignore\n        messages=input,  # type: ignore\n        model=self.model,\n        max_tokens=max_new_tokens,\n        n=num_generations,\n        frequency_penalty=frequency_penalty,\n        presence_penalty=presence_penalty,\n        temperature=temperature,\n        top_p=top_p,\n        timeout=50,\n    )\n    generations = []\n    for choice in completion.choices:\n        if (content := choice.message.content) is None:\n            self._logger.warning(\n                f\"Received no response using OpenAI client (model: '{self.model}').\"\n                f\" Finish reason was: {choice.finish_reason}\"\n            )\n        generations.append(content)\n    return generations\n</code></pre>"},{"location":"reference/distilabel/llms/openai/#distilabel.llms.openai.OpenAILLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>AsyncOpenAI</code> client to benefit from async requests.</p> Source code in <code>src/distilabel/llms/openai.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `AsyncOpenAI` client to benefit from async requests.\"\"\"\n    super().load()\n\n    try:\n        from openai import AsyncOpenAI\n    except ImportError as ie:\n        raise ImportError(\n            \"OpenAI Python client is not installed. Please install it using\"\n            \" `pip install openai`.\"\n        ) from ie\n\n    if self.api_key is None:\n        raise ValueError(\n            f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n            f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n        )\n\n    self._aclient = AsyncOpenAI(\n        base_url=self.base_url,\n        api_key=self.api_key.get_secret_value(),\n        max_retries=self.max_retries,\n        timeout=self.timeout,\n    )\n</code></pre>"},{"location":"reference/distilabel/llms/together/","title":"Together","text":""},{"location":"reference/distilabel/llms/together/#distilabel.llms.together.TogetherLLM","title":"<code>TogetherLLM</code>","text":"<p>             Bases: <code>OpenAILLM</code></p> <p>TogetherLLM LLM implementation running the async API client of OpenAI because of duplicate API behavior.</p> <p>Attributes:</p> Name Type Description <code>model</code> <p>the model name to use for the LLM e.g. \"mistralai/Mixtral-8x7B-Instruct-v0.1\". Supported models can be found here.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the Together API can be set with <code>TOGETHER_BASE_URL</code>. Defaults to <code>None</code> which means that the value set for the environment variable <code>TOGETHER_BASE_URL</code> will be used, or \"https://api.together.xyz/v1\" if not set.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Together API. Defaults to <code>None</code> which means that the value set for the environment variable <code>TOGETHER_API_KEY</code> will be used, or <code>None</code> if not set.</p> <code>_api_key_env_var</code> <code>str</code> <p>the name of the environment variable to use for the API key. It is meant to be used internally.</p> Source code in <code>src/distilabel/llms/together.py</code> <pre><code>class TogetherLLM(OpenAILLM):\n    \"\"\"TogetherLLM LLM implementation running the async API client of OpenAI because of\n    duplicate API behavior.\n\n    Attributes:\n        model: the model name to use for the LLM e.g. \"mistralai/Mixtral-8x7B-Instruct-v0.1\".\n            Supported models can be found [here](https://api.together.xyz/models).\n        base_url: the base URL to use for the Together API can be set with `TOGETHER_BASE_URL`.\n            Defaults to `None` which means that the value set for the environment variable\n            `TOGETHER_BASE_URL` will be used, or \"https://api.together.xyz/v1\" if not set.\n        api_key: the API key to authenticate the requests to the Together API. Defaults to `None`\n            which means that the value set for the environment variable `TOGETHER_API_KEY` will be\n            used, or `None` if not set.\n        _api_key_env_var: the name of the environment variable to use for the API key. It\n            is meant to be used internally.\n    \"\"\"\n\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(\n            \"TOGETHER_BASE_URL\", \"https://api.together.xyz/v1\"\n        ),\n        description=\"The base URL to use for the Together API requests.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_TOGETHER_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Together API.\",\n    )\n\n    _api_key_env_var: str = PrivateAttr(_TOGETHER_API_KEY_ENV_VAR_NAME)\n</code></pre>"},{"location":"reference/distilabel/llms/typing/","title":"Typing","text":""},{"location":"reference/distilabel/llms/vertexai/","title":"Vertexai","text":""},{"location":"reference/distilabel/llms/vertexai/#distilabel.llms.vertexai.VertexAILLM","title":"<code>VertexAILLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>VertexAI LLM implementation running the async API clients for Gemini.</p> <ul> <li>Gemini API: https://cloud.google.com/vertex-ai/docs/generative-ai/model-reference/gemini</li> </ul> <p>To use the <code>VertexAILLM</code> is necessary to have configured the Google Cloud authentication using one of these methods:</p> <ul> <li>Setting <code>GOOGLE_CLOUD_CREDENTIALS</code> environment variable</li> <li>Using <code>gcloud auth application-default login</code> command</li> <li>Using <code>vertexai.init</code> function from the <code>google-cloud-aiplatform</code> library</li> </ul> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model name to use for the LLM e.g. \"gemini-1.0-pro\". Supported models.</p> <code>_aclient</code> <code>Optional[GenerativeModel]</code> <p>the <code>GenerativeModel</code> to use for the Vertex AI Gemini API. It is meant to be used internally. Set in the <code>load</code> method.</p> Source code in <code>src/distilabel/llms/vertexai.py</code> <pre><code>class VertexAILLM(AsyncLLM):\n    \"\"\"VertexAI LLM implementation running the async API clients for Gemini.\n\n    - Gemini API: https://cloud.google.com/vertex-ai/docs/generative-ai/model-reference/gemini\n\n    To use the `VertexAILLM` is necessary to have configured the Google Cloud authentication\n    using one of these methods:\n\n    - Setting `GOOGLE_CLOUD_CREDENTIALS` environment variable\n    - Using `gcloud auth application-default login` command\n    - Using `vertexai.init` function from the `google-cloud-aiplatform` library\n\n    Attributes:\n        model: the model name to use for the LLM e.g. \"gemini-1.0-pro\". [Supported models](https://cloud.google.com/vertex-ai/generative-ai/docs/learn/models).\n        _aclient: the `GenerativeModel` to use for the Vertex AI Gemini API. It is meant\n            to be used internally. Set in the `load` method.\n    \"\"\"\n\n    model: str\n    _aclient: Optional[\"GenerativeModel\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `GenerativeModel` class which has access to `generate_content_async` to benefit from async requests.\"\"\"\n        super().load()\n\n        try:\n            from vertexai.generative_models import GenerationConfig, GenerativeModel\n\n            self._generation_config_class = GenerationConfig\n        except ImportError as e:\n            raise ImportError(\n                \"vertexai is not installed. Please install it using\"\n                \" `pip install google-cloud-aiplatform`.\"\n            ) from e\n\n        if _is_gemini_model(self.model):\n            self._aclient = GenerativeModel(model_name=self.model)\n        else:\n            raise NotImplementedError(\n                \"`VertexAILLM` is only implemented for `gemini` models that allow for `ChatType` data.\"\n            )\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    def _chattype_to_content(self, input: \"ChatType\") -&gt; List[\"Content\"]:\n        \"\"\"Converts a chat type to a list of content items expected by the API.\n\n        Args:\n            input: the chat type to be converted.\n\n        Returns:\n            List[str]: a list of content items expected by the API.\n        \"\"\"\n        from vertexai.generative_models import Content, Part\n\n        contents = []\n        for message in input:\n            if message[\"role\"] not in [\"user\", \"model\"]:\n                raise ValueError(\n                    \"`VertexAILLM only supports the roles 'user' or 'model'.\"\n                )\n            contents.append(\n                Content(\n                    role=message[\"role\"], parts=[Part.from_text(message[\"content\"])]\n                )\n            )\n        return contents\n\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        num_generations: int = 1,\n        temperature: Optional[float] = None,\n        top_p: Optional[float] = None,\n        top_k: Optional[int] = None,\n        max_output_tokens: Optional[int] = None,\n        stop_sequences: Optional[List[str]] = None,\n        safety_settings: Optional[\"SafetySettingsType\"] = None,\n        tools: Optional[List[\"Tool\"]] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates `num_generations` responses for the given input using the [VertexAI async client definition](https://cloud.google.com/vertex-ai/docs/generative-ai/model-reference/gemini).\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            num_generations: the number of generations to create per input. Defaults to\n                `1`.\n            temperature: Controls the randomness of predictions. Range: [0.0, 1.0]. Defaults to `None`.\n            top_p: If specified, nucleus sampling will be used. Range: (0.0, 1.0]. Defaults to `None`.\n            top_k: If specified, top-k sampling will be used. Defaults to `None`.\n            max_output_tokens: The maximum number of output tokens to generate per message. Defaults to `None`.\n            stop_sequences: A list of stop sequences. Defaults to `None`.\n            safety_settings: Safety configuration for returned content from the API. Defaults to `None`.\n            tools: A potential list of tools that can be used by the API. Defaults to `None`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        from vertexai.generative_models import GenerationConfig\n\n        contents = self._chattype_to_content(input)\n        generations = []\n        # TODO: remove this for-loop and override `generate`\n        for _ in range(num_generations):\n            content = await self._aclient.generate_content_async(  # type: ignore\n                contents=contents,\n                generation_config=GenerationConfig(\n                    candidate_count=1,  # only one candidate allowed per call\n                    temperature=temperature,\n                    top_k=top_k,\n                    top_p=top_p,\n                    max_output_tokens=max_output_tokens,\n                    stop_sequences=stop_sequences,\n                ),\n                safety_settings=safety_settings,\n                tools=tools,\n                stream=False,\n            )\n\n            text = None\n            try:\n                text = content.candidates[0].text\n            except ValueError:\n                self._logger.warning(\n                    f\"Received no response using VertexAI client (model: '{self.model}').\"\n                    f\" Finish reason was: '{content.candidates[0].finish_reason}'.\"\n                )\n            generations.append(text)\n\n        return generations\n</code></pre>"},{"location":"reference/distilabel/llms/vertexai/#distilabel.llms.vertexai.VertexAILLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/vertexai/#distilabel.llms.vertexai.VertexAILLM.agenerate","title":"<code>agenerate(input, num_generations=1, temperature=None, top_p=None, top_k=None, max_output_tokens=None, stop_sequences=None, safety_settings=None, tools=None)</code>  <code>async</code>","text":"<p>Generates <code>num_generations</code> responses for the given input using the VertexAI async client definition.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to create per input. Defaults to <code>1</code>.</p> <code>1</code> <code>temperature</code> <code>Optional[float]</code> <p>Controls the randomness of predictions. Range: [0.0, 1.0]. Defaults to <code>None</code>.</p> <code>None</code> <code>top_p</code> <code>Optional[float]</code> <p>If specified, nucleus sampling will be used. Range: (0.0, 1.0]. Defaults to <code>None</code>.</p> <code>None</code> <code>top_k</code> <code>Optional[int]</code> <p>If specified, top-k sampling will be used. Defaults to <code>None</code>.</p> <code>None</code> <code>max_output_tokens</code> <code>Optional[int]</code> <p>The maximum number of output tokens to generate per message. Defaults to <code>None</code>.</p> <code>None</code> <code>stop_sequences</code> <code>Optional[List[str]]</code> <p>A list of stop sequences. Defaults to <code>None</code>.</p> <code>None</code> <code>safety_settings</code> <code>Optional[SafetySettingsType]</code> <p>Safety configuration for returned content from the API. Defaults to <code>None</code>.</p> <code>None</code> <code>tools</code> <code>Optional[List[Tool]]</code> <p>A potential list of tools that can be used by the API. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>GenerateOutput</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/vertexai.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    num_generations: int = 1,\n    temperature: Optional[float] = None,\n    top_p: Optional[float] = None,\n    top_k: Optional[int] = None,\n    max_output_tokens: Optional[int] = None,\n    stop_sequences: Optional[List[str]] = None,\n    safety_settings: Optional[\"SafetySettingsType\"] = None,\n    tools: Optional[List[\"Tool\"]] = None,\n) -&gt; \"GenerateOutput\":\n    \"\"\"Generates `num_generations` responses for the given input using the [VertexAI async client definition](https://cloud.google.com/vertex-ai/docs/generative-ai/model-reference/gemini).\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        num_generations: the number of generations to create per input. Defaults to\n            `1`.\n        temperature: Controls the randomness of predictions. Range: [0.0, 1.0]. Defaults to `None`.\n        top_p: If specified, nucleus sampling will be used. Range: (0.0, 1.0]. Defaults to `None`.\n        top_k: If specified, top-k sampling will be used. Defaults to `None`.\n        max_output_tokens: The maximum number of output tokens to generate per message. Defaults to `None`.\n        stop_sequences: A list of stop sequences. Defaults to `None`.\n        safety_settings: Safety configuration for returned content from the API. Defaults to `None`.\n        tools: A potential list of tools that can be used by the API. Defaults to `None`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    from vertexai.generative_models import GenerationConfig\n\n    contents = self._chattype_to_content(input)\n    generations = []\n    # TODO: remove this for-loop and override `generate`\n    for _ in range(num_generations):\n        content = await self._aclient.generate_content_async(  # type: ignore\n            contents=contents,\n            generation_config=GenerationConfig(\n                candidate_count=1,  # only one candidate allowed per call\n                temperature=temperature,\n                top_k=top_k,\n                top_p=top_p,\n                max_output_tokens=max_output_tokens,\n                stop_sequences=stop_sequences,\n            ),\n            safety_settings=safety_settings,\n            tools=tools,\n            stream=False,\n        )\n\n        text = None\n        try:\n            text = content.candidates[0].text\n        except ValueError:\n            self._logger.warning(\n                f\"Received no response using VertexAI client (model: '{self.model}').\"\n                f\" Finish reason was: '{content.candidates[0].finish_reason}'.\"\n            )\n        generations.append(text)\n\n    return generations\n</code></pre>"},{"location":"reference/distilabel/llms/vertexai/#distilabel.llms.vertexai.VertexAILLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>GenerativeModel</code> class which has access to <code>generate_content_async</code> to benefit from async requests.</p> Source code in <code>src/distilabel/llms/vertexai.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `GenerativeModel` class which has access to `generate_content_async` to benefit from async requests.\"\"\"\n    super().load()\n\n    try:\n        from vertexai.generative_models import GenerationConfig, GenerativeModel\n\n        self._generation_config_class = GenerationConfig\n    except ImportError as e:\n        raise ImportError(\n            \"vertexai is not installed. Please install it using\"\n            \" `pip install google-cloud-aiplatform`.\"\n        ) from e\n\n    if _is_gemini_model(self.model):\n        self._aclient = GenerativeModel(model_name=self.model)\n    else:\n        raise NotImplementedError(\n            \"`VertexAILLM` is only implemented for `gemini` models that allow for `ChatType` data.\"\n        )\n</code></pre>"},{"location":"reference/distilabel/llms/vllm/","title":"Vllm","text":""},{"location":"reference/distilabel/llms/vllm/#distilabel.llms.vllm.vLLM","title":"<code>vLLM</code>","text":"<p>             Bases: <code>LLM</code>, <code>CudaDevicePlacementMixin</code></p> <p><code>vLLM</code> library LLM implementation.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model Hugging Face Hub repo id or a path to a directory containing the model weights and configuration files.</p> <code>model_kwargs</code> <code>Optional[RuntimeParameter[Dict[str, Any]]]</code> <p>additional dictionary of keyword arguments that will be passed to the <code>LLM</code> class of <code>vllm</code> library.</p> <code>chat_template</code> <code>Optional[str]</code> <p>a chat template that will be used to build the prompts before sending them to the model. If not provided, the chat template defined in the tokenizer config will be used. If not provided and the tokenizer doesn't have a chat template, then ChatML template will be used. Defaults to <code>None</code>.</p> <code>_model</code> <code>Optional[LLM]</code> <p>the <code>vLLM</code> model instance. This attribute is meant to be used internally and should not be accessed directly. It will be set in the <code>load</code> method.</p> <code>_tokenizer</code> <code>Optional[PreTrainedTokenizer]</code> <p>the tokenizer instance used to format the prompt before passing it to the <code>LLM</code>. This attribute is meant to be used internally and should not be accessed directly. It will be set in the <code>load</code> method.</p> Runtime parameters <ul> <li><code>model_kwargs</code>: additional dictionary of keyword arguments that will be passed to     the <code>LLM</code> class of <code>vllm</code> library.</li> </ul> Source code in <code>src/distilabel/llms/vllm.py</code> <pre><code>class vLLM(LLM, CudaDevicePlacementMixin):\n    \"\"\"`vLLM` library LLM implementation.\n\n    Attributes:\n        model: the model Hugging Face Hub repo id or a path to a directory containing the\n            model weights and configuration files.\n        model_kwargs: additional dictionary of keyword arguments that will be passed to\n            the `LLM` class of `vllm` library.\n        chat_template: a chat template that will be used to build the prompts before\n            sending them to the model. If not provided, the chat template defined in the\n            tokenizer config will be used. If not provided and the tokenizer doesn't have\n            a chat template, then ChatML template will be used. Defaults to `None`.\n        _model: the `vLLM` model instance. This attribute is meant to be used internally\n            and should not be accessed directly. It will be set in the `load` method.\n        _tokenizer: the tokenizer instance used to format the prompt before passing it to\n            the `LLM`. This attribute is meant to be used internally and should not be\n            accessed directly. It will be set in the `load` method.\n\n    Runtime parameters:\n        - `model_kwargs`: additional dictionary of keyword arguments that will be passed to\n            the `LLM` class of `vllm` library.\n    \"\"\"\n\n    model: str\n    model_kwargs: Optional[RuntimeParameter[Dict[str, Any]]] = Field(\n        default_factory=dict,\n        description=\"Additional dictionary of keyword arguments that will be passed to the\"\n        \" `LLM` class of `vllm` library.\",\n    )\n    chat_template: Optional[str] = None\n\n    _model: Optional[\"_vLLM\"] = PrivateAttr(...)\n    _tokenizer: Optional[\"PreTrainedTokenizer\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `vLLM` model using either the path or the Hugging Face Hub repository id.\n        Additionally, this method also sets the `chat_template` for the tokenizer, so as to properly\n        parse the list of OpenAI formatted inputs using the expected format by the model, otherwise, the\n        default value is ChatML format, unless explicitly provided.\n        \"\"\"\n        super().load()\n\n        CudaDevicePlacementMixin.load(self)\n\n        try:\n            from vllm import LLM as _vLLM\n            from vllm import SamplingParams as _SamplingParams\n\n            global SamplingParams\n            SamplingParams = _SamplingParams\n        except ImportError as ie:\n            raise ImportError(\n                \"vLLM is not installed. Please install it using `pip install vllm`.\"\n            ) from ie\n\n        self._model = _vLLM(self.model, **self.model_kwargs)  # type: ignore\n        self._tokenizer = self._model.get_tokenizer()  # type: ignore\n\n        if self.chat_template is not None:\n            self._tokenizer.chat_template = self.chat_template  # type: ignore\n        elif (\n            self._tokenizer.chat_template is None  # type: ignore\n            and self._tokenizer.default_chat_template is None  # type: ignore\n        ):\n            self._tokenizer.chat_template = CHATML_TEMPLATE\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    def prepare_input(self, input: \"ChatType\") -&gt; str:\n        \"\"\"Prepares the input by applying the chat template to the input, which is formatted\n        as an OpenAI conversation, and adding the generation prompt.\n        \"\"\"\n        return self._tokenizer.apply_chat_template(  # type: ignore\n            input,  # type: ignore\n            tokenize=False,\n            add_generation_prompt=True,  # type: ignore\n        )\n\n    def generate(\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        max_new_tokens: int = 128,\n        frequency_penalty: float = 0.0,\n        presence_penalty: float = 0.0,\n        temperature: float = 1.0,\n        top_p: float = 1.0,\n        top_k: int = -1,\n        extra_sampling_params: Optional[Dict[str, Any]] = None,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Generates `num_generations` responses for each input using the text generation\n        pipeline.\n\n        Args:\n            inputs: a list of inputs in chat format to generate responses for.\n            num_generations: the number of generations to create per input. Defaults to\n                `1`.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            frequency_penalty: the repetition penalty to use for the generation. Defaults\n                to `0.0`.\n            presence_penalty: the presence penalty to use for the generation. Defaults to\n                `0.0`.\n            temperature: the temperature to use for the generation. Defaults to `0.1`.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n            top_k: the top-k value to use for the generation. Defaults to `0`.\n            extra_sampling_params: dictionary with additional arguments to be passed to\n                the `SamplingParams` class from `vllm`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        if extra_sampling_params is None:\n            extra_sampling_params = {}\n        sampling_params = SamplingParams(  # type: ignore\n            n=num_generations,\n            presence_penalty=presence_penalty,\n            frequency_penalty=frequency_penalty,\n            temperature=temperature,\n            top_p=top_p,\n            top_k=top_k,\n            max_tokens=max_new_tokens,\n            **extra_sampling_params,\n        )\n\n        prepared_inputs = [self.prepare_input(input) for input in inputs]\n        batch_outputs = self._model.generate(  # type: ignore\n            prepared_inputs,\n            sampling_params,\n            use_tqdm=False,  # type: ignore\n        )\n        return [\n            [output.text for output in outputs.outputs] for outputs in batch_outputs\n        ]\n</code></pre>"},{"location":"reference/distilabel/llms/vllm/#distilabel.llms.vllm.vLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/vllm/#distilabel.llms.vllm.vLLM.generate","title":"<code>generate(inputs, num_generations=1, max_new_tokens=128, frequency_penalty=0.0, presence_penalty=0.0, temperature=1.0, top_p=1.0, top_k=-1, extra_sampling_params=None)</code>","text":"<p>Generates <code>num_generations</code> responses for each input using the text generation pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>List[ChatType]</code> <p>a list of inputs in chat format to generate responses for.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to create per input. Defaults to <code>1</code>.</p> <code>1</code> <code>max_new_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>frequency_penalty</code> <code>float</code> <p>the repetition penalty to use for the generation. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>presence_penalty</code> <code>float</code> <p>the presence penalty to use for the generation. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Defaults to <code>0.1</code>.</p> <code>1.0</code> <code>top_p</code> <code>float</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>top_k</code> <code>int</code> <p>the top-k value to use for the generation. Defaults to <code>0</code>.</p> <code>-1</code> <code>extra_sampling_params</code> <code>Optional[Dict[str, Any]]</code> <p>dictionary with additional arguments to be passed to the <code>SamplingParams</code> class from <code>vllm</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[GenerateOutput]</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/vllm.py</code> <pre><code>def generate(\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    max_new_tokens: int = 128,\n    frequency_penalty: float = 0.0,\n    presence_penalty: float = 0.0,\n    temperature: float = 1.0,\n    top_p: float = 1.0,\n    top_k: int = -1,\n    extra_sampling_params: Optional[Dict[str, Any]] = None,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Generates `num_generations` responses for each input using the text generation\n    pipeline.\n\n    Args:\n        inputs: a list of inputs in chat format to generate responses for.\n        num_generations: the number of generations to create per input. Defaults to\n            `1`.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        frequency_penalty: the repetition penalty to use for the generation. Defaults\n            to `0.0`.\n        presence_penalty: the presence penalty to use for the generation. Defaults to\n            `0.0`.\n        temperature: the temperature to use for the generation. Defaults to `0.1`.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n        top_k: the top-k value to use for the generation. Defaults to `0`.\n        extra_sampling_params: dictionary with additional arguments to be passed to\n            the `SamplingParams` class from `vllm`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    if extra_sampling_params is None:\n        extra_sampling_params = {}\n    sampling_params = SamplingParams(  # type: ignore\n        n=num_generations,\n        presence_penalty=presence_penalty,\n        frequency_penalty=frequency_penalty,\n        temperature=temperature,\n        top_p=top_p,\n        top_k=top_k,\n        max_tokens=max_new_tokens,\n        **extra_sampling_params,\n    )\n\n    prepared_inputs = [self.prepare_input(input) for input in inputs]\n    batch_outputs = self._model.generate(  # type: ignore\n        prepared_inputs,\n        sampling_params,\n        use_tqdm=False,  # type: ignore\n    )\n    return [\n        [output.text for output in outputs.outputs] for outputs in batch_outputs\n    ]\n</code></pre>"},{"location":"reference/distilabel/llms/vllm/#distilabel.llms.vllm.vLLM.load","title":"<code>load()</code>","text":"<p>Loads the <code>vLLM</code> model using either the path or the Hugging Face Hub repository id. Additionally, this method also sets the <code>chat_template</code> for the tokenizer, so as to properly parse the list of OpenAI formatted inputs using the expected format by the model, otherwise, the default value is ChatML format, unless explicitly provided.</p> Source code in <code>src/distilabel/llms/vllm.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `vLLM` model using either the path or the Hugging Face Hub repository id.\n    Additionally, this method also sets the `chat_template` for the tokenizer, so as to properly\n    parse the list of OpenAI formatted inputs using the expected format by the model, otherwise, the\n    default value is ChatML format, unless explicitly provided.\n    \"\"\"\n    super().load()\n\n    CudaDevicePlacementMixin.load(self)\n\n    try:\n        from vllm import LLM as _vLLM\n        from vllm import SamplingParams as _SamplingParams\n\n        global SamplingParams\n        SamplingParams = _SamplingParams\n    except ImportError as ie:\n        raise ImportError(\n            \"vLLM is not installed. Please install it using `pip install vllm`.\"\n        ) from ie\n\n    self._model = _vLLM(self.model, **self.model_kwargs)  # type: ignore\n    self._tokenizer = self._model.get_tokenizer()  # type: ignore\n\n    if self.chat_template is not None:\n        self._tokenizer.chat_template = self.chat_template  # type: ignore\n    elif (\n        self._tokenizer.chat_template is None  # type: ignore\n        and self._tokenizer.default_chat_template is None  # type: ignore\n    ):\n        self._tokenizer.chat_template = CHATML_TEMPLATE\n</code></pre>"},{"location":"reference/distilabel/llms/vllm/#distilabel.llms.vllm.vLLM.prepare_input","title":"<code>prepare_input(input)</code>","text":"<p>Prepares the input by applying the chat template to the input, which is formatted as an OpenAI conversation, and adding the generation prompt.</p> Source code in <code>src/distilabel/llms/vllm.py</code> <pre><code>def prepare_input(self, input: \"ChatType\") -&gt; str:\n    \"\"\"Prepares the input by applying the chat template to the input, which is formatted\n    as an OpenAI conversation, and adding the generation prompt.\n    \"\"\"\n    return self._tokenizer.apply_chat_template(  # type: ignore\n        input,  # type: ignore\n        tokenize=False,\n        add_generation_prompt=True,  # type: ignore\n    )\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/","title":"Index","text":""},{"location":"reference/distilabel/llms/huggingface/#distilabel.llms.huggingface.InferenceEndpointsLLM","title":"<code>InferenceEndpointsLLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>InferenceEndpoints LLM implementation running the async API client via either the <code>huggingface_hub.AsyncInferenceClient</code> or via <code>openai.AsyncOpenAI</code>.</p> <p>Attributes:</p> Name Type Description <code>model_id</code> <code>Optional[str]</code> <p>the model ID to use for the LLM as available in the Hugging Face Hub, which will be used to resolve the base URL for the serverless Inference Endpoints API requests. Defaults to <code>None</code>.</p> <code>endpoint_name</code> <code>Optional[RuntimeParameter[str]]</code> <p>the name of the Inference Endpoint to use for the LLM. Defaults to <code>None</code>.</p> <code>endpoint_namespace</code> <code>Optional[RuntimeParameter[str]]</code> <p>the namespace of the Inference Endpoint to use for the LLM. Defaults to <code>None</code>.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the Inference Endpoints API requests.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Inference Endpoints API.</p> <code>tokenizer_id</code> <code>Optional[str]</code> <p>the tokenizer ID to use for the LLM as available in the Hugging Face Hub. Defaults to <code>None</code>, but defining one is recommended to properly format the prompt.</p> <code>model_display_name</code> <code>Optional[str]</code> <p>the model display name to use for the LLM. Defaults to <code>None</code>.</p> <code>use_openai_client</code> <code>bool</code> <p>whether to use the OpenAI client instead of the Hugging Face client.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from distilabel.llms.huggingface import AsyncInferenceEndpointsLLM\n&gt;&gt;&gt; llm = AsyncInferenceEndpointsLLM(model_id=\"model-id\")\n&gt;&gt;&gt; llm.load()\n&gt;&gt;&gt; output = await llm.agenerate([{\"role\": \"user\", \"content\": \"Hello world!\"}])\n</code></pre> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>class InferenceEndpointsLLM(AsyncLLM):\n    \"\"\"InferenceEndpoints LLM implementation running the async API client via either\n    the `huggingface_hub.AsyncInferenceClient` or via `openai.AsyncOpenAI`.\n\n    Attributes:\n        model_id: the model ID to use for the LLM as available in the Hugging Face Hub, which\n            will be used to resolve the base URL for the serverless Inference Endpoints API requests.\n            Defaults to `None`.\n        endpoint_name: the name of the Inference Endpoint to use for the LLM. Defaults to `None`.\n        endpoint_namespace: the namespace of the Inference Endpoint to use for the LLM. Defaults to `None`.\n        base_url: the base URL to use for the Inference Endpoints API requests.\n        api_key: the API key to authenticate the requests to the Inference Endpoints API.\n        tokenizer_id: the tokenizer ID to use for the LLM as available in the Hugging Face Hub.\n            Defaults to `None`, but defining one is recommended to properly format the prompt.\n        model_display_name: the model display name to use for the LLM. Defaults to `None`.\n        use_openai_client: whether to use the OpenAI client instead of the Hugging Face client.\n\n    Examples:\n        &gt;&gt;&gt; from distilabel.llms.huggingface import AsyncInferenceEndpointsLLM\n        &gt;&gt;&gt; llm = AsyncInferenceEndpointsLLM(model_id=\"model-id\")\n        &gt;&gt;&gt; llm.load()\n        &gt;&gt;&gt; output = await llm.agenerate([{\"role\": \"user\", \"content\": \"Hello world!\"}])\n    \"\"\"\n\n    model_id: Optional[str] = None\n\n    endpoint_name: Optional[RuntimeParameter[str]] = Field(\n        default=None,\n        description=\"The name of the Inference Endpoint to use for the LLM.\",\n    )\n    endpoint_namespace: Optional[RuntimeParameter[str]] = Field(\n        default=None,\n        description=\"The namespace of the Inference Endpoint to use for the LLM.\",\n    )\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default=None,\n        description=\"The base URL to use for the Inference Endpoints API requests.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default=os.getenv(_INFERENCE_ENDPOINTS_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Inference Endpoints API.\",\n    )\n\n    tokenizer_id: Optional[str] = None\n    model_display_name: Optional[str] = None\n    use_openai_client: bool = False\n\n    _model_name: Optional[str] = PrivateAttr(default=None)\n    _tokenizer: Optional[\"PreTrainedTokenizer\"] = PrivateAttr(default=None)\n    _api_key_env_var: str = PrivateAttr(_INFERENCE_ENDPOINTS_API_KEY_ENV_VAR_NAME)\n    _aclient: Optional[Union[\"AsyncInferenceClient\", \"AsyncOpenAI\"]] = PrivateAttr(...)\n\n    @model_validator(mode=\"after\")  # type: ignore\n    def only_one_of_model_id_endpoint_name_or_base_url_provided(\n        self,\n    ) -&gt; \"InferenceEndpointsLLM\":\n        \"\"\"Validates that only one of `model_id`, `endpoint_name`, or `base_url` is provided.\"\"\"\n\n        if self.model_id and (not self.endpoint_name and not self.base_url):\n            return self\n\n        if self.endpoint_name and (not self.model_id and not self.base_url):\n            return self\n\n        if self.base_url and (not self.model_id and not self.endpoint_name):\n            return self\n\n        raise ValidationError(\n            \"Only one of `model_id`, `endpoint_name`, or `base_url` must be provided. Found\"\n            f\" `model_id`={self.model_id}, `endpoint_name`={self.endpoint_name}, and\"\n            f\" `base_url`={self.base_url}.\"\n        )\n\n    def load(self) -&gt; None:  # noqa: C901\n        \"\"\"Loads the either the `AsyncInferenceClient` or the `AsyncOpenAI` client to benefit\n        from async requests, running the Hugging Face Inference Endpoint underneath via the\n        `/v1/chat/completions` endpoint, exposed for the models running on TGI using the\n        `text-generation` task.\n\n        Raises:\n            ImportError: if the `openai` Python client is not installed.\n            ImportError: if the `huggingface-hub` Python client is not installed.\n            ValueError: if the model is not currently deployed or is not running the TGI framework.\n            ImportError: if the `transformers` Python client is not installed.\n        \"\"\"\n        super().load()\n\n        try:\n            from huggingface_hub import (\n                AsyncInferenceClient,\n                InferenceClient,\n                get_inference_endpoint,\n            )\n        except ImportError as ie:\n            raise ImportError(\n                \"Hugging Face Hub Python client is not installed. Please install it using\"\n                \" `pip install huggingface-hub`.\"\n            ) from ie\n\n        if self.api_key is None:\n            raise ValueError(\n                f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n                f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n            )\n\n        if self.model_id is not None:\n            client = InferenceClient()\n            status = client.get_model_status(self.model_id)\n\n            if (\n                status.state not in {\"Loadable\", \"Loaded\"}\n                and status.framework != \"text-generation-inference\"\n            ):\n                raise ValueError(\n                    f\"Model {self.model_id} is not currently deployed or is not running the TGI framework\"\n                )\n\n            self.base_url = client._resolve_url(\n                model=self.model_id, task=\"text-generation\"\n            )\n\n        if self.endpoint_name is not None:\n            client = get_inference_endpoint(\n                name=self.endpoint_name,\n                namespace=self.endpoint_namespace,\n                token=self.api_key.get_secret_value(),\n            )\n            if client.status in [\"paused\", \"scaledToZero\"]:\n                client.resume().wait(timeout=300)\n            elif client.status in [\"initializing\"]:\n                client.wait(timeout=300)\n\n            self.base_url = client.url\n            self._model_name = client.repository\n\n        if self.use_openai_client:\n            try:\n                from openai import AsyncOpenAI\n            except ImportError as ie:\n                raise ImportError(\n                    \"OpenAI Python client is not installed. Please install it using\"\n                    \" `pip install openai`.\"\n                ) from ie\n\n            self._aclient = AsyncOpenAI(\n                base_url=self.base_url,\n                api_key=self.api_key.get_secret_value(),\n                max_retries=6,\n            )\n        else:\n            self._aclient = AsyncInferenceClient(\n                model=self.base_url,\n                token=self.api_key.get_secret_value(),\n            )\n\n        if self.tokenizer_id:\n            try:\n                from transformers import AutoTokenizer\n            except ImportError as ie:\n                raise ImportError(\n                    \"Transformers Python client is not installed. Please install it using\"\n                    \" `pip install transformers`.\"\n                ) from ie\n\n            self._tokenizer = AutoTokenizer.from_pretrained(self.tokenizer_id)\n\n    @property\n    @override\n    def model_name(self) -&gt; Union[str, None]:  # type: ignore\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return (\n            self.model_display_name\n            or self._model_name\n            or self.model_id\n            or self.endpoint_name\n            or self.base_url\n        )\n\n    async def _openai_agenerate(\n        self,\n        input: \"ChatType\",\n        max_new_tokens: int = 128,\n        frequency_penalty: float = 0.0,\n        presence_penalty: float = 0.0,\n        temperature: float = 1.0,\n        top_p: Optional[float] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates completions for the given input using the OpenAI async client.\"\"\"\n        completion = await self._aclient.chat.completions.create(  # type: ignore\n            messages=input,  # type: ignore\n            model=\"tgi\",\n            max_tokens=max_new_tokens,\n            n=1,\n            frequency_penalty=frequency_penalty,\n            presence_penalty=presence_penalty,\n            temperature=temperature,\n            top_p=top_p,\n            timeout=50,\n        )\n        if completion.choices[0].message.content is None:\n            self._logger.warning(\n                f\"\u26a0\ufe0f Received no response using OpenAI client (model: '{self.model_name}').\"\n                f\" Finish reason was: {completion.choices[0].finish_reason}\"\n            )\n        return [completion.choices[0].message.content]\n\n    # TODO: add `num_generations` parameter once either TGI or `AsyncInferenceClient` allows `n` parameter\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        max_new_tokens: int = 128,\n        frequency_penalty: float = 0.0,\n        presence_penalty: float = 0.0,\n        repetition_penalty: Optional[float] = None,\n        temperature: float = 1.0,\n        do_sample: bool = False,\n        top_k: Optional[int] = None,\n        top_p: Optional[float] = None,\n        typical_p: Optional[float] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates completions for the given input using the OpenAI async client.\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            frequency_penalty: the repetition penalty to use for the generation. Defaults\n                to `0.0`. Only applies if `use_openai_client=True`.\n            presence_penalty: the presence penalty to use for the generation. Defaults to\n                `0.0`. Only applies if `use_openai_client=True`.\n            repetition_penalty: the repetition penalty to use for the generation. Defaults\n                to `None`. Only applies if `use_openai_client=False`.\n            temperature: the temperature to use for the generation. Defaults to `1.0`.\n            do_sample: whether to use sampling for the generation. Defaults to `False`.\n                Only applies if `use_openai_client=False`.\n            top_k: the top-k value to use for the generation. Defaults to `0.8`, since neither\n                `0.0` nor `1.0` are valid values in TGI.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n            typical_p: the typical-p value to use for the generation. Defaults to `0.5`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n\n        if self.use_openai_client:\n            return await self._openai_agenerate(\n                input=input,\n                max_new_tokens=max_new_tokens,\n                frequency_penalty=frequency_penalty,\n                presence_penalty=presence_penalty,\n                temperature=temperature,\n                top_p=top_p,\n            )\n\n        if self._tokenizer is not None:\n            prompt = self._tokenizer.apply_chat_template(  # type: ignore\n                conversation=input,  # type: ignore\n                tokenize=False,\n                add_generation_prompt=True,\n            )\n        else:\n            prompt = \"\\n\".join([message[\"content\"] for message in input])\n\n        try:\n            completion = await self._aclient.text_generation(  # type: ignore\n                prompt=prompt,  # type: ignore\n                max_new_tokens=max_new_tokens,\n                do_sample=do_sample,\n                typical_p=typical_p,\n                repetition_penalty=repetition_penalty,\n                temperature=temperature,\n                top_p=top_p,\n                top_k=top_k,\n            )\n            return [completion]\n        except Exception as e:\n            self._logger.warning(\n                f\"\u26a0\ufe0f Received no response using Inference Client (model: '{self.model_name}').\"\n                f\" Finish reason was: {e}\"\n            )\n            return [None]\n\n    # TODO: remove this function once `AsyncInferenceClient` allows `n` parameter\n    @override\n    def generate(\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        **kwargs: Any,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Method to generate a list of responses asynchronously, returning the output\n        synchronously awaiting for the response of each input sent to `agenerate`.\n        \"\"\"\n\n        async def agenerate(\n            inputs: List[\"ChatType\"], **kwargs: Any\n        ) -&gt; \"GenerateOutput\":\n            \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n            tasks = [\n                asyncio.create_task(self.agenerate(input=input, **kwargs))\n                for input in inputs\n                for _ in range(num_generations)\n            ]\n            return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n        outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n        return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/#distilabel.llms.huggingface.InferenceEndpointsLLM.model_name","title":"<code>model_name: Union[str, None]</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/huggingface/#distilabel.llms.huggingface.InferenceEndpointsLLM.agenerate","title":"<code>agenerate(input, max_new_tokens=128, frequency_penalty=0.0, presence_penalty=0.0, repetition_penalty=None, temperature=1.0, do_sample=False, top_k=None, top_p=None, typical_p=None)</code>  <code>async</code>","text":"<p>Generates completions for the given input using the OpenAI async client.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>max_new_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>frequency_penalty</code> <code>float</code> <p>the repetition penalty to use for the generation. Defaults to <code>0.0</code>. Only applies if <code>use_openai_client=True</code>.</p> <code>0.0</code> <code>presence_penalty</code> <code>float</code> <p>the presence penalty to use for the generation. Defaults to <code>0.0</code>. Only applies if <code>use_openai_client=True</code>.</p> <code>0.0</code> <code>repetition_penalty</code> <code>Optional[float]</code> <p>the repetition penalty to use for the generation. Defaults to <code>None</code>. Only applies if <code>use_openai_client=False</code>.</p> <code>None</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>do_sample</code> <code>bool</code> <p>whether to use sampling for the generation. Defaults to <code>False</code>. Only applies if <code>use_openai_client=False</code>.</p> <code>False</code> <code>top_k</code> <code>Optional[int]</code> <p>the top-k value to use for the generation. Defaults to <code>0.8</code>, since neither <code>0.0</code> nor <code>1.0</code> are valid values in TGI.</p> <code>None</code> <code>top_p</code> <code>Optional[float]</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>None</code> <code>typical_p</code> <code>Optional[float]</code> <p>the typical-p value to use for the generation. Defaults to <code>0.5</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>GenerateOutput</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    max_new_tokens: int = 128,\n    frequency_penalty: float = 0.0,\n    presence_penalty: float = 0.0,\n    repetition_penalty: Optional[float] = None,\n    temperature: float = 1.0,\n    do_sample: bool = False,\n    top_k: Optional[int] = None,\n    top_p: Optional[float] = None,\n    typical_p: Optional[float] = None,\n) -&gt; \"GenerateOutput\":\n    \"\"\"Generates completions for the given input using the OpenAI async client.\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        frequency_penalty: the repetition penalty to use for the generation. Defaults\n            to `0.0`. Only applies if `use_openai_client=True`.\n        presence_penalty: the presence penalty to use for the generation. Defaults to\n            `0.0`. Only applies if `use_openai_client=True`.\n        repetition_penalty: the repetition penalty to use for the generation. Defaults\n            to `None`. Only applies if `use_openai_client=False`.\n        temperature: the temperature to use for the generation. Defaults to `1.0`.\n        do_sample: whether to use sampling for the generation. Defaults to `False`.\n            Only applies if `use_openai_client=False`.\n        top_k: the top-k value to use for the generation. Defaults to `0.8`, since neither\n            `0.0` nor `1.0` are valid values in TGI.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n        typical_p: the typical-p value to use for the generation. Defaults to `0.5`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n\n    if self.use_openai_client:\n        return await self._openai_agenerate(\n            input=input,\n            max_new_tokens=max_new_tokens,\n            frequency_penalty=frequency_penalty,\n            presence_penalty=presence_penalty,\n            temperature=temperature,\n            top_p=top_p,\n        )\n\n    if self._tokenizer is not None:\n        prompt = self._tokenizer.apply_chat_template(  # type: ignore\n            conversation=input,  # type: ignore\n            tokenize=False,\n            add_generation_prompt=True,\n        )\n    else:\n        prompt = \"\\n\".join([message[\"content\"] for message in input])\n\n    try:\n        completion = await self._aclient.text_generation(  # type: ignore\n            prompt=prompt,  # type: ignore\n            max_new_tokens=max_new_tokens,\n            do_sample=do_sample,\n            typical_p=typical_p,\n            repetition_penalty=repetition_penalty,\n            temperature=temperature,\n            top_p=top_p,\n            top_k=top_k,\n        )\n        return [completion]\n    except Exception as e:\n        self._logger.warning(\n            f\"\u26a0\ufe0f Received no response using Inference Client (model: '{self.model_name}').\"\n            f\" Finish reason was: {e}\"\n        )\n        return [None]\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/#distilabel.llms.huggingface.InferenceEndpointsLLM.generate","title":"<code>generate(inputs, num_generations=1, **kwargs)</code>","text":"<p>Method to generate a list of responses asynchronously, returning the output synchronously awaiting for the response of each input sent to <code>agenerate</code>.</p> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>@override\ndef generate(\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    **kwargs: Any,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Method to generate a list of responses asynchronously, returning the output\n    synchronously awaiting for the response of each input sent to `agenerate`.\n    \"\"\"\n\n    async def agenerate(\n        inputs: List[\"ChatType\"], **kwargs: Any\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n        tasks = [\n            asyncio.create_task(self.agenerate(input=input, **kwargs))\n            for input in inputs\n            for _ in range(num_generations)\n        ]\n        return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n    outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n    return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/#distilabel.llms.huggingface.InferenceEndpointsLLM.load","title":"<code>load()</code>","text":"<p>Loads the either the <code>AsyncInferenceClient</code> or the <code>AsyncOpenAI</code> client to benefit from async requests, running the Hugging Face Inference Endpoint underneath via the <code>/v1/chat/completions</code> endpoint, exposed for the models running on TGI using the <code>text-generation</code> task.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>if the <code>openai</code> Python client is not installed.</p> <code>ImportError</code> <p>if the <code>huggingface-hub</code> Python client is not installed.</p> <code>ValueError</code> <p>if the model is not currently deployed or is not running the TGI framework.</p> <code>ImportError</code> <p>if the <code>transformers</code> Python client is not installed.</p> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>def load(self) -&gt; None:  # noqa: C901\n    \"\"\"Loads the either the `AsyncInferenceClient` or the `AsyncOpenAI` client to benefit\n    from async requests, running the Hugging Face Inference Endpoint underneath via the\n    `/v1/chat/completions` endpoint, exposed for the models running on TGI using the\n    `text-generation` task.\n\n    Raises:\n        ImportError: if the `openai` Python client is not installed.\n        ImportError: if the `huggingface-hub` Python client is not installed.\n        ValueError: if the model is not currently deployed or is not running the TGI framework.\n        ImportError: if the `transformers` Python client is not installed.\n    \"\"\"\n    super().load()\n\n    try:\n        from huggingface_hub import (\n            AsyncInferenceClient,\n            InferenceClient,\n            get_inference_endpoint,\n        )\n    except ImportError as ie:\n        raise ImportError(\n            \"Hugging Face Hub Python client is not installed. Please install it using\"\n            \" `pip install huggingface-hub`.\"\n        ) from ie\n\n    if self.api_key is None:\n        raise ValueError(\n            f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n            f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n        )\n\n    if self.model_id is not None:\n        client = InferenceClient()\n        status = client.get_model_status(self.model_id)\n\n        if (\n            status.state not in {\"Loadable\", \"Loaded\"}\n            and status.framework != \"text-generation-inference\"\n        ):\n            raise ValueError(\n                f\"Model {self.model_id} is not currently deployed or is not running the TGI framework\"\n            )\n\n        self.base_url = client._resolve_url(\n            model=self.model_id, task=\"text-generation\"\n        )\n\n    if self.endpoint_name is not None:\n        client = get_inference_endpoint(\n            name=self.endpoint_name,\n            namespace=self.endpoint_namespace,\n            token=self.api_key.get_secret_value(),\n        )\n        if client.status in [\"paused\", \"scaledToZero\"]:\n            client.resume().wait(timeout=300)\n        elif client.status in [\"initializing\"]:\n            client.wait(timeout=300)\n\n        self.base_url = client.url\n        self._model_name = client.repository\n\n    if self.use_openai_client:\n        try:\n            from openai import AsyncOpenAI\n        except ImportError as ie:\n            raise ImportError(\n                \"OpenAI Python client is not installed. Please install it using\"\n                \" `pip install openai`.\"\n            ) from ie\n\n        self._aclient = AsyncOpenAI(\n            base_url=self.base_url,\n            api_key=self.api_key.get_secret_value(),\n            max_retries=6,\n        )\n    else:\n        self._aclient = AsyncInferenceClient(\n            model=self.base_url,\n            token=self.api_key.get_secret_value(),\n        )\n\n    if self.tokenizer_id:\n        try:\n            from transformers import AutoTokenizer\n        except ImportError as ie:\n            raise ImportError(\n                \"Transformers Python client is not installed. Please install it using\"\n                \" `pip install transformers`.\"\n            ) from ie\n\n        self._tokenizer = AutoTokenizer.from_pretrained(self.tokenizer_id)\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/#distilabel.llms.huggingface.InferenceEndpointsLLM.only_one_of_model_id_endpoint_name_or_base_url_provided","title":"<code>only_one_of_model_id_endpoint_name_or_base_url_provided()</code>","text":"<p>Validates that only one of <code>model_id</code>, <code>endpoint_name</code>, or <code>base_url</code> is provided.</p> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>@model_validator(mode=\"after\")  # type: ignore\ndef only_one_of_model_id_endpoint_name_or_base_url_provided(\n    self,\n) -&gt; \"InferenceEndpointsLLM\":\n    \"\"\"Validates that only one of `model_id`, `endpoint_name`, or `base_url` is provided.\"\"\"\n\n    if self.model_id and (not self.endpoint_name and not self.base_url):\n        return self\n\n    if self.endpoint_name and (not self.model_id and not self.base_url):\n        return self\n\n    if self.base_url and (not self.model_id and not self.endpoint_name):\n        return self\n\n    raise ValidationError(\n        \"Only one of `model_id`, `endpoint_name`, or `base_url` must be provided. Found\"\n        f\" `model_id`={self.model_id}, `endpoint_name`={self.endpoint_name}, and\"\n        f\" `base_url`={self.base_url}.\"\n    )\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/#distilabel.llms.huggingface.TransformersLLM","title":"<code>TransformersLLM</code>","text":"<p>             Bases: <code>LLM</code>, <code>CudaDevicePlacementMixin</code></p> <p>Hugging Face <code>transformers</code> library LLM implementation using the text generation pipeline.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model Hugging Face Hub repo id or a path to a directory containing the model weights and configuration files.</p> <code>revision</code> <code>str</code> <p>if <code>model</code> refers to a Hugging Face Hub repository, then the revision (e.g. a branch name or a commit id) to use. Defaults to <code>\"main\"</code>.</p> <code>torch_dtype</code> <code>str</code> <p>the torch dtype to use for the model e.g. \"float16\", \"float32\", etc. Defaults to <code>\"auto\"</code>.</p> <code>trust_remote_code</code> <code>bool</code> <p>whether to trust or not remote (code in the Hugging Face Hub repository) code to load the model. Defaults to <code>False</code>.</p> <code>model_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>additional dictionary of keyword arguments that will be passed to the <code>from_pretrained</code> method of the model.</p> <code>tokenizer</code> <code>Optional[str]</code> <p>the tokenizer Hugging Face Hub repo id or a path to a directory containing the tokenizer config files. If not provided, the one associated to the <code>model</code> will be used. Defaults to <code>None</code>.</p> <code>use_fast</code> <code>bool</code> <p>whether to use a fast tokenizer or not. Defaults to <code>True</code>.</p> <code>chat_template</code> <code>Optional[str]</code> <p>a chat template that will be used to build the prompts before sending them to the model. If not provided, the chat template defined in the tokenizer config will be used. If not provided and the tokenizer doesn't have a chat template, then ChatML template will be used. Defaults to <code>None</code>.</p> <code>device</code> <code>Optional[Union[str, int]]</code> <p>the name or index of the device where the model will be loaded. Defaults to <code>None</code>.</p> <code>device_map</code> <code>Optional[Union[str, Dict[str, Any]]]</code> <p>a dictionary mapping each layer of the model to a device, or a mode like <code>\"sequential\"</code> or <code>\"auto\"</code>. Defaults to <code>None</code>.</p> <code>token</code> <code>Optional[str]</code> <p>the Hugging Face Hub token that will be used to authenticate to the Hugging Face Hub. If not provided, the <code>HF_TOKEN</code> environment or <code>huggingface_hub</code> package local configuration will be used. Defaults to <code>None</code>.</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>class TransformersLLM(LLM, CudaDevicePlacementMixin):\n    \"\"\"Hugging Face `transformers` library LLM implementation using the text generation\n    pipeline.\n\n    Attributes:\n        model: the model Hugging Face Hub repo id or a path to a directory containing the\n            model weights and configuration files.\n        revision: if `model` refers to a Hugging Face Hub repository, then the revision\n            (e.g. a branch name or a commit id) to use. Defaults to `\"main\"`.\n        torch_dtype: the torch dtype to use for the model e.g. \"float16\", \"float32\", etc.\n            Defaults to `\"auto\"`.\n        trust_remote_code: whether to trust or not remote (code in the Hugging Face Hub\n            repository) code to load the model. Defaults to `False`.\n        model_kwargs: additional dictionary of keyword arguments that will be passed to\n            the `from_pretrained` method of the model.\n        tokenizer: the tokenizer Hugging Face Hub repo id or a path to a directory containing\n            the tokenizer config files. If not provided, the one associated to the `model`\n            will be used. Defaults to `None`.\n        use_fast: whether to use a fast tokenizer or not. Defaults to `True`.\n        chat_template: a chat template that will be used to build the prompts before\n            sending them to the model. If not provided, the chat template defined in the\n            tokenizer config will be used. If not provided and the tokenizer doesn't have\n            a chat template, then ChatML template will be used. Defaults to `None`.\n        device: the name or index of the device where the model will be loaded. Defaults\n            to `None`.\n        device_map: a dictionary mapping each layer of the model to a device, or a mode\n            like `\"sequential\"` or `\"auto\"`. Defaults to `None`.\n        token: the Hugging Face Hub token that will be used to authenticate to the Hugging\n            Face Hub. If not provided, the `HF_TOKEN` environment or `huggingface_hub` package\n            local configuration will be used. Defaults to `None`.\n    \"\"\"\n\n    model: str\n    revision: str = \"main\"\n    torch_dtype: str = \"auto\"\n    trust_remote_code: bool = False\n    model_kwargs: Optional[Dict[str, Any]] = None\n    tokenizer: Optional[str] = None\n    use_fast: bool = True\n    chat_template: Optional[str] = None\n    device: Optional[Union[str, int]] = None\n    device_map: Optional[Union[str, Dict[str, Any]]] = None\n    token: Optional[str] = None\n\n    _pipeline: Optional[\"Pipeline\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the model and tokenizer and creates the text generation pipeline. In addition,\n        it will configure the tokenizer chat template.\"\"\"\n        super().load()\n\n        if self.device == \"cuda\":\n            CudaDevicePlacementMixin.load(self)\n\n        try:\n            from transformers import pipeline\n        except ImportError as ie:\n            raise ImportError(\n                \"Transformers is not installed. Please install it using `pip install transformers`.\"\n            ) from ie\n\n        self._pipeline = pipeline(\n            \"text-generation\",\n            model=self.model,\n            revision=self.revision,\n            torch_dtype=self.torch_dtype,\n            trust_remote_code=self.trust_remote_code,\n            model_kwargs=self.model_kwargs or {},\n            tokenizer=self.tokenizer or self.model,\n            use_fast=self.use_fast,\n            device=self.device,\n            device_map=self.device_map,\n            token=self.token or os.getenv(\"HF_TOKEN\"),\n            return_full_text=False,\n        )\n\n        if self.chat_template is not None:\n            self._pipeline.tokenizer.chat_template = self.chat_template  # type: ignore\n        elif (\n            self._pipeline.tokenizer.chat_template is None  # type: ignore\n            and self._pipeline.tokenizer.default_chat_template is None  # type: ignore\n        ):\n            self._pipeline.tokenizer.chat_template = CHATML_TEMPLATE  # type: ignore\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    def prepare_input(self, input: \"ChatType\") -&gt; str:\n        \"\"\"Prepares the input by applying the chat template to the input, which is formatted\n        as an OpenAI conversation, and adding the generation prompt.\n        \"\"\"\n        return self._pipeline.tokenizer.apply_chat_template(  # type: ignore\n            input,  # type: ignore\n            tokenize=False,\n            add_generation_prompt=True,\n        )\n\n    def generate(  # type: ignore\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        max_new_tokens: int = 128,\n        temperature: float = 0.1,\n        repetition_penalty: float = 1.1,\n        top_p: float = 1.0,\n        top_k: int = 0,\n        do_sample: bool = True,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Generates `num_generations` responses for each input using the text generation\n        pipeline.\n\n        Args:\n            inputs: a list of inputs in chat format to generate responses for.\n            num_generations: the number of generations to create per input. Defaults to\n                `1`.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            temperature: the temperature to use for the generation. Defaults to `0.1`.\n            repetition_penalty: the repetition penalty to use for the generation. Defaults\n                to `1.1`.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n            top_k: the top-k value to use for the generation. Defaults to `0`.\n            do_sample: whether to use sampling or not. Defaults to `True`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        outputs: List[List[Dict[str, str]]] = self._pipeline(  # type: ignore\n            [self.prepare_input(input=input) for input in inputs],\n            max_new_tokens=max_new_tokens,\n            temperature=temperature,\n            repetition_penalty=repetition_penalty,\n            top_p=top_p,\n            top_k=top_k,\n            do_sample=do_sample,\n            num_return_sequences=num_generations,\n        )\n        return [\n            [generation[\"generated_text\"] for generation in output]\n            for output in outputs\n        ]\n\n    def get_last_hidden_states(self, inputs: List[\"ChatType\"]) -&gt; List[\"HiddenState\"]:\n        \"\"\"Gets the last `hidden_states` of the model for the given inputs. It doesn't\n        execute the task head.\n\n        Args:\n            inputs: a list of inputs in chat format to generate the embeddings for.\n\n        Returns:\n            A list containing the last hidden state for each sequence using a NumPy array\n            with shape [num_tokens, hidden_size].\n        \"\"\"\n        model: \"PreTrainedModel\" = (\n            self._pipeline.model.model  # type: ignore\n            if hasattr(self._pipeline.model, \"model\")  # type: ignore\n            else next(self._pipeline.model.children())  # type: ignore\n        )\n        tokenizer: \"PreTrainedTokenizer\" = self._pipeline.tokenizer  # type: ignore\n        input_ids = tokenizer(\n            [self.prepare_input(input) for input in inputs],  # type: ignore\n            return_tensors=\"pt\",\n            padding=True,\n        ).to(model.device)\n        last_hidden_states = model(**input_ids)[\"last_hidden_state\"]\n\n        return [\n            seq_last_hidden_state[attention_mask.bool(), :].detach().cpu().numpy()\n            for seq_last_hidden_state, attention_mask in zip(\n                last_hidden_states,\n                input_ids[\"attention_mask\"],  # type: ignore\n            )\n        ]\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/#distilabel.llms.huggingface.TransformersLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/huggingface/#distilabel.llms.huggingface.TransformersLLM.generate","title":"<code>generate(inputs, num_generations=1, max_new_tokens=128, temperature=0.1, repetition_penalty=1.1, top_p=1.0, top_k=0, do_sample=True)</code>","text":"<p>Generates <code>num_generations</code> responses for each input using the text generation pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>List[ChatType]</code> <p>a list of inputs in chat format to generate responses for.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to create per input. Defaults to <code>1</code>.</p> <code>1</code> <code>max_new_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Defaults to <code>0.1</code>.</p> <code>0.1</code> <code>repetition_penalty</code> <code>float</code> <p>the repetition penalty to use for the generation. Defaults to <code>1.1</code>.</p> <code>1.1</code> <code>top_p</code> <code>float</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>top_k</code> <code>int</code> <p>the top-k value to use for the generation. Defaults to <code>0</code>.</p> <code>0</code> <code>do_sample</code> <code>bool</code> <p>whether to use sampling or not. Defaults to <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>List[GenerateOutput]</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>def generate(  # type: ignore\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    max_new_tokens: int = 128,\n    temperature: float = 0.1,\n    repetition_penalty: float = 1.1,\n    top_p: float = 1.0,\n    top_k: int = 0,\n    do_sample: bool = True,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Generates `num_generations` responses for each input using the text generation\n    pipeline.\n\n    Args:\n        inputs: a list of inputs in chat format to generate responses for.\n        num_generations: the number of generations to create per input. Defaults to\n            `1`.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        temperature: the temperature to use for the generation. Defaults to `0.1`.\n        repetition_penalty: the repetition penalty to use for the generation. Defaults\n            to `1.1`.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n        top_k: the top-k value to use for the generation. Defaults to `0`.\n        do_sample: whether to use sampling or not. Defaults to `True`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    outputs: List[List[Dict[str, str]]] = self._pipeline(  # type: ignore\n        [self.prepare_input(input=input) for input in inputs],\n        max_new_tokens=max_new_tokens,\n        temperature=temperature,\n        repetition_penalty=repetition_penalty,\n        top_p=top_p,\n        top_k=top_k,\n        do_sample=do_sample,\n        num_return_sequences=num_generations,\n    )\n    return [\n        [generation[\"generated_text\"] for generation in output]\n        for output in outputs\n    ]\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/#distilabel.llms.huggingface.TransformersLLM.get_last_hidden_states","title":"<code>get_last_hidden_states(inputs)</code>","text":"<p>Gets the last <code>hidden_states</code> of the model for the given inputs. It doesn't execute the task head.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>List[ChatType]</code> <p>a list of inputs in chat format to generate the embeddings for.</p> required <p>Returns:</p> Type Description <code>List[HiddenState]</code> <p>A list containing the last hidden state for each sequence using a NumPy array</p> <code>List[HiddenState]</code> <p>with shape [num_tokens, hidden_size].</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>def get_last_hidden_states(self, inputs: List[\"ChatType\"]) -&gt; List[\"HiddenState\"]:\n    \"\"\"Gets the last `hidden_states` of the model for the given inputs. It doesn't\n    execute the task head.\n\n    Args:\n        inputs: a list of inputs in chat format to generate the embeddings for.\n\n    Returns:\n        A list containing the last hidden state for each sequence using a NumPy array\n        with shape [num_tokens, hidden_size].\n    \"\"\"\n    model: \"PreTrainedModel\" = (\n        self._pipeline.model.model  # type: ignore\n        if hasattr(self._pipeline.model, \"model\")  # type: ignore\n        else next(self._pipeline.model.children())  # type: ignore\n    )\n    tokenizer: \"PreTrainedTokenizer\" = self._pipeline.tokenizer  # type: ignore\n    input_ids = tokenizer(\n        [self.prepare_input(input) for input in inputs],  # type: ignore\n        return_tensors=\"pt\",\n        padding=True,\n    ).to(model.device)\n    last_hidden_states = model(**input_ids)[\"last_hidden_state\"]\n\n    return [\n        seq_last_hidden_state[attention_mask.bool(), :].detach().cpu().numpy()\n        for seq_last_hidden_state, attention_mask in zip(\n            last_hidden_states,\n            input_ids[\"attention_mask\"],  # type: ignore\n        )\n    ]\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/#distilabel.llms.huggingface.TransformersLLM.load","title":"<code>load()</code>","text":"<p>Loads the model and tokenizer and creates the text generation pipeline. In addition, it will configure the tokenizer chat template.</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the model and tokenizer and creates the text generation pipeline. In addition,\n    it will configure the tokenizer chat template.\"\"\"\n    super().load()\n\n    if self.device == \"cuda\":\n        CudaDevicePlacementMixin.load(self)\n\n    try:\n        from transformers import pipeline\n    except ImportError as ie:\n        raise ImportError(\n            \"Transformers is not installed. Please install it using `pip install transformers`.\"\n        ) from ie\n\n    self._pipeline = pipeline(\n        \"text-generation\",\n        model=self.model,\n        revision=self.revision,\n        torch_dtype=self.torch_dtype,\n        trust_remote_code=self.trust_remote_code,\n        model_kwargs=self.model_kwargs or {},\n        tokenizer=self.tokenizer or self.model,\n        use_fast=self.use_fast,\n        device=self.device,\n        device_map=self.device_map,\n        token=self.token or os.getenv(\"HF_TOKEN\"),\n        return_full_text=False,\n    )\n\n    if self.chat_template is not None:\n        self._pipeline.tokenizer.chat_template = self.chat_template  # type: ignore\n    elif (\n        self._pipeline.tokenizer.chat_template is None  # type: ignore\n        and self._pipeline.tokenizer.default_chat_template is None  # type: ignore\n    ):\n        self._pipeline.tokenizer.chat_template = CHATML_TEMPLATE  # type: ignore\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/#distilabel.llms.huggingface.TransformersLLM.prepare_input","title":"<code>prepare_input(input)</code>","text":"<p>Prepares the input by applying the chat template to the input, which is formatted as an OpenAI conversation, and adding the generation prompt.</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>def prepare_input(self, input: \"ChatType\") -&gt; str:\n    \"\"\"Prepares the input by applying the chat template to the input, which is formatted\n    as an OpenAI conversation, and adding the generation prompt.\n    \"\"\"\n    return self._pipeline.tokenizer.apply_chat_template(  # type: ignore\n        input,  # type: ignore\n        tokenize=False,\n        add_generation_prompt=True,\n    )\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/inference_endpoints/","title":"Inference endpoints","text":""},{"location":"reference/distilabel/llms/huggingface/inference_endpoints/#distilabel.llms.huggingface.inference_endpoints.InferenceEndpointsLLM","title":"<code>InferenceEndpointsLLM</code>","text":"<p>             Bases: <code>AsyncLLM</code></p> <p>InferenceEndpoints LLM implementation running the async API client via either the <code>huggingface_hub.AsyncInferenceClient</code> or via <code>openai.AsyncOpenAI</code>.</p> <p>Attributes:</p> Name Type Description <code>model_id</code> <code>Optional[str]</code> <p>the model ID to use for the LLM as available in the Hugging Face Hub, which will be used to resolve the base URL for the serverless Inference Endpoints API requests. Defaults to <code>None</code>.</p> <code>endpoint_name</code> <code>Optional[RuntimeParameter[str]]</code> <p>the name of the Inference Endpoint to use for the LLM. Defaults to <code>None</code>.</p> <code>endpoint_namespace</code> <code>Optional[RuntimeParameter[str]]</code> <p>the namespace of the Inference Endpoint to use for the LLM. Defaults to <code>None</code>.</p> <code>base_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>the base URL to use for the Inference Endpoints API requests.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>the API key to authenticate the requests to the Inference Endpoints API.</p> <code>tokenizer_id</code> <code>Optional[str]</code> <p>the tokenizer ID to use for the LLM as available in the Hugging Face Hub. Defaults to <code>None</code>, but defining one is recommended to properly format the prompt.</p> <code>model_display_name</code> <code>Optional[str]</code> <p>the model display name to use for the LLM. Defaults to <code>None</code>.</p> <code>use_openai_client</code> <code>bool</code> <p>whether to use the OpenAI client instead of the Hugging Face client.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from distilabel.llms.huggingface import AsyncInferenceEndpointsLLM\n&gt;&gt;&gt; llm = AsyncInferenceEndpointsLLM(model_id=\"model-id\")\n&gt;&gt;&gt; llm.load()\n&gt;&gt;&gt; output = await llm.agenerate([{\"role\": \"user\", \"content\": \"Hello world!\"}])\n</code></pre> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>class InferenceEndpointsLLM(AsyncLLM):\n    \"\"\"InferenceEndpoints LLM implementation running the async API client via either\n    the `huggingface_hub.AsyncInferenceClient` or via `openai.AsyncOpenAI`.\n\n    Attributes:\n        model_id: the model ID to use for the LLM as available in the Hugging Face Hub, which\n            will be used to resolve the base URL for the serverless Inference Endpoints API requests.\n            Defaults to `None`.\n        endpoint_name: the name of the Inference Endpoint to use for the LLM. Defaults to `None`.\n        endpoint_namespace: the namespace of the Inference Endpoint to use for the LLM. Defaults to `None`.\n        base_url: the base URL to use for the Inference Endpoints API requests.\n        api_key: the API key to authenticate the requests to the Inference Endpoints API.\n        tokenizer_id: the tokenizer ID to use for the LLM as available in the Hugging Face Hub.\n            Defaults to `None`, but defining one is recommended to properly format the prompt.\n        model_display_name: the model display name to use for the LLM. Defaults to `None`.\n        use_openai_client: whether to use the OpenAI client instead of the Hugging Face client.\n\n    Examples:\n        &gt;&gt;&gt; from distilabel.llms.huggingface import AsyncInferenceEndpointsLLM\n        &gt;&gt;&gt; llm = AsyncInferenceEndpointsLLM(model_id=\"model-id\")\n        &gt;&gt;&gt; llm.load()\n        &gt;&gt;&gt; output = await llm.agenerate([{\"role\": \"user\", \"content\": \"Hello world!\"}])\n    \"\"\"\n\n    model_id: Optional[str] = None\n\n    endpoint_name: Optional[RuntimeParameter[str]] = Field(\n        default=None,\n        description=\"The name of the Inference Endpoint to use for the LLM.\",\n    )\n    endpoint_namespace: Optional[RuntimeParameter[str]] = Field(\n        default=None,\n        description=\"The namespace of the Inference Endpoint to use for the LLM.\",\n    )\n    base_url: Optional[RuntimeParameter[str]] = Field(\n        default=None,\n        description=\"The base URL to use for the Inference Endpoints API requests.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default=os.getenv(_INFERENCE_ENDPOINTS_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Inference Endpoints API.\",\n    )\n\n    tokenizer_id: Optional[str] = None\n    model_display_name: Optional[str] = None\n    use_openai_client: bool = False\n\n    _model_name: Optional[str] = PrivateAttr(default=None)\n    _tokenizer: Optional[\"PreTrainedTokenizer\"] = PrivateAttr(default=None)\n    _api_key_env_var: str = PrivateAttr(_INFERENCE_ENDPOINTS_API_KEY_ENV_VAR_NAME)\n    _aclient: Optional[Union[\"AsyncInferenceClient\", \"AsyncOpenAI\"]] = PrivateAttr(...)\n\n    @model_validator(mode=\"after\")  # type: ignore\n    def only_one_of_model_id_endpoint_name_or_base_url_provided(\n        self,\n    ) -&gt; \"InferenceEndpointsLLM\":\n        \"\"\"Validates that only one of `model_id`, `endpoint_name`, or `base_url` is provided.\"\"\"\n\n        if self.model_id and (not self.endpoint_name and not self.base_url):\n            return self\n\n        if self.endpoint_name and (not self.model_id and not self.base_url):\n            return self\n\n        if self.base_url and (not self.model_id and not self.endpoint_name):\n            return self\n\n        raise ValidationError(\n            \"Only one of `model_id`, `endpoint_name`, or `base_url` must be provided. Found\"\n            f\" `model_id`={self.model_id}, `endpoint_name`={self.endpoint_name}, and\"\n            f\" `base_url`={self.base_url}.\"\n        )\n\n    def load(self) -&gt; None:  # noqa: C901\n        \"\"\"Loads the either the `AsyncInferenceClient` or the `AsyncOpenAI` client to benefit\n        from async requests, running the Hugging Face Inference Endpoint underneath via the\n        `/v1/chat/completions` endpoint, exposed for the models running on TGI using the\n        `text-generation` task.\n\n        Raises:\n            ImportError: if the `openai` Python client is not installed.\n            ImportError: if the `huggingface-hub` Python client is not installed.\n            ValueError: if the model is not currently deployed or is not running the TGI framework.\n            ImportError: if the `transformers` Python client is not installed.\n        \"\"\"\n        super().load()\n\n        try:\n            from huggingface_hub import (\n                AsyncInferenceClient,\n                InferenceClient,\n                get_inference_endpoint,\n            )\n        except ImportError as ie:\n            raise ImportError(\n                \"Hugging Face Hub Python client is not installed. Please install it using\"\n                \" `pip install huggingface-hub`.\"\n            ) from ie\n\n        if self.api_key is None:\n            raise ValueError(\n                f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n                f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n            )\n\n        if self.model_id is not None:\n            client = InferenceClient()\n            status = client.get_model_status(self.model_id)\n\n            if (\n                status.state not in {\"Loadable\", \"Loaded\"}\n                and status.framework != \"text-generation-inference\"\n            ):\n                raise ValueError(\n                    f\"Model {self.model_id} is not currently deployed or is not running the TGI framework\"\n                )\n\n            self.base_url = client._resolve_url(\n                model=self.model_id, task=\"text-generation\"\n            )\n\n        if self.endpoint_name is not None:\n            client = get_inference_endpoint(\n                name=self.endpoint_name,\n                namespace=self.endpoint_namespace,\n                token=self.api_key.get_secret_value(),\n            )\n            if client.status in [\"paused\", \"scaledToZero\"]:\n                client.resume().wait(timeout=300)\n            elif client.status in [\"initializing\"]:\n                client.wait(timeout=300)\n\n            self.base_url = client.url\n            self._model_name = client.repository\n\n        if self.use_openai_client:\n            try:\n                from openai import AsyncOpenAI\n            except ImportError as ie:\n                raise ImportError(\n                    \"OpenAI Python client is not installed. Please install it using\"\n                    \" `pip install openai`.\"\n                ) from ie\n\n            self._aclient = AsyncOpenAI(\n                base_url=self.base_url,\n                api_key=self.api_key.get_secret_value(),\n                max_retries=6,\n            )\n        else:\n            self._aclient = AsyncInferenceClient(\n                model=self.base_url,\n                token=self.api_key.get_secret_value(),\n            )\n\n        if self.tokenizer_id:\n            try:\n                from transformers import AutoTokenizer\n            except ImportError as ie:\n                raise ImportError(\n                    \"Transformers Python client is not installed. Please install it using\"\n                    \" `pip install transformers`.\"\n                ) from ie\n\n            self._tokenizer = AutoTokenizer.from_pretrained(self.tokenizer_id)\n\n    @property\n    @override\n    def model_name(self) -&gt; Union[str, None]:  # type: ignore\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return (\n            self.model_display_name\n            or self._model_name\n            or self.model_id\n            or self.endpoint_name\n            or self.base_url\n        )\n\n    async def _openai_agenerate(\n        self,\n        input: \"ChatType\",\n        max_new_tokens: int = 128,\n        frequency_penalty: float = 0.0,\n        presence_penalty: float = 0.0,\n        temperature: float = 1.0,\n        top_p: Optional[float] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates completions for the given input using the OpenAI async client.\"\"\"\n        completion = await self._aclient.chat.completions.create(  # type: ignore\n            messages=input,  # type: ignore\n            model=\"tgi\",\n            max_tokens=max_new_tokens,\n            n=1,\n            frequency_penalty=frequency_penalty,\n            presence_penalty=presence_penalty,\n            temperature=temperature,\n            top_p=top_p,\n            timeout=50,\n        )\n        if completion.choices[0].message.content is None:\n            self._logger.warning(\n                f\"\u26a0\ufe0f Received no response using OpenAI client (model: '{self.model_name}').\"\n                f\" Finish reason was: {completion.choices[0].finish_reason}\"\n            )\n        return [completion.choices[0].message.content]\n\n    # TODO: add `num_generations` parameter once either TGI or `AsyncInferenceClient` allows `n` parameter\n    async def agenerate(  # type: ignore\n        self,\n        input: \"ChatType\",\n        max_new_tokens: int = 128,\n        frequency_penalty: float = 0.0,\n        presence_penalty: float = 0.0,\n        repetition_penalty: Optional[float] = None,\n        temperature: float = 1.0,\n        do_sample: bool = False,\n        top_k: Optional[int] = None,\n        top_p: Optional[float] = None,\n        typical_p: Optional[float] = None,\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Generates completions for the given input using the OpenAI async client.\n\n        Args:\n            input: a single input in chat format to generate responses for.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            frequency_penalty: the repetition penalty to use for the generation. Defaults\n                to `0.0`. Only applies if `use_openai_client=True`.\n            presence_penalty: the presence penalty to use for the generation. Defaults to\n                `0.0`. Only applies if `use_openai_client=True`.\n            repetition_penalty: the repetition penalty to use for the generation. Defaults\n                to `None`. Only applies if `use_openai_client=False`.\n            temperature: the temperature to use for the generation. Defaults to `1.0`.\n            do_sample: whether to use sampling for the generation. Defaults to `False`.\n                Only applies if `use_openai_client=False`.\n            top_k: the top-k value to use for the generation. Defaults to `0.8`, since neither\n                `0.0` nor `1.0` are valid values in TGI.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n            typical_p: the typical-p value to use for the generation. Defaults to `0.5`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n\n        if self.use_openai_client:\n            return await self._openai_agenerate(\n                input=input,\n                max_new_tokens=max_new_tokens,\n                frequency_penalty=frequency_penalty,\n                presence_penalty=presence_penalty,\n                temperature=temperature,\n                top_p=top_p,\n            )\n\n        if self._tokenizer is not None:\n            prompt = self._tokenizer.apply_chat_template(  # type: ignore\n                conversation=input,  # type: ignore\n                tokenize=False,\n                add_generation_prompt=True,\n            )\n        else:\n            prompt = \"\\n\".join([message[\"content\"] for message in input])\n\n        try:\n            completion = await self._aclient.text_generation(  # type: ignore\n                prompt=prompt,  # type: ignore\n                max_new_tokens=max_new_tokens,\n                do_sample=do_sample,\n                typical_p=typical_p,\n                repetition_penalty=repetition_penalty,\n                temperature=temperature,\n                top_p=top_p,\n                top_k=top_k,\n            )\n            return [completion]\n        except Exception as e:\n            self._logger.warning(\n                f\"\u26a0\ufe0f Received no response using Inference Client (model: '{self.model_name}').\"\n                f\" Finish reason was: {e}\"\n            )\n            return [None]\n\n    # TODO: remove this function once `AsyncInferenceClient` allows `n` parameter\n    @override\n    def generate(\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        **kwargs: Any,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Method to generate a list of responses asynchronously, returning the output\n        synchronously awaiting for the response of each input sent to `agenerate`.\n        \"\"\"\n\n        async def agenerate(\n            inputs: List[\"ChatType\"], **kwargs: Any\n        ) -&gt; \"GenerateOutput\":\n            \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n            tasks = [\n                asyncio.create_task(self.agenerate(input=input, **kwargs))\n                for input in inputs\n                for _ in range(num_generations)\n            ]\n            return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n        outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n        return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/inference_endpoints/#distilabel.llms.huggingface.inference_endpoints.InferenceEndpointsLLM.model_name","title":"<code>model_name: Union[str, None]</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/huggingface/inference_endpoints/#distilabel.llms.huggingface.inference_endpoints.InferenceEndpointsLLM.agenerate","title":"<code>agenerate(input, max_new_tokens=128, frequency_penalty=0.0, presence_penalty=0.0, repetition_penalty=None, temperature=1.0, do_sample=False, top_k=None, top_p=None, typical_p=None)</code>  <code>async</code>","text":"<p>Generates completions for the given input using the OpenAI async client.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>ChatType</code> <p>a single input in chat format to generate responses for.</p> required <code>max_new_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>frequency_penalty</code> <code>float</code> <p>the repetition penalty to use for the generation. Defaults to <code>0.0</code>. Only applies if <code>use_openai_client=True</code>.</p> <code>0.0</code> <code>presence_penalty</code> <code>float</code> <p>the presence penalty to use for the generation. Defaults to <code>0.0</code>. Only applies if <code>use_openai_client=True</code>.</p> <code>0.0</code> <code>repetition_penalty</code> <code>Optional[float]</code> <p>the repetition penalty to use for the generation. Defaults to <code>None</code>. Only applies if <code>use_openai_client=False</code>.</p> <code>None</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>do_sample</code> <code>bool</code> <p>whether to use sampling for the generation. Defaults to <code>False</code>. Only applies if <code>use_openai_client=False</code>.</p> <code>False</code> <code>top_k</code> <code>Optional[int]</code> <p>the top-k value to use for the generation. Defaults to <code>0.8</code>, since neither <code>0.0</code> nor <code>1.0</code> are valid values in TGI.</p> <code>None</code> <code>top_p</code> <code>Optional[float]</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>None</code> <code>typical_p</code> <code>Optional[float]</code> <p>the typical-p value to use for the generation. Defaults to <code>0.5</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>GenerateOutput</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>async def agenerate(  # type: ignore\n    self,\n    input: \"ChatType\",\n    max_new_tokens: int = 128,\n    frequency_penalty: float = 0.0,\n    presence_penalty: float = 0.0,\n    repetition_penalty: Optional[float] = None,\n    temperature: float = 1.0,\n    do_sample: bool = False,\n    top_k: Optional[int] = None,\n    top_p: Optional[float] = None,\n    typical_p: Optional[float] = None,\n) -&gt; \"GenerateOutput\":\n    \"\"\"Generates completions for the given input using the OpenAI async client.\n\n    Args:\n        input: a single input in chat format to generate responses for.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        frequency_penalty: the repetition penalty to use for the generation. Defaults\n            to `0.0`. Only applies if `use_openai_client=True`.\n        presence_penalty: the presence penalty to use for the generation. Defaults to\n            `0.0`. Only applies if `use_openai_client=True`.\n        repetition_penalty: the repetition penalty to use for the generation. Defaults\n            to `None`. Only applies if `use_openai_client=False`.\n        temperature: the temperature to use for the generation. Defaults to `1.0`.\n        do_sample: whether to use sampling for the generation. Defaults to `False`.\n            Only applies if `use_openai_client=False`.\n        top_k: the top-k value to use for the generation. Defaults to `0.8`, since neither\n            `0.0` nor `1.0` are valid values in TGI.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n        typical_p: the typical-p value to use for the generation. Defaults to `0.5`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n\n    if self.use_openai_client:\n        return await self._openai_agenerate(\n            input=input,\n            max_new_tokens=max_new_tokens,\n            frequency_penalty=frequency_penalty,\n            presence_penalty=presence_penalty,\n            temperature=temperature,\n            top_p=top_p,\n        )\n\n    if self._tokenizer is not None:\n        prompt = self._tokenizer.apply_chat_template(  # type: ignore\n            conversation=input,  # type: ignore\n            tokenize=False,\n            add_generation_prompt=True,\n        )\n    else:\n        prompt = \"\\n\".join([message[\"content\"] for message in input])\n\n    try:\n        completion = await self._aclient.text_generation(  # type: ignore\n            prompt=prompt,  # type: ignore\n            max_new_tokens=max_new_tokens,\n            do_sample=do_sample,\n            typical_p=typical_p,\n            repetition_penalty=repetition_penalty,\n            temperature=temperature,\n            top_p=top_p,\n            top_k=top_k,\n        )\n        return [completion]\n    except Exception as e:\n        self._logger.warning(\n            f\"\u26a0\ufe0f Received no response using Inference Client (model: '{self.model_name}').\"\n            f\" Finish reason was: {e}\"\n        )\n        return [None]\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/inference_endpoints/#distilabel.llms.huggingface.inference_endpoints.InferenceEndpointsLLM.generate","title":"<code>generate(inputs, num_generations=1, **kwargs)</code>","text":"<p>Method to generate a list of responses asynchronously, returning the output synchronously awaiting for the response of each input sent to <code>agenerate</code>.</p> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>@override\ndef generate(\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    **kwargs: Any,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Method to generate a list of responses asynchronously, returning the output\n    synchronously awaiting for the response of each input sent to `agenerate`.\n    \"\"\"\n\n    async def agenerate(\n        inputs: List[\"ChatType\"], **kwargs: Any\n    ) -&gt; \"GenerateOutput\":\n        \"\"\"Internal function to parallelize the asynchronous generation of responses.\"\"\"\n        tasks = [\n            asyncio.create_task(self.agenerate(input=input, **kwargs))\n            for input in inputs\n            for _ in range(num_generations)\n        ]\n        return [outputs[0] for outputs in await asyncio.gather(*tasks)]\n\n    outputs = self.event_loop.run_until_complete(agenerate(inputs, **kwargs))\n    return list(grouper(outputs, n=num_generations, incomplete=\"ignore\"))\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/inference_endpoints/#distilabel.llms.huggingface.inference_endpoints.InferenceEndpointsLLM.load","title":"<code>load()</code>","text":"<p>Loads the either the <code>AsyncInferenceClient</code> or the <code>AsyncOpenAI</code> client to benefit from async requests, running the Hugging Face Inference Endpoint underneath via the <code>/v1/chat/completions</code> endpoint, exposed for the models running on TGI using the <code>text-generation</code> task.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>if the <code>openai</code> Python client is not installed.</p> <code>ImportError</code> <p>if the <code>huggingface-hub</code> Python client is not installed.</p> <code>ValueError</code> <p>if the model is not currently deployed or is not running the TGI framework.</p> <code>ImportError</code> <p>if the <code>transformers</code> Python client is not installed.</p> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>def load(self) -&gt; None:  # noqa: C901\n    \"\"\"Loads the either the `AsyncInferenceClient` or the `AsyncOpenAI` client to benefit\n    from async requests, running the Hugging Face Inference Endpoint underneath via the\n    `/v1/chat/completions` endpoint, exposed for the models running on TGI using the\n    `text-generation` task.\n\n    Raises:\n        ImportError: if the `openai` Python client is not installed.\n        ImportError: if the `huggingface-hub` Python client is not installed.\n        ValueError: if the model is not currently deployed or is not running the TGI framework.\n        ImportError: if the `transformers` Python client is not installed.\n    \"\"\"\n    super().load()\n\n    try:\n        from huggingface_hub import (\n            AsyncInferenceClient,\n            InferenceClient,\n            get_inference_endpoint,\n        )\n    except ImportError as ie:\n        raise ImportError(\n            \"Hugging Face Hub Python client is not installed. Please install it using\"\n            \" `pip install huggingface-hub`.\"\n        ) from ie\n\n    if self.api_key is None:\n        raise ValueError(\n            f\"To use `{self.__class__.__name__}` an API key must be provided via `api_key`\"\n            f\" attribute or runtime parameter, or set the environment variable `{self._api_key_env_var}`.\"\n        )\n\n    if self.model_id is not None:\n        client = InferenceClient()\n        status = client.get_model_status(self.model_id)\n\n        if (\n            status.state not in {\"Loadable\", \"Loaded\"}\n            and status.framework != \"text-generation-inference\"\n        ):\n            raise ValueError(\n                f\"Model {self.model_id} is not currently deployed or is not running the TGI framework\"\n            )\n\n        self.base_url = client._resolve_url(\n            model=self.model_id, task=\"text-generation\"\n        )\n\n    if self.endpoint_name is not None:\n        client = get_inference_endpoint(\n            name=self.endpoint_name,\n            namespace=self.endpoint_namespace,\n            token=self.api_key.get_secret_value(),\n        )\n        if client.status in [\"paused\", \"scaledToZero\"]:\n            client.resume().wait(timeout=300)\n        elif client.status in [\"initializing\"]:\n            client.wait(timeout=300)\n\n        self.base_url = client.url\n        self._model_name = client.repository\n\n    if self.use_openai_client:\n        try:\n            from openai import AsyncOpenAI\n        except ImportError as ie:\n            raise ImportError(\n                \"OpenAI Python client is not installed. Please install it using\"\n                \" `pip install openai`.\"\n            ) from ie\n\n        self._aclient = AsyncOpenAI(\n            base_url=self.base_url,\n            api_key=self.api_key.get_secret_value(),\n            max_retries=6,\n        )\n    else:\n        self._aclient = AsyncInferenceClient(\n            model=self.base_url,\n            token=self.api_key.get_secret_value(),\n        )\n\n    if self.tokenizer_id:\n        try:\n            from transformers import AutoTokenizer\n        except ImportError as ie:\n            raise ImportError(\n                \"Transformers Python client is not installed. Please install it using\"\n                \" `pip install transformers`.\"\n            ) from ie\n\n        self._tokenizer = AutoTokenizer.from_pretrained(self.tokenizer_id)\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/inference_endpoints/#distilabel.llms.huggingface.inference_endpoints.InferenceEndpointsLLM.only_one_of_model_id_endpoint_name_or_base_url_provided","title":"<code>only_one_of_model_id_endpoint_name_or_base_url_provided()</code>","text":"<p>Validates that only one of <code>model_id</code>, <code>endpoint_name</code>, or <code>base_url</code> is provided.</p> Source code in <code>src/distilabel/llms/huggingface/inference_endpoints.py</code> <pre><code>@model_validator(mode=\"after\")  # type: ignore\ndef only_one_of_model_id_endpoint_name_or_base_url_provided(\n    self,\n) -&gt; \"InferenceEndpointsLLM\":\n    \"\"\"Validates that only one of `model_id`, `endpoint_name`, or `base_url` is provided.\"\"\"\n\n    if self.model_id and (not self.endpoint_name and not self.base_url):\n        return self\n\n    if self.endpoint_name and (not self.model_id and not self.base_url):\n        return self\n\n    if self.base_url and (not self.model_id and not self.endpoint_name):\n        return self\n\n    raise ValidationError(\n        \"Only one of `model_id`, `endpoint_name`, or `base_url` must be provided. Found\"\n        f\" `model_id`={self.model_id}, `endpoint_name`={self.endpoint_name}, and\"\n        f\" `base_url`={self.base_url}.\"\n    )\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/transformers/","title":"Transformers","text":""},{"location":"reference/distilabel/llms/huggingface/transformers/#distilabel.llms.huggingface.transformers.TransformersLLM","title":"<code>TransformersLLM</code>","text":"<p>             Bases: <code>LLM</code>, <code>CudaDevicePlacementMixin</code></p> <p>Hugging Face <code>transformers</code> library LLM implementation using the text generation pipeline.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>the model Hugging Face Hub repo id or a path to a directory containing the model weights and configuration files.</p> <code>revision</code> <code>str</code> <p>if <code>model</code> refers to a Hugging Face Hub repository, then the revision (e.g. a branch name or a commit id) to use. Defaults to <code>\"main\"</code>.</p> <code>torch_dtype</code> <code>str</code> <p>the torch dtype to use for the model e.g. \"float16\", \"float32\", etc. Defaults to <code>\"auto\"</code>.</p> <code>trust_remote_code</code> <code>bool</code> <p>whether to trust or not remote (code in the Hugging Face Hub repository) code to load the model. Defaults to <code>False</code>.</p> <code>model_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>additional dictionary of keyword arguments that will be passed to the <code>from_pretrained</code> method of the model.</p> <code>tokenizer</code> <code>Optional[str]</code> <p>the tokenizer Hugging Face Hub repo id or a path to a directory containing the tokenizer config files. If not provided, the one associated to the <code>model</code> will be used. Defaults to <code>None</code>.</p> <code>use_fast</code> <code>bool</code> <p>whether to use a fast tokenizer or not. Defaults to <code>True</code>.</p> <code>chat_template</code> <code>Optional[str]</code> <p>a chat template that will be used to build the prompts before sending them to the model. If not provided, the chat template defined in the tokenizer config will be used. If not provided and the tokenizer doesn't have a chat template, then ChatML template will be used. Defaults to <code>None</code>.</p> <code>device</code> <code>Optional[Union[str, int]]</code> <p>the name or index of the device where the model will be loaded. Defaults to <code>None</code>.</p> <code>device_map</code> <code>Optional[Union[str, Dict[str, Any]]]</code> <p>a dictionary mapping each layer of the model to a device, or a mode like <code>\"sequential\"</code> or <code>\"auto\"</code>. Defaults to <code>None</code>.</p> <code>token</code> <code>Optional[str]</code> <p>the Hugging Face Hub token that will be used to authenticate to the Hugging Face Hub. If not provided, the <code>HF_TOKEN</code> environment or <code>huggingface_hub</code> package local configuration will be used. Defaults to <code>None</code>.</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>class TransformersLLM(LLM, CudaDevicePlacementMixin):\n    \"\"\"Hugging Face `transformers` library LLM implementation using the text generation\n    pipeline.\n\n    Attributes:\n        model: the model Hugging Face Hub repo id or a path to a directory containing the\n            model weights and configuration files.\n        revision: if `model` refers to a Hugging Face Hub repository, then the revision\n            (e.g. a branch name or a commit id) to use. Defaults to `\"main\"`.\n        torch_dtype: the torch dtype to use for the model e.g. \"float16\", \"float32\", etc.\n            Defaults to `\"auto\"`.\n        trust_remote_code: whether to trust or not remote (code in the Hugging Face Hub\n            repository) code to load the model. Defaults to `False`.\n        model_kwargs: additional dictionary of keyword arguments that will be passed to\n            the `from_pretrained` method of the model.\n        tokenizer: the tokenizer Hugging Face Hub repo id or a path to a directory containing\n            the tokenizer config files. If not provided, the one associated to the `model`\n            will be used. Defaults to `None`.\n        use_fast: whether to use a fast tokenizer or not. Defaults to `True`.\n        chat_template: a chat template that will be used to build the prompts before\n            sending them to the model. If not provided, the chat template defined in the\n            tokenizer config will be used. If not provided and the tokenizer doesn't have\n            a chat template, then ChatML template will be used. Defaults to `None`.\n        device: the name or index of the device where the model will be loaded. Defaults\n            to `None`.\n        device_map: a dictionary mapping each layer of the model to a device, or a mode\n            like `\"sequential\"` or `\"auto\"`. Defaults to `None`.\n        token: the Hugging Face Hub token that will be used to authenticate to the Hugging\n            Face Hub. If not provided, the `HF_TOKEN` environment or `huggingface_hub` package\n            local configuration will be used. Defaults to `None`.\n    \"\"\"\n\n    model: str\n    revision: str = \"main\"\n    torch_dtype: str = \"auto\"\n    trust_remote_code: bool = False\n    model_kwargs: Optional[Dict[str, Any]] = None\n    tokenizer: Optional[str] = None\n    use_fast: bool = True\n    chat_template: Optional[str] = None\n    device: Optional[Union[str, int]] = None\n    device_map: Optional[Union[str, Dict[str, Any]]] = None\n    token: Optional[str] = None\n\n    _pipeline: Optional[\"Pipeline\"] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the model and tokenizer and creates the text generation pipeline. In addition,\n        it will configure the tokenizer chat template.\"\"\"\n        super().load()\n\n        if self.device == \"cuda\":\n            CudaDevicePlacementMixin.load(self)\n\n        try:\n            from transformers import pipeline\n        except ImportError as ie:\n            raise ImportError(\n                \"Transformers is not installed. Please install it using `pip install transformers`.\"\n            ) from ie\n\n        self._pipeline = pipeline(\n            \"text-generation\",\n            model=self.model,\n            revision=self.revision,\n            torch_dtype=self.torch_dtype,\n            trust_remote_code=self.trust_remote_code,\n            model_kwargs=self.model_kwargs or {},\n            tokenizer=self.tokenizer or self.model,\n            use_fast=self.use_fast,\n            device=self.device,\n            device_map=self.device_map,\n            token=self.token or os.getenv(\"HF_TOKEN\"),\n            return_full_text=False,\n        )\n\n        if self.chat_template is not None:\n            self._pipeline.tokenizer.chat_template = self.chat_template  # type: ignore\n        elif (\n            self._pipeline.tokenizer.chat_template is None  # type: ignore\n            and self._pipeline.tokenizer.default_chat_template is None  # type: ignore\n        ):\n            self._pipeline.tokenizer.chat_template = CHATML_TEMPLATE  # type: ignore\n\n    @property\n    def model_name(self) -&gt; str:\n        \"\"\"Returns the model name used for the LLM.\"\"\"\n        return self.model\n\n    def prepare_input(self, input: \"ChatType\") -&gt; str:\n        \"\"\"Prepares the input by applying the chat template to the input, which is formatted\n        as an OpenAI conversation, and adding the generation prompt.\n        \"\"\"\n        return self._pipeline.tokenizer.apply_chat_template(  # type: ignore\n            input,  # type: ignore\n            tokenize=False,\n            add_generation_prompt=True,\n        )\n\n    def generate(  # type: ignore\n        self,\n        inputs: List[\"ChatType\"],\n        num_generations: int = 1,\n        max_new_tokens: int = 128,\n        temperature: float = 0.1,\n        repetition_penalty: float = 1.1,\n        top_p: float = 1.0,\n        top_k: int = 0,\n        do_sample: bool = True,\n    ) -&gt; List[\"GenerateOutput\"]:\n        \"\"\"Generates `num_generations` responses for each input using the text generation\n        pipeline.\n\n        Args:\n            inputs: a list of inputs in chat format to generate responses for.\n            num_generations: the number of generations to create per input. Defaults to\n                `1`.\n            max_new_tokens: the maximum number of new tokens that the model will generate.\n                Defaults to `128`.\n            temperature: the temperature to use for the generation. Defaults to `0.1`.\n            repetition_penalty: the repetition penalty to use for the generation. Defaults\n                to `1.1`.\n            top_p: the top-p value to use for the generation. Defaults to `1.0`.\n            top_k: the top-k value to use for the generation. Defaults to `0`.\n            do_sample: whether to use sampling or not. Defaults to `True`.\n\n        Returns:\n            A list of lists of strings containing the generated responses for each input.\n        \"\"\"\n        outputs: List[List[Dict[str, str]]] = self._pipeline(  # type: ignore\n            [self.prepare_input(input=input) for input in inputs],\n            max_new_tokens=max_new_tokens,\n            temperature=temperature,\n            repetition_penalty=repetition_penalty,\n            top_p=top_p,\n            top_k=top_k,\n            do_sample=do_sample,\n            num_return_sequences=num_generations,\n        )\n        return [\n            [generation[\"generated_text\"] for generation in output]\n            for output in outputs\n        ]\n\n    def get_last_hidden_states(self, inputs: List[\"ChatType\"]) -&gt; List[\"HiddenState\"]:\n        \"\"\"Gets the last `hidden_states` of the model for the given inputs. It doesn't\n        execute the task head.\n\n        Args:\n            inputs: a list of inputs in chat format to generate the embeddings for.\n\n        Returns:\n            A list containing the last hidden state for each sequence using a NumPy array\n            with shape [num_tokens, hidden_size].\n        \"\"\"\n        model: \"PreTrainedModel\" = (\n            self._pipeline.model.model  # type: ignore\n            if hasattr(self._pipeline.model, \"model\")  # type: ignore\n            else next(self._pipeline.model.children())  # type: ignore\n        )\n        tokenizer: \"PreTrainedTokenizer\" = self._pipeline.tokenizer  # type: ignore\n        input_ids = tokenizer(\n            [self.prepare_input(input) for input in inputs],  # type: ignore\n            return_tensors=\"pt\",\n            padding=True,\n        ).to(model.device)\n        last_hidden_states = model(**input_ids)[\"last_hidden_state\"]\n\n        return [\n            seq_last_hidden_state[attention_mask.bool(), :].detach().cpu().numpy()\n            for seq_last_hidden_state, attention_mask in zip(\n                last_hidden_states,\n                input_ids[\"attention_mask\"],  # type: ignore\n            )\n        ]\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/transformers/#distilabel.llms.huggingface.transformers.TransformersLLM.model_name","title":"<code>model_name: str</code>  <code>property</code>","text":"<p>Returns the model name used for the LLM.</p>"},{"location":"reference/distilabel/llms/huggingface/transformers/#distilabel.llms.huggingface.transformers.TransformersLLM.generate","title":"<code>generate(inputs, num_generations=1, max_new_tokens=128, temperature=0.1, repetition_penalty=1.1, top_p=1.0, top_k=0, do_sample=True)</code>","text":"<p>Generates <code>num_generations</code> responses for each input using the text generation pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>List[ChatType]</code> <p>a list of inputs in chat format to generate responses for.</p> required <code>num_generations</code> <code>int</code> <p>the number of generations to create per input. Defaults to <code>1</code>.</p> <code>1</code> <code>max_new_tokens</code> <code>int</code> <p>the maximum number of new tokens that the model will generate. Defaults to <code>128</code>.</p> <code>128</code> <code>temperature</code> <code>float</code> <p>the temperature to use for the generation. Defaults to <code>0.1</code>.</p> <code>0.1</code> <code>repetition_penalty</code> <code>float</code> <p>the repetition penalty to use for the generation. Defaults to <code>1.1</code>.</p> <code>1.1</code> <code>top_p</code> <code>float</code> <p>the top-p value to use for the generation. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>top_k</code> <code>int</code> <p>the top-k value to use for the generation. Defaults to <code>0</code>.</p> <code>0</code> <code>do_sample</code> <code>bool</code> <p>whether to use sampling or not. Defaults to <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>List[GenerateOutput]</code> <p>A list of lists of strings containing the generated responses for each input.</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>def generate(  # type: ignore\n    self,\n    inputs: List[\"ChatType\"],\n    num_generations: int = 1,\n    max_new_tokens: int = 128,\n    temperature: float = 0.1,\n    repetition_penalty: float = 1.1,\n    top_p: float = 1.0,\n    top_k: int = 0,\n    do_sample: bool = True,\n) -&gt; List[\"GenerateOutput\"]:\n    \"\"\"Generates `num_generations` responses for each input using the text generation\n    pipeline.\n\n    Args:\n        inputs: a list of inputs in chat format to generate responses for.\n        num_generations: the number of generations to create per input. Defaults to\n            `1`.\n        max_new_tokens: the maximum number of new tokens that the model will generate.\n            Defaults to `128`.\n        temperature: the temperature to use for the generation. Defaults to `0.1`.\n        repetition_penalty: the repetition penalty to use for the generation. Defaults\n            to `1.1`.\n        top_p: the top-p value to use for the generation. Defaults to `1.0`.\n        top_k: the top-k value to use for the generation. Defaults to `0`.\n        do_sample: whether to use sampling or not. Defaults to `True`.\n\n    Returns:\n        A list of lists of strings containing the generated responses for each input.\n    \"\"\"\n    outputs: List[List[Dict[str, str]]] = self._pipeline(  # type: ignore\n        [self.prepare_input(input=input) for input in inputs],\n        max_new_tokens=max_new_tokens,\n        temperature=temperature,\n        repetition_penalty=repetition_penalty,\n        top_p=top_p,\n        top_k=top_k,\n        do_sample=do_sample,\n        num_return_sequences=num_generations,\n    )\n    return [\n        [generation[\"generated_text\"] for generation in output]\n        for output in outputs\n    ]\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/transformers/#distilabel.llms.huggingface.transformers.TransformersLLM.get_last_hidden_states","title":"<code>get_last_hidden_states(inputs)</code>","text":"<p>Gets the last <code>hidden_states</code> of the model for the given inputs. It doesn't execute the task head.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>List[ChatType]</code> <p>a list of inputs in chat format to generate the embeddings for.</p> required <p>Returns:</p> Type Description <code>List[HiddenState]</code> <p>A list containing the last hidden state for each sequence using a NumPy array</p> <code>List[HiddenState]</code> <p>with shape [num_tokens, hidden_size].</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>def get_last_hidden_states(self, inputs: List[\"ChatType\"]) -&gt; List[\"HiddenState\"]:\n    \"\"\"Gets the last `hidden_states` of the model for the given inputs. It doesn't\n    execute the task head.\n\n    Args:\n        inputs: a list of inputs in chat format to generate the embeddings for.\n\n    Returns:\n        A list containing the last hidden state for each sequence using a NumPy array\n        with shape [num_tokens, hidden_size].\n    \"\"\"\n    model: \"PreTrainedModel\" = (\n        self._pipeline.model.model  # type: ignore\n        if hasattr(self._pipeline.model, \"model\")  # type: ignore\n        else next(self._pipeline.model.children())  # type: ignore\n    )\n    tokenizer: \"PreTrainedTokenizer\" = self._pipeline.tokenizer  # type: ignore\n    input_ids = tokenizer(\n        [self.prepare_input(input) for input in inputs],  # type: ignore\n        return_tensors=\"pt\",\n        padding=True,\n    ).to(model.device)\n    last_hidden_states = model(**input_ids)[\"last_hidden_state\"]\n\n    return [\n        seq_last_hidden_state[attention_mask.bool(), :].detach().cpu().numpy()\n        for seq_last_hidden_state, attention_mask in zip(\n            last_hidden_states,\n            input_ids[\"attention_mask\"],  # type: ignore\n        )\n    ]\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/transformers/#distilabel.llms.huggingface.transformers.TransformersLLM.load","title":"<code>load()</code>","text":"<p>Loads the model and tokenizer and creates the text generation pipeline. In addition, it will configure the tokenizer chat template.</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the model and tokenizer and creates the text generation pipeline. In addition,\n    it will configure the tokenizer chat template.\"\"\"\n    super().load()\n\n    if self.device == \"cuda\":\n        CudaDevicePlacementMixin.load(self)\n\n    try:\n        from transformers import pipeline\n    except ImportError as ie:\n        raise ImportError(\n            \"Transformers is not installed. Please install it using `pip install transformers`.\"\n        ) from ie\n\n    self._pipeline = pipeline(\n        \"text-generation\",\n        model=self.model,\n        revision=self.revision,\n        torch_dtype=self.torch_dtype,\n        trust_remote_code=self.trust_remote_code,\n        model_kwargs=self.model_kwargs or {},\n        tokenizer=self.tokenizer or self.model,\n        use_fast=self.use_fast,\n        device=self.device,\n        device_map=self.device_map,\n        token=self.token or os.getenv(\"HF_TOKEN\"),\n        return_full_text=False,\n    )\n\n    if self.chat_template is not None:\n        self._pipeline.tokenizer.chat_template = self.chat_template  # type: ignore\n    elif (\n        self._pipeline.tokenizer.chat_template is None  # type: ignore\n        and self._pipeline.tokenizer.default_chat_template is None  # type: ignore\n    ):\n        self._pipeline.tokenizer.chat_template = CHATML_TEMPLATE  # type: ignore\n</code></pre>"},{"location":"reference/distilabel/llms/huggingface/transformers/#distilabel.llms.huggingface.transformers.TransformersLLM.prepare_input","title":"<code>prepare_input(input)</code>","text":"<p>Prepares the input by applying the chat template to the input, which is formatted as an OpenAI conversation, and adding the generation prompt.</p> Source code in <code>src/distilabel/llms/huggingface/transformers.py</code> <pre><code>def prepare_input(self, input: \"ChatType\") -&gt; str:\n    \"\"\"Prepares the input by applying the chat template to the input, which is formatted\n    as an OpenAI conversation, and adding the generation prompt.\n    \"\"\"\n    return self._pipeline.tokenizer.apply_chat_template(  # type: ignore\n        input,  # type: ignore\n        tokenize=False,\n        add_generation_prompt=True,\n    )\n</code></pre>"},{"location":"reference/distilabel/mixins/","title":"Index","text":""},{"location":"reference/distilabel/mixins/runtime_parameters/","title":"Runtime parameters","text":""},{"location":"reference/distilabel/mixins/runtime_parameters/#distilabel.mixins.runtime_parameters.RuntimeParameter","title":"<code>RuntimeParameter = Annotated[Union[_T, None], Field(default=None), _RUNTIME_PARAMETER_ANNOTATION]</code>  <code>module-attribute</code>","text":"<p>Used to mark the attributes of a <code>Step</code> as a runtime parameter.</p>"},{"location":"reference/distilabel/mixins/runtime_parameters/#distilabel.mixins.runtime_parameters.RuntimeParametersMixin","title":"<code>RuntimeParametersMixin</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Mixin for classes that have <code>RuntimeParameter</code>s attributes.</p> <p>Attributes:</p> Name Type Description <code>_runtime_parameters</code> <code>Dict[str, Any]</code> <p>A dictionary containing the values of the runtime parameters of the class. This attribute is meant to be used internally and should not be accessed directly.</p> Source code in <code>src/distilabel/mixins/runtime_parameters.py</code> <pre><code>class RuntimeParametersMixin(BaseModel, validate_assignment=True):\n    \"\"\"Mixin for classes that have `RuntimeParameter`s attributes.\n\n    Attributes:\n        _runtime_parameters: A dictionary containing the values of the runtime parameters\n            of the class. This attribute is meant to be used internally and should not be\n            accessed directly.\n    \"\"\"\n\n    _runtime_parameters: Dict[str, Any] = PrivateAttr(default_factory=dict)\n\n    @property\n    def runtime_parameters_names(self) -&gt; RuntimeParametersNames:\n        \"\"\"Returns a dictionary containing the name of the runtime parameters of the class\n        as keys and whether the parameter is required or not as values.\n\n        Returns:\n            A dictionary containing the name of the runtime parameters of the class as keys\n            and whether the parameter is required or not as values.\n        \"\"\"\n\n        runtime_parameters = {}\n\n        for name, field_info in self.model_fields.items():  # type: ignore\n            is_runtime_param, is_optional = _is_runtime_parameter(field_info)\n            if is_runtime_param:\n                runtime_parameters[name] = is_optional\n                continue\n\n            attr = getattr(self, name)\n            if isinstance(attr, RuntimeParametersMixin):\n                runtime_parameters[name] = attr.runtime_parameters_names\n\n        return runtime_parameters\n\n    def get_runtime_parameters_info(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Gets the information of the runtime parameters of the class such as the name and\n        the description. This function is meant to include the information of the runtime\n        parameters in the serialized data of the class.\n\n        Returns:\n            A list containing the information for each runtime parameter of the class.\n        \"\"\"\n        runtime_parameters_info = []\n        for name, field_info in self.model_fields.items():  # type: ignore\n            if name not in self.runtime_parameters_names:\n                continue\n\n            attr = getattr(self, name)\n            if isinstance(attr, RuntimeParametersMixin):\n                runtime_parameters_info.append(\n                    {\n                        \"name\": name,\n                        \"runtime_parameters_info\": attr.get_runtime_parameters_info(),\n                    }\n                )\n                continue\n\n            info = {\"name\": name, \"optional\": self.runtime_parameters_names[name]}\n            if field_info.description is not None:\n                info[\"description\"] = field_info.description\n            runtime_parameters_info.append(info)\n        return runtime_parameters_info\n\n    def set_runtime_parameters(self, runtime_parameters: Dict[str, Any]) -&gt; None:\n        \"\"\"Sets the runtime parameters of the class using the provided values. If the attr\n        to be set is a `RuntimeParametersMixin`, it will call `set_runtime_parameters` on\n        the attr.\n\n        Args:\n            runtime_parameters: A dictionary containing the values of the runtime parameters\n                to set.\n        \"\"\"\n        for name, value in runtime_parameters.items():\n            if name not in self.runtime_parameters_names:\n                continue\n\n            attr = getattr(self, name)\n            if isinstance(attr, RuntimeParametersMixin):\n                attr.set_runtime_parameters(value)\n                continue\n\n            # Handle settings values for `_SecretField`\n            field_info = self.model_fields[name]\n            inner_type = _extract_runtime_parameter_inner_type(field_info.annotation)\n            if inspect.isclass(inner_type) and issubclass(inner_type, _SecretField):\n                value = inner_type(value)\n\n            setattr(self, name, value)\n            self._runtime_parameters[name] = value\n</code></pre>"},{"location":"reference/distilabel/mixins/runtime_parameters/#distilabel.mixins.runtime_parameters.RuntimeParametersMixin.runtime_parameters_names","title":"<code>runtime_parameters_names: RuntimeParametersNames</code>  <code>property</code>","text":"<p>Returns a dictionary containing the name of the runtime parameters of the class as keys and whether the parameter is required or not as values.</p> <p>Returns:</p> Type Description <code>RuntimeParametersNames</code> <p>A dictionary containing the name of the runtime parameters of the class as keys</p> <code>RuntimeParametersNames</code> <p>and whether the parameter is required or not as values.</p>"},{"location":"reference/distilabel/mixins/runtime_parameters/#distilabel.mixins.runtime_parameters.RuntimeParametersMixin.get_runtime_parameters_info","title":"<code>get_runtime_parameters_info()</code>","text":"<p>Gets the information of the runtime parameters of the class such as the name and the description. This function is meant to include the information of the runtime parameters in the serialized data of the class.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>A list containing the information for each runtime parameter of the class.</p> Source code in <code>src/distilabel/mixins/runtime_parameters.py</code> <pre><code>def get_runtime_parameters_info(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"Gets the information of the runtime parameters of the class such as the name and\n    the description. This function is meant to include the information of the runtime\n    parameters in the serialized data of the class.\n\n    Returns:\n        A list containing the information for each runtime parameter of the class.\n    \"\"\"\n    runtime_parameters_info = []\n    for name, field_info in self.model_fields.items():  # type: ignore\n        if name not in self.runtime_parameters_names:\n            continue\n\n        attr = getattr(self, name)\n        if isinstance(attr, RuntimeParametersMixin):\n            runtime_parameters_info.append(\n                {\n                    \"name\": name,\n                    \"runtime_parameters_info\": attr.get_runtime_parameters_info(),\n                }\n            )\n            continue\n\n        info = {\"name\": name, \"optional\": self.runtime_parameters_names[name]}\n        if field_info.description is not None:\n            info[\"description\"] = field_info.description\n        runtime_parameters_info.append(info)\n    return runtime_parameters_info\n</code></pre>"},{"location":"reference/distilabel/mixins/runtime_parameters/#distilabel.mixins.runtime_parameters.RuntimeParametersMixin.set_runtime_parameters","title":"<code>set_runtime_parameters(runtime_parameters)</code>","text":"<p>Sets the runtime parameters of the class using the provided values. If the attr to be set is a <code>RuntimeParametersMixin</code>, it will call <code>set_runtime_parameters</code> on the attr.</p> <p>Parameters:</p> Name Type Description Default <code>runtime_parameters</code> <code>Dict[str, Any]</code> <p>A dictionary containing the values of the runtime parameters to set.</p> required Source code in <code>src/distilabel/mixins/runtime_parameters.py</code> <pre><code>def set_runtime_parameters(self, runtime_parameters: Dict[str, Any]) -&gt; None:\n    \"\"\"Sets the runtime parameters of the class using the provided values. If the attr\n    to be set is a `RuntimeParametersMixin`, it will call `set_runtime_parameters` on\n    the attr.\n\n    Args:\n        runtime_parameters: A dictionary containing the values of the runtime parameters\n            to set.\n    \"\"\"\n    for name, value in runtime_parameters.items():\n        if name not in self.runtime_parameters_names:\n            continue\n\n        attr = getattr(self, name)\n        if isinstance(attr, RuntimeParametersMixin):\n            attr.set_runtime_parameters(value)\n            continue\n\n        # Handle settings values for `_SecretField`\n        field_info = self.model_fields[name]\n        inner_type = _extract_runtime_parameter_inner_type(field_info.annotation)\n        if inspect.isclass(inner_type) and issubclass(inner_type, _SecretField):\n            value = inner_type(value)\n\n        setattr(self, name, value)\n        self._runtime_parameters[name] = value\n</code></pre>"},{"location":"reference/distilabel/pipeline/","title":"Index","text":""},{"location":"reference/distilabel/pipeline/#distilabel.pipeline.Pipeline","title":"<code>Pipeline</code>","text":"<p>             Bases: <code>BasePipeline</code></p> <p>Local pipeline implementation using <code>multiprocessing</code>.</p> Source code in <code>src/distilabel/pipeline/local.py</code> <pre><code>class Pipeline(BasePipeline):\n    \"\"\"Local pipeline implementation using `multiprocessing`.\"\"\"\n\n    def run(\n        self,\n        parameters: Optional[Dict[str, Dict[str, Any]]] = None,\n        use_cache: bool = True,\n    ) -&gt; \"Distiset\":\n        \"\"\"Runs the pipeline.\n\n        Args:\n            parameters: A dictionary with the step name as the key and a dictionary with\n                the runtime parameters for the step as the value. Defaults to `None`.\n            use_cache: Whether to use the cache from previous pipeline runs. Defaults to\n                `True`.\n\n        Returns:\n            The `Distiset` created by the pipeline.\n\n        Raises:\n            RuntimeError: If the pipeline fails to load all the steps.\n        \"\"\"\n        try:\n            mp.set_start_method(\"forkserver\")\n        except RuntimeError:\n            pass\n        log_queue = mp.Queue()\n        setup_logging(log_queue)  # type: ignore\n        self._logger = logging.getLogger(\"distilabel.pipeline.local\")\n\n        super().run(parameters, use_cache)\n\n        if self._batch_manager is None:\n            self._batch_manager = _BatchManager.from_dag(self.dag)\n\n        # If the batch manager is not able to generate batches, that means that the loaded\n        # `_BatchManager` from cache didn't have any remaining batches to process i.e.\n        # the previous pipeline execution was completed successfully.\n        if not self._batch_manager.can_generate():\n            self._logger.info(\n                \"\ud83d\udcbe Loaded batch manager from cache doesn't have any remaining data. Returning\"\n                \" `Distiset` from cache data...\"\n            )\n            stop_logging()\n            return create_distiset(\n                self._cache_location[\"data\"],\n                pipeline_path=self._cache_location[\"pipeline\"],\n            )\n\n        buffer_data_path = self._cache_location[\"data\"]\n        self._logger.info(f\"\ud83d\udcdd Pipeline data will be written to '{buffer_data_path}'\")\n        write_buffer = _WriteBuffer(buffer_data_path, self.dag.leaf_steps)\n\n        num_processes = len(self.dag)\n        ctx = mp.get_context(\"forkserver\")  # type: ignore\n        with ctx.Manager() as manager, ctx.Pool(\n            num_processes, initializer=_init_worker, initargs=(log_queue,)\n        ) as pool:\n            self.output_queue: \"Queue[Any]\" = manager.Queue()\n            self.shared_info = self._create_shared_info_dict(manager)\n            self._handle_keyboard_interrupt()\n\n            # Run the steps using the pool of processes\n            self._run_steps_in_loop(pool, manager, self.output_queue, self.shared_info)\n\n            # Wait for all the steps to be loaded correctly\n            if not self._all_steps_loaded():\n                write_buffer.close()\n                self._batch_manager = None\n                stop_logging()\n                raise RuntimeError(\n                    \"Failed to load all the steps. Could not run pipeline.\"\n                )\n\n            # Send the \"first\" batches to the steps so the batches starts flowing through\n            # the input queues and output queue\n            self._request_initial_batches()\n\n            # Start a loop to receive the output batches from the steps\n            self._run_output_queue_loop_in_thread(write_buffer)\n\n            pool.close()\n            pool.join()\n\n        write_buffer.close()\n        distiset = create_distiset(\n            self._cache_location[\"data\"], pipeline_path=self._cache_location[\"pipeline\"]\n        )\n        stop_logging()\n        return distiset\n\n    def _run_output_queue_loop_in_thread(self, write_buffer: \"_WriteBuffer\") -&gt; None:\n        \"\"\"Runs the output queue loop in a separate thread to receive the output batches\n        from the steps. This is done to avoid the signal handler to block the loop, which\n        would prevent the pipeline from stopping correctly.\n\n        Args:\n            write_buffer: The write buffer to write the data from the leaf steps to disk.\n        \"\"\"\n        thread = threading.Thread(target=self._output_queue_loop, args=(write_buffer,))\n        thread.start()\n        thread.join()\n\n    def _output_queue_loop(self, write_buffer: \"_WriteBuffer\") -&gt; None:\n        \"\"\"Loop to receive the output batches from the steps and manage the flow of the\n        batches through the pipeline.\n\n        Args:\n            write_buffer: The write buffer to write the data from the leaf steps to disk.\n        \"\"\"\n        while self._batch_manager.can_generate() and not _STOP_LOOP:  # type: ignore\n            self._logger.debug(\"Waiting for output batch from step...\")\n            if (batch := self.output_queue.get()) is None:\n                self._logger.debug(\"Received `None` from output queue. Breaking loop.\")\n                break\n\n            if batch.step_name in self.dag.leaf_steps:\n                write_buffer.add_batch(batch)\n\n            # If `_STOP_LOOP` was set to `True` while waiting for the output queue, then\n            # we need to handle the stop of the pipeline and break the loop to avoid\n            # propagating the batches through the pipeline and making the stop process\n            # slower.\n            if _STOP_LOOP:\n                self._handle_batch_on_stop(batch)\n                self._handle_stop(write_buffer)\n                break\n\n            self._logger.debug(\n                f\"Received batch with seq_no {batch.seq_no} from step '{batch.step_name}'\"\n                f\" from output queue: {batch}\"\n            )\n\n            self._manage_batch_flow(batch)\n\n        if _STOP_LOOP:\n            self._handle_stop(write_buffer)\n\n    def _manage_batch_flow(self, batch: \"_Batch\") -&gt; None:\n        \"\"\"Checks if the step that generated the batch has more data in its buffer to\n        generate a new batch. If there's data, then a new batch is sent to the step. If\n        the step has no data in its buffer, then the predecessors generator steps are\n        requested to send a new batch.\n\n        Args:\n            batch: The batch that was processed.\n        \"\"\"\n        assert self._batch_manager, \"Batch manager is not set\"\n\n        self._batch_manager.register_batch(batch)\n        self._logger.debug(\n            f\"Batch {batch.seq_no} from step '{batch.step_name}' registered in batch\"\n            \" manager\"\n        )\n\n        step: \"Step\" = self.dag.get_step(batch.step_name)[\"step\"]\n\n        for successor in self.dag.get_step_successors(step.name):\n            self._batch_manager.add_batch(successor, batch)\n\n            # Check if the step is a generator and if there are successors that need data\n            # from this step. This usually happens when the generator `batch_size` is smaller\n            # than the `input_batch_size` of the successor steps.\n            if (\n                step.is_generator\n                and step.name in self._batch_manager.step_empty_buffers(successor)\n            ):\n                last_batch = self._batch_manager.get_last_batch(step.name)\n                self._send_batch_to_step(last_batch.next_batch())  # type: ignore\n\n            if new_batch := self._batch_manager.get_batch(successor):\n                self._send_batch_to_step(new_batch)\n\n        if step.is_generator:\n            return\n\n        # Step has enough data on its buffers to create a new batch\n        if next_batch := self._batch_manager.get_batch(step.name):\n            self._send_batch_to_step(next_batch)\n            return\n\n        # Request more batches to the predecessors generator steps\n        empty_buffers = self._batch_manager.step_empty_buffers(step.name)\n        for previous_step_name in empty_buffers:\n            if previous_step_name not in self.dag.root_steps:\n                continue\n\n            if last_batch := self._batch_manager.get_last_batch(previous_step_name):\n                self._logger.debug(\n                    f\"Step '{step.name}' input buffer for step '{previous_step_name}' is\"\n                    \" empty. Requesting new batch...\"\n                )\n                self._send_batch_to_step(last_batch.next_batch())\n\n        self._cache()\n\n    def _handle_stop(self, write_buffer: \"_WriteBuffer\") -&gt; None:\n        \"\"\"Handles the stop of the pipeline execution, which will stop the steps from\n        processing more batches and wait for the output queue to be empty, to not lose\n        any data that was already processed by the steps before the stop was called.\n\n        Args:\n            write_buffer: The write buffer to write the data from the leaf steps to disk.\n        \"\"\"\n        self._logger.debug(\"Handling stop of the pipeline execution...\")\n\n        # Send `None` to the input queues of all the steps to notify them to stop\n        # processing batches.\n        for step_name in self.dag:\n            if input_queue := self._wait_step_input_queue_empty(step_name):\n                if self._check_step_not_loaded_or_finished(step_name):\n                    self._logger.debug(\n                        f\"Step '{step_name}' not loaded or already finished. Skipping sending\"\n                        \" sentinel `None`\"\n                    )\n                    continue\n                input_queue.put(None)\n                self._logger.debug(f\"Send `None` to step '{step_name}' input queue.\")\n\n        # Wait for the input queue to be empty, which means that all the steps finished\n        # processing the batches that were sent before the stop flag.\n        for step_name in self.dag:\n            self._wait_step_input_queue_empty(step_name)\n\n        # Consume the output queue until it's empty to not lose any data that was already\n        # processed by the steps before stop was called.\n        while not self.output_queue.empty():\n            batch = self.output_queue.get()\n            if batch.step_name in self.dag.leaf_steps:\n                write_buffer.add_batch(batch)\n            self._handle_batch_on_stop(batch)\n\n        self._cache()\n\n    def _handle_batch_on_stop(self, batch: \"_Batch\") -&gt; None:\n        \"\"\"Handles a batch that was received from the output queue when the pipeline was\n        stopped. It will add and register the batch in the batch manager.\n\n        Args:\n            batch: The batch to handle.\n        \"\"\"\n        self._batch_manager.register_batch(batch)  # type: ignore\n        step: \"Step\" = self.dag.get_step(batch.step_name)[\"step\"]\n        for successor in self.dag.get_step_successors(step.name):\n            self._batch_manager.add_batch(successor, batch)  # type: ignore\n\n    def _wait_step_input_queue_empty(self, step_name: str) -&gt; Union[\"Queue[Any]\", None]:\n        \"\"\"Waits for the input queue of a step to be empty.\n\n        Args:\n            step_name: The name of the step.\n\n        Returns:\n            The input queue of the step if it's not loaded or finished, `None` otherwise.\n        \"\"\"\n        if self._check_step_not_loaded_or_finished(step_name):\n            return None\n\n        if input_queue := self.dag.get_step(step_name).get(\"input_queue\"):\n            while input_queue.qsize() != 0:\n                pass\n            return input_queue\n\n    def _create_shared_info_dict(self, manager: \"SyncManager\") -&gt; \"DictProxy[str, Any]\":\n        \"\"\"Creates the shared information dictionary to be used by the processes.\n\n        Args:\n            manager: The manager to create the shared information.\n\n        Returns:\n            The shared information dictionary.\n        \"\"\"\n        # TODO: not very important, but we could use a different lock for each matter\n        return manager.dict(\n            **{\n                _STEPS_LOADED_KEY: manager.list(),\n                _STEPS_LOADED_LOCK_KEY: manager.Lock(),\n                _CUDA_LLM_DEVICE_PLACEMENT_KEY: manager.dict(**{}),\n                _CUDA_LLM_DEVICE_PLACEMENT_LOCK_KEY: manager.Lock(),\n            }\n        )\n\n    def _all_steps_loaded(self) -&gt; bool:\n        \"\"\"Waits for all the steps to load.\n\n        Returns:\n            `True` if all the steps have been loaded correctly, `False` otherwise.\n        \"\"\"\n\n        def _update_all_steps_loaded(steps_loaded: List[str]) -&gt; None:\n            with _STEPS_LOADED_LOCK:\n                _STEPS_LOADED.update(steps_loaded)\n\n        self._logger.info(\"\u23f3 Waiting for all the steps to load...\")\n        previous_message = None\n        while True:\n            with self.shared_info[_STEPS_LOADED_LOCK_KEY]:\n                steps_loaded = self.shared_info[_STEPS_LOADED_KEY]\n                num_steps_loaded = (\n                    len(steps_loaded)\n                    if steps_loaded != [_STEPS_LOADED_ERROR_CODE]\n                    else 0\n                )\n                self._logger.debug(f\"Steps loaded: {steps_loaded}\")\n\n                message = f\"\u23f3 Steps loaded: {num_steps_loaded}/{len(self.dag)}\"\n                if num_steps_loaded &gt; 0 and message != previous_message:\n                    self._logger.info(message)\n                    previous_message = message\n\n                if num_steps_loaded == len(self.dag):\n                    self._logger.info(\"\u2705 All the steps have been loaded!\")\n                    _update_all_steps_loaded(steps_loaded)\n                    return True\n\n                if steps_loaded == [_STEPS_LOADED_ERROR_CODE]:\n                    self._logger.error(\"\u274c Failed to load all the steps\")\n                    _update_all_steps_loaded(steps_loaded)\n                    return False\n\n            time.sleep(2.5)\n\n    def _request_initial_batches(self) -&gt; None:\n        \"\"\"Requests the initial batches to the generator steps.\"\"\"\n        assert self._batch_manager, \"Batch manager is not set\"\n\n        for step in self._batch_manager._steps.values():\n            if batch := step.get_batch():\n                self._send_batch_to_step(batch)\n\n        for step_name in self.dag.root_steps:\n            seq_no = 0\n            if last_batch := self._batch_manager.get_last_batch(step_name):\n                seq_no = last_batch.seq_no + 1\n            batch = _Batch(seq_no=seq_no, step_name=step_name, last_batch=False)\n            self._send_batch_to_step(batch)\n\n    def _send_batch_to_step(self, batch: \"_Batch\") -&gt; None:\n        \"\"\"Sends a batch to the input queue of a step.\n\n        Args:\n            batch: The batch to send.\n        \"\"\"\n        self._logger.debug(\n            f\"Sending batch {batch.seq_no} to step '{batch.step_name}': {batch}\"\n        )\n        input_queue = self.dag.get_step(batch.step_name)[\"input_queue\"]\n        input_queue.put(batch)\n\n    def _run_steps_in_loop(\n        self,\n        pool: \"Pool\",\n        manager: \"SyncManager\",\n        output_queue: \"Queue[_Batch]\",\n        shared_info: \"DictProxy[str, Any]\",\n    ) -&gt; None:\n        \"\"\"Using the `pool`, runs the steps in the DAG in an infinite loop waiting for\n        input batches and sending the output batches to the `output_queue`.\n\n        Each `Step` is wrapped in a `_ProcessWrapper`, which will handle the lifecycle of\n        the `Step` and the communication with the `input_queue` and `output_queue`. The\n        `_ProcessWrapper.run` method is the target function of the process.\n\n        Args:\n            pool: The pool of processes.\n            manager: The manager to create the queues.\n            output_queue: The queue to send the output batches.\n            shared_info: The shared information between the processes.\n        \"\"\"\n        for step_name in self.dag:\n            step: \"Step\" = self.dag.get_step(step_name)[\"step\"]\n            input_queue = manager.Queue()\n            self.dag.set_step_attr(step.name, \"input_queue\", input_queue)\n\n            # Set `pipeline` to `None` as in some Python environments the pipeline is not\n            # picklable and it will raise an error when trying to send the step to the process.\n            # `TypeError: cannot pickle 'code' object`\n            step.pipeline = None\n\n            process_wrapper = _ProcessWrapper(\n                step=step,\n                input_queue=input_queue,\n                output_queue=output_queue,\n                shared_info=shared_info,\n            )\n\n            pool.apply_async(\n                process_wrapper.run,\n                callback=self._finished_callback,\n                error_callback=self._error_callback,\n            )  # type: ignore\n\n    def _error_callback(self, e: BaseException) -&gt; None:\n        \"\"\"Error callback that will be called when an error occurs in a `Step` process.\n\n        Args:\n            e: The exception raised by the process.\n        \"\"\"\n        # First we check that the exception is a `_ProcessWrapperException`, otherwise, we\n        # print it out and stop the pipeline, since some errors may be unhandled\n        if not isinstance(e, _ProcessWrapperException):\n            self._logger.error(f\"\u274c Failed with an unhandled exception: {e}\")\n            self._stop()\n            return\n\n        if e.is_load_error:\n            self._logger.error(f\"\u274c Failed to load step '{e.step.name}': {e.message}\")\n            with self.shared_info[_STEPS_LOADED_LOCK_KEY]:\n                self.shared_info[_STEPS_LOADED_KEY] = [_STEPS_LOADED_ERROR_CODE]\n            return\n\n        # If the step is global, is not in the last trophic level and has no successors,\n        # then we can ignore the error and continue executing the pipeline\n        if (\n            e.step.is_global\n            and not self.dag.step_in_last_trophic_level(e.step.name)\n            and list(self.dag.get_step_successors(e.step.name)) == []\n        ):\n            self._logger.error(\n                f\"\u270b An error occurred when running global step '{e.step.name}' with no\"\n                \" successors and not in the last trophic level. Pipeline execution can\"\n                f\" continue. Error will be ignored: {e.message}\"\n            )\n            return\n\n        self._logger.error(f\"An error occurred in step '{e.step.name}': {e.message}\")\n        self._cache()\n        self._stop()\n\n    def _finished_callback(self, step_name: str) -&gt; None:\n        \"\"\"Callback that will be called when a `Step` process finishes.\n\n        Args:\n            step_name: The name of the step that finished.\n        \"\"\"\n        with _STEPS_FINISHED_LOCK:\n            _STEPS_FINISHED.add(step_name)\n\n    def _check_step_not_loaded_or_finished(self, step_name: str) -&gt; bool:\n        \"\"\"Checks if a step is not loaded or already finished.\n\n        Args:\n            step_name: The name of the step.\n\n        Returns:\n            `True` if the step is not loaded or already finished, `False` otherwise.\n        \"\"\"\n        with _STEPS_LOADED_LOCK:\n            if step_name not in _STEPS_LOADED:\n                return True\n\n        with _STEPS_FINISHED_LOCK:\n            if step_name in _STEPS_FINISHED:\n                return True\n\n        return False\n\n    def _stop(self) -&gt; None:\n        \"\"\"Stops the pipeline execution. It will first send `None` to the input queues\n        of all the steps and then wait until the output queue is empty i.e. all the steps\n        finished processing the batches that were sent before the stop flag. Then it will\n        send `None` to the output queue to notify the pipeline to stop.\"\"\"\n\n        global _STOP_LOOP, _STOP_CALLED\n\n        _STOP_LOOP = True\n\n        with _STOP_CALLED_LOCK:\n            if _STOP_CALLED:\n                self._logger.warning(\n                    \"\ud83d\uded1 Stop has already been called. Ignoring subsequent calls and waiting\"\n                    \" for the pipeline to finish...\"\n                )\n                return\n            _STOP_CALLED = True\n\n        self._logger.debug(f\"Steps loaded before calling `stop`: {_STEPS_LOADED}\")\n        self._logger.info(\n            \"\ud83d\uded1 Stopping pipeline. Waiting for steps to finish processing batches...\"\n        )\n\n    def _handle_keyboard_interrupt(self) -&gt; None:\n        \"\"\"Handles KeyboardInterrupt signal sent during the Pipeline.run method.\n\n        It will try to call self._stop (if the pipeline didn't started yet, it won't\n        have any effect), and if the pool is already started, will close it before exiting\n        the program.\n        \"\"\"\n\n        def signal_handler(signumber: int, frame: Any) -&gt; None:\n            self._stop()\n\n        signal.signal(signal.SIGINT, signal_handler)\n</code></pre>"},{"location":"reference/distilabel/pipeline/#distilabel.pipeline.Pipeline.run","title":"<code>run(parameters=None, use_cache=True)</code>","text":"<p>Runs the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Optional[Dict[str, Dict[str, Any]]]</code> <p>A dictionary with the step name as the key and a dictionary with the runtime parameters for the step as the value. Defaults to <code>None</code>.</p> <code>None</code> <code>use_cache</code> <code>bool</code> <p>Whether to use the cache from previous pipeline runs. Defaults to <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>Distiset</code> <p>The <code>Distiset</code> created by the pipeline.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the pipeline fails to load all the steps.</p> Source code in <code>src/distilabel/pipeline/local.py</code> <pre><code>def run(\n    self,\n    parameters: Optional[Dict[str, Dict[str, Any]]] = None,\n    use_cache: bool = True,\n) -&gt; \"Distiset\":\n    \"\"\"Runs the pipeline.\n\n    Args:\n        parameters: A dictionary with the step name as the key and a dictionary with\n            the runtime parameters for the step as the value. Defaults to `None`.\n        use_cache: Whether to use the cache from previous pipeline runs. Defaults to\n            `True`.\n\n    Returns:\n        The `Distiset` created by the pipeline.\n\n    Raises:\n        RuntimeError: If the pipeline fails to load all the steps.\n    \"\"\"\n    try:\n        mp.set_start_method(\"forkserver\")\n    except RuntimeError:\n        pass\n    log_queue = mp.Queue()\n    setup_logging(log_queue)  # type: ignore\n    self._logger = logging.getLogger(\"distilabel.pipeline.local\")\n\n    super().run(parameters, use_cache)\n\n    if self._batch_manager is None:\n        self._batch_manager = _BatchManager.from_dag(self.dag)\n\n    # If the batch manager is not able to generate batches, that means that the loaded\n    # `_BatchManager` from cache didn't have any remaining batches to process i.e.\n    # the previous pipeline execution was completed successfully.\n    if not self._batch_manager.can_generate():\n        self._logger.info(\n            \"\ud83d\udcbe Loaded batch manager from cache doesn't have any remaining data. Returning\"\n            \" `Distiset` from cache data...\"\n        )\n        stop_logging()\n        return create_distiset(\n            self._cache_location[\"data\"],\n            pipeline_path=self._cache_location[\"pipeline\"],\n        )\n\n    buffer_data_path = self._cache_location[\"data\"]\n    self._logger.info(f\"\ud83d\udcdd Pipeline data will be written to '{buffer_data_path}'\")\n    write_buffer = _WriteBuffer(buffer_data_path, self.dag.leaf_steps)\n\n    num_processes = len(self.dag)\n    ctx = mp.get_context(\"forkserver\")  # type: ignore\n    with ctx.Manager() as manager, ctx.Pool(\n        num_processes, initializer=_init_worker, initargs=(log_queue,)\n    ) as pool:\n        self.output_queue: \"Queue[Any]\" = manager.Queue()\n        self.shared_info = self._create_shared_info_dict(manager)\n        self._handle_keyboard_interrupt()\n\n        # Run the steps using the pool of processes\n        self._run_steps_in_loop(pool, manager, self.output_queue, self.shared_info)\n\n        # Wait for all the steps to be loaded correctly\n        if not self._all_steps_loaded():\n            write_buffer.close()\n            self._batch_manager = None\n            stop_logging()\n            raise RuntimeError(\n                \"Failed to load all the steps. Could not run pipeline.\"\n            )\n\n        # Send the \"first\" batches to the steps so the batches starts flowing through\n        # the input queues and output queue\n        self._request_initial_batches()\n\n        # Start a loop to receive the output batches from the steps\n        self._run_output_queue_loop_in_thread(write_buffer)\n\n        pool.close()\n        pool.join()\n\n    write_buffer.close()\n    distiset = create_distiset(\n        self._cache_location[\"data\"], pipeline_path=self._cache_location[\"pipeline\"]\n    )\n    stop_logging()\n    return distiset\n</code></pre>"},{"location":"reference/distilabel/pipeline/_dag/","title":"dag","text":""},{"location":"reference/distilabel/pipeline/_dag/#distilabel.pipeline._dag.DAG","title":"<code>DAG</code>","text":"<p>             Bases: <code>_Serializable</code></p> <p>A Directed Acyclic Graph (DAG) to represent the pipeline.</p> <p>Attributes:</p> Name Type Description <code>G</code> <p>The graph representing the pipeline.</p> Source code in <code>src/distilabel/pipeline/_dag.py</code> <pre><code>class DAG(_Serializable):\n    \"\"\"A Directed Acyclic Graph (DAG) to represent the pipeline.\n\n    Attributes:\n        G: The graph representing the pipeline.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.G = nx.DiGraph()\n\n    def __iter__(self) -&gt; Generator[str, None, None]:\n        yield from self.G\n\n    def __len__(self) -&gt; int:\n        return len(self.G)\n\n    def add_step(self, step: \"_Step\") -&gt; None:\n        \"\"\"Add a step to the DAG.\n\n        Args:\n            step: The step to add to the DAG.\n\n        Raises:\n            ValueError: If a step with the same name already exists in the DAG.\n        \"\"\"\n        name = step.name\n        if name in self.G:\n            raise ValueError(f\"Step with name '{name}' already exists\")\n        self.G.add_node(name, step=step)\n\n    def get_step(self, name: str) -&gt; Dict[str, Any]:\n        \"\"\"Get a step from the DAG.\n\n        Args:\n            name: The name of the step to get.\n\n        Returns:\n            The step with the given name.\n\n        Raises:\n            ValueError: If the step with the given name does not exist.\n        \"\"\"\n        if name not in self.G:\n            raise ValueError(f\"Step with name '{name}' does not exist\")\n        return self.G.nodes[name]\n\n    def set_step_attr(self, name: str, attr: str, value: Any) -&gt; None:\n        \"\"\"Set an attribute of a step in the DAG.\n\n        Args:\n            name: The name of the step.\n            attr: The attribute to set.\n            value: The value to set.\n\n        Raises:\n            ValueError: If the step with the given name does not exist.\n        \"\"\"\n        if name not in self.G:\n            raise ValueError(f\"Step with name '{name}' does not exist\")\n        self.G.nodes[name][attr] = value\n\n    def add_edge(self, from_step: str, to_step: str) -&gt; None:\n        \"\"\"Add an edge between two steps in the DAG.\n\n        Args:\n            from_step: The name of the step from which the edge starts.\n            to_step: The name of the step to which the edge ends.\n\n        Raises:\n            ValueError: If the edge cannot be added.\n        \"\"\"\n        if from_step not in self.G:\n            raise ValueError(f\"Step with name '{from_step}' does not exist\")\n\n        if to_step not in self.G:\n            raise ValueError(f\"Step with name '{to_step}' does not exist\")\n\n        if to_step in self.G[from_step]:\n            raise ValueError(\n                f\"There is already a edge from '{to_step}' to '{from_step}'\"\n            )\n\n        if to_step in nx.ancestors(self.G, from_step):\n            raise ValueError(\n                f\"Cannot add edge from '{from_step}' to '{to_step}' as it would create a cycle.\"\n            )\n\n        self.G.add_edge(from_step, to_step)\n\n    @cached_property\n    def root_steps(self) -&gt; Set[str]:\n        \"\"\"The steps that don't have any predecessors i.e. generator steps.\n\n        Returns:\n            A list with the names of the steps that don't have any predecessors.\n        \"\"\"\n        return {node for node, degree in self.G.in_degree() if degree == 0}\n\n    @cached_property\n    def leaf_steps(self) -&gt; Set[str]:\n        \"\"\"The steps that don't have any successors.\n\n        Returns:\n            A list with the names of the steps that don't have any successors.\n        \"\"\"\n        return {node for node, degree in self.G.out_degree() if degree == 0}\n\n    @cached_property\n    def trophic_levels(self) -&gt; Dict[str, int]:\n        \"\"\"The trophic level of each step in the DAG.\n\n        Returns:\n            A dictionary with the trophic level of each step.\n        \"\"\"\n        return {step: int(level) for step, level in nx.trophic_levels(self.G).items()}\n\n    def get_step_predecessors(self, step_name: str) -&gt; Iterable[str]:\n        \"\"\"Gets the predecessors of a step.\n\n        Args:\n            step_name: The name of the step.\n\n        Returns:\n            An iterable with the names of the steps that are predecessors of the given step.\n        \"\"\"\n        if step_name not in self.G:\n            raise ValueError(f\"Step '{step_name}' does not exist\")\n        return self.G.predecessors(step_name)\n\n    def get_step_successors(self, step_name: str) -&gt; Iterable[str]:\n        \"\"\"Gets the successors of a step.\n\n        Args:\n            step_name: The name of the step.\n\n        Returns:\n            An iterable with the names of the steps that are successors of the given step.\n        \"\"\"\n\n        if step_name not in self.G:\n            raise ValueError(f\"Step '{step_name}' does not exist\")\n        return self.G.successors(step_name)\n\n    def iter_based_on_trophic_levels(self) -&gt; Iterable[List[str]]:\n        \"\"\"Iterate over steps names in the DAG based on their trophic levels. This is similar\n        to a topological sort, but we also know which steps are at the same level and\n        can be run in parallel.\n\n        Yields:\n            A list containing the names of the steps that can be run in parallel.\n        \"\"\"\n        v = defaultdict(list)\n        for step, trophic_level in self.trophic_levels.items():\n            v[trophic_level].append(step)\n\n        for trophic_level in sorted(v.keys()):\n            yield v[trophic_level]\n\n    def get_step_trophic_level(self, step_name: str) -&gt; int:\n        \"\"\"Gets the trophic level of a step.\n\n        Args:\n            step_name: The name of the step.\n\n        Returns:\n            The trophic level of the step.\n        \"\"\"\n        return int(self.trophic_levels[step_name])\n\n    def is_step_in_trophic_level(self, step_name: str, trophic_level: int) -&gt; bool:\n        \"\"\"Checks if a step is in a given trophic level.\n\n        Args:\n            step_name: The name of the step.\n            trophic_level: The trophic level.\n\n        Returns:\n            True if the step is in the given trophic level, False otherwise.\n        \"\"\"\n        return self.get_step_trophic_level(step_name) == trophic_level\n\n    def step_in_last_trophic_level(self, step_name: str) -&gt; bool:\n        \"\"\"Checks if a step is in the last trophic level.\n\n        Args:\n            step_name: The name of the step.\n\n        Returns:\n            True if the step is in the last trophic level, False otherwise.\n        \"\"\"\n        return self.is_step_in_trophic_level(\n            step_name, max(self.trophic_levels.values())\n        )\n\n    def validate(self) -&gt; None:\n        \"\"\"Validates that the `Step`s included in the pipeline are correctly connected and\n        have the correct inputs and outputs.\n\n        Raises:\n            ValueError: If the pipeline is not valid.\n        \"\"\"\n\n        for trophic_level, steps in enumerate(\n            self.iter_based_on_trophic_levels(), start=1\n        ):\n            for step_name in steps:\n                step: \"_Step\" = self.get_step(step_name)[\"step\"]\n\n                self._validate_step_process_arguments(step)\n                step.verify_inputs_mappings()\n                step.verify_outputs_mappings()\n\n                # Validate that the steps in the first trophic level are `GeneratorStep`s\n                if trophic_level == 1:\n                    if not step.is_generator:\n                        raise ValueError(\n                            f\"Step '{step_name}' cannot be a root step because it is not\"\n                            \" a `GeneratorStep`. It should have a previous step in the pipeline.\"\n                        )\n                    self._validate_generator_step_process_signature(step)\n                else:\n                    self._step_inputs_are_available(step)\n\n    def _step_inputs_are_available(self, step: \"_Step\") -&gt; None:\n        \"\"\"Validates that the `Step.inputs` will be available when the step gets to be\n        executed in the pipeline i.e. the step will receive list of dictionaries containing\n        its inputs as keys.\n\n        Args:\n            step: The step.\n        \"\"\"\n        inputs_available_for_step = [\n            output\n            for step_name in nx.ancestors(self.G, step.name)\n            for output in self.get_step(step_name)[\"step\"].get_outputs()\n        ]\n        step_inputs = step.get_inputs()\n        if not all(input in inputs_available_for_step for input in step_inputs):\n            raise ValueError(\n                f\"Step '{step.name}' requires inputs {step_inputs} which are not\"\n                f\" available when the step gets to be executed in the pipeline.\"\n                f\" Please make sure previous steps to '{step.name}' are generating\"\n                f\" the required inputs. Available inputs are: {inputs_available_for_step}\"\n            )\n\n    def _validate_step_process_arguments(self, step: \"_Step\") -&gt; None:\n        \"\"\"Validates the arguments of the `Step.process` method, checking there is an\n        argument with type hint `StepInput` and that all the required runtime parameters\n        are provided.\n\n        Args:\n            step: The step to validate.\n\n        Raises:\n            ValueError: If the arguments of the `process` method of the step are not valid.\n        \"\"\"\n\n        step_input_parameter = step.get_process_step_input()\n        self._validate_process_step_input_parameter(step.name, step_input_parameter)\n        self._validate_step_process_runtime_parameters(step)\n\n    def _validate_process_step_input_parameter(\n        self,\n        step_name: str,\n        step_input_parameter: Union[inspect.Parameter, None] = None,\n    ) -&gt; None:\n        \"\"\"Validates that the `Step.process` method has a parameter with type hint `StepInput`\n\n        Args:\n            step_name: The name of the step.\n            step_input_parameter: The parameter with type hint `StepInput` of the `process`\n                method of the step.\n\n        Raises:\n            ValueError: If the `step_input_parameter` is not valid.\n        \"\"\"\n\n        predecessors = {\n            step_name: self.get_step(step_name)[\"step\"]\n            for step_name in self.G.predecessors(step_name)\n        }\n        num_predecessors = len(predecessors)\n\n        if num_predecessors == 0:\n            return\n\n        if step_input_parameter is None:\n            if num_predecessors &gt; 1:\n                prev_steps = \", \".join([f\"'{step_name}'\" for step_name in predecessors])\n                raise ValueError(\n                    f\"Step '{step_name}' should have a `*args` parameter with type hint\"\n                    f\" `StepInput` to receive outputs from previous steps: {prev_steps}.\"\n                )\n\n            prev_step_name = next(iter(predecessors))\n            raise ValueError(\n                f\"Step '{step_name}' should have a parameter with type hint `StepInput`\"\n                f\" to receive the output from the previous step: '{prev_step_name}'.\"\n            )\n\n        if (\n            num_predecessors &gt; 1\n            and step_input_parameter.kind != inspect.Parameter.VAR_POSITIONAL\n        ):\n            raise ValueError(\n                f\"Step '{step_name}' should have a `*args` parameter with type hint `StepInput`\"\n                f\" to receive outputs from previous steps.\"\n            )\n\n    def _validate_step_process_runtime_parameters(self, step: \"_Step\") -&gt; None:\n        \"\"\"Validates that the required runtime parameters of the step are provided. A\n        runtime parameter is considered required if it doesn't have a default value. The\n        name of the runtime parameters are separated by dots to represent nested parameters.\n\n        Args:\n            step: The step to validate.\n\n        Raises:\n            ValueError: If not all the required runtime parameters haven't been provided\n                with a value.\n        \"\"\"\n\n        def _get_pipeline_aux_code(step_name: str, param_name: str) -&gt; str:\n            parts = param_name.split(\".\")\n            result = f'pipeline.run(parameters={{\"{step_name}\":'\n            nested_dict = \"...\"\n            for part in reversed(parts):\n                nested_dict = f' {{\"{part}\": {nested_dict}}}'\n            result += nested_dict + \"})\"\n            return result\n\n        def _check_required_parameter(\n            param_name: str,\n            composed_param_name: str,\n            is_optional_or_nested: Union[bool, \"RuntimeParametersNames\"],\n            runtime_parameters: Dict[str, Any],\n            runtime_parameters_names: \"RuntimeParametersNames\",\n        ) -&gt; None:\n            if isinstance(is_optional_or_nested, dict):\n                runtime_parameters_names = runtime_parameters_names[param_name]  # type: ignore\n                for subparam, value in runtime_parameters_names.items():\n                    _check_required_parameter(\n                        param_name=subparam,\n                        composed_param_name=f\"{composed_param_name}.{subparam}\",\n                        is_optional_or_nested=value,\n                        runtime_parameters=runtime_parameters.get(subparam, {}),\n                        runtime_parameters_names=runtime_parameters_names,\n                    )\n                return\n\n            if not is_optional_or_nested and param_name not in runtime_parameters:\n                aux_code = _get_pipeline_aux_code(step.name, composed_param_name)\n                raise ValueError(\n                    f\"Step '{step.name}' is missing required runtime parameter '{param_name}'.\"\n                    \" Please, provide a value for it when calling `Pipeline.run` method:\\n\\n\"\n                    f\"    {aux_code}\"\n                )\n\n        runtime_parameters_names = step.runtime_parameters_names\n        for param_name, value in runtime_parameters_names.items():\n            _check_required_parameter(\n                param_name=param_name,\n                composed_param_name=param_name,\n                is_optional_or_nested=value,\n                runtime_parameters=step._runtime_parameters,\n                runtime_parameters_names=runtime_parameters_names,\n            )\n\n    def _validate_generator_step_process_signature(self, step: \"GeneratorStep\") -&gt; None:\n        \"\"\"Validates that the `process` method of the `GeneratorStep` does not expect the\n        `inputs` arg within the method signature, and also the `offset` arg should always\n        be present.\n\n        Args:\n            step: The step to validate.\n\n        Raises:\n            ValueError: If the `process` method of the `GeneratorStep` expects the `inputs` arg.\n            ValueError: If the `process` method of the `GeneratorStep` does not expect the `offset` arg.\n        \"\"\"\n        if step.get_process_step_input() is not None:\n            raise ValueError(\n                f\"Generator step '{step.name}' should not have a parameter with type hint\"\n                \" `StepInput` within the `process` method signature.\"\n            )\n        if not any(\"offset\" == parameter.name for parameter in step.process_parameters):\n            raise ValueError(\n                f\"Generator step '{step.name}' should have an `offset` parameter within\"\n                \" the `process` method signature.\"\n            )\n\n    def _model_dump(self, obj: Any, **kwargs: Any) -&gt; Dict[str, Any]:\n        \"\"\"Dumps the content of the DAG to a dict.\n\n        References:\n        * [`adjacency_data` - NetworkX Documentation](https://networkx.org/documentation/stable/reference/readwrite/generated/networkx.readwrite.json_graph.adjacency_data.html#networkx.readwrite.json_graph.adjacency_data)\n\n        Args:\n            obj (Any): Unused, just kept to match the signature of the parent method.\n            kwargs (Any): Additional arguments that could be passed to the networkx function.\n\n        Returns:\n            Dict[str, Any]: Internal representation of the DAG from networkx in a serializable format.\n        \"\"\"\n        from networkx.readwrite import json_graph\n\n        adjacency_data = json_graph.adjacency_data(self.G, **kwargs)\n\n        data = {\"steps\": [], \"connections\": []}\n        for i, node in enumerate(adjacency_data[\"nodes\"]):\n            name = node[\"id\"]\n            data[\"steps\"].append({\"step\": node[\"step\"].dump(), \"name\": name})\n            data[\"connections\"].append(\n                {\n                    \"from\": name,\n                    \"to\": [node[\"id\"] for node in adjacency_data[\"adjacency\"][i]],\n                }\n            )\n\n        return data\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"DAG\":\n        \"\"\"Generates the DAG from a dictionary with the steps serialized.\n\n        Args:\n            data (Dict[str, Any]): Dictionary with the serialized content (the content from self.dump()).\n\n        Returns:\n            DAG: Instance of the DAG from the serialized content.\n        \"\"\"\n\n        dag = cls()\n\n        for step in data[\"steps\"]:\n            cls_step: Type[\"_Step\"] = _get_class(**step[\"step\"][TYPE_INFO_KEY])\n            dag.add_step(cls_step.from_dict(step[\"step\"]))\n\n        for connection in data[\"connections\"]:\n            from_step = connection[\"from\"]\n            for to_step in connection[\"to\"]:\n                dag.add_edge(from_step, to_step)\n\n        return dag\n</code></pre>"},{"location":"reference/distilabel/pipeline/_dag/#distilabel.pipeline._dag.DAG.leaf_steps","title":"<code>leaf_steps: Set[str]</code>  <code>cached</code> <code>property</code>","text":"<p>The steps that don't have any successors.</p> <p>Returns:</p> Type Description <code>Set[str]</code> <p>A list with the names of the steps that don't have any successors.</p>"},{"location":"reference/distilabel/pipeline/_dag/#distilabel.pipeline._dag.DAG.root_steps","title":"<code>root_steps: Set[str]</code>  <code>cached</code> <code>property</code>","text":"<p>The steps that don't have any predecessors i.e. generator steps.</p> <p>Returns:</p> Type Description <code>Set[str]</code> <p>A list with the names of the steps that don't have any predecessors.</p>"},{"location":"reference/distilabel/pipeline/_dag/#distilabel.pipeline._dag.DAG.trophic_levels","title":"<code>trophic_levels: Dict[str, int]</code>  <code>cached</code> <code>property</code>","text":"<p>The trophic level of each step in the DAG.</p> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>A dictionary with the trophic level of each step.</p>"},{"location":"reference/distilabel/pipeline/_dag/#distilabel.pipeline._dag.DAG.add_edge","title":"<code>add_edge(from_step, to_step)</code>","text":"<p>Add an edge between two steps in the DAG.</p> <p>Parameters:</p> Name Type Description Default <code>from_step</code> <code>str</code> <p>The name of the step from which the edge starts.</p> required <code>to_step</code> <code>str</code> <p>The name of the step to which the edge ends.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the edge cannot be added.</p> Source code in <code>src/distilabel/pipeline/_dag.py</code> <pre><code>def add_edge(self, from_step: str, to_step: str) -&gt; None:\n    \"\"\"Add an edge between two steps in the DAG.\n\n    Args:\n        from_step: The name of the step from which the edge starts.\n        to_step: The name of the step to which the edge ends.\n\n    Raises:\n        ValueError: If the edge cannot be added.\n    \"\"\"\n    if from_step not in self.G:\n        raise ValueError(f\"Step with name '{from_step}' does not exist\")\n\n    if to_step not in self.G:\n        raise ValueError(f\"Step with name '{to_step}' does not exist\")\n\n    if to_step in self.G[from_step]:\n        raise ValueError(\n            f\"There is already a edge from '{to_step}' to '{from_step}'\"\n        )\n\n    if to_step in nx.ancestors(self.G, from_step):\n        raise ValueError(\n            f\"Cannot add edge from '{from_step}' to '{to_step}' as it would create a cycle.\"\n        )\n\n    self.G.add_edge(from_step, to_step)\n</code></pre>"},{"location":"reference/distilabel/pipeline/_dag/#distilabel.pipeline._dag.DAG.add_step","title":"<code>add_step(step)</code>","text":"<p>Add a step to the DAG.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>_Step</code> <p>The step to add to the DAG.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a step with the same name already exists in the DAG.</p> Source code in <code>src/distilabel/pipeline/_dag.py</code> <pre><code>def add_step(self, step: \"_Step\") -&gt; None:\n    \"\"\"Add a step to the DAG.\n\n    Args:\n        step: The step to add to the DAG.\n\n    Raises:\n        ValueError: If a step with the same name already exists in the DAG.\n    \"\"\"\n    name = step.name\n    if name in self.G:\n        raise ValueError(f\"Step with name '{name}' already exists\")\n    self.G.add_node(name, step=step)\n</code></pre>"},{"location":"reference/distilabel/pipeline/_dag/#distilabel.pipeline._dag.DAG.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Generates the DAG from a dictionary with the steps serialized.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>Dictionary with the serialized content (the content from self.dump()).</p> required <p>Returns:</p> Name Type Description <code>DAG</code> <code>DAG</code> <p>Instance of the DAG from the serialized content.</p> Source code in <code>src/distilabel/pipeline/_dag.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; \"DAG\":\n    \"\"\"Generates the DAG from a dictionary with the steps serialized.\n\n    Args:\n        data (Dict[str, Any]): Dictionary with the serialized content (the content from self.dump()).\n\n    Returns:\n        DAG: Instance of the DAG from the serialized content.\n    \"\"\"\n\n    dag = cls()\n\n    for step in data[\"steps\"]:\n        cls_step: Type[\"_Step\"] = _get_class(**step[\"step\"][TYPE_INFO_KEY])\n        dag.add_step(cls_step.from_dict(step[\"step\"]))\n\n    for connection in data[\"connections\"]:\n        from_step = connection[\"from\"]\n        for to_step in connection[\"to\"]:\n            dag.add_edge(from_step, to_step)\n\n    return dag\n</code></pre>"},{"location":"reference/distilabel/pipeline/_dag/#distilabel.pipeline._dag.DAG.get_step","title":"<code>get_step(name)</code>","text":"<p>Get a step from the DAG.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the step to get.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The step with the given name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the step with the given name does not exist.</p> Source code in <code>src/distilabel/pipeline/_dag.py</code> <pre><code>def get_step(self, name: str) -&gt; Dict[str, Any]:\n    \"\"\"Get a step from the DAG.\n\n    Args:\n        name: The name of the step to get.\n\n    Returns:\n        The step with the given name.\n\n    Raises:\n        ValueError: If the step with the given name does not exist.\n    \"\"\"\n    if name not in self.G:\n        raise ValueError(f\"Step with name '{name}' does not exist\")\n    return self.G.nodes[name]\n</code></pre>"},{"location":"reference/distilabel/pipeline/_dag/#distilabel.pipeline._dag.DAG.get_step_predecessors","title":"<code>get_step_predecessors(step_name)</code>","text":"<p>Gets the predecessors of a step.</p> <p>Parameters:</p> Name Type Description Default <code>step_name</code> <code>str</code> <p>The name of the step.</p> required <p>Returns:</p> Type Description <code>Iterable[str]</code> <p>An iterable with the names of the steps that are predecessors of the given step.</p> Source code in <code>src/distilabel/pipeline/_dag.py</code> <pre><code>def get_step_predecessors(self, step_name: str) -&gt; Iterable[str]:\n    \"\"\"Gets the predecessors of a step.\n\n    Args:\n        step_name: The name of the step.\n\n    Returns:\n        An iterable with the names of the steps that are predecessors of the given step.\n    \"\"\"\n    if step_name not in self.G:\n        raise ValueError(f\"Step '{step_name}' does not exist\")\n    return self.G.predecessors(step_name)\n</code></pre>"},{"location":"reference/distilabel/pipeline/_dag/#distilabel.pipeline._dag.DAG.get_step_successors","title":"<code>get_step_successors(step_name)</code>","text":"<p>Gets the successors of a step.</p> <p>Parameters:</p> Name Type Description Default <code>step_name</code> <code>str</code> <p>The name of the step.</p> required <p>Returns:</p> Type Description <code>Iterable[str]</code> <p>An iterable with the names of the steps that are successors of the given step.</p> Source code in <code>src/distilabel/pipeline/_dag.py</code> <pre><code>def get_step_successors(self, step_name: str) -&gt; Iterable[str]:\n    \"\"\"Gets the successors of a step.\n\n    Args:\n        step_name: The name of the step.\n\n    Returns:\n        An iterable with the names of the steps that are successors of the given step.\n    \"\"\"\n\n    if step_name not in self.G:\n        raise ValueError(f\"Step '{step_name}' does not exist\")\n    return self.G.successors(step_name)\n</code></pre>"},{"location":"reference/distilabel/pipeline/_dag/#distilabel.pipeline._dag.DAG.get_step_trophic_level","title":"<code>get_step_trophic_level(step_name)</code>","text":"<p>Gets the trophic level of a step.</p> <p>Parameters:</p> Name Type Description Default <code>step_name</code> <code>str</code> <p>The name of the step.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The trophic level of the step.</p> Source code in <code>src/distilabel/pipeline/_dag.py</code> <pre><code>def get_step_trophic_level(self, step_name: str) -&gt; int:\n    \"\"\"Gets the trophic level of a step.\n\n    Args:\n        step_name: The name of the step.\n\n    Returns:\n        The trophic level of the step.\n    \"\"\"\n    return int(self.trophic_levels[step_name])\n</code></pre>"},{"location":"reference/distilabel/pipeline/_dag/#distilabel.pipeline._dag.DAG.is_step_in_trophic_level","title":"<code>is_step_in_trophic_level(step_name, trophic_level)</code>","text":"<p>Checks if a step is in a given trophic level.</p> <p>Parameters:</p> Name Type Description Default <code>step_name</code> <code>str</code> <p>The name of the step.</p> required <code>trophic_level</code> <code>int</code> <p>The trophic level.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the step is in the given trophic level, False otherwise.</p> Source code in <code>src/distilabel/pipeline/_dag.py</code> <pre><code>def is_step_in_trophic_level(self, step_name: str, trophic_level: int) -&gt; bool:\n    \"\"\"Checks if a step is in a given trophic level.\n\n    Args:\n        step_name: The name of the step.\n        trophic_level: The trophic level.\n\n    Returns:\n        True if the step is in the given trophic level, False otherwise.\n    \"\"\"\n    return self.get_step_trophic_level(step_name) == trophic_level\n</code></pre>"},{"location":"reference/distilabel/pipeline/_dag/#distilabel.pipeline._dag.DAG.iter_based_on_trophic_levels","title":"<code>iter_based_on_trophic_levels()</code>","text":"<p>Iterate over steps names in the DAG based on their trophic levels. This is similar to a topological sort, but we also know which steps are at the same level and can be run in parallel.</p> <p>Yields:</p> Type Description <code>Iterable[List[str]]</code> <p>A list containing the names of the steps that can be run in parallel.</p> Source code in <code>src/distilabel/pipeline/_dag.py</code> <pre><code>def iter_based_on_trophic_levels(self) -&gt; Iterable[List[str]]:\n    \"\"\"Iterate over steps names in the DAG based on their trophic levels. This is similar\n    to a topological sort, but we also know which steps are at the same level and\n    can be run in parallel.\n\n    Yields:\n        A list containing the names of the steps that can be run in parallel.\n    \"\"\"\n    v = defaultdict(list)\n    for step, trophic_level in self.trophic_levels.items():\n        v[trophic_level].append(step)\n\n    for trophic_level in sorted(v.keys()):\n        yield v[trophic_level]\n</code></pre>"},{"location":"reference/distilabel/pipeline/_dag/#distilabel.pipeline._dag.DAG.set_step_attr","title":"<code>set_step_attr(name, attr, value)</code>","text":"<p>Set an attribute of a step in the DAG.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the step.</p> required <code>attr</code> <code>str</code> <p>The attribute to set.</p> required <code>value</code> <code>Any</code> <p>The value to set.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the step with the given name does not exist.</p> Source code in <code>src/distilabel/pipeline/_dag.py</code> <pre><code>def set_step_attr(self, name: str, attr: str, value: Any) -&gt; None:\n    \"\"\"Set an attribute of a step in the DAG.\n\n    Args:\n        name: The name of the step.\n        attr: The attribute to set.\n        value: The value to set.\n\n    Raises:\n        ValueError: If the step with the given name does not exist.\n    \"\"\"\n    if name not in self.G:\n        raise ValueError(f\"Step with name '{name}' does not exist\")\n    self.G.nodes[name][attr] = value\n</code></pre>"},{"location":"reference/distilabel/pipeline/_dag/#distilabel.pipeline._dag.DAG.step_in_last_trophic_level","title":"<code>step_in_last_trophic_level(step_name)</code>","text":"<p>Checks if a step is in the last trophic level.</p> <p>Parameters:</p> Name Type Description Default <code>step_name</code> <code>str</code> <p>The name of the step.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the step is in the last trophic level, False otherwise.</p> Source code in <code>src/distilabel/pipeline/_dag.py</code> <pre><code>def step_in_last_trophic_level(self, step_name: str) -&gt; bool:\n    \"\"\"Checks if a step is in the last trophic level.\n\n    Args:\n        step_name: The name of the step.\n\n    Returns:\n        True if the step is in the last trophic level, False otherwise.\n    \"\"\"\n    return self.is_step_in_trophic_level(\n        step_name, max(self.trophic_levels.values())\n    )\n</code></pre>"},{"location":"reference/distilabel/pipeline/_dag/#distilabel.pipeline._dag.DAG.validate","title":"<code>validate()</code>","text":"<p>Validates that the <code>Step</code>s included in the pipeline are correctly connected and have the correct inputs and outputs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the pipeline is not valid.</p> Source code in <code>src/distilabel/pipeline/_dag.py</code> <pre><code>def validate(self) -&gt; None:\n    \"\"\"Validates that the `Step`s included in the pipeline are correctly connected and\n    have the correct inputs and outputs.\n\n    Raises:\n        ValueError: If the pipeline is not valid.\n    \"\"\"\n\n    for trophic_level, steps in enumerate(\n        self.iter_based_on_trophic_levels(), start=1\n    ):\n        for step_name in steps:\n            step: \"_Step\" = self.get_step(step_name)[\"step\"]\n\n            self._validate_step_process_arguments(step)\n            step.verify_inputs_mappings()\n            step.verify_outputs_mappings()\n\n            # Validate that the steps in the first trophic level are `GeneratorStep`s\n            if trophic_level == 1:\n                if not step.is_generator:\n                    raise ValueError(\n                        f\"Step '{step_name}' cannot be a root step because it is not\"\n                        \" a `GeneratorStep`. It should have a previous step in the pipeline.\"\n                    )\n                self._validate_generator_step_process_signature(step)\n            else:\n                self._step_inputs_are_available(step)\n</code></pre>"},{"location":"reference/distilabel/pipeline/base/","title":"Base","text":""},{"location":"reference/distilabel/pipeline/base/#distilabel.pipeline.base.BasePipeline","title":"<code>BasePipeline</code>","text":"<p>             Bases: <code>_Serializable</code></p> <p>Base class for a <code>distilabel</code> pipeline.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>The name of the pipeline.</p> <code>description</code> <p>A description of the pipeline.</p> <code>dag</code> <p>The <code>DAG</code> instance that represents the pipeline.</p> <code>_cache_dir</code> <p>The directory where the pipeline will be cached.</p> <code>_logger</code> <p>The logger instance that will be used by the pipeline.</p> <code>_batch_manager</code> <code>Optional[_BatchManager]</code> <p>The batch manager that will manage the batches received from the steps while running the pipeline.</p> Source code in <code>src/distilabel/pipeline/base.py</code> <pre><code>class BasePipeline(_Serializable):\n    \"\"\"Base class for a `distilabel` pipeline.\n\n    Attributes:\n        name: The name of the pipeline.\n        description: A description of the pipeline.\n        dag: The `DAG` instance that represents the pipeline.\n        _cache_dir: The directory where the pipeline will be cached.\n        _logger: The logger instance that will be used by the pipeline.\n        _batch_manager: The batch manager that will manage the batches received from the\n            steps while running the pipeline.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        description: Optional[str] = None,\n        cache_dir: Optional[\"PathLike\"] = None,\n    ) -&gt; None:\n        \"\"\"Initialize the `BasePipeline` instance.\n\n        Args:\n            name: The name of the pipeline.\n            description: A description of the pipeline. Defaults to `None`.\n            cache_dir: A directory where the pipeline will be cached. Defaults to `None`.\n        \"\"\"\n        self.name = name\n        self.description = description\n        self.dag = DAG()\n\n        if cache_dir:\n            self._cache_dir = Path(cache_dir)\n        elif env_cache_dir := os.getenv(\"DISTILABEL_CACHE_DIR\"):\n            self._cache_dir = Path(env_cache_dir)\n        else:\n            self._cache_dir = BASE_CACHE_DIR\n\n        self._logger = logging.getLogger(\"distilabel.pipeline\")\n\n        # It's set to None here, will be created in the call to run\n        self._batch_manager: Optional[\"_BatchManager\"] = None\n\n    def __enter__(self) -&gt; Self:\n        \"\"\"Set the global pipeline instance when entering a pipeline context.\"\"\"\n        _GlobalPipelineManager.set_pipeline(self)\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback) -&gt; None:\n        \"\"\"Unset the global pipeline instance when exiting a pipeline context.\"\"\"\n        _GlobalPipelineManager.set_pipeline(None)\n\n    def _create_signature(self) -&gt; str:\n        \"\"\"Makes a signature (hash) of a pipeline, using the step ids and the adjacency between them.\n\n        The main use is to find the pipeline in the cache folder.\n\n        Returns:\n            int: Signature of the pipeline.\n        \"\"\"\n        hasher = hashlib.sha1()\n\n        steps_info = []\n        pipeline_dump = self.dump()[\"pipeline\"]\n        for step in pipeline_dump[\"steps\"]:\n            step_info = step[\"name\"]\n            for argument, value in sorted(step[\"step\"].items()):\n                if (\n                    (argument == TYPE_INFO_KEY)\n                    or (argument == \"llm\")\n                    or (value is None)\n                ):\n                    # NOTE: Should we include the LLM info at this stage??\n                    continue\n\n                if isinstance(value, dict):\n                    # input_mappings/output_mappings\n                    step_info += \"-\".join(\n                        [f\"{str(k)}-{str(v)}\" for k, v in value.items()]\n                    )\n                elif isinstance(value, (list, tuple)):\n                    # runtime_parameters_info\n                    step_info += \"-\".join([str(v) for v in value])\n                elif isinstance(value, (int, str, float)):\n                    # batch_size/name\n                    step_info += str(value)\n                else:\n                    raise ValueError(\n                        f\"Field '{argument}' in step '{step['name']}' has type {type(value)}, explicitly cast the type to 'str'.\"\n                    )\n\n            steps_info.append(step_info)\n\n        connections_info = [\n            f\"{c['from']}-{'-'.join(c['to'])}\" for c in pipeline_dump[\"connections\"]\n        ]\n        hasher.update(\",\".join(steps_info + connections_info).encode())\n\n        return hasher.hexdigest()\n\n    def run(\n        self,\n        parameters: Optional[Dict[str, Dict[str, Any]]] = None,\n        use_cache: bool = True,\n    ) -&gt; \"Distiset\":  # type: ignore\n        \"\"\"Run the pipeline. It will set the runtime parameters for the steps and validate\n        the pipeline.\n\n        This method should be extended by the specific pipeline implementation,\n        adding the logic to run the pipeline.\n\n        Args:\n            parameters: A dictionary with the step name as the key and a dictionary with\n                the runtime parameters for the step as the value. Defaults to `None`.\n            use_cache: Whether to use the cache from previous pipeline runs. Defaults to\n                `True`.\n\n        Returns:\n            The `Distiset` created by the pipeline.\n        \"\"\"\n        self._set_runtime_parameters(parameters or {})\n        self.dag.validate()\n        if use_cache:\n            self._load_from_cache()\n\n    def get_runtime_parameters_info(self) -&gt; Dict[str, List[Dict[str, Any]]]:\n        \"\"\"Get the runtime parameters for the steps in the pipeline.\n\n        Returns:\n            A dictionary with the step name as the key and a list of dictionaries with\n            the parameter name and the parameter info as the value.\n        \"\"\"\n        runtime_parameters = {}\n        for step_name in self.dag:\n            step: \"_Step\" = self.dag.get_step(step_name)[\"step\"]\n            runtime_parameters[step_name] = step.get_runtime_parameters_info()\n        return runtime_parameters\n\n    def _add_step(self, step: \"_Step\") -&gt; None:\n        \"\"\"Add a step to the pipeline.\n\n        Args:\n            step: The step to be added to the pipeline.\n        \"\"\"\n        self.dag.add_step(step)\n\n    def _add_edge(self, from_step: str, to_step: str) -&gt; None:\n        \"\"\"Add an edge between two steps in the pipeline.\n\n        Args:\n            from_step: The name of the step that will generate the input for `to_step`.\n            to_step: The name of the step that will receive the input from `from_step`.\n        \"\"\"\n        self.dag.add_edge(from_step, to_step)\n\n    def _set_runtime_parameters(self, parameters: Dict[str, Dict[str, Any]]) -&gt; None:\n        \"\"\"Set the runtime parameters for the steps in the pipeline.\n\n        Args:\n            parameters: A dictionary with the step name as the key and a dictionary with\n            the parameter name as the key and the parameter value as the value.\n        \"\"\"\n        for step_name, step_parameters in parameters.items():\n            step: \"_Step\" = self.dag.get_step(step_name)[\"step\"]\n            step.set_runtime_parameters(step_parameters)\n\n    def _model_dump(self, obj: Any, **kwargs: Any) -&gt; Dict[str, Any]:\n        \"\"\"Dumps the DAG content to a dict.\n\n        Args:\n            obj (Any): Unused, just kept to match the signature of the parent method.\n            kwargs (Any): Unused, just kept to match the signature of the parent method.\n\n        Returns:\n            Dict[str, Any]: Internal representation of the DAG from networkx in a serializable format.\n        \"\"\"\n        return self.dag.dump()\n\n    def dump(self, **kwargs: Any) -&gt; Dict[str, Any]:\n        return {\n            \"distilabel\": {\"version\": __version__},\n            \"pipeline\": {\n                \"name\": self.name,\n                \"description\": self.description,\n                **super().dump(),\n            },\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; Self:\n        \"\"\"Create a Pipeline from a dict containing the serialized data.\n\n        Note:\n            It's intended for internal use.\n\n        Args:\n            data (Dict[str, Any]): Dictionary containing the serialized data from a Pipeline.\n\n        Returns:\n            BasePipeline: Pipeline recreated from the dictionary info.\n        \"\"\"\n        name = data[\"pipeline\"][\"name\"]\n        description = data[\"pipeline\"].get(\"description\")\n        with cls(name=name, description=description) as pipe:\n            pipe.dag = DAG.from_dict(data[\"pipeline\"])\n        return pipe\n\n    @property\n    def _cache_location(self) -&gt; CacheLocation:\n        \"\"\"Dictionary containing the the object that will stored and the location,\n        whether it is a filename or a folder.\n\n        Returns:\n            Path: Filenames where the pipeline content will be serialized.\n        \"\"\"\n        folder = self._cache_dir / self._create_signature()\n        return {\n            \"pipeline\": folder / \"pipeline.yaml\",\n            \"batch_manager\": folder / \"batch_manager.json\",\n            \"data\": folder / \"data\",\n        }\n\n    def _cache(self) -&gt; None:\n        \"\"\"Saves the `BasePipeline` using the `_cache_filename`.\"\"\"\n        self.save(\n            path=self._cache_location[\"pipeline\"],\n            format=self._cache_location[\"pipeline\"].suffix.replace(\".\", \"\"),\n        )\n        if self._batch_manager is not None:\n            self._batch_manager.save(\n                self._cache_location[\"batch_manager\"],\n                format=self._cache_location[\"batch_manager\"].suffix.replace(\".\", \"\"),\n            )\n        self._logger.debug(\"Pipeline and batch manager saved to cache.\")\n\n    def _load_from_cache(self) -&gt; None:\n        \"\"\"Will try to load the `BasePipeline` from the cache dir if found, updating\n        the internal `DAG` and `_BatchManager`.\n        \"\"\"\n        cache_loc = self._cache_location\n        if cache_loc[\"pipeline\"].exists():\n            # Refresh the DAG to avoid errors when it's created within a context manager\n            # (it will check the steps aren't already defined for the DAG).\n            self.dag = DAG()\n            new_class = self.from_yaml(cache_loc[\"pipeline\"])\n            # Update the internal dag and batch_manager\n            self.dag.G = new_class.dag.G\n            if cache_loc[\"batch_manager\"].exists():\n                self._batch_manager = _BatchManager.from_json(\n                    cache_loc[\"batch_manager\"]\n                )\n            self._logger.info(\"\ud83d\udcbe Load pipeline from cache\")\n</code></pre>"},{"location":"reference/distilabel/pipeline/base/#distilabel.pipeline.base.BasePipeline.__enter__","title":"<code>__enter__()</code>","text":"<p>Set the global pipeline instance when entering a pipeline context.</p> Source code in <code>src/distilabel/pipeline/base.py</code> <pre><code>def __enter__(self) -&gt; Self:\n    \"\"\"Set the global pipeline instance when entering a pipeline context.\"\"\"\n    _GlobalPipelineManager.set_pipeline(self)\n    return self\n</code></pre>"},{"location":"reference/distilabel/pipeline/base/#distilabel.pipeline.base.BasePipeline.__exit__","title":"<code>__exit__(exc_type, exc_value, traceback)</code>","text":"<p>Unset the global pipeline instance when exiting a pipeline context.</p> Source code in <code>src/distilabel/pipeline/base.py</code> <pre><code>def __exit__(self, exc_type, exc_value, traceback) -&gt; None:\n    \"\"\"Unset the global pipeline instance when exiting a pipeline context.\"\"\"\n    _GlobalPipelineManager.set_pipeline(None)\n</code></pre>"},{"location":"reference/distilabel/pipeline/base/#distilabel.pipeline.base.BasePipeline.__init__","title":"<code>__init__(name, description=None, cache_dir=None)</code>","text":"<p>Initialize the <code>BasePipeline</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the pipeline.</p> required <code>description</code> <code>Optional[str]</code> <p>A description of the pipeline. Defaults to <code>None</code>.</p> <code>None</code> <code>cache_dir</code> <code>Optional[PathLike]</code> <p>A directory where the pipeline will be cached. Defaults to <code>None</code>.</p> <code>None</code> Source code in <code>src/distilabel/pipeline/base.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    description: Optional[str] = None,\n    cache_dir: Optional[\"PathLike\"] = None,\n) -&gt; None:\n    \"\"\"Initialize the `BasePipeline` instance.\n\n    Args:\n        name: The name of the pipeline.\n        description: A description of the pipeline. Defaults to `None`.\n        cache_dir: A directory where the pipeline will be cached. Defaults to `None`.\n    \"\"\"\n    self.name = name\n    self.description = description\n    self.dag = DAG()\n\n    if cache_dir:\n        self._cache_dir = Path(cache_dir)\n    elif env_cache_dir := os.getenv(\"DISTILABEL_CACHE_DIR\"):\n        self._cache_dir = Path(env_cache_dir)\n    else:\n        self._cache_dir = BASE_CACHE_DIR\n\n    self._logger = logging.getLogger(\"distilabel.pipeline\")\n\n    # It's set to None here, will be created in the call to run\n    self._batch_manager: Optional[\"_BatchManager\"] = None\n</code></pre>"},{"location":"reference/distilabel/pipeline/base/#distilabel.pipeline.base.BasePipeline.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a Pipeline from a dict containing the serialized data.</p> Note <p>It's intended for internal use.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>Dictionary containing the serialized data from a Pipeline.</p> required <p>Returns:</p> Name Type Description <code>BasePipeline</code> <code>Self</code> <p>Pipeline recreated from the dictionary info.</p> Source code in <code>src/distilabel/pipeline/base.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; Self:\n    \"\"\"Create a Pipeline from a dict containing the serialized data.\n\n    Note:\n        It's intended for internal use.\n\n    Args:\n        data (Dict[str, Any]): Dictionary containing the serialized data from a Pipeline.\n\n    Returns:\n        BasePipeline: Pipeline recreated from the dictionary info.\n    \"\"\"\n    name = data[\"pipeline\"][\"name\"]\n    description = data[\"pipeline\"].get(\"description\")\n    with cls(name=name, description=description) as pipe:\n        pipe.dag = DAG.from_dict(data[\"pipeline\"])\n    return pipe\n</code></pre>"},{"location":"reference/distilabel/pipeline/base/#distilabel.pipeline.base.BasePipeline.get_runtime_parameters_info","title":"<code>get_runtime_parameters_info()</code>","text":"<p>Get the runtime parameters for the steps in the pipeline.</p> <p>Returns:</p> Type Description <code>Dict[str, List[Dict[str, Any]]]</code> <p>A dictionary with the step name as the key and a list of dictionaries with</p> <code>Dict[str, List[Dict[str, Any]]]</code> <p>the parameter name and the parameter info as the value.</p> Source code in <code>src/distilabel/pipeline/base.py</code> <pre><code>def get_runtime_parameters_info(self) -&gt; Dict[str, List[Dict[str, Any]]]:\n    \"\"\"Get the runtime parameters for the steps in the pipeline.\n\n    Returns:\n        A dictionary with the step name as the key and a list of dictionaries with\n        the parameter name and the parameter info as the value.\n    \"\"\"\n    runtime_parameters = {}\n    for step_name in self.dag:\n        step: \"_Step\" = self.dag.get_step(step_name)[\"step\"]\n        runtime_parameters[step_name] = step.get_runtime_parameters_info()\n    return runtime_parameters\n</code></pre>"},{"location":"reference/distilabel/pipeline/base/#distilabel.pipeline.base.BasePipeline.run","title":"<code>run(parameters=None, use_cache=True)</code>","text":"<p>Run the pipeline. It will set the runtime parameters for the steps and validate the pipeline.</p> <p>This method should be extended by the specific pipeline implementation, adding the logic to run the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Optional[Dict[str, Dict[str, Any]]]</code> <p>A dictionary with the step name as the key and a dictionary with the runtime parameters for the step as the value. Defaults to <code>None</code>.</p> <code>None</code> <code>use_cache</code> <code>bool</code> <p>Whether to use the cache from previous pipeline runs. Defaults to <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>Distiset</code> <p>The <code>Distiset</code> created by the pipeline.</p> Source code in <code>src/distilabel/pipeline/base.py</code> <pre><code>def run(\n    self,\n    parameters: Optional[Dict[str, Dict[str, Any]]] = None,\n    use_cache: bool = True,\n) -&gt; \"Distiset\":  # type: ignore\n    \"\"\"Run the pipeline. It will set the runtime parameters for the steps and validate\n    the pipeline.\n\n    This method should be extended by the specific pipeline implementation,\n    adding the logic to run the pipeline.\n\n    Args:\n        parameters: A dictionary with the step name as the key and a dictionary with\n            the runtime parameters for the step as the value. Defaults to `None`.\n        use_cache: Whether to use the cache from previous pipeline runs. Defaults to\n            `True`.\n\n    Returns:\n        The `Distiset` created by the pipeline.\n    \"\"\"\n    self._set_runtime_parameters(parameters or {})\n    self.dag.validate()\n    if use_cache:\n        self._load_from_cache()\n</code></pre>"},{"location":"reference/distilabel/pipeline/base/#distilabel.pipeline.base.CacheLocation","title":"<code>CacheLocation</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>Dictionary to store the filenames and directories of a cached pipeline.</p> Source code in <code>src/distilabel/pipeline/base.py</code> <pre><code>class CacheLocation(TypedDict):\n    \"\"\"Dictionary to store the filenames and directories of a cached pipeline.\"\"\"\n\n    pipeline: Path\n    batch_manager: Path\n    data: Path\n</code></pre>"},{"location":"reference/distilabel/pipeline/local/","title":"Local","text":""},{"location":"reference/distilabel/pipeline/local/#distilabel.pipeline.local.Pipeline","title":"<code>Pipeline</code>","text":"<p>             Bases: <code>BasePipeline</code></p> <p>Local pipeline implementation using <code>multiprocessing</code>.</p> Source code in <code>src/distilabel/pipeline/local.py</code> <pre><code>class Pipeline(BasePipeline):\n    \"\"\"Local pipeline implementation using `multiprocessing`.\"\"\"\n\n    def run(\n        self,\n        parameters: Optional[Dict[str, Dict[str, Any]]] = None,\n        use_cache: bool = True,\n    ) -&gt; \"Distiset\":\n        \"\"\"Runs the pipeline.\n\n        Args:\n            parameters: A dictionary with the step name as the key and a dictionary with\n                the runtime parameters for the step as the value. Defaults to `None`.\n            use_cache: Whether to use the cache from previous pipeline runs. Defaults to\n                `True`.\n\n        Returns:\n            The `Distiset` created by the pipeline.\n\n        Raises:\n            RuntimeError: If the pipeline fails to load all the steps.\n        \"\"\"\n        try:\n            mp.set_start_method(\"forkserver\")\n        except RuntimeError:\n            pass\n        log_queue = mp.Queue()\n        setup_logging(log_queue)  # type: ignore\n        self._logger = logging.getLogger(\"distilabel.pipeline.local\")\n\n        super().run(parameters, use_cache)\n\n        if self._batch_manager is None:\n            self._batch_manager = _BatchManager.from_dag(self.dag)\n\n        # If the batch manager is not able to generate batches, that means that the loaded\n        # `_BatchManager` from cache didn't have any remaining batches to process i.e.\n        # the previous pipeline execution was completed successfully.\n        if not self._batch_manager.can_generate():\n            self._logger.info(\n                \"\ud83d\udcbe Loaded batch manager from cache doesn't have any remaining data. Returning\"\n                \" `Distiset` from cache data...\"\n            )\n            stop_logging()\n            return create_distiset(\n                self._cache_location[\"data\"],\n                pipeline_path=self._cache_location[\"pipeline\"],\n            )\n\n        buffer_data_path = self._cache_location[\"data\"]\n        self._logger.info(f\"\ud83d\udcdd Pipeline data will be written to '{buffer_data_path}'\")\n        write_buffer = _WriteBuffer(buffer_data_path, self.dag.leaf_steps)\n\n        num_processes = len(self.dag)\n        ctx = mp.get_context(\"forkserver\")  # type: ignore\n        with ctx.Manager() as manager, ctx.Pool(\n            num_processes, initializer=_init_worker, initargs=(log_queue,)\n        ) as pool:\n            self.output_queue: \"Queue[Any]\" = manager.Queue()\n            self.shared_info = self._create_shared_info_dict(manager)\n            self._handle_keyboard_interrupt()\n\n            # Run the steps using the pool of processes\n            self._run_steps_in_loop(pool, manager, self.output_queue, self.shared_info)\n\n            # Wait for all the steps to be loaded correctly\n            if not self._all_steps_loaded():\n                write_buffer.close()\n                self._batch_manager = None\n                stop_logging()\n                raise RuntimeError(\n                    \"Failed to load all the steps. Could not run pipeline.\"\n                )\n\n            # Send the \"first\" batches to the steps so the batches starts flowing through\n            # the input queues and output queue\n            self._request_initial_batches()\n\n            # Start a loop to receive the output batches from the steps\n            self._run_output_queue_loop_in_thread(write_buffer)\n\n            pool.close()\n            pool.join()\n\n        write_buffer.close()\n        distiset = create_distiset(\n            self._cache_location[\"data\"], pipeline_path=self._cache_location[\"pipeline\"]\n        )\n        stop_logging()\n        return distiset\n\n    def _run_output_queue_loop_in_thread(self, write_buffer: \"_WriteBuffer\") -&gt; None:\n        \"\"\"Runs the output queue loop in a separate thread to receive the output batches\n        from the steps. This is done to avoid the signal handler to block the loop, which\n        would prevent the pipeline from stopping correctly.\n\n        Args:\n            write_buffer: The write buffer to write the data from the leaf steps to disk.\n        \"\"\"\n        thread = threading.Thread(target=self._output_queue_loop, args=(write_buffer,))\n        thread.start()\n        thread.join()\n\n    def _output_queue_loop(self, write_buffer: \"_WriteBuffer\") -&gt; None:\n        \"\"\"Loop to receive the output batches from the steps and manage the flow of the\n        batches through the pipeline.\n\n        Args:\n            write_buffer: The write buffer to write the data from the leaf steps to disk.\n        \"\"\"\n        while self._batch_manager.can_generate() and not _STOP_LOOP:  # type: ignore\n            self._logger.debug(\"Waiting for output batch from step...\")\n            if (batch := self.output_queue.get()) is None:\n                self._logger.debug(\"Received `None` from output queue. Breaking loop.\")\n                break\n\n            if batch.step_name in self.dag.leaf_steps:\n                write_buffer.add_batch(batch)\n\n            # If `_STOP_LOOP` was set to `True` while waiting for the output queue, then\n            # we need to handle the stop of the pipeline and break the loop to avoid\n            # propagating the batches through the pipeline and making the stop process\n            # slower.\n            if _STOP_LOOP:\n                self._handle_batch_on_stop(batch)\n                self._handle_stop(write_buffer)\n                break\n\n            self._logger.debug(\n                f\"Received batch with seq_no {batch.seq_no} from step '{batch.step_name}'\"\n                f\" from output queue: {batch}\"\n            )\n\n            self._manage_batch_flow(batch)\n\n        if _STOP_LOOP:\n            self._handle_stop(write_buffer)\n\n    def _manage_batch_flow(self, batch: \"_Batch\") -&gt; None:\n        \"\"\"Checks if the step that generated the batch has more data in its buffer to\n        generate a new batch. If there's data, then a new batch is sent to the step. If\n        the step has no data in its buffer, then the predecessors generator steps are\n        requested to send a new batch.\n\n        Args:\n            batch: The batch that was processed.\n        \"\"\"\n        assert self._batch_manager, \"Batch manager is not set\"\n\n        self._batch_manager.register_batch(batch)\n        self._logger.debug(\n            f\"Batch {batch.seq_no} from step '{batch.step_name}' registered in batch\"\n            \" manager\"\n        )\n\n        step: \"Step\" = self.dag.get_step(batch.step_name)[\"step\"]\n\n        for successor in self.dag.get_step_successors(step.name):\n            self._batch_manager.add_batch(successor, batch)\n\n            # Check if the step is a generator and if there are successors that need data\n            # from this step. This usually happens when the generator `batch_size` is smaller\n            # than the `input_batch_size` of the successor steps.\n            if (\n                step.is_generator\n                and step.name in self._batch_manager.step_empty_buffers(successor)\n            ):\n                last_batch = self._batch_manager.get_last_batch(step.name)\n                self._send_batch_to_step(last_batch.next_batch())  # type: ignore\n\n            if new_batch := self._batch_manager.get_batch(successor):\n                self._send_batch_to_step(new_batch)\n\n        if step.is_generator:\n            return\n\n        # Step has enough data on its buffers to create a new batch\n        if next_batch := self._batch_manager.get_batch(step.name):\n            self._send_batch_to_step(next_batch)\n            return\n\n        # Request more batches to the predecessors generator steps\n        empty_buffers = self._batch_manager.step_empty_buffers(step.name)\n        for previous_step_name in empty_buffers:\n            if previous_step_name not in self.dag.root_steps:\n                continue\n\n            if last_batch := self._batch_manager.get_last_batch(previous_step_name):\n                self._logger.debug(\n                    f\"Step '{step.name}' input buffer for step '{previous_step_name}' is\"\n                    \" empty. Requesting new batch...\"\n                )\n                self._send_batch_to_step(last_batch.next_batch())\n\n        self._cache()\n\n    def _handle_stop(self, write_buffer: \"_WriteBuffer\") -&gt; None:\n        \"\"\"Handles the stop of the pipeline execution, which will stop the steps from\n        processing more batches and wait for the output queue to be empty, to not lose\n        any data that was already processed by the steps before the stop was called.\n\n        Args:\n            write_buffer: The write buffer to write the data from the leaf steps to disk.\n        \"\"\"\n        self._logger.debug(\"Handling stop of the pipeline execution...\")\n\n        # Send `None` to the input queues of all the steps to notify them to stop\n        # processing batches.\n        for step_name in self.dag:\n            if input_queue := self._wait_step_input_queue_empty(step_name):\n                if self._check_step_not_loaded_or_finished(step_name):\n                    self._logger.debug(\n                        f\"Step '{step_name}' not loaded or already finished. Skipping sending\"\n                        \" sentinel `None`\"\n                    )\n                    continue\n                input_queue.put(None)\n                self._logger.debug(f\"Send `None` to step '{step_name}' input queue.\")\n\n        # Wait for the input queue to be empty, which means that all the steps finished\n        # processing the batches that were sent before the stop flag.\n        for step_name in self.dag:\n            self._wait_step_input_queue_empty(step_name)\n\n        # Consume the output queue until it's empty to not lose any data that was already\n        # processed by the steps before stop was called.\n        while not self.output_queue.empty():\n            batch = self.output_queue.get()\n            if batch.step_name in self.dag.leaf_steps:\n                write_buffer.add_batch(batch)\n            self._handle_batch_on_stop(batch)\n\n        self._cache()\n\n    def _handle_batch_on_stop(self, batch: \"_Batch\") -&gt; None:\n        \"\"\"Handles a batch that was received from the output queue when the pipeline was\n        stopped. It will add and register the batch in the batch manager.\n\n        Args:\n            batch: The batch to handle.\n        \"\"\"\n        self._batch_manager.register_batch(batch)  # type: ignore\n        step: \"Step\" = self.dag.get_step(batch.step_name)[\"step\"]\n        for successor in self.dag.get_step_successors(step.name):\n            self._batch_manager.add_batch(successor, batch)  # type: ignore\n\n    def _wait_step_input_queue_empty(self, step_name: str) -&gt; Union[\"Queue[Any]\", None]:\n        \"\"\"Waits for the input queue of a step to be empty.\n\n        Args:\n            step_name: The name of the step.\n\n        Returns:\n            The input queue of the step if it's not loaded or finished, `None` otherwise.\n        \"\"\"\n        if self._check_step_not_loaded_or_finished(step_name):\n            return None\n\n        if input_queue := self.dag.get_step(step_name).get(\"input_queue\"):\n            while input_queue.qsize() != 0:\n                pass\n            return input_queue\n\n    def _create_shared_info_dict(self, manager: \"SyncManager\") -&gt; \"DictProxy[str, Any]\":\n        \"\"\"Creates the shared information dictionary to be used by the processes.\n\n        Args:\n            manager: The manager to create the shared information.\n\n        Returns:\n            The shared information dictionary.\n        \"\"\"\n        # TODO: not very important, but we could use a different lock for each matter\n        return manager.dict(\n            **{\n                _STEPS_LOADED_KEY: manager.list(),\n                _STEPS_LOADED_LOCK_KEY: manager.Lock(),\n                _CUDA_LLM_DEVICE_PLACEMENT_KEY: manager.dict(**{}),\n                _CUDA_LLM_DEVICE_PLACEMENT_LOCK_KEY: manager.Lock(),\n            }\n        )\n\n    def _all_steps_loaded(self) -&gt; bool:\n        \"\"\"Waits for all the steps to load.\n\n        Returns:\n            `True` if all the steps have been loaded correctly, `False` otherwise.\n        \"\"\"\n\n        def _update_all_steps_loaded(steps_loaded: List[str]) -&gt; None:\n            with _STEPS_LOADED_LOCK:\n                _STEPS_LOADED.update(steps_loaded)\n\n        self._logger.info(\"\u23f3 Waiting for all the steps to load...\")\n        previous_message = None\n        while True:\n            with self.shared_info[_STEPS_LOADED_LOCK_KEY]:\n                steps_loaded = self.shared_info[_STEPS_LOADED_KEY]\n                num_steps_loaded = (\n                    len(steps_loaded)\n                    if steps_loaded != [_STEPS_LOADED_ERROR_CODE]\n                    else 0\n                )\n                self._logger.debug(f\"Steps loaded: {steps_loaded}\")\n\n                message = f\"\u23f3 Steps loaded: {num_steps_loaded}/{len(self.dag)}\"\n                if num_steps_loaded &gt; 0 and message != previous_message:\n                    self._logger.info(message)\n                    previous_message = message\n\n                if num_steps_loaded == len(self.dag):\n                    self._logger.info(\"\u2705 All the steps have been loaded!\")\n                    _update_all_steps_loaded(steps_loaded)\n                    return True\n\n                if steps_loaded == [_STEPS_LOADED_ERROR_CODE]:\n                    self._logger.error(\"\u274c Failed to load all the steps\")\n                    _update_all_steps_loaded(steps_loaded)\n                    return False\n\n            time.sleep(2.5)\n\n    def _request_initial_batches(self) -&gt; None:\n        \"\"\"Requests the initial batches to the generator steps.\"\"\"\n        assert self._batch_manager, \"Batch manager is not set\"\n\n        for step in self._batch_manager._steps.values():\n            if batch := step.get_batch():\n                self._send_batch_to_step(batch)\n\n        for step_name in self.dag.root_steps:\n            seq_no = 0\n            if last_batch := self._batch_manager.get_last_batch(step_name):\n                seq_no = last_batch.seq_no + 1\n            batch = _Batch(seq_no=seq_no, step_name=step_name, last_batch=False)\n            self._send_batch_to_step(batch)\n\n    def _send_batch_to_step(self, batch: \"_Batch\") -&gt; None:\n        \"\"\"Sends a batch to the input queue of a step.\n\n        Args:\n            batch: The batch to send.\n        \"\"\"\n        self._logger.debug(\n            f\"Sending batch {batch.seq_no} to step '{batch.step_name}': {batch}\"\n        )\n        input_queue = self.dag.get_step(batch.step_name)[\"input_queue\"]\n        input_queue.put(batch)\n\n    def _run_steps_in_loop(\n        self,\n        pool: \"Pool\",\n        manager: \"SyncManager\",\n        output_queue: \"Queue[_Batch]\",\n        shared_info: \"DictProxy[str, Any]\",\n    ) -&gt; None:\n        \"\"\"Using the `pool`, runs the steps in the DAG in an infinite loop waiting for\n        input batches and sending the output batches to the `output_queue`.\n\n        Each `Step` is wrapped in a `_ProcessWrapper`, which will handle the lifecycle of\n        the `Step` and the communication with the `input_queue` and `output_queue`. The\n        `_ProcessWrapper.run` method is the target function of the process.\n\n        Args:\n            pool: The pool of processes.\n            manager: The manager to create the queues.\n            output_queue: The queue to send the output batches.\n            shared_info: The shared information between the processes.\n        \"\"\"\n        for step_name in self.dag:\n            step: \"Step\" = self.dag.get_step(step_name)[\"step\"]\n            input_queue = manager.Queue()\n            self.dag.set_step_attr(step.name, \"input_queue\", input_queue)\n\n            # Set `pipeline` to `None` as in some Python environments the pipeline is not\n            # picklable and it will raise an error when trying to send the step to the process.\n            # `TypeError: cannot pickle 'code' object`\n            step.pipeline = None\n\n            process_wrapper = _ProcessWrapper(\n                step=step,\n                input_queue=input_queue,\n                output_queue=output_queue,\n                shared_info=shared_info,\n            )\n\n            pool.apply_async(\n                process_wrapper.run,\n                callback=self._finished_callback,\n                error_callback=self._error_callback,\n            )  # type: ignore\n\n    def _error_callback(self, e: BaseException) -&gt; None:\n        \"\"\"Error callback that will be called when an error occurs in a `Step` process.\n\n        Args:\n            e: The exception raised by the process.\n        \"\"\"\n        # First we check that the exception is a `_ProcessWrapperException`, otherwise, we\n        # print it out and stop the pipeline, since some errors may be unhandled\n        if not isinstance(e, _ProcessWrapperException):\n            self._logger.error(f\"\u274c Failed with an unhandled exception: {e}\")\n            self._stop()\n            return\n\n        if e.is_load_error:\n            self._logger.error(f\"\u274c Failed to load step '{e.step.name}': {e.message}\")\n            with self.shared_info[_STEPS_LOADED_LOCK_KEY]:\n                self.shared_info[_STEPS_LOADED_KEY] = [_STEPS_LOADED_ERROR_CODE]\n            return\n\n        # If the step is global, is not in the last trophic level and has no successors,\n        # then we can ignore the error and continue executing the pipeline\n        if (\n            e.step.is_global\n            and not self.dag.step_in_last_trophic_level(e.step.name)\n            and list(self.dag.get_step_successors(e.step.name)) == []\n        ):\n            self._logger.error(\n                f\"\u270b An error occurred when running global step '{e.step.name}' with no\"\n                \" successors and not in the last trophic level. Pipeline execution can\"\n                f\" continue. Error will be ignored: {e.message}\"\n            )\n            return\n\n        self._logger.error(f\"An error occurred in step '{e.step.name}': {e.message}\")\n        self._cache()\n        self._stop()\n\n    def _finished_callback(self, step_name: str) -&gt; None:\n        \"\"\"Callback that will be called when a `Step` process finishes.\n\n        Args:\n            step_name: The name of the step that finished.\n        \"\"\"\n        with _STEPS_FINISHED_LOCK:\n            _STEPS_FINISHED.add(step_name)\n\n    def _check_step_not_loaded_or_finished(self, step_name: str) -&gt; bool:\n        \"\"\"Checks if a step is not loaded or already finished.\n\n        Args:\n            step_name: The name of the step.\n\n        Returns:\n            `True` if the step is not loaded or already finished, `False` otherwise.\n        \"\"\"\n        with _STEPS_LOADED_LOCK:\n            if step_name not in _STEPS_LOADED:\n                return True\n\n        with _STEPS_FINISHED_LOCK:\n            if step_name in _STEPS_FINISHED:\n                return True\n\n        return False\n\n    def _stop(self) -&gt; None:\n        \"\"\"Stops the pipeline execution. It will first send `None` to the input queues\n        of all the steps and then wait until the output queue is empty i.e. all the steps\n        finished processing the batches that were sent before the stop flag. Then it will\n        send `None` to the output queue to notify the pipeline to stop.\"\"\"\n\n        global _STOP_LOOP, _STOP_CALLED\n\n        _STOP_LOOP = True\n\n        with _STOP_CALLED_LOCK:\n            if _STOP_CALLED:\n                self._logger.warning(\n                    \"\ud83d\uded1 Stop has already been called. Ignoring subsequent calls and waiting\"\n                    \" for the pipeline to finish...\"\n                )\n                return\n            _STOP_CALLED = True\n\n        self._logger.debug(f\"Steps loaded before calling `stop`: {_STEPS_LOADED}\")\n        self._logger.info(\n            \"\ud83d\uded1 Stopping pipeline. Waiting for steps to finish processing batches...\"\n        )\n\n    def _handle_keyboard_interrupt(self) -&gt; None:\n        \"\"\"Handles KeyboardInterrupt signal sent during the Pipeline.run method.\n\n        It will try to call self._stop (if the pipeline didn't started yet, it won't\n        have any effect), and if the pool is already started, will close it before exiting\n        the program.\n        \"\"\"\n\n        def signal_handler(signumber: int, frame: Any) -&gt; None:\n            self._stop()\n\n        signal.signal(signal.SIGINT, signal_handler)\n</code></pre>"},{"location":"reference/distilabel/pipeline/local/#distilabel.pipeline.local.Pipeline.run","title":"<code>run(parameters=None, use_cache=True)</code>","text":"<p>Runs the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Optional[Dict[str, Dict[str, Any]]]</code> <p>A dictionary with the step name as the key and a dictionary with the runtime parameters for the step as the value. Defaults to <code>None</code>.</p> <code>None</code> <code>use_cache</code> <code>bool</code> <p>Whether to use the cache from previous pipeline runs. Defaults to <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>Distiset</code> <p>The <code>Distiset</code> created by the pipeline.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the pipeline fails to load all the steps.</p> Source code in <code>src/distilabel/pipeline/local.py</code> <pre><code>def run(\n    self,\n    parameters: Optional[Dict[str, Dict[str, Any]]] = None,\n    use_cache: bool = True,\n) -&gt; \"Distiset\":\n    \"\"\"Runs the pipeline.\n\n    Args:\n        parameters: A dictionary with the step name as the key and a dictionary with\n            the runtime parameters for the step as the value. Defaults to `None`.\n        use_cache: Whether to use the cache from previous pipeline runs. Defaults to\n            `True`.\n\n    Returns:\n        The `Distiset` created by the pipeline.\n\n    Raises:\n        RuntimeError: If the pipeline fails to load all the steps.\n    \"\"\"\n    try:\n        mp.set_start_method(\"forkserver\")\n    except RuntimeError:\n        pass\n    log_queue = mp.Queue()\n    setup_logging(log_queue)  # type: ignore\n    self._logger = logging.getLogger(\"distilabel.pipeline.local\")\n\n    super().run(parameters, use_cache)\n\n    if self._batch_manager is None:\n        self._batch_manager = _BatchManager.from_dag(self.dag)\n\n    # If the batch manager is not able to generate batches, that means that the loaded\n    # `_BatchManager` from cache didn't have any remaining batches to process i.e.\n    # the previous pipeline execution was completed successfully.\n    if not self._batch_manager.can_generate():\n        self._logger.info(\n            \"\ud83d\udcbe Loaded batch manager from cache doesn't have any remaining data. Returning\"\n            \" `Distiset` from cache data...\"\n        )\n        stop_logging()\n        return create_distiset(\n            self._cache_location[\"data\"],\n            pipeline_path=self._cache_location[\"pipeline\"],\n        )\n\n    buffer_data_path = self._cache_location[\"data\"]\n    self._logger.info(f\"\ud83d\udcdd Pipeline data will be written to '{buffer_data_path}'\")\n    write_buffer = _WriteBuffer(buffer_data_path, self.dag.leaf_steps)\n\n    num_processes = len(self.dag)\n    ctx = mp.get_context(\"forkserver\")  # type: ignore\n    with ctx.Manager() as manager, ctx.Pool(\n        num_processes, initializer=_init_worker, initargs=(log_queue,)\n    ) as pool:\n        self.output_queue: \"Queue[Any]\" = manager.Queue()\n        self.shared_info = self._create_shared_info_dict(manager)\n        self._handle_keyboard_interrupt()\n\n        # Run the steps using the pool of processes\n        self._run_steps_in_loop(pool, manager, self.output_queue, self.shared_info)\n\n        # Wait for all the steps to be loaded correctly\n        if not self._all_steps_loaded():\n            write_buffer.close()\n            self._batch_manager = None\n            stop_logging()\n            raise RuntimeError(\n                \"Failed to load all the steps. Could not run pipeline.\"\n            )\n\n        # Send the \"first\" batches to the steps so the batches starts flowing through\n        # the input queues and output queue\n        self._request_initial_batches()\n\n        # Start a loop to receive the output batches from the steps\n        self._run_output_queue_loop_in_thread(write_buffer)\n\n        pool.close()\n        pool.join()\n\n    write_buffer.close()\n    distiset = create_distiset(\n        self._cache_location[\"data\"], pipeline_path=self._cache_location[\"pipeline\"]\n    )\n    stop_logging()\n    return distiset\n</code></pre>"},{"location":"reference/distilabel/pipeline/utils/","title":"Utils","text":""},{"location":"reference/distilabel/steps/","title":"Index","text":""},{"location":"reference/distilabel/steps/#distilabel.steps.GeneratorStepOutput","title":"<code>GeneratorStepOutput = Iterator[Tuple[List[Dict[str, Any]], bool]]</code>  <code>module-attribute</code>","text":"<p>GeneratorStepOutput is an alias of the typing <code>Iterator[Tuple[List[Dict[str, Any]], bool]]</code></p>"},{"location":"reference/distilabel/steps/#distilabel.steps.StepInput","title":"<code>StepInput = Annotated[List[Dict[str, Any]], _STEP_INPUT_ANNOTATION]</code>  <code>module-attribute</code>","text":"<p>StepInput is just an <code>Annotated</code> alias of the typing <code>List[Dict[str, Any]]</code> with extra metadata that allows <code>distilabel</code> to perform validations over the <code>process</code> step method defined in each <code>Step</code></p>"},{"location":"reference/distilabel/steps/#distilabel.steps.StepOutput","title":"<code>StepOutput = Iterator[List[Dict[str, Any]]]</code>  <code>module-attribute</code>","text":"<p>StepOutput is an alias of the typing <code>Iterator[List[Dict[str, Any]]]</code></p>"},{"location":"reference/distilabel/steps/#distilabel.steps.CombineColumns","title":"<code>CombineColumns</code>","text":"<p>             Bases: <code>Step</code></p> <p>CombineColumns is a Step that implements the <code>process</code> method that calls the <code>combine_dicts</code> function to handle and combine a list of <code>StepInput</code>. Also <code>CombineColumns</code> provides two attributes <code>columns</code> and <code>output_columns</code> to specify the columns to merge and the output columns which will override the default value for the properties <code>inputs</code> and <code>outputs</code>, respectively.</p> <p>Attributes:</p> Name Type Description <code>columns</code> <code>List[str]</code> <p>List of strings with the names of the columns to merge.</p> <code>output_columns</code> <code>Optional[List[str]]</code> <p>Optional list of strings with the names of the output columns.</p> Input columns <ul> <li>dynamic, based on the <code>columns</code> value provided.</li> </ul> Output columns <ul> <li>dynamic, based on the <code>output_columns</code> value provided or <code>merged_{column}</code> for each column in <code>columns</code>.</li> </ul> Source code in <code>src/distilabel/steps/combine.py</code> <pre><code>class CombineColumns(Step):\n    \"\"\"CombineColumns is a Step that implements the `process` method that calls the `combine_dicts`\n    function to handle and combine a list of `StepInput`. Also `CombineColumns` provides two attributes\n    `columns` and `output_columns` to specify the columns to merge and the output columns\n    which will override the default value for the properties `inputs` and `outputs`, respectively.\n\n    Attributes:\n        columns: List of strings with the names of the columns to merge.\n        output_columns: Optional list of strings with the names of the output columns.\n\n    Input columns:\n        - dynamic, based on the `columns` value provided.\n\n    Output columns:\n        - dynamic, based on the `output_columns` value provided or `merged_{column}` for each column in `columns`.\n    \"\"\"\n\n    columns: List[str]\n    output_columns: Optional[List[str]] = None\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The inputs for the task are the column names in `columns`.\"\"\"\n        return self.columns\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The outputs for the task are the column names in `output_columns` or\n        `merged_{column}` for each column in `columns`.\"\"\"\n        return (\n            self.output_columns\n            if self.output_columns is not None\n            else [f\"merged_{column}\" for column in self.columns]\n        )\n\n    @override\n    def process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n        \"\"\"The `process` method calls the `combine_dicts` function to handle and combine a list of `StepInput`.\n\n        Args:\n            *inputs: A list of `StepInput` to be combined.\n\n        Yields:\n            A `StepOutput` with the combined `StepInput` using the `combine_dicts` function.\n        \"\"\"\n        yield combine_dicts(\n            *inputs,\n            merge_keys=self.inputs,\n            output_merge_keys=self.outputs,\n        )\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.CombineColumns.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The inputs for the task are the column names in <code>columns</code>.</p>"},{"location":"reference/distilabel/steps/#distilabel.steps.CombineColumns.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The outputs for the task are the column names in <code>output_columns</code> or <code>merged_{column}</code> for each column in <code>columns</code>.</p>"},{"location":"reference/distilabel/steps/#distilabel.steps.CombineColumns.process","title":"<code>process(*inputs)</code>","text":"<p>The <code>process</code> method calls the <code>combine_dicts</code> function to handle and combine a list of <code>StepInput</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*inputs</code> <code>StepInput</code> <p>A list of <code>StepInput</code> to be combined.</p> <code>()</code> <p>Yields:</p> Type Description <code>StepOutput</code> <p>A <code>StepOutput</code> with the combined <code>StepInput</code> using the <code>combine_dicts</code> function.</p> Source code in <code>src/distilabel/steps/combine.py</code> <pre><code>@override\ndef process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n    \"\"\"The `process` method calls the `combine_dicts` function to handle and combine a list of `StepInput`.\n\n    Args:\n        *inputs: A list of `StepInput` to be combined.\n\n    Yields:\n        A `StepOutput` with the combined `StepInput` using the `combine_dicts` function.\n    \"\"\"\n    yield combine_dicts(\n        *inputs,\n        merge_keys=self.inputs,\n        output_merge_keys=self.outputs,\n    )\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.ConversationTemplate","title":"<code>ConversationTemplate</code>","text":"<p>             Bases: <code>Step</code></p> <p>Generate a conversation template from an instruction and a response.</p> Input columns <ul> <li>instruction (<code>str</code>): The instruction to be used in the conversation.</li> <li>response (<code>str</code>): The response to be used in the conversation.</li> </ul> Output columns <ul> <li>conversation (<code>ChatType</code>): The conversation template.</li> </ul> Source code in <code>src/distilabel/steps/conversation.py</code> <pre><code>class ConversationTemplate(Step):\n    \"\"\"Generate a conversation template from an instruction and a response.\n\n    Input columns:\n        - instruction (`str`): The instruction to be used in the conversation.\n        - response (`str`): The response to be used in the conversation.\n\n    Output columns:\n        - conversation (`ChatType`): The conversation template.\n    \"\"\"\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The instruction and response.\"\"\"\n        return [\"instruction\", \"response\"]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The conversation template.\"\"\"\n        return [\"conversation\"]\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Generate a conversation template from an instruction and a response.\n\n        Args:\n            inputs: The input data.\n\n        Yields:\n            The input data with the conversation template.\n        \"\"\"\n        for input in inputs:\n            input[\"conversation\"] = [\n                {\"role\": \"user\", \"content\": input[\"instruction\"]},\n                {\"role\": \"assistant\", \"content\": input[\"response\"]},\n            ]\n        yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.ConversationTemplate.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The instruction and response.</p>"},{"location":"reference/distilabel/steps/#distilabel.steps.ConversationTemplate.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The conversation template.</p>"},{"location":"reference/distilabel/steps/#distilabel.steps.ConversationTemplate.process","title":"<code>process(inputs)</code>","text":"<p>Generate a conversation template from an instruction and a response.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>The input data.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>The input data with the conversation template.</p> Source code in <code>src/distilabel/steps/conversation.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Generate a conversation template from an instruction and a response.\n\n    Args:\n        inputs: The input data.\n\n    Yields:\n        The input data with the conversation template.\n    \"\"\"\n    for input in inputs:\n        input[\"conversation\"] = [\n            {\"role\": \"user\", \"content\": input[\"instruction\"]},\n            {\"role\": \"assistant\", \"content\": input[\"response\"]},\n        ]\n    yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.DeitaFiltering","title":"<code>DeitaFiltering</code>","text":"<p>             Bases: <code>GlobalStep</code></p> <p>Filter the dataset based on the DEITA score and the cosine distance between the embeddings. It's an implementation of the filtering step from the paper 'What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.</p> <p>Attributes:</p> Name Type Description <code>data_budget</code> <code>RuntimeParameter[int]</code> <p>The desired size of the dataset after filtering.</p> <code>diversity_threshold</code> <code>RuntimeParameter[float]</code> <p>If a row has a cosine distance with respect to it's nearest neighbor greater than this value, it will be included in the filtered dataset. Defaults to <code>0.9</code>.</p> <code>normalize_embeddings</code> <code>RuntimeParameter[bool]</code> <p>Whether to normalize the embeddings before computing the cosine distance. Defaults to <code>True</code>.</p> Runtime parameters <ul> <li><code>data_budget</code>: The desired size of the dataset after filtering.</li> <li><code>diversity_threshold</code>: If a row has a cosine distance with respect to it's nearest     neighbor greater than this value, it will be included in the filtered dataset.</li> </ul> Input columns <ul> <li>evol_instruction_score (<code>float</code>): The score of the instruction generated by     <code>ComplexityScorer</code> step.</li> <li>evol_response_score (<code>float</code>): The score of the response generated by     <code>QualityScorer</code> step.</li> <li>embedding (<code>List[float]</code>): The embedding generated for the conversation of the     instruction-response pair using <code>GenerateEmbeddings</code> step.</li> </ul> Output columns <ul> <li>deita_score (<code>float</code>): The DEITA score for the instruction-response pair.</li> <li>deita_score_computed_with (<code>List[str]</code>): The scores used to compute the DEITA     score.</li> <li>nearest_neighbor_distance (<code>float</code>): The cosine distance between the embeddings     of the instruction-response pair.</li> </ul> References <ul> <li><code>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</code></li> </ul> Source code in <code>src/distilabel/steps/deita.py</code> <pre><code>class DeitaFiltering(GlobalStep):\n    \"\"\"Filter the dataset based on the DEITA score and the cosine distance between the embeddings.\n    It's an implementation of the filtering step from the paper 'What Makes Good Data\n    for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.\n\n    Attributes:\n        data_budget: The desired size of the dataset after filtering.\n        diversity_threshold: If a row has a cosine distance with respect to it's nearest\n            neighbor greater than this value, it will be included in the filtered dataset.\n            Defaults to `0.9`.\n        normalize_embeddings: Whether to normalize the embeddings before computing the cosine\n            distance. Defaults to `True`.\n\n    Runtime parameters:\n        - `data_budget`: The desired size of the dataset after filtering.\n        - `diversity_threshold`: If a row has a cosine distance with respect to it's nearest\n            neighbor greater than this value, it will be included in the filtered dataset.\n\n    Input columns:\n        - evol_instruction_score (`float`): The score of the instruction generated by\n            `ComplexityScorer` step.\n        - evol_response_score (`float`): The score of the response generated by\n            `QualityScorer` step.\n        - embedding (`List[float]`): The embedding generated for the conversation of the\n            instruction-response pair using `GenerateEmbeddings` step.\n\n    Output columns:\n        - deita_score (`float`): The DEITA score for the instruction-response pair.\n        - deita_score_computed_with (`List[str]`): The scores used to compute the DEITA\n            score.\n        - nearest_neighbor_distance (`float`): The cosine distance between the embeddings\n            of the instruction-response pair.\n\n    References:\n        - [`What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning`](https://arxiv.org/abs/2312.15685)\n    \"\"\"\n\n    data_budget: RuntimeParameter[int] = Field(\n        default=None, description=\"The desired size of the dataset after filtering.\"\n    )\n    diversity_threshold: RuntimeParameter[float] = Field(\n        default=0.9,\n        description=\"If a row has a cosine distance with respect to it's nearest neighbor\"\n        \" greater than this value, it will be included in the filtered dataset.\",\n    )\n    normalize_embeddings: RuntimeParameter[bool] = Field(\n        default=True,\n        description=\"Whether to normalize the embeddings before computing the cosine distance.\",\n    )\n    distance_metric: RuntimeParameter[Literal[\"cosine\", \"manhattan\"]] = Field(\n        default=\"cosine\",\n        description=\"The distance metric to use. Currently only 'cosine' is supported.\",\n    )\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        return [\"evol_instruction_score\", \"evol_response_score\", \"embedding\"]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        return [\"deita_score\", \"nearest_neighbor_distance\", \"deita_score_computed_with\"]\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Filter the dataset based on the DEITA score and the cosine distance between the\n        embeddings.\n\n        Args:\n            inputs: The input data.\n\n        Returns:\n            The filtered dataset.\n        \"\"\"\n        inputs = self._compute_deita_score(inputs)\n        inputs = self._compute_nearest_neighbor(inputs)\n        inputs.sort(key=lambda x: x[\"deita_score\"], reverse=True)\n\n        selected_rows = []\n        for input in inputs:\n            if len(selected_rows) &gt;= self.data_budget:  # type: ignore\n                break\n            if input[\"nearest_neighbor_distance\"] &gt;= self.diversity_threshold:\n                selected_rows.append(input)\n        yield selected_rows\n\n    def _compute_deita_score(self, inputs: StepInput) -&gt; StepInput:\n        \"\"\"Computes the DEITA score for each instruction-response pair. The DEITA score is\n        the product of the instruction score and the response score.\n\n        Args:\n            inputs: The input data.\n\n        Returns:\n            The input data with the DEITA score computed.\n        \"\"\"\n        for input_ in inputs:\n            evol_instruction_score = input_.get(\"evol_instruction_score\")\n            evol_response_score = input_.get(\"evol_response_score\")\n\n            if evol_instruction_score and evol_response_score:\n                deita_score = evol_instruction_score * evol_response_score\n                score_computed_with = [\"evol_instruction_score\", \"evol_response_score\"]\n            elif evol_instruction_score:\n                self._logger.warning(\n                    \"Response score is missing for the instruction-response pair. Using\"\n                    \" instruction score as DEITA score.\"\n                )\n                deita_score = evol_instruction_score\n                score_computed_with = [\"evol_instruction_score\"]\n            elif evol_response_score:\n                self._logger.warning(\n                    \"Instruction score is missing for the instruction-response pair. Using\"\n                    \" response score as DEITA score.\"\n                )\n                deita_score = evol_response_score\n                score_computed_with = [\"evol_response_score\"]\n            else:\n                self._logger.warning(\n                    \"Instruction and response scores are missing for the instruction-response\"\n                    \" pair. Setting DEITA score to 0.\"\n                )\n                deita_score = 0\n                score_computed_with = []\n\n            input_.update(\n                {\n                    \"deita_score\": deita_score,\n                    \"deita_score_computed_with\": score_computed_with,\n                }\n            )\n        return inputs\n\n    def _compute_nearest_neighbor(self, inputs: StepInput) -&gt; StepInput:\n        \"\"\"Computes the cosine distance between the embeddings of the instruction-response\n        pairs and the nearest neighbor.\n\n        Args:\n            inputs: The input data.\n\n        Returns:\n            The input data with the cosine distance computed.\n        \"\"\"\n        embeddings = np.array([input[\"embedding\"] for input in inputs])\n        if self.normalize_embeddings:\n            embeddings = self._normalize_embeddings(embeddings)\n        self._logger.info(\"\ud83d\udccf Computing nearest neighbor distance...\")\n\n        if self.distance_metric == \"cosine\":\n            self._logger.info(\"\ud83d\udccf Using cosine distance.\")\n            distances = self._cosine_distance(embeddings)\n        else:\n            self._logger.info(\"\ud83d\udccf Using manhattan distance.\")\n            distances = self._manhattan_distance(embeddings)\n\n        for distance, input in zip(distances, inputs):\n            input[\"nearest_neighbor_distance\"] = distance\n        return inputs\n\n    def _normalize_embeddings(self, embeddings: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Normalize the embeddings.\n\n        Args:\n            embeddings: The embeddings to normalize.\n\n        Returns:\n            The normalized embeddings.\n        \"\"\"\n        self._logger.info(\"\u2696\ufe0f Normalizing embeddings...\")\n        norms = np.linalg.norm(embeddings, axis=1, keepdims=True)\n        return embeddings / norms\n\n    def _cosine_distance(self, embeddings: np.array) -&gt; np.array:  # type: ignore\n        \"\"\"Computes the cosine distance between the embeddings.\n\n        Args:\n            embeddings: The embeddings.\n\n        Returns:\n            The cosine distance between the embeddings.\n        \"\"\"\n        cosine_similarity = np.dot(embeddings, embeddings.T)\n        cosine_distance = 1 - cosine_similarity\n        # Ignore self-distance\n        np.fill_diagonal(cosine_distance, np.inf)\n        return np.min(cosine_distance, axis=1)\n\n    def _manhattan_distance(self, embeddings: np.array) -&gt; np.array:  # type: ignore\n        \"\"\"Computes the manhattan distance between the embeddings.\n\n        Args:\n            embeddings: The embeddings.\n\n        Returns:\n            The manhattan distance between the embeddings.\n        \"\"\"\n        manhattan_distance = np.abs(embeddings[:, None] - embeddings).sum(-1)\n        # Ignore self-distance\n        np.fill_diagonal(manhattan_distance, np.inf)\n        return np.min(manhattan_distance, axis=1)\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.DeitaFiltering.process","title":"<code>process(inputs)</code>","text":"<p>Filter the dataset based on the DEITA score and the cosine distance between the embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>The input data.</p> required <p>Returns:</p> Type Description <code>StepOutput</code> <p>The filtered dataset.</p> Source code in <code>src/distilabel/steps/deita.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Filter the dataset based on the DEITA score and the cosine distance between the\n    embeddings.\n\n    Args:\n        inputs: The input data.\n\n    Returns:\n        The filtered dataset.\n    \"\"\"\n    inputs = self._compute_deita_score(inputs)\n    inputs = self._compute_nearest_neighbor(inputs)\n    inputs.sort(key=lambda x: x[\"deita_score\"], reverse=True)\n\n    selected_rows = []\n    for input in inputs:\n        if len(selected_rows) &gt;= self.data_budget:  # type: ignore\n            break\n        if input[\"nearest_neighbor_distance\"] &gt;= self.diversity_threshold:\n            selected_rows.append(input)\n    yield selected_rows\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.ExpandColumns","title":"<code>ExpandColumns</code>","text":"<p>             Bases: <code>Step</code></p> <p>Expand columns that contain lists into multiple rows.</p> <p>Attributes:</p> Name Type Description <code>columns</code> <code>Union[Dict[str, str], List[str]]</code> <p>A dictionary that maps the column to be expanded to the new column name or a list of columns to be expanded. If a list is provided, the new column name will be the same as the column name.</p> Input columns <ul> <li>The columns to be expanded.</li> </ul> Output columns <ul> <li>The expanded columns.</li> </ul> Source code in <code>src/distilabel/steps/expand.py</code> <pre><code>class ExpandColumns(Step):\n    \"\"\"Expand columns that contain lists into multiple rows.\n\n    Attributes:\n        columns: A dictionary that maps the column to be expanded to the new column name\n            or a list of columns to be expanded. If a list is provided, the new column name\n            will be the same as the column name.\n\n    Input columns:\n        - The columns to be expanded.\n\n    Output columns:\n        - The expanded columns.\n    \"\"\"\n\n    columns: Union[Dict[str, str], List[str]]\n\n    @field_validator(\"columns\")\n    @classmethod\n    def always_dict(cls, value: Union[Dict[str, str], List[str]]) -&gt; Dict[str, str]:\n        \"\"\"Ensure that the columns are always a dictionary.\n\n        Args:\n            value: The columns to be expanded.\n\n        Returns:\n            The columns to be expanded as a dictionary.\n        \"\"\"\n        if isinstance(value, list):\n            return {col: col for col in value}\n\n        return value\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The columns to be expanded.\"\"\"\n        return list(self.columns.keys())\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The expanded columns.\"\"\"\n        return [\n            new_column if new_column else expand_column\n            for expand_column, new_column in self.columns.items()\n        ]\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Expand the columns in the input data.\n\n        Args:\n            inputs: The input data.\n\n        Yields:\n            The expanded rows.\n        \"\"\"\n        yield [row for input in inputs for row in self._expand_columns(input)]\n\n    def _expand_columns(self, input: Dict[str, Any]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Expand the columns in the input data.\n\n        Args:\n            input: The input data.\n\n        Returns:\n            The expanded rows.\n        \"\"\"\n        expanded_rows = []\n        for expand_column, new_column in self.columns.items():  # type: ignore\n            data = input.get(expand_column)\n            rows = []\n            for item, expanded in zip_longest(*[data, expanded_rows], fillvalue=input):\n                rows.append({**expanded, new_column: item})\n            expanded_rows = rows\n        return expanded_rows\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.ExpandColumns.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The columns to be expanded.</p>"},{"location":"reference/distilabel/steps/#distilabel.steps.ExpandColumns.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The expanded columns.</p>"},{"location":"reference/distilabel/steps/#distilabel.steps.ExpandColumns.always_dict","title":"<code>always_dict(value)</code>  <code>classmethod</code>","text":"<p>Ensure that the columns are always a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[Dict[str, str], List[str]]</code> <p>The columns to be expanded.</p> required <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>The columns to be expanded as a dictionary.</p> Source code in <code>src/distilabel/steps/expand.py</code> <pre><code>@field_validator(\"columns\")\n@classmethod\ndef always_dict(cls, value: Union[Dict[str, str], List[str]]) -&gt; Dict[str, str]:\n    \"\"\"Ensure that the columns are always a dictionary.\n\n    Args:\n        value: The columns to be expanded.\n\n    Returns:\n        The columns to be expanded as a dictionary.\n    \"\"\"\n    if isinstance(value, list):\n        return {col: col for col in value}\n\n    return value\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.ExpandColumns.process","title":"<code>process(inputs)</code>","text":"<p>Expand the columns in the input data.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>The input data.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>The expanded rows.</p> Source code in <code>src/distilabel/steps/expand.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Expand the columns in the input data.\n\n    Args:\n        inputs: The input data.\n\n    Yields:\n        The expanded rows.\n    \"\"\"\n    yield [row for input in inputs for row in self._expand_columns(input)]\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.GeneratorStep","title":"<code>GeneratorStep</code>","text":"<p>             Bases: <code>_Step</code>, <code>ABC</code></p> <p>A special kind of <code>Step</code> that is able to generate data i.e. it doesn't receive any input from the previous steps.</p> <p>Attributes:</p> Name Type Description <code>batch_size</code> <code>RuntimeParameter[int]</code> <p>The number of rows that will contain the batches generated by the step. Defaults to <code>50</code>.</p> Runtime parameters <ul> <li><code>batch_size</code>: The number of rows that will contain the batches generated by     the step. Defaults to <code>50</code>.</li> </ul> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>class GeneratorStep(_Step, ABC):\n    \"\"\"A special kind of `Step` that is able to generate data i.e. it doesn't receive\n    any input from the previous steps.\n\n    Attributes:\n        batch_size: The number of rows that will contain the batches generated by the\n            step. Defaults to `50`.\n\n    Runtime parameters:\n        - `batch_size`: The number of rows that will contain the batches generated by\n            the step. Defaults to `50`.\n    \"\"\"\n\n    batch_size: RuntimeParameter[int] = Field(\n        default=50,\n        description=\"The number of rows that will contain the batches generated by the\"\n        \" step.\",\n    )\n\n    @abstractmethod\n    def process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":\n        \"\"\"Method that defines the generation logic of the step. It should yield the\n        output rows and a boolean indicating if it's the last batch or not.\n\n        Args:\n            offset: The offset to start the generation from. Defaults to 0.\n\n        Yields:\n            The output rows and a boolean indicating if it's the last batch or not.\n        \"\"\"\n        pass\n\n    def process_applying_mappings(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":\n        \"\"\"Runs the `process` method of the step applying the `outputs_mappings` to the\n        output rows. This is the function that should be used to run the generation logic\n        of the step.\n\n        Args:\n            offset: The offset to start the generation from. Defaults to 0.\n\n        Yields:\n            The output rows and a boolean indicating if it's the last batch or not.\n        \"\"\"\n\n        # If the `Step` was built using the `@step` decorator, then we need to pass\n        # the runtime parameters as `kwargs`, so they can be used within the processing\n        # function\n        generator = (\n            self.process(offset=offset)\n            if not self._built_from_decorator\n            else self.process(offset=offset, **self._runtime_parameters)\n        )\n\n        for output_rows, last_batch in generator:\n            yield (\n                [\n                    {self.output_mappings.get(k, k): v for k, v in row.items()}\n                    for row in output_rows\n                ],\n                last_batch,\n            )\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.GeneratorStep.process","title":"<code>process(offset=0)</code>  <code>abstractmethod</code>","text":"<p>Method that defines the generation logic of the step. It should yield the output rows and a boolean indicating if it's the last batch or not.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The offset to start the generation from. Defaults to 0.</p> <code>0</code> <p>Yields:</p> Type Description <code>GeneratorStepOutput</code> <p>The output rows and a boolean indicating if it's the last batch or not.</p> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>@abstractmethod\ndef process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":\n    \"\"\"Method that defines the generation logic of the step. It should yield the\n    output rows and a boolean indicating if it's the last batch or not.\n\n    Args:\n        offset: The offset to start the generation from. Defaults to 0.\n\n    Yields:\n        The output rows and a boolean indicating if it's the last batch or not.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.GeneratorStep.process_applying_mappings","title":"<code>process_applying_mappings(offset=0)</code>","text":"<p>Runs the <code>process</code> method of the step applying the <code>outputs_mappings</code> to the output rows. This is the function that should be used to run the generation logic of the step.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The offset to start the generation from. Defaults to 0.</p> <code>0</code> <p>Yields:</p> Type Description <code>GeneratorStepOutput</code> <p>The output rows and a boolean indicating if it's the last batch or not.</p> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>def process_applying_mappings(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":\n    \"\"\"Runs the `process` method of the step applying the `outputs_mappings` to the\n    output rows. This is the function that should be used to run the generation logic\n    of the step.\n\n    Args:\n        offset: The offset to start the generation from. Defaults to 0.\n\n    Yields:\n        The output rows and a boolean indicating if it's the last batch or not.\n    \"\"\"\n\n    # If the `Step` was built using the `@step` decorator, then we need to pass\n    # the runtime parameters as `kwargs`, so they can be used within the processing\n    # function\n    generator = (\n        self.process(offset=offset)\n        if not self._built_from_decorator\n        else self.process(offset=offset, **self._runtime_parameters)\n    )\n\n    for output_rows, last_batch in generator:\n        yield (\n            [\n                {self.output_mappings.get(k, k): v for k, v in row.items()}\n                for row in output_rows\n            ],\n            last_batch,\n        )\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.GlobalStep","title":"<code>GlobalStep</code>","text":"<p>             Bases: <code>Step</code>, <code>ABC</code></p> <p>A special kind of <code>Step</code> which it's <code>process</code> method receives all the data processed by their previous steps at once, instead of receiving it in batches. This kind of steps are useful when the processing logic requires to have all the data at once, for example to train a model, to perform a global aggregation, etc.</p> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>class GlobalStep(Step, ABC):\n    \"\"\"A special kind of `Step` which it's `process` method receives all the data processed\n    by their previous steps at once, instead of receiving it in batches. This kind of steps\n    are useful when the processing logic requires to have all the data at once, for example\n    to train a model, to perform a global aggregation, etc.\n    \"\"\"\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        return []\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        return []\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.KeepColumns","title":"<code>KeepColumns</code>","text":"<p>             Bases: <code>Step</code></p> <p>KeepColumns is a Step that implements the <code>process</code> method that keeps only the columns specified in the <code>columns</code> attribute. Also <code>KeepColumns</code> provides an attribute <code>columns</code> to specify the columns to keep which will override the default value for the properties <code>inputs</code> and <code>outputs</code>.</p> Note <p>The order in which the columns are provided is important, as the output will be sorted using the provided order, which is useful before pushing either a <code>dataset.Dataset</code> via the <code>PushToHub</code> step or a <code>distilabel.Distiset</code> via the <code>Pipeline.run</code> output variable.</p> <p>Attributes:</p> Name Type Description <code>columns</code> <code>List[str]</code> <p>List of strings with the names of the columns to keep.</p> Input columns <ul> <li>dynamic, based on the <code>columns</code> value provided.</li> </ul> Output columns <ul> <li>dynamic, based on the <code>columns</code> value provided.</li> </ul> Source code in <code>src/distilabel/steps/keep.py</code> <pre><code>class KeepColumns(Step):\n    \"\"\"KeepColumns is a Step that implements the `process` method that keeps only the columns\n    specified in the `columns` attribute. Also `KeepColumns` provides an attribute `columns` to\n    specify the columns to keep which will override the default value for the properties `inputs`\n    and `outputs`.\n\n    Note:\n        The order in which the columns are provided is important, as the output will be sorted\n        using the provided order, which is useful before pushing either a `dataset.Dataset` via\n        the `PushToHub` step or a `distilabel.Distiset` via the `Pipeline.run` output variable.\n\n    Attributes:\n        columns: List of strings with the names of the columns to keep.\n\n    Input columns:\n        - dynamic, based on the `columns` value provided.\n\n    Output columns:\n        - dynamic, based on the `columns` value provided.\n    \"\"\"\n\n    columns: List[str]\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The inputs for the task are the column names in `columns`.\"\"\"\n        return self.columns\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The outputs for the task are the column names in `columns`.\"\"\"\n        return self.columns\n\n    @override\n    def process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n        \"\"\"The `process` method keeps only the columns specified in the `columns` attribute.\n\n        Args:\n            *inputs: A list of dictionaries with the input data.\n\n        Yields:\n            A list of dictionaries with the output data.\n        \"\"\"\n        for input in inputs:\n            outputs = []\n            for item in input:\n                outputs.append({col: item[col] for col in self.columns})\n            yield outputs\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.KeepColumns.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The inputs for the task are the column names in <code>columns</code>.</p>"},{"location":"reference/distilabel/steps/#distilabel.steps.KeepColumns.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The outputs for the task are the column names in <code>columns</code>.</p>"},{"location":"reference/distilabel/steps/#distilabel.steps.KeepColumns.process","title":"<code>process(*inputs)</code>","text":"<p>The <code>process</code> method keeps only the columns specified in the <code>columns</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>*inputs</code> <code>StepInput</code> <p>A list of dictionaries with the input data.</p> <code>()</code> <p>Yields:</p> Type Description <code>StepOutput</code> <p>A list of dictionaries with the output data.</p> Source code in <code>src/distilabel/steps/keep.py</code> <pre><code>@override\ndef process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n    \"\"\"The `process` method keeps only the columns specified in the `columns` attribute.\n\n    Args:\n        *inputs: A list of dictionaries with the input data.\n\n    Yields:\n        A list of dictionaries with the output data.\n    \"\"\"\n    for input in inputs:\n        outputs = []\n        for item in input:\n            outputs.append({col: item[col] for col in self.columns})\n        yield outputs\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.LoadDataFromDicts","title":"<code>LoadDataFromDicts</code>","text":"<p>             Bases: <code>GeneratorStep</code></p> <p>A generator step that loads a dataset from a list of dictionaries.</p> <p>This step will load the dataset and yield the transformed data as it is loaded from the list of dictionaries.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>List[Dict[str, Any]]</code> <p>The list of dictionaries to load the data from.</p> Runtime parameters <ul> <li><code>batch_size</code>: The batch size to use when processing the data.</li> </ul> Output columns <p>Dynamic, based on the keys found on the first dictionary of the list</p> Source code in <code>src/distilabel/steps/generators/data.py</code> <pre><code>class LoadDataFromDicts(GeneratorStep):\n    \"\"\"A generator step that loads a dataset from a list of dictionaries.\n\n    This step will load the dataset and yield the transformed data as it is loaded from the list of dictionaries.\n\n    Attributes:\n        data: The list of dictionaries to load the data from.\n\n    Runtime parameters:\n        - `batch_size`: The batch size to use when processing the data.\n\n    Output columns:\n        Dynamic, based on the keys found on the first dictionary of the list\n    \"\"\"\n\n    data: List[Dict[str, Any]]\n\n    @override\n    def process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":  # type: ignore\n        \"\"\"Yields batches from a list of dictionaries.\n\n        Args:\n            offset: The offset to start the generation from. Defaults to `0`.\n\n        Yields:\n            A list of Python dictionaries as read from the inputs (propagated in batches)\n            and a flag indicating whether the yield batch is the last one.\n        \"\"\"\n        if offset:\n            self.data = self.data[offset:]\n\n        while self.data:\n            batch = self.data[: self.batch_size]\n            self.data = self.data[self.batch_size :]\n            yield (\n                batch,\n                True if len(self.data) == 0 else False,\n            )\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"Returns a list of strings with the names of the columns that the step will generate.\"\"\"\n        return list(self.data[0].keys())\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.LoadDataFromDicts.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>Returns a list of strings with the names of the columns that the step will generate.</p>"},{"location":"reference/distilabel/steps/#distilabel.steps.LoadDataFromDicts.process","title":"<code>process(offset=0)</code>","text":"<p>Yields batches from a list of dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The offset to start the generation from. Defaults to <code>0</code>.</p> <code>0</code> <p>Yields:</p> Type Description <code>GeneratorStepOutput</code> <p>A list of Python dictionaries as read from the inputs (propagated in batches)</p> <code>GeneratorStepOutput</code> <p>and a flag indicating whether the yield batch is the last one.</p> Source code in <code>src/distilabel/steps/generators/data.py</code> <pre><code>@override\ndef process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":  # type: ignore\n    \"\"\"Yields batches from a list of dictionaries.\n\n    Args:\n        offset: The offset to start the generation from. Defaults to `0`.\n\n    Yields:\n        A list of Python dictionaries as read from the inputs (propagated in batches)\n        and a flag indicating whether the yield batch is the last one.\n    \"\"\"\n    if offset:\n        self.data = self.data[offset:]\n\n    while self.data:\n        batch = self.data[: self.batch_size]\n        self.data = self.data[self.batch_size :]\n        yield (\n            batch,\n            True if len(self.data) == 0 else False,\n        )\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.LoadHubDataset","title":"<code>LoadHubDataset</code>","text":"<p>             Bases: <code>GeneratorStep</code></p> <p>A generator step that loads a dataset from the Hugging Face Hub using the <code>datasets</code> library.</p> <p>This step will load the dataset in streaming mode, which means that it will not load the entire dataset into memory at once. Instead, it will load the dataset in chunks and yield the transformed data as it is loaded from the Hugging Face Hub.</p> <p>Attributes:</p> Name Type Description <code>repo_id</code> <code>RuntimeParameter[str]</code> <p>The Hugging Face Hub repository ID of the dataset to load.</p> <code>split</code> <code>RuntimeParameter[str]</code> <p>The split of the dataset to load.</p> <code>config</code> <code>Optional[RuntimeParameter[str]]</code> <p>The configuration of the dataset to load. This is optional and only needed if the dataset has multiple configurations.</p> Runtime parameters <ul> <li><code>batch_size</code>: The batch size to use when processing the data.</li> <li><code>repo_id</code>: The Hugging Face Hub repository ID of the dataset to load.</li> <li><code>split</code>: The split of the dataset to load. Defaults to 'train'.</li> <li><code>config</code>: The configuration of the dataset to load. This is optional and only     needed if the dataset has multiple configurations.</li> </ul> <p>Output columns     - dynamic, based on the dataset being loaded</p> Source code in <code>src/distilabel/steps/generators/huggingface.py</code> <pre><code>class LoadHubDataset(GeneratorStep):\n    \"\"\"A generator step that loads a dataset from the Hugging Face Hub using the `datasets`\n    library.\n\n    This step will load the dataset in streaming mode, which means that it will not load the\n    entire dataset into memory at once. Instead, it will load the dataset in chunks and yield\n    the transformed data as it is loaded from the Hugging Face Hub.\n\n    Attributes:\n        repo_id: The Hugging Face Hub repository ID of the dataset to load.\n        split: The split of the dataset to load.\n        config: The configuration of the dataset to load. This is optional and only needed\n            if the dataset has multiple configurations.\n\n    Runtime parameters:\n        - `batch_size`: The batch size to use when processing the data.\n        - `repo_id`: The Hugging Face Hub repository ID of the dataset to load.\n        - `split`: The split of the dataset to load. Defaults to 'train'.\n        - `config`: The configuration of the dataset to load. This is optional and only\n            needed if the dataset has multiple configurations.\n\n    Output columns\n        - dynamic, based on the dataset being loaded\n    \"\"\"\n\n    repo_id: RuntimeParameter[str] = Field(\n        default=None,\n        description=\"The Hugging Face Hub repository ID of the dataset to load.\",\n    )\n    split: RuntimeParameter[str] = Field(\n        default=\"train\",\n        description=\"The split of the dataset to load. Defaults to 'train'.\",\n    )\n    config: Optional[RuntimeParameter[str]] = Field(\n        default=None,\n        description=\"The configuration of the dataset to load. This is optional and only\"\n        \" needed if the dataset has multiple configurations.\",\n    )\n\n    _dataset: Union[IterableDataset, None] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Load the dataset from the Hugging Face Hub\"\"\"\n        super().load()\n\n        self._dataset = load_dataset(\n            self.repo_id,  # type: ignore\n            self.config,\n            split=self.split,\n            streaming=True,\n        )\n\n    def process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":\n        \"\"\"Yields batches from the loaded dataset from the Hugging Face Hub.\n\n        Args:\n            offset: The offset to start yielding the data from. Will be used during the caching\n                process to help skipping already processed data.\n\n        Yields:\n            A tuple containing a batch of rows and a boolean indicating if the batch is\n            the last one.\n        \"\"\"\n        num_examples = self._get_dataset_num_examples()\n        num_returned_rows = 0\n        for batch_num, batch in enumerate(\n            self._dataset.iter(batch_size=self.batch_size)  # type: ignore\n        ):\n            if batch_num * self.batch_size &lt; offset:\n                continue\n            transformed_batch = self._transform_batch(batch)\n            batch_size = len(transformed_batch)\n            num_returned_rows += batch_size\n            yield transformed_batch, num_returned_rows == num_examples\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The columns that will be generated by this step, based on the datasets loaded\n        from the Hugging Face Hub.\n\n        Returns:\n            The columns that will be generated by this step.\n        \"\"\"\n        return self._get_dataset_columns()\n\n    def _transform_batch(self, batch: Dict[str, Any]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Transform a batch of data from the Hugging Face Hub into a list of rows.\n\n        Args:\n            batch: The batch of data from the Hugging Face Hub.\n\n        Returns:\n            A list of rows, where each row is a dictionary of column names and values.\n        \"\"\"\n        length = len(next(iter(batch.values())))\n        rows = []\n        for i in range(length):\n            rows.append({col: values[i] for col, values in batch.items()})\n        return rows\n\n    def _get_dataset_num_examples(self) -&gt; int:\n        \"\"\"Get the number of examples in the dataset, based on the `split` and `config`\n        runtime parameters provided.\n\n        Returns:\n            The number of examples in the dataset.\n        \"\"\"\n        dataset_info = self._get_dataset_info()\n        split = self.split\n        if self.config:\n            return dataset_info[\"splits\"][split][\"num_examples\"]\n        return dataset_info[\"default\"][\"splits\"][split][\"num_examples\"]\n\n    def _get_dataset_columns(self) -&gt; List[str]:\n        \"\"\"Get the columns of the dataset, based on the `config` runtime parameter provided.\n\n        Returns:\n            The columns of the dataset.\n        \"\"\"\n        dataset_info = self._get_dataset_info()\n        if self.config:\n            return list(dataset_info[\"features\"].keys())\n        return list(dataset_info[\"default\"][\"features\"].keys())\n\n    def _get_dataset_info(self) -&gt; Dict[str, Any]:\n        \"\"\"Calls the Datasets Server API from Hugging Face to obtain the dataset information.\n\n        Returns:\n            The dataset information.\n        \"\"\"\n        repo_id = self.repo_id\n        config = self.config\n        return _get_hf_dataset_info(repo_id, config)\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.LoadHubDataset.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The columns that will be generated by this step, based on the datasets loaded from the Hugging Face Hub.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The columns that will be generated by this step.</p>"},{"location":"reference/distilabel/steps/#distilabel.steps.LoadHubDataset.load","title":"<code>load()</code>","text":"<p>Load the dataset from the Hugging Face Hub</p> Source code in <code>src/distilabel/steps/generators/huggingface.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Load the dataset from the Hugging Face Hub\"\"\"\n    super().load()\n\n    self._dataset = load_dataset(\n        self.repo_id,  # type: ignore\n        self.config,\n        split=self.split,\n        streaming=True,\n    )\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.LoadHubDataset.process","title":"<code>process(offset=0)</code>","text":"<p>Yields batches from the loaded dataset from the Hugging Face Hub.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The offset to start yielding the data from. Will be used during the caching process to help skipping already processed data.</p> <code>0</code> <p>Yields:</p> Type Description <code>GeneratorStepOutput</code> <p>A tuple containing a batch of rows and a boolean indicating if the batch is</p> <code>GeneratorStepOutput</code> <p>the last one.</p> Source code in <code>src/distilabel/steps/generators/huggingface.py</code> <pre><code>def process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":\n    \"\"\"Yields batches from the loaded dataset from the Hugging Face Hub.\n\n    Args:\n        offset: The offset to start yielding the data from. Will be used during the caching\n            process to help skipping already processed data.\n\n    Yields:\n        A tuple containing a batch of rows and a boolean indicating if the batch is\n        the last one.\n    \"\"\"\n    num_examples = self._get_dataset_num_examples()\n    num_returned_rows = 0\n    for batch_num, batch in enumerate(\n        self._dataset.iter(batch_size=self.batch_size)  # type: ignore\n    ):\n        if batch_num * self.batch_size &lt; offset:\n            continue\n        transformed_batch = self._transform_batch(batch)\n        batch_size = len(transformed_batch)\n        num_returned_rows += batch_size\n        yield transformed_batch, num_returned_rows == num_examples\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.PreferenceToArgilla","title":"<code>PreferenceToArgilla</code>","text":"<p>             Bases: <code>Argilla</code></p> <p>Step that creates a dataset in Argilla during the load phase, and then pushes the input batches into it as records. This dataset is a preference dataset, where there's one field for the instruction and one extra field per each generation within the same record, and then a rating question per each of the generation fields. The rating question asks the annotator to set a rating from 1 to 5 for each of the provided generations.</p> Note <p>This step is meant to be used in conjunction with the <code>UltraFeedback</code> step, or any other step generating both ratings and responses for a given set of instruction and generations for the given instruction. But alternatively, it can also be used with any other task or step generating only the <code>instruction</code> and <code>generations</code>, as the <code>ratings</code> and <code>rationales</code> are optional.</p> <p>Attributes:</p> Name Type Description <code>num_generations</code> <code>int</code> <p>The number of generations to include in the dataset.</p> <code>dataset_name</code> <code>int</code> <p>The name of the dataset in Argilla.</p> <code>dataset_workspace</code> <code>int</code> <p>The workspace where the dataset will be created in Argilla. Defaults to <code>None</code>, which means it will be created in the default workspace.</p> <code>api_url</code> <code>int</code> <p>The URL of the Argilla API. Defaults to <code>None</code>, which means it will be read from the <code>ARGILLA_API_URL</code> environment variable.</p> <code>api_key</code> <code>int</code> <p>The API key to authenticate with Argilla. Defaults to <code>None</code>, which means it will be read from the <code>ARGILLA_API_KEY</code> environment variable.</p> Runtime parameters <ul> <li><code>api_url</code>: The base URL to use for the Argilla API requests.</li> <li><code>api_key</code>: The API key to authenticate the requests to the Argilla API.</li> </ul> Input columns <ul> <li>instruction (<code>str</code>): The instruction that was used to generate the completion.</li> <li>generations (<code>List[str]</code>): The completion that was generated based on the input instruction.</li> <li>ratings (<code>List[str]</code>, optional): The ratings for the generations. If not provided, the     generated ratings won't be pushed to Argilla.</li> <li>rationales (<code>List[str]</code>, optional): The rationales for the ratings. If not provided, the     generated rationales won't be pushed to Argilla.</li> </ul> Source code in <code>src/distilabel/steps/argilla/preference.py</code> <pre><code>class PreferenceToArgilla(Argilla):\n    \"\"\"Step that creates a dataset in Argilla during the load phase, and then pushes the input\n    batches into it as records. This dataset is a preference dataset, where there's one field\n    for the instruction and one extra field per each generation within the same record, and then\n    a rating question per each of the generation fields. The rating question asks the annotator to\n    set a rating from 1 to 5 for each of the provided generations.\n\n    Note:\n        This step is meant to be used in conjunction with the `UltraFeedback` step, or any other step\n        generating both ratings and responses for a given set of instruction and generations for the\n        given instruction. But alternatively, it can also be used with any other task or step generating\n        only the `instruction` and `generations`, as the `ratings` and `rationales` are optional.\n\n    Attributes:\n        num_generations: The number of generations to include in the dataset.\n        dataset_name: The name of the dataset in Argilla.\n        dataset_workspace: The workspace where the dataset will be created in Argilla. Defaults to\n            `None`, which means it will be created in the default workspace.\n        api_url: The URL of the Argilla API. Defaults to `None`, which means it will be read from\n            the `ARGILLA_API_URL` environment variable.\n        api_key: The API key to authenticate with Argilla. Defaults to `None`, which means it will\n            be read from the `ARGILLA_API_KEY` environment variable.\n\n    Runtime parameters:\n        - `api_url`: The base URL to use for the Argilla API requests.\n        - `api_key`: The API key to authenticate the requests to the Argilla API.\n\n    Input columns:\n        - instruction (`str`): The instruction that was used to generate the completion.\n        - generations (`List[str]`): The completion that was generated based on the input instruction.\n        - ratings (`List[str]`, optional): The ratings for the generations. If not provided, the\n            generated ratings won't be pushed to Argilla.\n        - rationales (`List[str]`, optional): The rationales for the ratings. If not provided, the\n            generated rationales won't be pushed to Argilla.\n    \"\"\"\n\n    num_generations: int\n\n    _id: str = PrivateAttr(default=\"id\")\n    _instruction: str = PrivateAttr(...)\n    _generations: str = PrivateAttr(...)\n    _ratings: str = PrivateAttr(...)\n    _rationales: str = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Sets the `_instruction` and `_generations` attributes based on the `inputs_mapping`, otherwise\n        uses the default values; and then uses those values to create a `FeedbackDataset` suited for\n        the text-generation scenario. And then it pushes it to Argilla.\n        \"\"\"\n        super().load()\n\n        self._rg_init()\n\n        # Both `instruction` and `generations` will be used as the fields of the dataset\n        self._instruction = self.input_mappings.get(\"instruction\", \"instruction\")\n        self._generations = self.input_mappings.get(\"generations\", \"generations\")\n        # Both `ratings` and `rationales` will be used as suggestions to the default questions of the dataset\n        self._ratings = self.input_mappings.get(\"ratings\", \"ratings\")\n        self._rationales = self.input_mappings.get(\"rationales\", \"rationales\")\n\n        if self._rg_dataset_exists():\n            _rg_dataset = rg.FeedbackDataset.from_argilla(  # type: ignore\n                name=self.dataset_name,\n                workspace=self.dataset_workspace,\n            )\n\n            for field in _rg_dataset.fields:\n                if (\n                    field.name\n                    not in [self._id, self._instruction]\n                    + [\n                        f\"{self._generations}-{idx}\"\n                        for idx in range(self.num_generations)\n                    ]\n                    and field.required\n                ):\n                    raise ValueError(\n                        f\"The dataset {self.dataset_name} in the workspace {self.dataset_workspace} already exists,\"\n                        f\" but contains at least a required field that is neither `{self._id}`, `{self._instruction}`,\"\n                        f\" nor `{self._generations}`.\"\n                    )\n\n            self._rg_dataset = _rg_dataset\n        else:\n            _rg_dataset = rg.FeedbackDataset(  # type: ignore\n                fields=[\n                    rg.TextField(name=self._id, title=self._id),  # type: ignore\n                    rg.TextField(name=self._instruction, title=self._instruction),  # type: ignore\n                    *self._generation_fields(),  # type: ignore\n                ],\n                questions=self._rating_rationale_pairs(),  # type: ignore\n            )\n            self._rg_dataset = _rg_dataset.push_to_argilla(\n                name=self.dataset_name, workspace=self.dataset_workspace\n            )\n\n    def _generation_fields(self) -&gt; List[\"TextField\"]:\n        \"\"\"Method to generate the fields for each of the generations.\"\"\"\n        return [\n            rg.TextField(  # type: ignore\n                name=f\"{self._generations}-{idx}\",\n                title=f\"{self._generations}-{idx}\",\n                required=True if idx == 0 else False,\n            )\n            for idx in range(self.num_generations)\n        ]\n\n    def _rating_rationale_pairs(\n        self,\n    ) -&gt; List[Union[\"RatingQuestion\", \"TextQuestion\"]]:\n        \"\"\"Method to generate the rating and rationale questions for each of the generations.\"\"\"\n        questions = []\n        for idx in range(self.num_generations):\n            questions.extend(\n                [\n                    rg.RatingQuestion(  # type: ignore\n                        name=f\"{self._generations}-{idx}-rating\",\n                        title=f\"Rate {self._generations}-{idx} given {self._instruction} based on the annotation guidelines.\",\n                        description=f\"Ignore this question if the corresponding `{self._generations}-{idx}` field is not available.\"\n                        if idx != 0\n                        else None,\n                        values=[1, 2, 3, 4, 5],\n                        required=True if idx == 0 else False,\n                    ),\n                    rg.TextQuestion(  # type: ignore\n                        name=f\"{self._generations}-{idx}-rationale\",\n                        title=f\"Specify the rationale for {self._generations}-{idx}'s rating.\",\n                        description=f\"Ignore this question if the corresponding `{self._generations}-{idx}` field is not available.\"\n                        if idx != 0\n                        else None,\n                        required=False,\n                    ),\n                ]\n            )\n        return questions\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The inputs for the step are the `instruction` and the `generations`. Optionally, one could also\n        provide the `ratings` and the `rationales` for the generations.\"\"\"\n        return [\"instruction\", \"generations\"]\n\n    def _add_suggestions_if_any(\n        self, input: Dict[str, Any]\n    ) -&gt; List[\"SuggestionSchema\"]:\n        \"\"\"Method to generate the suggestions for the `FeedbackRecord` based on the input.\"\"\"\n        # Since the `suggestions` i.e. answers to the `questions` are optional, will default to {}\n        suggestions = []\n        # If `ratings` is in `input`, then add those as suggestions\n        if self._ratings in input:\n            suggestions.extend(\n                [\n                    {\n                        \"question_name\": f\"{self._generations}-{idx}-rating\",\n                        \"value\": rating,\n                    }\n                    for idx, rating in enumerate(input[self._ratings])\n                    if rating is not None\n                    and isinstance(rating, int)\n                    and rating in [1, 2, 3, 4, 5]\n                ],\n            )\n        # If `rationales` is in `input`, then add those as suggestions\n        if self._rationales in input:\n            suggestions.extend(\n                [\n                    {\n                        \"question_name\": f\"{self._generations}-{idx}-rationale\",\n                        \"value\": rationale,\n                    }\n                    for idx, rationale in enumerate(input[self._rationales])\n                    if rationale is not None and isinstance(rationale, str)\n                ],\n            )\n        return suggestions\n\n    @override\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Creates and pushes the records as FeedbackRecords to the Argilla dataset.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Returns:\n            A list of Python dictionaries with the outputs of the task.\n        \"\"\"\n        records = []\n        for input in inputs:\n            # Generate the SHA-256 hash of the instruction to use it as the metadata\n            instruction_id = hashlib.sha256(\n                input[\"instruction\"].encode(\"utf-8\")  # type: ignore\n            ).hexdigest()\n\n            generations = {\n                f\"{self._generations}-{idx}\": generation\n                for idx, generation in enumerate(input[\"generations\"])  # type: ignore\n            }\n\n            records.append(  # type: ignore\n                rg.FeedbackRecord(  # type: ignore\n                    fields={\n                        \"id\": instruction_id,\n                        \"instruction\": input[\"instruction\"],  # type: ignore\n                        **generations,\n                    },\n                    suggestions=self._add_suggestions_if_any(input),  # type: ignore\n                )\n            )\n        self._rg_dataset.add_records(records)  # type: ignore\n        yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.PreferenceToArgilla.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The inputs for the step are the <code>instruction</code> and the <code>generations</code>. Optionally, one could also provide the <code>ratings</code> and the <code>rationales</code> for the generations.</p>"},{"location":"reference/distilabel/steps/#distilabel.steps.PreferenceToArgilla.load","title":"<code>load()</code>","text":"<p>Sets the <code>_instruction</code> and <code>_generations</code> attributes based on the <code>inputs_mapping</code>, otherwise uses the default values; and then uses those values to create a <code>FeedbackDataset</code> suited for the text-generation scenario. And then it pushes it to Argilla.</p> Source code in <code>src/distilabel/steps/argilla/preference.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Sets the `_instruction` and `_generations` attributes based on the `inputs_mapping`, otherwise\n    uses the default values; and then uses those values to create a `FeedbackDataset` suited for\n    the text-generation scenario. And then it pushes it to Argilla.\n    \"\"\"\n    super().load()\n\n    self._rg_init()\n\n    # Both `instruction` and `generations` will be used as the fields of the dataset\n    self._instruction = self.input_mappings.get(\"instruction\", \"instruction\")\n    self._generations = self.input_mappings.get(\"generations\", \"generations\")\n    # Both `ratings` and `rationales` will be used as suggestions to the default questions of the dataset\n    self._ratings = self.input_mappings.get(\"ratings\", \"ratings\")\n    self._rationales = self.input_mappings.get(\"rationales\", \"rationales\")\n\n    if self._rg_dataset_exists():\n        _rg_dataset = rg.FeedbackDataset.from_argilla(  # type: ignore\n            name=self.dataset_name,\n            workspace=self.dataset_workspace,\n        )\n\n        for field in _rg_dataset.fields:\n            if (\n                field.name\n                not in [self._id, self._instruction]\n                + [\n                    f\"{self._generations}-{idx}\"\n                    for idx in range(self.num_generations)\n                ]\n                and field.required\n            ):\n                raise ValueError(\n                    f\"The dataset {self.dataset_name} in the workspace {self.dataset_workspace} already exists,\"\n                    f\" but contains at least a required field that is neither `{self._id}`, `{self._instruction}`,\"\n                    f\" nor `{self._generations}`.\"\n                )\n\n        self._rg_dataset = _rg_dataset\n    else:\n        _rg_dataset = rg.FeedbackDataset(  # type: ignore\n            fields=[\n                rg.TextField(name=self._id, title=self._id),  # type: ignore\n                rg.TextField(name=self._instruction, title=self._instruction),  # type: ignore\n                *self._generation_fields(),  # type: ignore\n            ],\n            questions=self._rating_rationale_pairs(),  # type: ignore\n        )\n        self._rg_dataset = _rg_dataset.push_to_argilla(\n            name=self.dataset_name, workspace=self.dataset_workspace\n        )\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.PreferenceToArgilla.process","title":"<code>process(inputs)</code>","text":"<p>Creates and pushes the records as FeedbackRecords to the Argilla dataset.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>A list of Python dictionaries with the inputs of the task.</p> required <p>Returns:</p> Type Description <code>StepOutput</code> <p>A list of Python dictionaries with the outputs of the task.</p> Source code in <code>src/distilabel/steps/argilla/preference.py</code> <pre><code>@override\ndef process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Creates and pushes the records as FeedbackRecords to the Argilla dataset.\n\n    Args:\n        inputs: A list of Python dictionaries with the inputs of the task.\n\n    Returns:\n        A list of Python dictionaries with the outputs of the task.\n    \"\"\"\n    records = []\n    for input in inputs:\n        # Generate the SHA-256 hash of the instruction to use it as the metadata\n        instruction_id = hashlib.sha256(\n            input[\"instruction\"].encode(\"utf-8\")  # type: ignore\n        ).hexdigest()\n\n        generations = {\n            f\"{self._generations}-{idx}\": generation\n            for idx, generation in enumerate(input[\"generations\"])  # type: ignore\n        }\n\n        records.append(  # type: ignore\n            rg.FeedbackRecord(  # type: ignore\n                fields={\n                    \"id\": instruction_id,\n                    \"instruction\": input[\"instruction\"],  # type: ignore\n                    **generations,\n                },\n                suggestions=self._add_suggestions_if_any(input),  # type: ignore\n            )\n        )\n    self._rg_dataset.add_records(records)  # type: ignore\n    yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.PushToHub","title":"<code>PushToHub</code>","text":"<p>             Bases: <code>GlobalStep</code></p> <p>A <code>GlobalStep</code> which creates a <code>datasets.Dataset</code> with the input data and pushes it to the Hugging Face Hub.</p> <p>Attributes:</p> Name Type Description <code>repo_id</code> <code>RuntimeParameter[str]</code> <p>The Hugging Face Hub repository ID where the dataset will be uploaded.</p> <code>split</code> <code>RuntimeParameter[str]</code> <p>The split of the dataset that will be pushed. Defaults to <code>\"train\"</code>.</p> <code>private</code> <code>RuntimeParameter[bool]</code> <p>Whether the dataset to be pushed should be private or not. Defaults to <code>False</code>.</p> <code>token</code> <code>Optional[RuntimeParameter[str]]</code> <p>The token that will be used to authenticate in the Hub. If not provided, the token will be tried to be obtained from the environment variable <code>HF_TOKEN</code>. If not provided using one of the previous methods, then <code>huggingface_hub</code> library will try to use the token from the local Hugging Face CLI configuration. Defaults to <code>None</code>.</p> Runtime parameters <ul> <li><code>repo_id</code>: The Hugging Face Hub repository ID where the dataset will be uploaded.</li> <li><code>split</code>: The split of the dataset that will be pushed.</li> <li><code>private</code>: Whether the dataset to be pushed should be private or not.</li> <li><code>token</code>: The token that will be used to authenticate in the Hub.</li> </ul> Input columns <ul> <li>dynamic, based on the existing data within inputs</li> </ul> Source code in <code>src/distilabel/steps/globals/huggingface.py</code> <pre><code>class PushToHub(GlobalStep):\n    \"\"\"A `GlobalStep` which creates a `datasets.Dataset` with the input data and pushes\n    it to the Hugging Face Hub.\n\n    Attributes:\n        repo_id: The Hugging Face Hub repository ID where the dataset will be uploaded.\n        split: The split of the dataset that will be pushed. Defaults to `\"train\"`.\n        private: Whether the dataset to be pushed should be private or not. Defaults to\n            `False`.\n        token: The token that will be used to authenticate in the Hub. If not provided, the\n            token will be tried to be obtained from the environment variable `HF_TOKEN`.\n            If not provided using one of the previous methods, then `huggingface_hub` library\n            will try to use the token from the local Hugging Face CLI configuration. Defaults\n            to `None`.\n\n    Runtime parameters:\n        - `repo_id`: The Hugging Face Hub repository ID where the dataset will be uploaded.\n        - `split`: The split of the dataset that will be pushed.\n        - `private`: Whether the dataset to be pushed should be private or not.\n        - `token`: The token that will be used to authenticate in the Hub.\n\n    Input columns:\n        - dynamic, based on the existing data within inputs\n    \"\"\"\n\n    repo_id: RuntimeParameter[str] = Field(\n        default=None,\n        description=\"The Hugging Face Hub repository ID where the dataset will be uploaded.\",\n    )\n    split: RuntimeParameter[str] = Field(\n        default=\"train\",\n        description=\"The split of the dataset that will be pushed. Defaults to 'train'.\",\n    )\n    private: RuntimeParameter[bool] = Field(\n        default=False,\n        description=\"Whether the dataset to be pushed should be private or not. Defaults\"\n        \" to `False`.\",\n    )\n    token: Optional[RuntimeParameter[str]] = Field(\n        default=None,\n        description=\"The token that will be used to authenticate in the Hub. If not provided,\"\n        \" the token will be tried to be obtained from the environment variable `HF_TOKEN`.\"\n        \" If not provided using one of the previous methods, then `huggingface_hub` library\"\n        \" will try to use the token from the local Hugging Face CLI configuration. Defaults\"\n        \" to `None`\",\n    )\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Method that processes the input data, respecting the `datasets.Dataset` formatting,\n        and pushes it to the Hugging Face Hub based on the `RuntimeParameter`s attributes.\n\n        Args:\n            inputs: that input data within a single object (as it's a GlobalStep) that\n                will be transformed into a `datasets.Dataset`.\n\n        Yields:\n            Propagates the received inputs so that the `Distiset` can be generated if this is\n            the last step of the `Pipeline`, or if this is not a leaf step and has follow up\n            steps.\n        \"\"\"\n        dataset_dict = defaultdict(list)\n        for input in inputs:\n            for key, value in input.items():\n                dataset_dict[key].append(value)\n        dataset_dict = dict(dataset_dict)\n        dataset = Dataset.from_dict(dataset_dict)\n        dataset.push_to_hub(\n            self.repo_id,  # type: ignore\n            split=self.split,\n            private=self.private,\n            token=self.token or os.getenv(\"HF_TOKEN\"),\n        )\n        yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.PushToHub.process","title":"<code>process(inputs)</code>","text":"<p>Method that processes the input data, respecting the <code>datasets.Dataset</code> formatting, and pushes it to the Hugging Face Hub based on the <code>RuntimeParameter</code>s attributes.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>that input data within a single object (as it's a GlobalStep) that will be transformed into a <code>datasets.Dataset</code>.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>Propagates the received inputs so that the <code>Distiset</code> can be generated if this is</p> <code>StepOutput</code> <p>the last step of the <code>Pipeline</code>, or if this is not a leaf step and has follow up</p> <code>StepOutput</code> <p>steps.</p> Source code in <code>src/distilabel/steps/globals/huggingface.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Method that processes the input data, respecting the `datasets.Dataset` formatting,\n    and pushes it to the Hugging Face Hub based on the `RuntimeParameter`s attributes.\n\n    Args:\n        inputs: that input data within a single object (as it's a GlobalStep) that\n            will be transformed into a `datasets.Dataset`.\n\n    Yields:\n        Propagates the received inputs so that the `Distiset` can be generated if this is\n        the last step of the `Pipeline`, or if this is not a leaf step and has follow up\n        steps.\n    \"\"\"\n    dataset_dict = defaultdict(list)\n    for input in inputs:\n        for key, value in input.items():\n            dataset_dict[key].append(value)\n    dataset_dict = dict(dataset_dict)\n    dataset = Dataset.from_dict(dataset_dict)\n    dataset.push_to_hub(\n        self.repo_id,  # type: ignore\n        split=self.split,\n        private=self.private,\n        token=self.token or os.getenv(\"HF_TOKEN\"),\n    )\n    yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.Step","title":"<code>Step</code>","text":"<p>             Bases: <code>_Step</code>, <code>ABC</code></p> <p>Base class for the steps that can be included in a <code>Pipeline</code>.</p> <p>Attributes:</p> Name Type Description <code>input_batch_size</code> <code>RuntimeParameter[PositiveInt]</code> <p>The number of rows that will contain the batches processed by the step. Defaults to <code>50</code>.</p> Runtime parameters <ul> <li><code>input_batch_size</code>: The number of rows that will contain the batches processed     by the step. Defaults to <code>50</code>.</li> </ul> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>class Step(_Step, ABC):\n    \"\"\"Base class for the steps that can be included in a `Pipeline`.\n\n    Attributes:\n        input_batch_size: The number of rows that will contain the batches processed by\n            the step. Defaults to `50`.\n\n    Runtime parameters:\n        - `input_batch_size`: The number of rows that will contain the batches processed\n            by the step. Defaults to `50`.\n    \"\"\"\n\n    input_batch_size: RuntimeParameter[PositiveInt] = Field(\n        default=DEFAULT_INPUT_BATCH_SIZE,\n        description=\"The number of rows that will contain the batches processed by the\"\n        \" step.\",\n    )\n\n    @abstractmethod\n    def process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n        \"\"\"Method that defines the processing logic of the step. It should yield the\n        output rows.\n\n        Args:\n            *inputs: An argument used to receive the outputs of the previous steps. The\n                number of arguments depends on the number of previous steps. It doesn't\n                need to be an `*args` argument, it can be a regular argument annotated\n                with `StepInput` if the step has only one previous step.\n        \"\"\"\n        pass\n\n    def process_applying_mappings(self, *args: List[Dict[str, Any]]) -&gt; \"StepOutput\":\n        \"\"\"Runs the `process` method of the step applying the `input_mappings` to the input\n        rows and the `outputs_mappings` to the output rows. This is the function that\n        should be used to run the processing logic of the step.\n\n        Yields:\n            The output rows.\n        \"\"\"\n\n        inputs = self._apply_input_mappings(args) if self.input_mappings else args\n\n        # If the `Step` was built using the `@step` decorator, then we need to pass\n        # the runtime parameters as kwargs, so they can be used within the processing\n        # function\n        generator = (\n            self.process(*inputs)\n            if not self._built_from_decorator\n            else self.process(*inputs, **self._runtime_parameters)\n        )\n\n        for output_rows in generator:\n            yield [\n                {\n                    # Apply output mapping and revert input mapping\n                    self.output_mappings.get(k, None)\n                    or self.input_mappings.get(k, None)\n                    or k: v\n                    for k, v in row.items()\n                }\n                for row in output_rows\n            ]\n\n    def _revert_input_mappings(self, input: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Reverts the `input_mappings` of the step to the input row.\n\n        Args:\n            input: The input row.\n\n        Returns:\n            The input row with the `input_mappings` reverted.\n        \"\"\"\n        return {self.input_mappings.get(k, k): v for k, v in input.items()}\n\n    def _apply_input_mappings(\n        self, inputs: Tuple[List[Dict[str, Any]], ...]\n    ) -&gt; List[List[Dict[str, Any]]]:\n        \"\"\"Applies the `input_mappings` to the input rows.\n\n        Args:\n            inputs: The input rows.\n\n        Returns:\n            The input rows with the `input_mappings` applied.\n        \"\"\"\n        reverted_input_mappings = {v: k for k, v in self.input_mappings.items()}\n\n        return [\n            [\n                {reverted_input_mappings.get(k, k): v for k, v in row.items()}\n                for row in row_inputs\n            ]\n            for row_inputs in inputs\n        ]\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.Step.process","title":"<code>process(*inputs)</code>  <code>abstractmethod</code>","text":"<p>Method that defines the processing logic of the step. It should yield the output rows.</p> <p>Parameters:</p> Name Type Description Default <code>*inputs</code> <code>StepInput</code> <p>An argument used to receive the outputs of the previous steps. The number of arguments depends on the number of previous steps. It doesn't need to be an <code>*args</code> argument, it can be a regular argument annotated with <code>StepInput</code> if the step has only one previous step.</p> <code>()</code> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>@abstractmethod\ndef process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n    \"\"\"Method that defines the processing logic of the step. It should yield the\n    output rows.\n\n    Args:\n        *inputs: An argument used to receive the outputs of the previous steps. The\n            number of arguments depends on the number of previous steps. It doesn't\n            need to be an `*args` argument, it can be a regular argument annotated\n            with `StepInput` if the step has only one previous step.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.Step.process_applying_mappings","title":"<code>process_applying_mappings(*args)</code>","text":"<p>Runs the <code>process</code> method of the step applying the <code>input_mappings</code> to the input rows and the <code>outputs_mappings</code> to the output rows. This is the function that should be used to run the processing logic of the step.</p> <p>Yields:</p> Type Description <code>StepOutput</code> <p>The output rows.</p> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>def process_applying_mappings(self, *args: List[Dict[str, Any]]) -&gt; \"StepOutput\":\n    \"\"\"Runs the `process` method of the step applying the `input_mappings` to the input\n    rows and the `outputs_mappings` to the output rows. This is the function that\n    should be used to run the processing logic of the step.\n\n    Yields:\n        The output rows.\n    \"\"\"\n\n    inputs = self._apply_input_mappings(args) if self.input_mappings else args\n\n    # If the `Step` was built using the `@step` decorator, then we need to pass\n    # the runtime parameters as kwargs, so they can be used within the processing\n    # function\n    generator = (\n        self.process(*inputs)\n        if not self._built_from_decorator\n        else self.process(*inputs, **self._runtime_parameters)\n    )\n\n    for output_rows in generator:\n        yield [\n            {\n                # Apply output mapping and revert input mapping\n                self.output_mappings.get(k, None)\n                or self.input_mappings.get(k, None)\n                or k: v\n                for k, v in row.items()\n            }\n            for row in output_rows\n        ]\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.TextGenerationToArgilla","title":"<code>TextGenerationToArgilla</code>","text":"<p>             Bases: <code>Argilla</code></p> <p>Step that creates a dataset in Argilla during the load phase, and then pushes the input batches into it as records. This dataset is a text-generation dataset, where there's one field per each input, and then a label question to rate the quality of the completion in either bad (represented with \ud83d\udc4e) or good (represented with \ud83d\udc4d).</p> Note <p>This step is meant to be used in conjunction with a <code>TextGeneration</code> step and no column mapping is needed, as it will use the default values for the <code>instruction</code> and <code>generation</code> columns.</p> <p>Attributes:</p> Name Type Description <code>dataset_name</code> <p>The name of the dataset in Argilla.</p> <code>dataset_workspace</code> <p>The workspace where the dataset will be created in Argilla. Defaults to <code>None</code>, which means it will be created in the default workspace.</p> <code>api_url</code> <p>The URL of the Argilla API. Defaults to <code>None</code>, which means it will be read from the <code>ARGILLA_API_URL</code> environment variable.</p> <code>api_key</code> <p>The API key to authenticate with Argilla. Defaults to <code>None</code>, which means it will be read from the <code>ARGILLA_API_KEY</code> environment variable.</p> Runtime parameters <ul> <li><code>api_url</code>: The base URL to use for the Argilla API requests.</li> <li><code>api_key</code>: The API key to authenticate the requests to the Argilla API.</li> </ul> Input columns <ul> <li>instruction (<code>str</code>): The instruction that was used to generate the completion.</li> <li>generation (<code>str</code> or <code>List[str]</code>): The completions that were generated based on the input instruction.</li> </ul> Source code in <code>src/distilabel/steps/argilla/text_generation.py</code> <pre><code>class TextGenerationToArgilla(Argilla):\n    \"\"\"Step that creates a dataset in Argilla during the load phase, and then pushes the input\n    batches into it as records. This dataset is a text-generation dataset, where there's one field\n    per each input, and then a label question to rate the quality of the completion in either bad\n    (represented with \ud83d\udc4e) or good (represented with \ud83d\udc4d).\n\n    Note:\n        This step is meant to be used in conjunction with a `TextGeneration` step and no column mapping\n        is needed, as it will use the default values for the `instruction` and `generation` columns.\n\n    Attributes:\n        dataset_name: The name of the dataset in Argilla.\n        dataset_workspace: The workspace where the dataset will be created in Argilla. Defaults to\n            `None`, which means it will be created in the default workspace.\n        api_url: The URL of the Argilla API. Defaults to `None`, which means it will be read from\n            the `ARGILLA_API_URL` environment variable.\n        api_key: The API key to authenticate with Argilla. Defaults to `None`, which means it will\n            be read from the `ARGILLA_API_KEY` environment variable.\n\n    Runtime parameters:\n        - `api_url`: The base URL to use for the Argilla API requests.\n        - `api_key`: The API key to authenticate the requests to the Argilla API.\n\n    Input columns:\n        - instruction (`str`): The instruction that was used to generate the completion.\n        - generation (`str` or `List[str]`): The completions that were generated based on the input instruction.\n    \"\"\"\n\n    _id: str = PrivateAttr(default=\"id\")\n    _instruction: str = PrivateAttr(...)\n    _generation: str = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Sets the `_instruction` and `_generation` attributes based on the `inputs_mapping`, otherwise\n        uses the default values; and then uses those values to create a `FeedbackDataset` suited for\n        the text-generation scenario. And then it pushes it to Argilla.\n        \"\"\"\n        super().load()\n\n        self._rg_init()\n\n        self._instruction = self.input_mappings.get(\"instruction\", \"instruction\")\n        self._generation = self.input_mappings.get(\"generation\", \"generation\")\n\n        if self._rg_dataset_exists():\n            _rg_dataset = rg.FeedbackDataset.from_argilla(\n                name=self.dataset_name,\n                workspace=self.dataset_workspace,\n            )\n\n            for field in _rg_dataset.fields:\n                if (\n                    field.name not in [self._id, self._instruction, self._generation]\n                    and field.required\n                ):\n                    raise ValueError(\n                        f\"The dataset {self.dataset_name} in the workspace {self.dataset_workspace} already exists,\"\n                        f\" but contains at least a required field that is neither `{self._id}`, `{self._instruction}`\"\n                        f\", nor `{self._generation}`.\"\n                    )\n\n            self._rg_dataset = _rg_dataset\n        else:\n            _rg_dataset = rg.FeedbackDataset(\n                fields=[\n                    rg.TextField(name=self._id, title=self._id),  # type: ignore\n                    rg.TextField(name=self._instruction, title=self._instruction),  # type: ignore\n                    rg.TextField(name=self._generation, title=self._generation),  # type: ignore\n                ],\n                questions=[\n                    rg.LabelQuestion(  # type: ignore\n                        name=\"quality\",\n                        title=f\"What's the quality of the {self._generation} for the given {self._instruction}?\",\n                        labels={\"bad\": \"\ud83d\udc4e\", \"good\": \"\ud83d\udc4d\"},\n                    )\n                ],\n            )\n            self._rg_dataset = _rg_dataset.push_to_argilla(\n                name=self.dataset_name, workspace=self.dataset_workspace\n            )\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The inputs for the step are the `instruction` and the `generation`.\"\"\"\n        return [\"instruction\", \"generation\"]\n\n    @override\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Creates and pushes the records as FeedbackRecords to the Argilla dataset.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Returns:\n            A list of Python dictionaries with the outputs of the task.\n        \"\"\"\n        records = []\n        for input in inputs:\n            # Generate the SHA-256 hash of the instruction to use it as the metadata\n            instruction_id = hashlib.sha256(\n                input[\"instruction\"].encode(\"utf-8\")\n            ).hexdigest()\n\n            generations = input[\"generation\"]\n\n            # If the `generation` is not a list, then convert it into a list\n            if not isinstance(generations, list):\n                generations = [generations]\n\n            # Create a `generations_set` to avoid adding duplicates\n            generations_set = set()\n\n            for generation in generations:\n                # If the generation is already in the set, then skip it\n                if generation in generations_set:\n                    continue\n                # Otherwise, add it to the set\n                generations_set.add(generation)\n\n                records.append(\n                    rg.FeedbackRecord(\n                        fields={\n                            self._id: instruction_id,\n                            self._instruction: input[\"instruction\"],\n                            self._generation: generation,\n                        },\n                    )\n                )\n        self._rg_dataset.add_records(records)  # type: ignore\n        yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.TextGenerationToArgilla.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The inputs for the step are the <code>instruction</code> and the <code>generation</code>.</p>"},{"location":"reference/distilabel/steps/#distilabel.steps.TextGenerationToArgilla.load","title":"<code>load()</code>","text":"<p>Sets the <code>_instruction</code> and <code>_generation</code> attributes based on the <code>inputs_mapping</code>, otherwise uses the default values; and then uses those values to create a <code>FeedbackDataset</code> suited for the text-generation scenario. And then it pushes it to Argilla.</p> Source code in <code>src/distilabel/steps/argilla/text_generation.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Sets the `_instruction` and `_generation` attributes based on the `inputs_mapping`, otherwise\n    uses the default values; and then uses those values to create a `FeedbackDataset` suited for\n    the text-generation scenario. And then it pushes it to Argilla.\n    \"\"\"\n    super().load()\n\n    self._rg_init()\n\n    self._instruction = self.input_mappings.get(\"instruction\", \"instruction\")\n    self._generation = self.input_mappings.get(\"generation\", \"generation\")\n\n    if self._rg_dataset_exists():\n        _rg_dataset = rg.FeedbackDataset.from_argilla(\n            name=self.dataset_name,\n            workspace=self.dataset_workspace,\n        )\n\n        for field in _rg_dataset.fields:\n            if (\n                field.name not in [self._id, self._instruction, self._generation]\n                and field.required\n            ):\n                raise ValueError(\n                    f\"The dataset {self.dataset_name} in the workspace {self.dataset_workspace} already exists,\"\n                    f\" but contains at least a required field that is neither `{self._id}`, `{self._instruction}`\"\n                    f\", nor `{self._generation}`.\"\n                )\n\n        self._rg_dataset = _rg_dataset\n    else:\n        _rg_dataset = rg.FeedbackDataset(\n            fields=[\n                rg.TextField(name=self._id, title=self._id),  # type: ignore\n                rg.TextField(name=self._instruction, title=self._instruction),  # type: ignore\n                rg.TextField(name=self._generation, title=self._generation),  # type: ignore\n            ],\n            questions=[\n                rg.LabelQuestion(  # type: ignore\n                    name=\"quality\",\n                    title=f\"What's the quality of the {self._generation} for the given {self._instruction}?\",\n                    labels={\"bad\": \"\ud83d\udc4e\", \"good\": \"\ud83d\udc4d\"},\n                )\n            ],\n        )\n        self._rg_dataset = _rg_dataset.push_to_argilla(\n            name=self.dataset_name, workspace=self.dataset_workspace\n        )\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.TextGenerationToArgilla.process","title":"<code>process(inputs)</code>","text":"<p>Creates and pushes the records as FeedbackRecords to the Argilla dataset.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>A list of Python dictionaries with the inputs of the task.</p> required <p>Returns:</p> Type Description <code>StepOutput</code> <p>A list of Python dictionaries with the outputs of the task.</p> Source code in <code>src/distilabel/steps/argilla/text_generation.py</code> <pre><code>@override\ndef process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Creates and pushes the records as FeedbackRecords to the Argilla dataset.\n\n    Args:\n        inputs: A list of Python dictionaries with the inputs of the task.\n\n    Returns:\n        A list of Python dictionaries with the outputs of the task.\n    \"\"\"\n    records = []\n    for input in inputs:\n        # Generate the SHA-256 hash of the instruction to use it as the metadata\n        instruction_id = hashlib.sha256(\n            input[\"instruction\"].encode(\"utf-8\")\n        ).hexdigest()\n\n        generations = input[\"generation\"]\n\n        # If the `generation` is not a list, then convert it into a list\n        if not isinstance(generations, list):\n            generations = [generations]\n\n        # Create a `generations_set` to avoid adding duplicates\n        generations_set = set()\n\n        for generation in generations:\n            # If the generation is already in the set, then skip it\n            if generation in generations_set:\n                continue\n            # Otherwise, add it to the set\n            generations_set.add(generation)\n\n            records.append(\n                rg.FeedbackRecord(\n                    fields={\n                        self._id: instruction_id,\n                        self._instruction: input[\"instruction\"],\n                        self._generation: generation,\n                    },\n                )\n            )\n    self._rg_dataset.add_records(records)  # type: ignore\n    yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/#distilabel.steps.step","title":"<code>step(inputs=None, outputs=None, step_type='normal')</code>","text":"<p>Creates an <code>Step</code> from a processing function.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Union[List[str], None]</code> <p>a list containing the name of the inputs columns/keys expected by this step. If not provided the default will be an empty list <code>[]</code> and it will be assumed that the step doesn't need any specific columns. Defaults to <code>None</code>.</p> <code>None</code> <code>outputs</code> <code>Union[List[str], None]</code> <p>a list containing the name of the outputs columns/keys that the step will generate. If not provided the default will be an empty list <code>[]</code> and it will be assumed that the step doesn't need any specific columns. Defaults to <code>None</code>.</p> <code>None</code> <code>step_type</code> <code>Literal['normal', 'global', 'generator']</code> <p>the kind of step to create. Valid choices are: \"normal\" (<code>Step</code>), \"global\" (<code>GlobalStep</code>) or \"generator\" (<code>GeneratorStep</code>). Defaults to <code>\"normal\"</code>.</p> <code>'normal'</code> <p>Returns:</p> Type Description <code>Callable[..., Type[_Step]]</code> <p>A callable that will generate the type given the processing function.</p> <p>Example:</p> <pre><code># Normal step\n@step(inputs=[\"instruction\"], outputs=[\"generation\"])\ndef GenerationStep(inputs: StepInput, dummy_generation: RuntimeParameter[str]) -&gt; StepOutput:\n    for input in inputs:\n        input[\"generation\"] = dummy_generation\n    yield inputs\n\n# Global step\n@step(inputs=[\"instruction\"], step_type=\"global\")\ndef FilteringStep(inputs: StepInput, max_length: RuntimeParameter[int] = 256) -&gt; StepOutput:\n    yield [\n        input\n        for input in inputs\n        if len(input[\"instruction\"]) &lt;= max_length\n    ]\n\n# Generator step\n@step(outputs=[\"num\"], step_type=\"generator\")\ndef RowGenerator(num_rows: RuntimeParameter[int] = 500) -&gt; GeneratorStepOutput:\n    data = list(range(num_rows))\n    for i in range(0, len(data), 100):\n        last_batch = i + 100 &gt;= len(data)\n        yield [{\"num\": num} for num in data[i : i + 100]], last_batch\n</code></pre> Source code in <code>src/distilabel/steps/decorator.py</code> <pre><code>def step(\n    inputs: Union[List[str], None] = None,\n    outputs: Union[List[str], None] = None,\n    step_type: Literal[\"normal\", \"global\", \"generator\"] = \"normal\",\n) -&gt; Callable[..., Type[\"_Step\"]]:\n    \"\"\"Creates an `Step` from a processing function.\n\n    Args:\n        inputs: a list containing the name of the inputs columns/keys expected by this step.\n            If not provided the default will be an empty list `[]` and it will be assumed\n            that the step doesn't need any specific columns. Defaults to `None`.\n        outputs: a list containing the name of the outputs columns/keys that the step\n            will generate. If not provided the default will be an empty list `[]` and it\n            will be assumed that the step doesn't need any specific columns. Defaults to\n            `None`.\n        step_type: the kind of step to create. Valid choices are: \"normal\" (`Step`),\n            \"global\" (`GlobalStep`) or \"generator\" (`GeneratorStep`). Defaults to\n            `\"normal\"`.\n\n    Returns:\n        A callable that will generate the type given the processing function.\n\n    Example:\n\n    ```python\n    # Normal step\n    @step(inputs=[\"instruction\"], outputs=[\"generation\"])\n    def GenerationStep(inputs: StepInput, dummy_generation: RuntimeParameter[str]) -&gt; StepOutput:\n        for input in inputs:\n            input[\"generation\"] = dummy_generation\n        yield inputs\n\n    # Global step\n    @step(inputs=[\"instruction\"], step_type=\"global\")\n    def FilteringStep(inputs: StepInput, max_length: RuntimeParameter[int] = 256) -&gt; StepOutput:\n        yield [\n            input\n            for input in inputs\n            if len(input[\"instruction\"]) &lt;= max_length\n        ]\n\n    # Generator step\n    @step(outputs=[\"num\"], step_type=\"generator\")\n    def RowGenerator(num_rows: RuntimeParameter[int] = 500) -&gt; GeneratorStepOutput:\n        data = list(range(num_rows))\n        for i in range(0, len(data), 100):\n            last_batch = i + 100 &gt;= len(data)\n            yield [{\"num\": num} for num in data[i : i + 100]], last_batch\n    ```\n    \"\"\"\n\n    inputs = inputs or []\n    outputs = outputs or []\n\n    def decorator(func: ProcessingFunc) -&gt; Type[\"_Step\"]:\n        if step_type not in _STEP_MAPPING:\n            raise ValueError(\n                f\"Invalid step type '{step_type}'. Please, review the '{func.__name__}'\"\n                \" function decorated with the `@step` decorator and provide a valid\"\n                \" `step_type`. Valid choices are: 'normal', 'global' or 'generator'.\"\n            )\n\n        BaseClass = _STEP_MAPPING[step_type]\n\n        signature = inspect.signature(func)\n\n        runtime_parameters = {\n            name: (\n                param.annotation,\n                param.default if param.default != param.empty else None,\n            )\n            for name, param in signature.parameters.items()\n        }\n\n        runtime_parameters = {}\n        step_input_parameter = None\n        for name, param in signature.parameters.items():\n            if is_parameter_annotated_with(param, _RUNTIME_PARAMETER_ANNOTATION):\n                runtime_parameters[name] = (\n                    param.annotation,\n                    param.default if param.default != param.empty else None,\n                )\n\n            if not step_type == \"generator\" and is_parameter_annotated_with(\n                param, _STEP_INPUT_ANNOTATION\n            ):\n                if step_input_parameter is not None:\n                    raise ValueError(\n                        f\"Function '{func.__name__}' has more than one parameter annotated\"\n                        f\" with `StepInput`. Please, review the '{func.__name__}' function\"\n                        \" decorated with the `@step` decorator and provide only one\"\n                        \" argument annotated with `StepInput`.\"\n                    )\n                step_input_parameter = param\n\n        RuntimeParametersModel = create_model(  # type: ignore\n            \"RuntimeParametersModel\",\n            **runtime_parameters,  # type: ignore\n        )\n\n        def inputs_property(self) -&gt; List[str]:\n            return inputs\n\n        def outputs_property(self) -&gt; List[str]:\n            return outputs\n\n        def process(\n            self, *args: Any, **kwargs: Any\n        ) -&gt; Union[\"StepOutput\", \"GeneratorStepOutput\"]:\n            return func(*args, **kwargs)\n\n        return type(  # type: ignore\n            func.__name__,\n            (\n                BaseClass,\n                RuntimeParametersModel,\n            ),\n            {\n                \"process\": process,\n                \"inputs\": property(inputs_property),\n                \"outputs\": property(outputs_property),\n                \"__module__\": func.__module__,\n                \"__doc__\": func.__doc__,\n                \"_built_from_decorator\": True,\n                # Override the `get_process_step_input` method to return the parameter\n                # of the original function annotated with `StepInput`.\n                \"get_process_step_input\": lambda self: step_input_parameter,\n            },\n        )\n\n    return decorator\n</code></pre>"},{"location":"reference/distilabel/steps/base/","title":"Base","text":""},{"location":"reference/distilabel/steps/base/#distilabel.steps.base.StepInput","title":"<code>StepInput = Annotated[List[Dict[str, Any]], _STEP_INPUT_ANNOTATION]</code>  <code>module-attribute</code>","text":"<p>StepInput is just an <code>Annotated</code> alias of the typing <code>List[Dict[str, Any]]</code> with extra metadata that allows <code>distilabel</code> to perform validations over the <code>process</code> step method defined in each <code>Step</code></p>"},{"location":"reference/distilabel/steps/base/#distilabel.steps.base.GeneratorStep","title":"<code>GeneratorStep</code>","text":"<p>             Bases: <code>_Step</code>, <code>ABC</code></p> <p>A special kind of <code>Step</code> that is able to generate data i.e. it doesn't receive any input from the previous steps.</p> <p>Attributes:</p> Name Type Description <code>batch_size</code> <code>RuntimeParameter[int]</code> <p>The number of rows that will contain the batches generated by the step. Defaults to <code>50</code>.</p> Runtime parameters <ul> <li><code>batch_size</code>: The number of rows that will contain the batches generated by     the step. Defaults to <code>50</code>.</li> </ul> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>class GeneratorStep(_Step, ABC):\n    \"\"\"A special kind of `Step` that is able to generate data i.e. it doesn't receive\n    any input from the previous steps.\n\n    Attributes:\n        batch_size: The number of rows that will contain the batches generated by the\n            step. Defaults to `50`.\n\n    Runtime parameters:\n        - `batch_size`: The number of rows that will contain the batches generated by\n            the step. Defaults to `50`.\n    \"\"\"\n\n    batch_size: RuntimeParameter[int] = Field(\n        default=50,\n        description=\"The number of rows that will contain the batches generated by the\"\n        \" step.\",\n    )\n\n    @abstractmethod\n    def process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":\n        \"\"\"Method that defines the generation logic of the step. It should yield the\n        output rows and a boolean indicating if it's the last batch or not.\n\n        Args:\n            offset: The offset to start the generation from. Defaults to 0.\n\n        Yields:\n            The output rows and a boolean indicating if it's the last batch or not.\n        \"\"\"\n        pass\n\n    def process_applying_mappings(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":\n        \"\"\"Runs the `process` method of the step applying the `outputs_mappings` to the\n        output rows. This is the function that should be used to run the generation logic\n        of the step.\n\n        Args:\n            offset: The offset to start the generation from. Defaults to 0.\n\n        Yields:\n            The output rows and a boolean indicating if it's the last batch or not.\n        \"\"\"\n\n        # If the `Step` was built using the `@step` decorator, then we need to pass\n        # the runtime parameters as `kwargs`, so they can be used within the processing\n        # function\n        generator = (\n            self.process(offset=offset)\n            if not self._built_from_decorator\n            else self.process(offset=offset, **self._runtime_parameters)\n        )\n\n        for output_rows, last_batch in generator:\n            yield (\n                [\n                    {self.output_mappings.get(k, k): v for k, v in row.items()}\n                    for row in output_rows\n                ],\n                last_batch,\n            )\n</code></pre>"},{"location":"reference/distilabel/steps/base/#distilabel.steps.base.GeneratorStep.process","title":"<code>process(offset=0)</code>  <code>abstractmethod</code>","text":"<p>Method that defines the generation logic of the step. It should yield the output rows and a boolean indicating if it's the last batch or not.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The offset to start the generation from. Defaults to 0.</p> <code>0</code> <p>Yields:</p> Type Description <code>GeneratorStepOutput</code> <p>The output rows and a boolean indicating if it's the last batch or not.</p> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>@abstractmethod\ndef process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":\n    \"\"\"Method that defines the generation logic of the step. It should yield the\n    output rows and a boolean indicating if it's the last batch or not.\n\n    Args:\n        offset: The offset to start the generation from. Defaults to 0.\n\n    Yields:\n        The output rows and a boolean indicating if it's the last batch or not.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/distilabel/steps/base/#distilabel.steps.base.GeneratorStep.process_applying_mappings","title":"<code>process_applying_mappings(offset=0)</code>","text":"<p>Runs the <code>process</code> method of the step applying the <code>outputs_mappings</code> to the output rows. This is the function that should be used to run the generation logic of the step.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The offset to start the generation from. Defaults to 0.</p> <code>0</code> <p>Yields:</p> Type Description <code>GeneratorStepOutput</code> <p>The output rows and a boolean indicating if it's the last batch or not.</p> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>def process_applying_mappings(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":\n    \"\"\"Runs the `process` method of the step applying the `outputs_mappings` to the\n    output rows. This is the function that should be used to run the generation logic\n    of the step.\n\n    Args:\n        offset: The offset to start the generation from. Defaults to 0.\n\n    Yields:\n        The output rows and a boolean indicating if it's the last batch or not.\n    \"\"\"\n\n    # If the `Step` was built using the `@step` decorator, then we need to pass\n    # the runtime parameters as `kwargs`, so they can be used within the processing\n    # function\n    generator = (\n        self.process(offset=offset)\n        if not self._built_from_decorator\n        else self.process(offset=offset, **self._runtime_parameters)\n    )\n\n    for output_rows, last_batch in generator:\n        yield (\n            [\n                {self.output_mappings.get(k, k): v for k, v in row.items()}\n                for row in output_rows\n            ],\n            last_batch,\n        )\n</code></pre>"},{"location":"reference/distilabel/steps/base/#distilabel.steps.base.GlobalStep","title":"<code>GlobalStep</code>","text":"<p>             Bases: <code>Step</code>, <code>ABC</code></p> <p>A special kind of <code>Step</code> which it's <code>process</code> method receives all the data processed by their previous steps at once, instead of receiving it in batches. This kind of steps are useful when the processing logic requires to have all the data at once, for example to train a model, to perform a global aggregation, etc.</p> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>class GlobalStep(Step, ABC):\n    \"\"\"A special kind of `Step` which it's `process` method receives all the data processed\n    by their previous steps at once, instead of receiving it in batches. This kind of steps\n    are useful when the processing logic requires to have all the data at once, for example\n    to train a model, to perform a global aggregation, etc.\n    \"\"\"\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        return []\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        return []\n</code></pre>"},{"location":"reference/distilabel/steps/base/#distilabel.steps.base.Step","title":"<code>Step</code>","text":"<p>             Bases: <code>_Step</code>, <code>ABC</code></p> <p>Base class for the steps that can be included in a <code>Pipeline</code>.</p> <p>Attributes:</p> Name Type Description <code>input_batch_size</code> <code>RuntimeParameter[PositiveInt]</code> <p>The number of rows that will contain the batches processed by the step. Defaults to <code>50</code>.</p> Runtime parameters <ul> <li><code>input_batch_size</code>: The number of rows that will contain the batches processed     by the step. Defaults to <code>50</code>.</li> </ul> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>class Step(_Step, ABC):\n    \"\"\"Base class for the steps that can be included in a `Pipeline`.\n\n    Attributes:\n        input_batch_size: The number of rows that will contain the batches processed by\n            the step. Defaults to `50`.\n\n    Runtime parameters:\n        - `input_batch_size`: The number of rows that will contain the batches processed\n            by the step. Defaults to `50`.\n    \"\"\"\n\n    input_batch_size: RuntimeParameter[PositiveInt] = Field(\n        default=DEFAULT_INPUT_BATCH_SIZE,\n        description=\"The number of rows that will contain the batches processed by the\"\n        \" step.\",\n    )\n\n    @abstractmethod\n    def process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n        \"\"\"Method that defines the processing logic of the step. It should yield the\n        output rows.\n\n        Args:\n            *inputs: An argument used to receive the outputs of the previous steps. The\n                number of arguments depends on the number of previous steps. It doesn't\n                need to be an `*args` argument, it can be a regular argument annotated\n                with `StepInput` if the step has only one previous step.\n        \"\"\"\n        pass\n\n    def process_applying_mappings(self, *args: List[Dict[str, Any]]) -&gt; \"StepOutput\":\n        \"\"\"Runs the `process` method of the step applying the `input_mappings` to the input\n        rows and the `outputs_mappings` to the output rows. This is the function that\n        should be used to run the processing logic of the step.\n\n        Yields:\n            The output rows.\n        \"\"\"\n\n        inputs = self._apply_input_mappings(args) if self.input_mappings else args\n\n        # If the `Step` was built using the `@step` decorator, then we need to pass\n        # the runtime parameters as kwargs, so they can be used within the processing\n        # function\n        generator = (\n            self.process(*inputs)\n            if not self._built_from_decorator\n            else self.process(*inputs, **self._runtime_parameters)\n        )\n\n        for output_rows in generator:\n            yield [\n                {\n                    # Apply output mapping and revert input mapping\n                    self.output_mappings.get(k, None)\n                    or self.input_mappings.get(k, None)\n                    or k: v\n                    for k, v in row.items()\n                }\n                for row in output_rows\n            ]\n\n    def _revert_input_mappings(self, input: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Reverts the `input_mappings` of the step to the input row.\n\n        Args:\n            input: The input row.\n\n        Returns:\n            The input row with the `input_mappings` reverted.\n        \"\"\"\n        return {self.input_mappings.get(k, k): v for k, v in input.items()}\n\n    def _apply_input_mappings(\n        self, inputs: Tuple[List[Dict[str, Any]], ...]\n    ) -&gt; List[List[Dict[str, Any]]]:\n        \"\"\"Applies the `input_mappings` to the input rows.\n\n        Args:\n            inputs: The input rows.\n\n        Returns:\n            The input rows with the `input_mappings` applied.\n        \"\"\"\n        reverted_input_mappings = {v: k for k, v in self.input_mappings.items()}\n\n        return [\n            [\n                {reverted_input_mappings.get(k, k): v for k, v in row.items()}\n                for row in row_inputs\n            ]\n            for row_inputs in inputs\n        ]\n</code></pre>"},{"location":"reference/distilabel/steps/base/#distilabel.steps.base.Step.process","title":"<code>process(*inputs)</code>  <code>abstractmethod</code>","text":"<p>Method that defines the processing logic of the step. It should yield the output rows.</p> <p>Parameters:</p> Name Type Description Default <code>*inputs</code> <code>StepInput</code> <p>An argument used to receive the outputs of the previous steps. The number of arguments depends on the number of previous steps. It doesn't need to be an <code>*args</code> argument, it can be a regular argument annotated with <code>StepInput</code> if the step has only one previous step.</p> <code>()</code> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>@abstractmethod\ndef process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n    \"\"\"Method that defines the processing logic of the step. It should yield the\n    output rows.\n\n    Args:\n        *inputs: An argument used to receive the outputs of the previous steps. The\n            number of arguments depends on the number of previous steps. It doesn't\n            need to be an `*args` argument, it can be a regular argument annotated\n            with `StepInput` if the step has only one previous step.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/distilabel/steps/base/#distilabel.steps.base.Step.process_applying_mappings","title":"<code>process_applying_mappings(*args)</code>","text":"<p>Runs the <code>process</code> method of the step applying the <code>input_mappings</code> to the input rows and the <code>outputs_mappings</code> to the output rows. This is the function that should be used to run the processing logic of the step.</p> <p>Yields:</p> Type Description <code>StepOutput</code> <p>The output rows.</p> Source code in <code>src/distilabel/steps/base.py</code> <pre><code>def process_applying_mappings(self, *args: List[Dict[str, Any]]) -&gt; \"StepOutput\":\n    \"\"\"Runs the `process` method of the step applying the `input_mappings` to the input\n    rows and the `outputs_mappings` to the output rows. This is the function that\n    should be used to run the processing logic of the step.\n\n    Yields:\n        The output rows.\n    \"\"\"\n\n    inputs = self._apply_input_mappings(args) if self.input_mappings else args\n\n    # If the `Step` was built using the `@step` decorator, then we need to pass\n    # the runtime parameters as kwargs, so they can be used within the processing\n    # function\n    generator = (\n        self.process(*inputs)\n        if not self._built_from_decorator\n        else self.process(*inputs, **self._runtime_parameters)\n    )\n\n    for output_rows in generator:\n        yield [\n            {\n                # Apply output mapping and revert input mapping\n                self.output_mappings.get(k, None)\n                or self.input_mappings.get(k, None)\n                or k: v\n                for k, v in row.items()\n            }\n            for row in output_rows\n        ]\n</code></pre>"},{"location":"reference/distilabel/steps/combine/","title":"Combine","text":""},{"location":"reference/distilabel/steps/combine/#distilabel.steps.combine.CombineColumns","title":"<code>CombineColumns</code>","text":"<p>             Bases: <code>Step</code></p> <p>CombineColumns is a Step that implements the <code>process</code> method that calls the <code>combine_dicts</code> function to handle and combine a list of <code>StepInput</code>. Also <code>CombineColumns</code> provides two attributes <code>columns</code> and <code>output_columns</code> to specify the columns to merge and the output columns which will override the default value for the properties <code>inputs</code> and <code>outputs</code>, respectively.</p> <p>Attributes:</p> Name Type Description <code>columns</code> <code>List[str]</code> <p>List of strings with the names of the columns to merge.</p> <code>output_columns</code> <code>Optional[List[str]]</code> <p>Optional list of strings with the names of the output columns.</p> Input columns <ul> <li>dynamic, based on the <code>columns</code> value provided.</li> </ul> Output columns <ul> <li>dynamic, based on the <code>output_columns</code> value provided or <code>merged_{column}</code> for each column in <code>columns</code>.</li> </ul> Source code in <code>src/distilabel/steps/combine.py</code> <pre><code>class CombineColumns(Step):\n    \"\"\"CombineColumns is a Step that implements the `process` method that calls the `combine_dicts`\n    function to handle and combine a list of `StepInput`. Also `CombineColumns` provides two attributes\n    `columns` and `output_columns` to specify the columns to merge and the output columns\n    which will override the default value for the properties `inputs` and `outputs`, respectively.\n\n    Attributes:\n        columns: List of strings with the names of the columns to merge.\n        output_columns: Optional list of strings with the names of the output columns.\n\n    Input columns:\n        - dynamic, based on the `columns` value provided.\n\n    Output columns:\n        - dynamic, based on the `output_columns` value provided or `merged_{column}` for each column in `columns`.\n    \"\"\"\n\n    columns: List[str]\n    output_columns: Optional[List[str]] = None\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The inputs for the task are the column names in `columns`.\"\"\"\n        return self.columns\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The outputs for the task are the column names in `output_columns` or\n        `merged_{column}` for each column in `columns`.\"\"\"\n        return (\n            self.output_columns\n            if self.output_columns is not None\n            else [f\"merged_{column}\" for column in self.columns]\n        )\n\n    @override\n    def process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n        \"\"\"The `process` method calls the `combine_dicts` function to handle and combine a list of `StepInput`.\n\n        Args:\n            *inputs: A list of `StepInput` to be combined.\n\n        Yields:\n            A `StepOutput` with the combined `StepInput` using the `combine_dicts` function.\n        \"\"\"\n        yield combine_dicts(\n            *inputs,\n            merge_keys=self.inputs,\n            output_merge_keys=self.outputs,\n        )\n</code></pre>"},{"location":"reference/distilabel/steps/combine/#distilabel.steps.combine.CombineColumns.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The inputs for the task are the column names in <code>columns</code>.</p>"},{"location":"reference/distilabel/steps/combine/#distilabel.steps.combine.CombineColumns.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The outputs for the task are the column names in <code>output_columns</code> or <code>merged_{column}</code> for each column in <code>columns</code>.</p>"},{"location":"reference/distilabel/steps/combine/#distilabel.steps.combine.CombineColumns.process","title":"<code>process(*inputs)</code>","text":"<p>The <code>process</code> method calls the <code>combine_dicts</code> function to handle and combine a list of <code>StepInput</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*inputs</code> <code>StepInput</code> <p>A list of <code>StepInput</code> to be combined.</p> <code>()</code> <p>Yields:</p> Type Description <code>StepOutput</code> <p>A <code>StepOutput</code> with the combined <code>StepInput</code> using the <code>combine_dicts</code> function.</p> Source code in <code>src/distilabel/steps/combine.py</code> <pre><code>@override\ndef process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n    \"\"\"The `process` method calls the `combine_dicts` function to handle and combine a list of `StepInput`.\n\n    Args:\n        *inputs: A list of `StepInput` to be combined.\n\n    Yields:\n        A `StepOutput` with the combined `StepInput` using the `combine_dicts` function.\n    \"\"\"\n    yield combine_dicts(\n        *inputs,\n        merge_keys=self.inputs,\n        output_merge_keys=self.outputs,\n    )\n</code></pre>"},{"location":"reference/distilabel/steps/conversation/","title":"Conversation","text":""},{"location":"reference/distilabel/steps/conversation/#distilabel.steps.conversation.ConversationTemplate","title":"<code>ConversationTemplate</code>","text":"<p>             Bases: <code>Step</code></p> <p>Generate a conversation template from an instruction and a response.</p> Input columns <ul> <li>instruction (<code>str</code>): The instruction to be used in the conversation.</li> <li>response (<code>str</code>): The response to be used in the conversation.</li> </ul> Output columns <ul> <li>conversation (<code>ChatType</code>): The conversation template.</li> </ul> Source code in <code>src/distilabel/steps/conversation.py</code> <pre><code>class ConversationTemplate(Step):\n    \"\"\"Generate a conversation template from an instruction and a response.\n\n    Input columns:\n        - instruction (`str`): The instruction to be used in the conversation.\n        - response (`str`): The response to be used in the conversation.\n\n    Output columns:\n        - conversation (`ChatType`): The conversation template.\n    \"\"\"\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The instruction and response.\"\"\"\n        return [\"instruction\", \"response\"]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The conversation template.\"\"\"\n        return [\"conversation\"]\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Generate a conversation template from an instruction and a response.\n\n        Args:\n            inputs: The input data.\n\n        Yields:\n            The input data with the conversation template.\n        \"\"\"\n        for input in inputs:\n            input[\"conversation\"] = [\n                {\"role\": \"user\", \"content\": input[\"instruction\"]},\n                {\"role\": \"assistant\", \"content\": input[\"response\"]},\n            ]\n        yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/conversation/#distilabel.steps.conversation.ConversationTemplate.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The instruction and response.</p>"},{"location":"reference/distilabel/steps/conversation/#distilabel.steps.conversation.ConversationTemplate.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The conversation template.</p>"},{"location":"reference/distilabel/steps/conversation/#distilabel.steps.conversation.ConversationTemplate.process","title":"<code>process(inputs)</code>","text":"<p>Generate a conversation template from an instruction and a response.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>The input data.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>The input data with the conversation template.</p> Source code in <code>src/distilabel/steps/conversation.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Generate a conversation template from an instruction and a response.\n\n    Args:\n        inputs: The input data.\n\n    Yields:\n        The input data with the conversation template.\n    \"\"\"\n    for input in inputs:\n        input[\"conversation\"] = [\n            {\"role\": \"user\", \"content\": input[\"instruction\"]},\n            {\"role\": \"assistant\", \"content\": input[\"response\"]},\n        ]\n    yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/decorator/","title":"Decorator","text":""},{"location":"reference/distilabel/steps/decorator/#distilabel.steps.decorator.step","title":"<code>step(inputs=None, outputs=None, step_type='normal')</code>","text":"<p>Creates an <code>Step</code> from a processing function.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Union[List[str], None]</code> <p>a list containing the name of the inputs columns/keys expected by this step. If not provided the default will be an empty list <code>[]</code> and it will be assumed that the step doesn't need any specific columns. Defaults to <code>None</code>.</p> <code>None</code> <code>outputs</code> <code>Union[List[str], None]</code> <p>a list containing the name of the outputs columns/keys that the step will generate. If not provided the default will be an empty list <code>[]</code> and it will be assumed that the step doesn't need any specific columns. Defaults to <code>None</code>.</p> <code>None</code> <code>step_type</code> <code>Literal['normal', 'global', 'generator']</code> <p>the kind of step to create. Valid choices are: \"normal\" (<code>Step</code>), \"global\" (<code>GlobalStep</code>) or \"generator\" (<code>GeneratorStep</code>). Defaults to <code>\"normal\"</code>.</p> <code>'normal'</code> <p>Returns:</p> Type Description <code>Callable[..., Type[_Step]]</code> <p>A callable that will generate the type given the processing function.</p> <p>Example:</p> <pre><code># Normal step\n@step(inputs=[\"instruction\"], outputs=[\"generation\"])\ndef GenerationStep(inputs: StepInput, dummy_generation: RuntimeParameter[str]) -&gt; StepOutput:\n    for input in inputs:\n        input[\"generation\"] = dummy_generation\n    yield inputs\n\n# Global step\n@step(inputs=[\"instruction\"], step_type=\"global\")\ndef FilteringStep(inputs: StepInput, max_length: RuntimeParameter[int] = 256) -&gt; StepOutput:\n    yield [\n        input\n        for input in inputs\n        if len(input[\"instruction\"]) &lt;= max_length\n    ]\n\n# Generator step\n@step(outputs=[\"num\"], step_type=\"generator\")\ndef RowGenerator(num_rows: RuntimeParameter[int] = 500) -&gt; GeneratorStepOutput:\n    data = list(range(num_rows))\n    for i in range(0, len(data), 100):\n        last_batch = i + 100 &gt;= len(data)\n        yield [{\"num\": num} for num in data[i : i + 100]], last_batch\n</code></pre> Source code in <code>src/distilabel/steps/decorator.py</code> <pre><code>def step(\n    inputs: Union[List[str], None] = None,\n    outputs: Union[List[str], None] = None,\n    step_type: Literal[\"normal\", \"global\", \"generator\"] = \"normal\",\n) -&gt; Callable[..., Type[\"_Step\"]]:\n    \"\"\"Creates an `Step` from a processing function.\n\n    Args:\n        inputs: a list containing the name of the inputs columns/keys expected by this step.\n            If not provided the default will be an empty list `[]` and it will be assumed\n            that the step doesn't need any specific columns. Defaults to `None`.\n        outputs: a list containing the name of the outputs columns/keys that the step\n            will generate. If not provided the default will be an empty list `[]` and it\n            will be assumed that the step doesn't need any specific columns. Defaults to\n            `None`.\n        step_type: the kind of step to create. Valid choices are: \"normal\" (`Step`),\n            \"global\" (`GlobalStep`) or \"generator\" (`GeneratorStep`). Defaults to\n            `\"normal\"`.\n\n    Returns:\n        A callable that will generate the type given the processing function.\n\n    Example:\n\n    ```python\n    # Normal step\n    @step(inputs=[\"instruction\"], outputs=[\"generation\"])\n    def GenerationStep(inputs: StepInput, dummy_generation: RuntimeParameter[str]) -&gt; StepOutput:\n        for input in inputs:\n            input[\"generation\"] = dummy_generation\n        yield inputs\n\n    # Global step\n    @step(inputs=[\"instruction\"], step_type=\"global\")\n    def FilteringStep(inputs: StepInput, max_length: RuntimeParameter[int] = 256) -&gt; StepOutput:\n        yield [\n            input\n            for input in inputs\n            if len(input[\"instruction\"]) &lt;= max_length\n        ]\n\n    # Generator step\n    @step(outputs=[\"num\"], step_type=\"generator\")\n    def RowGenerator(num_rows: RuntimeParameter[int] = 500) -&gt; GeneratorStepOutput:\n        data = list(range(num_rows))\n        for i in range(0, len(data), 100):\n            last_batch = i + 100 &gt;= len(data)\n            yield [{\"num\": num} for num in data[i : i + 100]], last_batch\n    ```\n    \"\"\"\n\n    inputs = inputs or []\n    outputs = outputs or []\n\n    def decorator(func: ProcessingFunc) -&gt; Type[\"_Step\"]:\n        if step_type not in _STEP_MAPPING:\n            raise ValueError(\n                f\"Invalid step type '{step_type}'. Please, review the '{func.__name__}'\"\n                \" function decorated with the `@step` decorator and provide a valid\"\n                \" `step_type`. Valid choices are: 'normal', 'global' or 'generator'.\"\n            )\n\n        BaseClass = _STEP_MAPPING[step_type]\n\n        signature = inspect.signature(func)\n\n        runtime_parameters = {\n            name: (\n                param.annotation,\n                param.default if param.default != param.empty else None,\n            )\n            for name, param in signature.parameters.items()\n        }\n\n        runtime_parameters = {}\n        step_input_parameter = None\n        for name, param in signature.parameters.items():\n            if is_parameter_annotated_with(param, _RUNTIME_PARAMETER_ANNOTATION):\n                runtime_parameters[name] = (\n                    param.annotation,\n                    param.default if param.default != param.empty else None,\n                )\n\n            if not step_type == \"generator\" and is_parameter_annotated_with(\n                param, _STEP_INPUT_ANNOTATION\n            ):\n                if step_input_parameter is not None:\n                    raise ValueError(\n                        f\"Function '{func.__name__}' has more than one parameter annotated\"\n                        f\" with `StepInput`. Please, review the '{func.__name__}' function\"\n                        \" decorated with the `@step` decorator and provide only one\"\n                        \" argument annotated with `StepInput`.\"\n                    )\n                step_input_parameter = param\n\n        RuntimeParametersModel = create_model(  # type: ignore\n            \"RuntimeParametersModel\",\n            **runtime_parameters,  # type: ignore\n        )\n\n        def inputs_property(self) -&gt; List[str]:\n            return inputs\n\n        def outputs_property(self) -&gt; List[str]:\n            return outputs\n\n        def process(\n            self, *args: Any, **kwargs: Any\n        ) -&gt; Union[\"StepOutput\", \"GeneratorStepOutput\"]:\n            return func(*args, **kwargs)\n\n        return type(  # type: ignore\n            func.__name__,\n            (\n                BaseClass,\n                RuntimeParametersModel,\n            ),\n            {\n                \"process\": process,\n                \"inputs\": property(inputs_property),\n                \"outputs\": property(outputs_property),\n                \"__module__\": func.__module__,\n                \"__doc__\": func.__doc__,\n                \"_built_from_decorator\": True,\n                # Override the `get_process_step_input` method to return the parameter\n                # of the original function annotated with `StepInput`.\n                \"get_process_step_input\": lambda self: step_input_parameter,\n            },\n        )\n\n    return decorator\n</code></pre>"},{"location":"reference/distilabel/steps/deita/","title":"Deita","text":""},{"location":"reference/distilabel/steps/deita/#distilabel.steps.deita.DeitaFiltering","title":"<code>DeitaFiltering</code>","text":"<p>             Bases: <code>GlobalStep</code></p> <p>Filter the dataset based on the DEITA score and the cosine distance between the embeddings. It's an implementation of the filtering step from the paper 'What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.</p> <p>Attributes:</p> Name Type Description <code>data_budget</code> <code>RuntimeParameter[int]</code> <p>The desired size of the dataset after filtering.</p> <code>diversity_threshold</code> <code>RuntimeParameter[float]</code> <p>If a row has a cosine distance with respect to it's nearest neighbor greater than this value, it will be included in the filtered dataset. Defaults to <code>0.9</code>.</p> <code>normalize_embeddings</code> <code>RuntimeParameter[bool]</code> <p>Whether to normalize the embeddings before computing the cosine distance. Defaults to <code>True</code>.</p> Runtime parameters <ul> <li><code>data_budget</code>: The desired size of the dataset after filtering.</li> <li><code>diversity_threshold</code>: If a row has a cosine distance with respect to it's nearest     neighbor greater than this value, it will be included in the filtered dataset.</li> </ul> Input columns <ul> <li>evol_instruction_score (<code>float</code>): The score of the instruction generated by     <code>ComplexityScorer</code> step.</li> <li>evol_response_score (<code>float</code>): The score of the response generated by     <code>QualityScorer</code> step.</li> <li>embedding (<code>List[float]</code>): The embedding generated for the conversation of the     instruction-response pair using <code>GenerateEmbeddings</code> step.</li> </ul> Output columns <ul> <li>deita_score (<code>float</code>): The DEITA score for the instruction-response pair.</li> <li>deita_score_computed_with (<code>List[str]</code>): The scores used to compute the DEITA     score.</li> <li>nearest_neighbor_distance (<code>float</code>): The cosine distance between the embeddings     of the instruction-response pair.</li> </ul> References <ul> <li><code>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</code></li> </ul> Source code in <code>src/distilabel/steps/deita.py</code> <pre><code>class DeitaFiltering(GlobalStep):\n    \"\"\"Filter the dataset based on the DEITA score and the cosine distance between the embeddings.\n    It's an implementation of the filtering step from the paper 'What Makes Good Data\n    for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.\n\n    Attributes:\n        data_budget: The desired size of the dataset after filtering.\n        diversity_threshold: If a row has a cosine distance with respect to it's nearest\n            neighbor greater than this value, it will be included in the filtered dataset.\n            Defaults to `0.9`.\n        normalize_embeddings: Whether to normalize the embeddings before computing the cosine\n            distance. Defaults to `True`.\n\n    Runtime parameters:\n        - `data_budget`: The desired size of the dataset after filtering.\n        - `diversity_threshold`: If a row has a cosine distance with respect to it's nearest\n            neighbor greater than this value, it will be included in the filtered dataset.\n\n    Input columns:\n        - evol_instruction_score (`float`): The score of the instruction generated by\n            `ComplexityScorer` step.\n        - evol_response_score (`float`): The score of the response generated by\n            `QualityScorer` step.\n        - embedding (`List[float]`): The embedding generated for the conversation of the\n            instruction-response pair using `GenerateEmbeddings` step.\n\n    Output columns:\n        - deita_score (`float`): The DEITA score for the instruction-response pair.\n        - deita_score_computed_with (`List[str]`): The scores used to compute the DEITA\n            score.\n        - nearest_neighbor_distance (`float`): The cosine distance between the embeddings\n            of the instruction-response pair.\n\n    References:\n        - [`What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning`](https://arxiv.org/abs/2312.15685)\n    \"\"\"\n\n    data_budget: RuntimeParameter[int] = Field(\n        default=None, description=\"The desired size of the dataset after filtering.\"\n    )\n    diversity_threshold: RuntimeParameter[float] = Field(\n        default=0.9,\n        description=\"If a row has a cosine distance with respect to it's nearest neighbor\"\n        \" greater than this value, it will be included in the filtered dataset.\",\n    )\n    normalize_embeddings: RuntimeParameter[bool] = Field(\n        default=True,\n        description=\"Whether to normalize the embeddings before computing the cosine distance.\",\n    )\n    distance_metric: RuntimeParameter[Literal[\"cosine\", \"manhattan\"]] = Field(\n        default=\"cosine\",\n        description=\"The distance metric to use. Currently only 'cosine' is supported.\",\n    )\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        return [\"evol_instruction_score\", \"evol_response_score\", \"embedding\"]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        return [\"deita_score\", \"nearest_neighbor_distance\", \"deita_score_computed_with\"]\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Filter the dataset based on the DEITA score and the cosine distance between the\n        embeddings.\n\n        Args:\n            inputs: The input data.\n\n        Returns:\n            The filtered dataset.\n        \"\"\"\n        inputs = self._compute_deita_score(inputs)\n        inputs = self._compute_nearest_neighbor(inputs)\n        inputs.sort(key=lambda x: x[\"deita_score\"], reverse=True)\n\n        selected_rows = []\n        for input in inputs:\n            if len(selected_rows) &gt;= self.data_budget:  # type: ignore\n                break\n            if input[\"nearest_neighbor_distance\"] &gt;= self.diversity_threshold:\n                selected_rows.append(input)\n        yield selected_rows\n\n    def _compute_deita_score(self, inputs: StepInput) -&gt; StepInput:\n        \"\"\"Computes the DEITA score for each instruction-response pair. The DEITA score is\n        the product of the instruction score and the response score.\n\n        Args:\n            inputs: The input data.\n\n        Returns:\n            The input data with the DEITA score computed.\n        \"\"\"\n        for input_ in inputs:\n            evol_instruction_score = input_.get(\"evol_instruction_score\")\n            evol_response_score = input_.get(\"evol_response_score\")\n\n            if evol_instruction_score and evol_response_score:\n                deita_score = evol_instruction_score * evol_response_score\n                score_computed_with = [\"evol_instruction_score\", \"evol_response_score\"]\n            elif evol_instruction_score:\n                self._logger.warning(\n                    \"Response score is missing for the instruction-response pair. Using\"\n                    \" instruction score as DEITA score.\"\n                )\n                deita_score = evol_instruction_score\n                score_computed_with = [\"evol_instruction_score\"]\n            elif evol_response_score:\n                self._logger.warning(\n                    \"Instruction score is missing for the instruction-response pair. Using\"\n                    \" response score as DEITA score.\"\n                )\n                deita_score = evol_response_score\n                score_computed_with = [\"evol_response_score\"]\n            else:\n                self._logger.warning(\n                    \"Instruction and response scores are missing for the instruction-response\"\n                    \" pair. Setting DEITA score to 0.\"\n                )\n                deita_score = 0\n                score_computed_with = []\n\n            input_.update(\n                {\n                    \"deita_score\": deita_score,\n                    \"deita_score_computed_with\": score_computed_with,\n                }\n            )\n        return inputs\n\n    def _compute_nearest_neighbor(self, inputs: StepInput) -&gt; StepInput:\n        \"\"\"Computes the cosine distance between the embeddings of the instruction-response\n        pairs and the nearest neighbor.\n\n        Args:\n            inputs: The input data.\n\n        Returns:\n            The input data with the cosine distance computed.\n        \"\"\"\n        embeddings = np.array([input[\"embedding\"] for input in inputs])\n        if self.normalize_embeddings:\n            embeddings = self._normalize_embeddings(embeddings)\n        self._logger.info(\"\ud83d\udccf Computing nearest neighbor distance...\")\n\n        if self.distance_metric == \"cosine\":\n            self._logger.info(\"\ud83d\udccf Using cosine distance.\")\n            distances = self._cosine_distance(embeddings)\n        else:\n            self._logger.info(\"\ud83d\udccf Using manhattan distance.\")\n            distances = self._manhattan_distance(embeddings)\n\n        for distance, input in zip(distances, inputs):\n            input[\"nearest_neighbor_distance\"] = distance\n        return inputs\n\n    def _normalize_embeddings(self, embeddings: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Normalize the embeddings.\n\n        Args:\n            embeddings: The embeddings to normalize.\n\n        Returns:\n            The normalized embeddings.\n        \"\"\"\n        self._logger.info(\"\u2696\ufe0f Normalizing embeddings...\")\n        norms = np.linalg.norm(embeddings, axis=1, keepdims=True)\n        return embeddings / norms\n\n    def _cosine_distance(self, embeddings: np.array) -&gt; np.array:  # type: ignore\n        \"\"\"Computes the cosine distance between the embeddings.\n\n        Args:\n            embeddings: The embeddings.\n\n        Returns:\n            The cosine distance between the embeddings.\n        \"\"\"\n        cosine_similarity = np.dot(embeddings, embeddings.T)\n        cosine_distance = 1 - cosine_similarity\n        # Ignore self-distance\n        np.fill_diagonal(cosine_distance, np.inf)\n        return np.min(cosine_distance, axis=1)\n\n    def _manhattan_distance(self, embeddings: np.array) -&gt; np.array:  # type: ignore\n        \"\"\"Computes the manhattan distance between the embeddings.\n\n        Args:\n            embeddings: The embeddings.\n\n        Returns:\n            The manhattan distance between the embeddings.\n        \"\"\"\n        manhattan_distance = np.abs(embeddings[:, None] - embeddings).sum(-1)\n        # Ignore self-distance\n        np.fill_diagonal(manhattan_distance, np.inf)\n        return np.min(manhattan_distance, axis=1)\n</code></pre>"},{"location":"reference/distilabel/steps/deita/#distilabel.steps.deita.DeitaFiltering.process","title":"<code>process(inputs)</code>","text":"<p>Filter the dataset based on the DEITA score and the cosine distance between the embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>The input data.</p> required <p>Returns:</p> Type Description <code>StepOutput</code> <p>The filtered dataset.</p> Source code in <code>src/distilabel/steps/deita.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Filter the dataset based on the DEITA score and the cosine distance between the\n    embeddings.\n\n    Args:\n        inputs: The input data.\n\n    Returns:\n        The filtered dataset.\n    \"\"\"\n    inputs = self._compute_deita_score(inputs)\n    inputs = self._compute_nearest_neighbor(inputs)\n    inputs.sort(key=lambda x: x[\"deita_score\"], reverse=True)\n\n    selected_rows = []\n    for input in inputs:\n        if len(selected_rows) &gt;= self.data_budget:  # type: ignore\n            break\n        if input[\"nearest_neighbor_distance\"] &gt;= self.diversity_threshold:\n            selected_rows.append(input)\n    yield selected_rows\n</code></pre>"},{"location":"reference/distilabel/steps/expand/","title":"Expand","text":""},{"location":"reference/distilabel/steps/expand/#distilabel.steps.expand.ExpandColumns","title":"<code>ExpandColumns</code>","text":"<p>             Bases: <code>Step</code></p> <p>Expand columns that contain lists into multiple rows.</p> <p>Attributes:</p> Name Type Description <code>columns</code> <code>Union[Dict[str, str], List[str]]</code> <p>A dictionary that maps the column to be expanded to the new column name or a list of columns to be expanded. If a list is provided, the new column name will be the same as the column name.</p> Input columns <ul> <li>The columns to be expanded.</li> </ul> Output columns <ul> <li>The expanded columns.</li> </ul> Source code in <code>src/distilabel/steps/expand.py</code> <pre><code>class ExpandColumns(Step):\n    \"\"\"Expand columns that contain lists into multiple rows.\n\n    Attributes:\n        columns: A dictionary that maps the column to be expanded to the new column name\n            or a list of columns to be expanded. If a list is provided, the new column name\n            will be the same as the column name.\n\n    Input columns:\n        - The columns to be expanded.\n\n    Output columns:\n        - The expanded columns.\n    \"\"\"\n\n    columns: Union[Dict[str, str], List[str]]\n\n    @field_validator(\"columns\")\n    @classmethod\n    def always_dict(cls, value: Union[Dict[str, str], List[str]]) -&gt; Dict[str, str]:\n        \"\"\"Ensure that the columns are always a dictionary.\n\n        Args:\n            value: The columns to be expanded.\n\n        Returns:\n            The columns to be expanded as a dictionary.\n        \"\"\"\n        if isinstance(value, list):\n            return {col: col for col in value}\n\n        return value\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The columns to be expanded.\"\"\"\n        return list(self.columns.keys())\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The expanded columns.\"\"\"\n        return [\n            new_column if new_column else expand_column\n            for expand_column, new_column in self.columns.items()\n        ]\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Expand the columns in the input data.\n\n        Args:\n            inputs: The input data.\n\n        Yields:\n            The expanded rows.\n        \"\"\"\n        yield [row for input in inputs for row in self._expand_columns(input)]\n\n    def _expand_columns(self, input: Dict[str, Any]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Expand the columns in the input data.\n\n        Args:\n            input: The input data.\n\n        Returns:\n            The expanded rows.\n        \"\"\"\n        expanded_rows = []\n        for expand_column, new_column in self.columns.items():  # type: ignore\n            data = input.get(expand_column)\n            rows = []\n            for item, expanded in zip_longest(*[data, expanded_rows], fillvalue=input):\n                rows.append({**expanded, new_column: item})\n            expanded_rows = rows\n        return expanded_rows\n</code></pre>"},{"location":"reference/distilabel/steps/expand/#distilabel.steps.expand.ExpandColumns.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The columns to be expanded.</p>"},{"location":"reference/distilabel/steps/expand/#distilabel.steps.expand.ExpandColumns.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The expanded columns.</p>"},{"location":"reference/distilabel/steps/expand/#distilabel.steps.expand.ExpandColumns.always_dict","title":"<code>always_dict(value)</code>  <code>classmethod</code>","text":"<p>Ensure that the columns are always a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[Dict[str, str], List[str]]</code> <p>The columns to be expanded.</p> required <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>The columns to be expanded as a dictionary.</p> Source code in <code>src/distilabel/steps/expand.py</code> <pre><code>@field_validator(\"columns\")\n@classmethod\ndef always_dict(cls, value: Union[Dict[str, str], List[str]]) -&gt; Dict[str, str]:\n    \"\"\"Ensure that the columns are always a dictionary.\n\n    Args:\n        value: The columns to be expanded.\n\n    Returns:\n        The columns to be expanded as a dictionary.\n    \"\"\"\n    if isinstance(value, list):\n        return {col: col for col in value}\n\n    return value\n</code></pre>"},{"location":"reference/distilabel/steps/expand/#distilabel.steps.expand.ExpandColumns.process","title":"<code>process(inputs)</code>","text":"<p>Expand the columns in the input data.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>The input data.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>The expanded rows.</p> Source code in <code>src/distilabel/steps/expand.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Expand the columns in the input data.\n\n    Args:\n        inputs: The input data.\n\n    Yields:\n        The expanded rows.\n    \"\"\"\n    yield [row for input in inputs for row in self._expand_columns(input)]\n</code></pre>"},{"location":"reference/distilabel/steps/keep/","title":"Keep","text":""},{"location":"reference/distilabel/steps/keep/#distilabel.steps.keep.KeepColumns","title":"<code>KeepColumns</code>","text":"<p>             Bases: <code>Step</code></p> <p>KeepColumns is a Step that implements the <code>process</code> method that keeps only the columns specified in the <code>columns</code> attribute. Also <code>KeepColumns</code> provides an attribute <code>columns</code> to specify the columns to keep which will override the default value for the properties <code>inputs</code> and <code>outputs</code>.</p> Note <p>The order in which the columns are provided is important, as the output will be sorted using the provided order, which is useful before pushing either a <code>dataset.Dataset</code> via the <code>PushToHub</code> step or a <code>distilabel.Distiset</code> via the <code>Pipeline.run</code> output variable.</p> <p>Attributes:</p> Name Type Description <code>columns</code> <code>List[str]</code> <p>List of strings with the names of the columns to keep.</p> Input columns <ul> <li>dynamic, based on the <code>columns</code> value provided.</li> </ul> Output columns <ul> <li>dynamic, based on the <code>columns</code> value provided.</li> </ul> Source code in <code>src/distilabel/steps/keep.py</code> <pre><code>class KeepColumns(Step):\n    \"\"\"KeepColumns is a Step that implements the `process` method that keeps only the columns\n    specified in the `columns` attribute. Also `KeepColumns` provides an attribute `columns` to\n    specify the columns to keep which will override the default value for the properties `inputs`\n    and `outputs`.\n\n    Note:\n        The order in which the columns are provided is important, as the output will be sorted\n        using the provided order, which is useful before pushing either a `dataset.Dataset` via\n        the `PushToHub` step or a `distilabel.Distiset` via the `Pipeline.run` output variable.\n\n    Attributes:\n        columns: List of strings with the names of the columns to keep.\n\n    Input columns:\n        - dynamic, based on the `columns` value provided.\n\n    Output columns:\n        - dynamic, based on the `columns` value provided.\n    \"\"\"\n\n    columns: List[str]\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The inputs for the task are the column names in `columns`.\"\"\"\n        return self.columns\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The outputs for the task are the column names in `columns`.\"\"\"\n        return self.columns\n\n    @override\n    def process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n        \"\"\"The `process` method keeps only the columns specified in the `columns` attribute.\n\n        Args:\n            *inputs: A list of dictionaries with the input data.\n\n        Yields:\n            A list of dictionaries with the output data.\n        \"\"\"\n        for input in inputs:\n            outputs = []\n            for item in input:\n                outputs.append({col: item[col] for col in self.columns})\n            yield outputs\n</code></pre>"},{"location":"reference/distilabel/steps/keep/#distilabel.steps.keep.KeepColumns.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The inputs for the task are the column names in <code>columns</code>.</p>"},{"location":"reference/distilabel/steps/keep/#distilabel.steps.keep.KeepColumns.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The outputs for the task are the column names in <code>columns</code>.</p>"},{"location":"reference/distilabel/steps/keep/#distilabel.steps.keep.KeepColumns.process","title":"<code>process(*inputs)</code>","text":"<p>The <code>process</code> method keeps only the columns specified in the <code>columns</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>*inputs</code> <code>StepInput</code> <p>A list of dictionaries with the input data.</p> <code>()</code> <p>Yields:</p> Type Description <code>StepOutput</code> <p>A list of dictionaries with the output data.</p> Source code in <code>src/distilabel/steps/keep.py</code> <pre><code>@override\ndef process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n    \"\"\"The `process` method keeps only the columns specified in the `columns` attribute.\n\n    Args:\n        *inputs: A list of dictionaries with the input data.\n\n    Yields:\n        A list of dictionaries with the output data.\n    \"\"\"\n    for input in inputs:\n        outputs = []\n        for item in input:\n            outputs.append({col: item[col] for col in self.columns})\n        yield outputs\n</code></pre>"},{"location":"reference/distilabel/steps/typing/","title":"Typing","text":""},{"location":"reference/distilabel/steps/typing/#distilabel.steps.typing.GeneratorStepOutput","title":"<code>GeneratorStepOutput = Iterator[Tuple[List[Dict[str, Any]], bool]]</code>  <code>module-attribute</code>","text":"<p>GeneratorStepOutput is an alias of the typing <code>Iterator[Tuple[List[Dict[str, Any]], bool]]</code></p>"},{"location":"reference/distilabel/steps/typing/#distilabel.steps.typing.StepOutput","title":"<code>StepOutput = Iterator[List[Dict[str, Any]]]</code>  <code>module-attribute</code>","text":"<p>StepOutput is an alias of the typing <code>Iterator[List[Dict[str, Any]]]</code></p>"},{"location":"reference/distilabel/steps/argilla/","title":"Index","text":""},{"location":"reference/distilabel/steps/argilla/base/","title":"Base","text":""},{"location":"reference/distilabel/steps/argilla/base/#distilabel.steps.argilla.base.Argilla","title":"<code>Argilla</code>","text":"<p>             Bases: <code>Step</code>, <code>ABC</code></p> <p>Abstract step that provides a class to subclass from, that contains the boilerplate code required to interact with Argilla, as well as some extra validations on top of it. It also defines the abstract methods that need to be implemented in order to add a new dataset type as a step.</p> Note <p>This class is not intended to be instanced directly, but via subclass.</p> <p>Attributes:</p> Name Type Description <code>dataset_name</code> <code>str</code> <p>The name of the dataset in Argilla.</p> <code>dataset_workspace</code> <code>Optional[str]</code> <p>The workspace where the dataset will be created in Argilla. Defaults to None, which means it will be created in the default workspace.</p> <code>api_url</code> <code>Optional[RuntimeParameter[str]]</code> <p>The URL of the Argilla API. Defaults to <code>None</code>, which means it will be read from the <code>ARGILLA_API_URL</code> environment variable.</p> <code>api_key</code> <code>Optional[RuntimeParameter[SecretStr]]</code> <p>The API key to authenticate with Argilla. Defaults to <code>None</code>, which means it will be read from the <code>ARGILLA_API_KEY</code> environment variable.</p> Runtime parameters <ul> <li><code>api_url</code>: The base URL to use for the Argilla API requests.</li> <li><code>api_key</code>: The API key to authenticate the requests to the Argilla API.</li> </ul> Input columns <ul> <li>dynamic, based on the <code>inputs</code> value provided</li> </ul> Source code in <code>src/distilabel/steps/argilla/base.py</code> <pre><code>class Argilla(Step, ABC):\n    \"\"\"Abstract step that provides a class to subclass from, that contains the boilerplate code\n    required to interact with Argilla, as well as some extra validations on top of it. It also defines\n    the abstract methods that need to be implemented in order to add a new dataset type as a step.\n\n    Note:\n        This class is not intended to be instanced directly, but via subclass.\n\n    Attributes:\n        dataset_name: The name of the dataset in Argilla.\n        dataset_workspace: The workspace where the dataset will be created in Argilla. Defaults to\n            None, which means it will be created in the default workspace.\n        api_url: The URL of the Argilla API. Defaults to `None`, which means it will be read from\n            the `ARGILLA_API_URL` environment variable.\n        api_key: The API key to authenticate with Argilla. Defaults to `None`, which means it will\n            be read from the `ARGILLA_API_KEY` environment variable.\n\n    Runtime parameters:\n        - `api_url`: The base URL to use for the Argilla API requests.\n        - `api_key`: The API key to authenticate the requests to the Argilla API.\n\n    Input columns:\n        - dynamic, based on the `inputs` value provided\n    \"\"\"\n\n    dataset_name: str\n    dataset_workspace: Optional[str] = None\n\n    api_url: Optional[RuntimeParameter[str]] = Field(\n        default_factory=lambda: os.getenv(\"ARGILLA_BASE_URL\"),\n        description=\"The base URL to use for the Argilla API requests.\",\n    )\n    api_key: Optional[RuntimeParameter[SecretStr]] = Field(\n        default_factory=lambda: os.getenv(_ARGILLA_API_KEY_ENV_VAR_NAME),\n        description=\"The API key to authenticate the requests to the Argilla API.\",\n    )\n\n    _rg_dataset: Optional[\"RemoteFeedbackDataset\"] = PrivateAttr(...)\n\n    def model_post_init(self, __context: Any) -&gt; None:\n        \"\"\"Checks that the Argilla Python SDK is installed, and then filters the Argilla warnings.\"\"\"\n        try:\n            import argilla as rg  # noqa\n        except ImportError as ie:\n            raise ImportError(\n                \"Argilla is not installed. Please install it using `pip install argilla`.\"\n            ) from ie\n\n        warnings.filterwarnings(\"ignore\")\n        return super().model_post_init(__context)\n\n    def _rg_init(self) -&gt; None:\n        \"\"\"Initializes the Argilla API client with the provided `api_url` and `api_key`.\"\"\"\n        try:\n            if \"hf.space\" in self.api_url and \"HF_TOKEN\" in os.environ:\n                headers = {\"Authorization\": f\"Bearer {os.environ['HF_TOKEN']}\"}\n            else:\n                headers = None\n            rg.init(\n                api_url=self.api_url,\n                api_key=self.api_key.get_secret_value(),\n                extra_headers=headers,\n            )  # type: ignore\n        except Exception as e:\n            raise ValueError(f\"Failed to initialize the Argilla API: {e}\") from e\n\n    def _rg_dataset_exists(self) -&gt; bool:\n        \"\"\"Checks if the dataset already exists in Argilla.\"\"\"\n        return self.dataset_name in [\n            dataset.name\n            for dataset in rg.FeedbackDataset.list(workspace=self.dataset_workspace)  # type: ignore\n        ]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The outputs of the step is an empty list, since the steps subclassing from this one, will\n        always be leaf nodes and won't propagate the inputs neither generate any outputs.\n        \"\"\"\n        return []\n\n    def load(self) -&gt; None:\n        \"\"\"Method to perform any initialization logic before the `process` method is\n        called. For example, to load an LLM, stablish a connection to a database, etc.\n        \"\"\"\n        super().load()\n\n    @property\n    @abstractmethod\n    def inputs(self) -&gt; List[str]:\n        ...\n\n    @abstractmethod\n    def process(self, *inputs: StepInput) -&gt; \"StepOutput\":\n        ...\n</code></pre>"},{"location":"reference/distilabel/steps/argilla/base/#distilabel.steps.argilla.base.Argilla.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The outputs of the step is an empty list, since the steps subclassing from this one, will always be leaf nodes and won't propagate the inputs neither generate any outputs.</p>"},{"location":"reference/distilabel/steps/argilla/base/#distilabel.steps.argilla.base.Argilla.load","title":"<code>load()</code>","text":"<p>Method to perform any initialization logic before the <code>process</code> method is called. For example, to load an LLM, stablish a connection to a database, etc.</p> Source code in <code>src/distilabel/steps/argilla/base.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Method to perform any initialization logic before the `process` method is\n    called. For example, to load an LLM, stablish a connection to a database, etc.\n    \"\"\"\n    super().load()\n</code></pre>"},{"location":"reference/distilabel/steps/argilla/base/#distilabel.steps.argilla.base.Argilla.model_post_init","title":"<code>model_post_init(__context)</code>","text":"<p>Checks that the Argilla Python SDK is installed, and then filters the Argilla warnings.</p> Source code in <code>src/distilabel/steps/argilla/base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Checks that the Argilla Python SDK is installed, and then filters the Argilla warnings.\"\"\"\n    try:\n        import argilla as rg  # noqa\n    except ImportError as ie:\n        raise ImportError(\n            \"Argilla is not installed. Please install it using `pip install argilla`.\"\n        ) from ie\n\n    warnings.filterwarnings(\"ignore\")\n    return super().model_post_init(__context)\n</code></pre>"},{"location":"reference/distilabel/steps/argilla/preference/","title":"Preference","text":""},{"location":"reference/distilabel/steps/argilla/preference/#distilabel.steps.argilla.preference.PreferenceToArgilla","title":"<code>PreferenceToArgilla</code>","text":"<p>             Bases: <code>Argilla</code></p> <p>Step that creates a dataset in Argilla during the load phase, and then pushes the input batches into it as records. This dataset is a preference dataset, where there's one field for the instruction and one extra field per each generation within the same record, and then a rating question per each of the generation fields. The rating question asks the annotator to set a rating from 1 to 5 for each of the provided generations.</p> Note <p>This step is meant to be used in conjunction with the <code>UltraFeedback</code> step, or any other step generating both ratings and responses for a given set of instruction and generations for the given instruction. But alternatively, it can also be used with any other task or step generating only the <code>instruction</code> and <code>generations</code>, as the <code>ratings</code> and <code>rationales</code> are optional.</p> <p>Attributes:</p> Name Type Description <code>num_generations</code> <code>int</code> <p>The number of generations to include in the dataset.</p> <code>dataset_name</code> <code>int</code> <p>The name of the dataset in Argilla.</p> <code>dataset_workspace</code> <code>int</code> <p>The workspace where the dataset will be created in Argilla. Defaults to <code>None</code>, which means it will be created in the default workspace.</p> <code>api_url</code> <code>int</code> <p>The URL of the Argilla API. Defaults to <code>None</code>, which means it will be read from the <code>ARGILLA_API_URL</code> environment variable.</p> <code>api_key</code> <code>int</code> <p>The API key to authenticate with Argilla. Defaults to <code>None</code>, which means it will be read from the <code>ARGILLA_API_KEY</code> environment variable.</p> Runtime parameters <ul> <li><code>api_url</code>: The base URL to use for the Argilla API requests.</li> <li><code>api_key</code>: The API key to authenticate the requests to the Argilla API.</li> </ul> Input columns <ul> <li>instruction (<code>str</code>): The instruction that was used to generate the completion.</li> <li>generations (<code>List[str]</code>): The completion that was generated based on the input instruction.</li> <li>ratings (<code>List[str]</code>, optional): The ratings for the generations. If not provided, the     generated ratings won't be pushed to Argilla.</li> <li>rationales (<code>List[str]</code>, optional): The rationales for the ratings. If not provided, the     generated rationales won't be pushed to Argilla.</li> </ul> Source code in <code>src/distilabel/steps/argilla/preference.py</code> <pre><code>class PreferenceToArgilla(Argilla):\n    \"\"\"Step that creates a dataset in Argilla during the load phase, and then pushes the input\n    batches into it as records. This dataset is a preference dataset, where there's one field\n    for the instruction and one extra field per each generation within the same record, and then\n    a rating question per each of the generation fields. The rating question asks the annotator to\n    set a rating from 1 to 5 for each of the provided generations.\n\n    Note:\n        This step is meant to be used in conjunction with the `UltraFeedback` step, or any other step\n        generating both ratings and responses for a given set of instruction and generations for the\n        given instruction. But alternatively, it can also be used with any other task or step generating\n        only the `instruction` and `generations`, as the `ratings` and `rationales` are optional.\n\n    Attributes:\n        num_generations: The number of generations to include in the dataset.\n        dataset_name: The name of the dataset in Argilla.\n        dataset_workspace: The workspace where the dataset will be created in Argilla. Defaults to\n            `None`, which means it will be created in the default workspace.\n        api_url: The URL of the Argilla API. Defaults to `None`, which means it will be read from\n            the `ARGILLA_API_URL` environment variable.\n        api_key: The API key to authenticate with Argilla. Defaults to `None`, which means it will\n            be read from the `ARGILLA_API_KEY` environment variable.\n\n    Runtime parameters:\n        - `api_url`: The base URL to use for the Argilla API requests.\n        - `api_key`: The API key to authenticate the requests to the Argilla API.\n\n    Input columns:\n        - instruction (`str`): The instruction that was used to generate the completion.\n        - generations (`List[str]`): The completion that was generated based on the input instruction.\n        - ratings (`List[str]`, optional): The ratings for the generations. If not provided, the\n            generated ratings won't be pushed to Argilla.\n        - rationales (`List[str]`, optional): The rationales for the ratings. If not provided, the\n            generated rationales won't be pushed to Argilla.\n    \"\"\"\n\n    num_generations: int\n\n    _id: str = PrivateAttr(default=\"id\")\n    _instruction: str = PrivateAttr(...)\n    _generations: str = PrivateAttr(...)\n    _ratings: str = PrivateAttr(...)\n    _rationales: str = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Sets the `_instruction` and `_generations` attributes based on the `inputs_mapping`, otherwise\n        uses the default values; and then uses those values to create a `FeedbackDataset` suited for\n        the text-generation scenario. And then it pushes it to Argilla.\n        \"\"\"\n        super().load()\n\n        self._rg_init()\n\n        # Both `instruction` and `generations` will be used as the fields of the dataset\n        self._instruction = self.input_mappings.get(\"instruction\", \"instruction\")\n        self._generations = self.input_mappings.get(\"generations\", \"generations\")\n        # Both `ratings` and `rationales` will be used as suggestions to the default questions of the dataset\n        self._ratings = self.input_mappings.get(\"ratings\", \"ratings\")\n        self._rationales = self.input_mappings.get(\"rationales\", \"rationales\")\n\n        if self._rg_dataset_exists():\n            _rg_dataset = rg.FeedbackDataset.from_argilla(  # type: ignore\n                name=self.dataset_name,\n                workspace=self.dataset_workspace,\n            )\n\n            for field in _rg_dataset.fields:\n                if (\n                    field.name\n                    not in [self._id, self._instruction]\n                    + [\n                        f\"{self._generations}-{idx}\"\n                        for idx in range(self.num_generations)\n                    ]\n                    and field.required\n                ):\n                    raise ValueError(\n                        f\"The dataset {self.dataset_name} in the workspace {self.dataset_workspace} already exists,\"\n                        f\" but contains at least a required field that is neither `{self._id}`, `{self._instruction}`,\"\n                        f\" nor `{self._generations}`.\"\n                    )\n\n            self._rg_dataset = _rg_dataset\n        else:\n            _rg_dataset = rg.FeedbackDataset(  # type: ignore\n                fields=[\n                    rg.TextField(name=self._id, title=self._id),  # type: ignore\n                    rg.TextField(name=self._instruction, title=self._instruction),  # type: ignore\n                    *self._generation_fields(),  # type: ignore\n                ],\n                questions=self._rating_rationale_pairs(),  # type: ignore\n            )\n            self._rg_dataset = _rg_dataset.push_to_argilla(\n                name=self.dataset_name, workspace=self.dataset_workspace\n            )\n\n    def _generation_fields(self) -&gt; List[\"TextField\"]:\n        \"\"\"Method to generate the fields for each of the generations.\"\"\"\n        return [\n            rg.TextField(  # type: ignore\n                name=f\"{self._generations}-{idx}\",\n                title=f\"{self._generations}-{idx}\",\n                required=True if idx == 0 else False,\n            )\n            for idx in range(self.num_generations)\n        ]\n\n    def _rating_rationale_pairs(\n        self,\n    ) -&gt; List[Union[\"RatingQuestion\", \"TextQuestion\"]]:\n        \"\"\"Method to generate the rating and rationale questions for each of the generations.\"\"\"\n        questions = []\n        for idx in range(self.num_generations):\n            questions.extend(\n                [\n                    rg.RatingQuestion(  # type: ignore\n                        name=f\"{self._generations}-{idx}-rating\",\n                        title=f\"Rate {self._generations}-{idx} given {self._instruction} based on the annotation guidelines.\",\n                        description=f\"Ignore this question if the corresponding `{self._generations}-{idx}` field is not available.\"\n                        if idx != 0\n                        else None,\n                        values=[1, 2, 3, 4, 5],\n                        required=True if idx == 0 else False,\n                    ),\n                    rg.TextQuestion(  # type: ignore\n                        name=f\"{self._generations}-{idx}-rationale\",\n                        title=f\"Specify the rationale for {self._generations}-{idx}'s rating.\",\n                        description=f\"Ignore this question if the corresponding `{self._generations}-{idx}` field is not available.\"\n                        if idx != 0\n                        else None,\n                        required=False,\n                    ),\n                ]\n            )\n        return questions\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The inputs for the step are the `instruction` and the `generations`. Optionally, one could also\n        provide the `ratings` and the `rationales` for the generations.\"\"\"\n        return [\"instruction\", \"generations\"]\n\n    def _add_suggestions_if_any(\n        self, input: Dict[str, Any]\n    ) -&gt; List[\"SuggestionSchema\"]:\n        \"\"\"Method to generate the suggestions for the `FeedbackRecord` based on the input.\"\"\"\n        # Since the `suggestions` i.e. answers to the `questions` are optional, will default to {}\n        suggestions = []\n        # If `ratings` is in `input`, then add those as suggestions\n        if self._ratings in input:\n            suggestions.extend(\n                [\n                    {\n                        \"question_name\": f\"{self._generations}-{idx}-rating\",\n                        \"value\": rating,\n                    }\n                    for idx, rating in enumerate(input[self._ratings])\n                    if rating is not None\n                    and isinstance(rating, int)\n                    and rating in [1, 2, 3, 4, 5]\n                ],\n            )\n        # If `rationales` is in `input`, then add those as suggestions\n        if self._rationales in input:\n            suggestions.extend(\n                [\n                    {\n                        \"question_name\": f\"{self._generations}-{idx}-rationale\",\n                        \"value\": rationale,\n                    }\n                    for idx, rationale in enumerate(input[self._rationales])\n                    if rationale is not None and isinstance(rationale, str)\n                ],\n            )\n        return suggestions\n\n    @override\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Creates and pushes the records as FeedbackRecords to the Argilla dataset.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Returns:\n            A list of Python dictionaries with the outputs of the task.\n        \"\"\"\n        records = []\n        for input in inputs:\n            # Generate the SHA-256 hash of the instruction to use it as the metadata\n            instruction_id = hashlib.sha256(\n                input[\"instruction\"].encode(\"utf-8\")  # type: ignore\n            ).hexdigest()\n\n            generations = {\n                f\"{self._generations}-{idx}\": generation\n                for idx, generation in enumerate(input[\"generations\"])  # type: ignore\n            }\n\n            records.append(  # type: ignore\n                rg.FeedbackRecord(  # type: ignore\n                    fields={\n                        \"id\": instruction_id,\n                        \"instruction\": input[\"instruction\"],  # type: ignore\n                        **generations,\n                    },\n                    suggestions=self._add_suggestions_if_any(input),  # type: ignore\n                )\n            )\n        self._rg_dataset.add_records(records)  # type: ignore\n        yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/argilla/preference/#distilabel.steps.argilla.preference.PreferenceToArgilla.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The inputs for the step are the <code>instruction</code> and the <code>generations</code>. Optionally, one could also provide the <code>ratings</code> and the <code>rationales</code> for the generations.</p>"},{"location":"reference/distilabel/steps/argilla/preference/#distilabel.steps.argilla.preference.PreferenceToArgilla.load","title":"<code>load()</code>","text":"<p>Sets the <code>_instruction</code> and <code>_generations</code> attributes based on the <code>inputs_mapping</code>, otherwise uses the default values; and then uses those values to create a <code>FeedbackDataset</code> suited for the text-generation scenario. And then it pushes it to Argilla.</p> Source code in <code>src/distilabel/steps/argilla/preference.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Sets the `_instruction` and `_generations` attributes based on the `inputs_mapping`, otherwise\n    uses the default values; and then uses those values to create a `FeedbackDataset` suited for\n    the text-generation scenario. And then it pushes it to Argilla.\n    \"\"\"\n    super().load()\n\n    self._rg_init()\n\n    # Both `instruction` and `generations` will be used as the fields of the dataset\n    self._instruction = self.input_mappings.get(\"instruction\", \"instruction\")\n    self._generations = self.input_mappings.get(\"generations\", \"generations\")\n    # Both `ratings` and `rationales` will be used as suggestions to the default questions of the dataset\n    self._ratings = self.input_mappings.get(\"ratings\", \"ratings\")\n    self._rationales = self.input_mappings.get(\"rationales\", \"rationales\")\n\n    if self._rg_dataset_exists():\n        _rg_dataset = rg.FeedbackDataset.from_argilla(  # type: ignore\n            name=self.dataset_name,\n            workspace=self.dataset_workspace,\n        )\n\n        for field in _rg_dataset.fields:\n            if (\n                field.name\n                not in [self._id, self._instruction]\n                + [\n                    f\"{self._generations}-{idx}\"\n                    for idx in range(self.num_generations)\n                ]\n                and field.required\n            ):\n                raise ValueError(\n                    f\"The dataset {self.dataset_name} in the workspace {self.dataset_workspace} already exists,\"\n                    f\" but contains at least a required field that is neither `{self._id}`, `{self._instruction}`,\"\n                    f\" nor `{self._generations}`.\"\n                )\n\n        self._rg_dataset = _rg_dataset\n    else:\n        _rg_dataset = rg.FeedbackDataset(  # type: ignore\n            fields=[\n                rg.TextField(name=self._id, title=self._id),  # type: ignore\n                rg.TextField(name=self._instruction, title=self._instruction),  # type: ignore\n                *self._generation_fields(),  # type: ignore\n            ],\n            questions=self._rating_rationale_pairs(),  # type: ignore\n        )\n        self._rg_dataset = _rg_dataset.push_to_argilla(\n            name=self.dataset_name, workspace=self.dataset_workspace\n        )\n</code></pre>"},{"location":"reference/distilabel/steps/argilla/preference/#distilabel.steps.argilla.preference.PreferenceToArgilla.process","title":"<code>process(inputs)</code>","text":"<p>Creates and pushes the records as FeedbackRecords to the Argilla dataset.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>A list of Python dictionaries with the inputs of the task.</p> required <p>Returns:</p> Type Description <code>StepOutput</code> <p>A list of Python dictionaries with the outputs of the task.</p> Source code in <code>src/distilabel/steps/argilla/preference.py</code> <pre><code>@override\ndef process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Creates and pushes the records as FeedbackRecords to the Argilla dataset.\n\n    Args:\n        inputs: A list of Python dictionaries with the inputs of the task.\n\n    Returns:\n        A list of Python dictionaries with the outputs of the task.\n    \"\"\"\n    records = []\n    for input in inputs:\n        # Generate the SHA-256 hash of the instruction to use it as the metadata\n        instruction_id = hashlib.sha256(\n            input[\"instruction\"].encode(\"utf-8\")  # type: ignore\n        ).hexdigest()\n\n        generations = {\n            f\"{self._generations}-{idx}\": generation\n            for idx, generation in enumerate(input[\"generations\"])  # type: ignore\n        }\n\n        records.append(  # type: ignore\n            rg.FeedbackRecord(  # type: ignore\n                fields={\n                    \"id\": instruction_id,\n                    \"instruction\": input[\"instruction\"],  # type: ignore\n                    **generations,\n                },\n                suggestions=self._add_suggestions_if_any(input),  # type: ignore\n            )\n        )\n    self._rg_dataset.add_records(records)  # type: ignore\n    yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/argilla/text_generation/","title":"Text generation","text":""},{"location":"reference/distilabel/steps/argilla/text_generation/#distilabel.steps.argilla.text_generation.TextGenerationToArgilla","title":"<code>TextGenerationToArgilla</code>","text":"<p>             Bases: <code>Argilla</code></p> <p>Step that creates a dataset in Argilla during the load phase, and then pushes the input batches into it as records. This dataset is a text-generation dataset, where there's one field per each input, and then a label question to rate the quality of the completion in either bad (represented with \ud83d\udc4e) or good (represented with \ud83d\udc4d).</p> Note <p>This step is meant to be used in conjunction with a <code>TextGeneration</code> step and no column mapping is needed, as it will use the default values for the <code>instruction</code> and <code>generation</code> columns.</p> <p>Attributes:</p> Name Type Description <code>dataset_name</code> <p>The name of the dataset in Argilla.</p> <code>dataset_workspace</code> <p>The workspace where the dataset will be created in Argilla. Defaults to <code>None</code>, which means it will be created in the default workspace.</p> <code>api_url</code> <p>The URL of the Argilla API. Defaults to <code>None</code>, which means it will be read from the <code>ARGILLA_API_URL</code> environment variable.</p> <code>api_key</code> <p>The API key to authenticate with Argilla. Defaults to <code>None</code>, which means it will be read from the <code>ARGILLA_API_KEY</code> environment variable.</p> Runtime parameters <ul> <li><code>api_url</code>: The base URL to use for the Argilla API requests.</li> <li><code>api_key</code>: The API key to authenticate the requests to the Argilla API.</li> </ul> Input columns <ul> <li>instruction (<code>str</code>): The instruction that was used to generate the completion.</li> <li>generation (<code>str</code> or <code>List[str]</code>): The completions that were generated based on the input instruction.</li> </ul> Source code in <code>src/distilabel/steps/argilla/text_generation.py</code> <pre><code>class TextGenerationToArgilla(Argilla):\n    \"\"\"Step that creates a dataset in Argilla during the load phase, and then pushes the input\n    batches into it as records. This dataset is a text-generation dataset, where there's one field\n    per each input, and then a label question to rate the quality of the completion in either bad\n    (represented with \ud83d\udc4e) or good (represented with \ud83d\udc4d).\n\n    Note:\n        This step is meant to be used in conjunction with a `TextGeneration` step and no column mapping\n        is needed, as it will use the default values for the `instruction` and `generation` columns.\n\n    Attributes:\n        dataset_name: The name of the dataset in Argilla.\n        dataset_workspace: The workspace where the dataset will be created in Argilla. Defaults to\n            `None`, which means it will be created in the default workspace.\n        api_url: The URL of the Argilla API. Defaults to `None`, which means it will be read from\n            the `ARGILLA_API_URL` environment variable.\n        api_key: The API key to authenticate with Argilla. Defaults to `None`, which means it will\n            be read from the `ARGILLA_API_KEY` environment variable.\n\n    Runtime parameters:\n        - `api_url`: The base URL to use for the Argilla API requests.\n        - `api_key`: The API key to authenticate the requests to the Argilla API.\n\n    Input columns:\n        - instruction (`str`): The instruction that was used to generate the completion.\n        - generation (`str` or `List[str]`): The completions that were generated based on the input instruction.\n    \"\"\"\n\n    _id: str = PrivateAttr(default=\"id\")\n    _instruction: str = PrivateAttr(...)\n    _generation: str = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Sets the `_instruction` and `_generation` attributes based on the `inputs_mapping`, otherwise\n        uses the default values; and then uses those values to create a `FeedbackDataset` suited for\n        the text-generation scenario. And then it pushes it to Argilla.\n        \"\"\"\n        super().load()\n\n        self._rg_init()\n\n        self._instruction = self.input_mappings.get(\"instruction\", \"instruction\")\n        self._generation = self.input_mappings.get(\"generation\", \"generation\")\n\n        if self._rg_dataset_exists():\n            _rg_dataset = rg.FeedbackDataset.from_argilla(\n                name=self.dataset_name,\n                workspace=self.dataset_workspace,\n            )\n\n            for field in _rg_dataset.fields:\n                if (\n                    field.name not in [self._id, self._instruction, self._generation]\n                    and field.required\n                ):\n                    raise ValueError(\n                        f\"The dataset {self.dataset_name} in the workspace {self.dataset_workspace} already exists,\"\n                        f\" but contains at least a required field that is neither `{self._id}`, `{self._instruction}`\"\n                        f\", nor `{self._generation}`.\"\n                    )\n\n            self._rg_dataset = _rg_dataset\n        else:\n            _rg_dataset = rg.FeedbackDataset(\n                fields=[\n                    rg.TextField(name=self._id, title=self._id),  # type: ignore\n                    rg.TextField(name=self._instruction, title=self._instruction),  # type: ignore\n                    rg.TextField(name=self._generation, title=self._generation),  # type: ignore\n                ],\n                questions=[\n                    rg.LabelQuestion(  # type: ignore\n                        name=\"quality\",\n                        title=f\"What's the quality of the {self._generation} for the given {self._instruction}?\",\n                        labels={\"bad\": \"\ud83d\udc4e\", \"good\": \"\ud83d\udc4d\"},\n                    )\n                ],\n            )\n            self._rg_dataset = _rg_dataset.push_to_argilla(\n                name=self.dataset_name, workspace=self.dataset_workspace\n            )\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The inputs for the step are the `instruction` and the `generation`.\"\"\"\n        return [\"instruction\", \"generation\"]\n\n    @override\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Creates and pushes the records as FeedbackRecords to the Argilla dataset.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Returns:\n            A list of Python dictionaries with the outputs of the task.\n        \"\"\"\n        records = []\n        for input in inputs:\n            # Generate the SHA-256 hash of the instruction to use it as the metadata\n            instruction_id = hashlib.sha256(\n                input[\"instruction\"].encode(\"utf-8\")\n            ).hexdigest()\n\n            generations = input[\"generation\"]\n\n            # If the `generation` is not a list, then convert it into a list\n            if not isinstance(generations, list):\n                generations = [generations]\n\n            # Create a `generations_set` to avoid adding duplicates\n            generations_set = set()\n\n            for generation in generations:\n                # If the generation is already in the set, then skip it\n                if generation in generations_set:\n                    continue\n                # Otherwise, add it to the set\n                generations_set.add(generation)\n\n                records.append(\n                    rg.FeedbackRecord(\n                        fields={\n                            self._id: instruction_id,\n                            self._instruction: input[\"instruction\"],\n                            self._generation: generation,\n                        },\n                    )\n                )\n        self._rg_dataset.add_records(records)  # type: ignore\n        yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/argilla/text_generation/#distilabel.steps.argilla.text_generation.TextGenerationToArgilla.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The inputs for the step are the <code>instruction</code> and the <code>generation</code>.</p>"},{"location":"reference/distilabel/steps/argilla/text_generation/#distilabel.steps.argilla.text_generation.TextGenerationToArgilla.load","title":"<code>load()</code>","text":"<p>Sets the <code>_instruction</code> and <code>_generation</code> attributes based on the <code>inputs_mapping</code>, otherwise uses the default values; and then uses those values to create a <code>FeedbackDataset</code> suited for the text-generation scenario. And then it pushes it to Argilla.</p> Source code in <code>src/distilabel/steps/argilla/text_generation.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Sets the `_instruction` and `_generation` attributes based on the `inputs_mapping`, otherwise\n    uses the default values; and then uses those values to create a `FeedbackDataset` suited for\n    the text-generation scenario. And then it pushes it to Argilla.\n    \"\"\"\n    super().load()\n\n    self._rg_init()\n\n    self._instruction = self.input_mappings.get(\"instruction\", \"instruction\")\n    self._generation = self.input_mappings.get(\"generation\", \"generation\")\n\n    if self._rg_dataset_exists():\n        _rg_dataset = rg.FeedbackDataset.from_argilla(\n            name=self.dataset_name,\n            workspace=self.dataset_workspace,\n        )\n\n        for field in _rg_dataset.fields:\n            if (\n                field.name not in [self._id, self._instruction, self._generation]\n                and field.required\n            ):\n                raise ValueError(\n                    f\"The dataset {self.dataset_name} in the workspace {self.dataset_workspace} already exists,\"\n                    f\" but contains at least a required field that is neither `{self._id}`, `{self._instruction}`\"\n                    f\", nor `{self._generation}`.\"\n                )\n\n        self._rg_dataset = _rg_dataset\n    else:\n        _rg_dataset = rg.FeedbackDataset(\n            fields=[\n                rg.TextField(name=self._id, title=self._id),  # type: ignore\n                rg.TextField(name=self._instruction, title=self._instruction),  # type: ignore\n                rg.TextField(name=self._generation, title=self._generation),  # type: ignore\n            ],\n            questions=[\n                rg.LabelQuestion(  # type: ignore\n                    name=\"quality\",\n                    title=f\"What's the quality of the {self._generation} for the given {self._instruction}?\",\n                    labels={\"bad\": \"\ud83d\udc4e\", \"good\": \"\ud83d\udc4d\"},\n                )\n            ],\n        )\n        self._rg_dataset = _rg_dataset.push_to_argilla(\n            name=self.dataset_name, workspace=self.dataset_workspace\n        )\n</code></pre>"},{"location":"reference/distilabel/steps/argilla/text_generation/#distilabel.steps.argilla.text_generation.TextGenerationToArgilla.process","title":"<code>process(inputs)</code>","text":"<p>Creates and pushes the records as FeedbackRecords to the Argilla dataset.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>A list of Python dictionaries with the inputs of the task.</p> required <p>Returns:</p> Type Description <code>StepOutput</code> <p>A list of Python dictionaries with the outputs of the task.</p> Source code in <code>src/distilabel/steps/argilla/text_generation.py</code> <pre><code>@override\ndef process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Creates and pushes the records as FeedbackRecords to the Argilla dataset.\n\n    Args:\n        inputs: A list of Python dictionaries with the inputs of the task.\n\n    Returns:\n        A list of Python dictionaries with the outputs of the task.\n    \"\"\"\n    records = []\n    for input in inputs:\n        # Generate the SHA-256 hash of the instruction to use it as the metadata\n        instruction_id = hashlib.sha256(\n            input[\"instruction\"].encode(\"utf-8\")\n        ).hexdigest()\n\n        generations = input[\"generation\"]\n\n        # If the `generation` is not a list, then convert it into a list\n        if not isinstance(generations, list):\n            generations = [generations]\n\n        # Create a `generations_set` to avoid adding duplicates\n        generations_set = set()\n\n        for generation in generations:\n            # If the generation is already in the set, then skip it\n            if generation in generations_set:\n                continue\n            # Otherwise, add it to the set\n            generations_set.add(generation)\n\n            records.append(\n                rg.FeedbackRecord(\n                    fields={\n                        self._id: instruction_id,\n                        self._instruction: input[\"instruction\"],\n                        self._generation: generation,\n                    },\n                )\n            )\n    self._rg_dataset.add_records(records)  # type: ignore\n    yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/generators/","title":"Index","text":""},{"location":"reference/distilabel/steps/generators/data/","title":"Data","text":""},{"location":"reference/distilabel/steps/generators/data/#distilabel.steps.generators.data.LoadDataFromDicts","title":"<code>LoadDataFromDicts</code>","text":"<p>             Bases: <code>GeneratorStep</code></p> <p>A generator step that loads a dataset from a list of dictionaries.</p> <p>This step will load the dataset and yield the transformed data as it is loaded from the list of dictionaries.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>List[Dict[str, Any]]</code> <p>The list of dictionaries to load the data from.</p> Runtime parameters <ul> <li><code>batch_size</code>: The batch size to use when processing the data.</li> </ul> Output columns <p>Dynamic, based on the keys found on the first dictionary of the list</p> Source code in <code>src/distilabel/steps/generators/data.py</code> <pre><code>class LoadDataFromDicts(GeneratorStep):\n    \"\"\"A generator step that loads a dataset from a list of dictionaries.\n\n    This step will load the dataset and yield the transformed data as it is loaded from the list of dictionaries.\n\n    Attributes:\n        data: The list of dictionaries to load the data from.\n\n    Runtime parameters:\n        - `batch_size`: The batch size to use when processing the data.\n\n    Output columns:\n        Dynamic, based on the keys found on the first dictionary of the list\n    \"\"\"\n\n    data: List[Dict[str, Any]]\n\n    @override\n    def process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":  # type: ignore\n        \"\"\"Yields batches from a list of dictionaries.\n\n        Args:\n            offset: The offset to start the generation from. Defaults to `0`.\n\n        Yields:\n            A list of Python dictionaries as read from the inputs (propagated in batches)\n            and a flag indicating whether the yield batch is the last one.\n        \"\"\"\n        if offset:\n            self.data = self.data[offset:]\n\n        while self.data:\n            batch = self.data[: self.batch_size]\n            self.data = self.data[self.batch_size :]\n            yield (\n                batch,\n                True if len(self.data) == 0 else False,\n            )\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"Returns a list of strings with the names of the columns that the step will generate.\"\"\"\n        return list(self.data[0].keys())\n</code></pre>"},{"location":"reference/distilabel/steps/generators/data/#distilabel.steps.generators.data.LoadDataFromDicts.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>Returns a list of strings with the names of the columns that the step will generate.</p>"},{"location":"reference/distilabel/steps/generators/data/#distilabel.steps.generators.data.LoadDataFromDicts.process","title":"<code>process(offset=0)</code>","text":"<p>Yields batches from a list of dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The offset to start the generation from. Defaults to <code>0</code>.</p> <code>0</code> <p>Yields:</p> Type Description <code>GeneratorStepOutput</code> <p>A list of Python dictionaries as read from the inputs (propagated in batches)</p> <code>GeneratorStepOutput</code> <p>and a flag indicating whether the yield batch is the last one.</p> Source code in <code>src/distilabel/steps/generators/data.py</code> <pre><code>@override\ndef process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":  # type: ignore\n    \"\"\"Yields batches from a list of dictionaries.\n\n    Args:\n        offset: The offset to start the generation from. Defaults to `0`.\n\n    Yields:\n        A list of Python dictionaries as read from the inputs (propagated in batches)\n        and a flag indicating whether the yield batch is the last one.\n    \"\"\"\n    if offset:\n        self.data = self.data[offset:]\n\n    while self.data:\n        batch = self.data[: self.batch_size]\n        self.data = self.data[self.batch_size :]\n        yield (\n            batch,\n            True if len(self.data) == 0 else False,\n        )\n</code></pre>"},{"location":"reference/distilabel/steps/generators/huggingface/","title":"Huggingface","text":""},{"location":"reference/distilabel/steps/generators/huggingface/#distilabel.steps.generators.huggingface.LoadHubDataset","title":"<code>LoadHubDataset</code>","text":"<p>             Bases: <code>GeneratorStep</code></p> <p>A generator step that loads a dataset from the Hugging Face Hub using the <code>datasets</code> library.</p> <p>This step will load the dataset in streaming mode, which means that it will not load the entire dataset into memory at once. Instead, it will load the dataset in chunks and yield the transformed data as it is loaded from the Hugging Face Hub.</p> <p>Attributes:</p> Name Type Description <code>repo_id</code> <code>RuntimeParameter[str]</code> <p>The Hugging Face Hub repository ID of the dataset to load.</p> <code>split</code> <code>RuntimeParameter[str]</code> <p>The split of the dataset to load.</p> <code>config</code> <code>Optional[RuntimeParameter[str]]</code> <p>The configuration of the dataset to load. This is optional and only needed if the dataset has multiple configurations.</p> Runtime parameters <ul> <li><code>batch_size</code>: The batch size to use when processing the data.</li> <li><code>repo_id</code>: The Hugging Face Hub repository ID of the dataset to load.</li> <li><code>split</code>: The split of the dataset to load. Defaults to 'train'.</li> <li><code>config</code>: The configuration of the dataset to load. This is optional and only     needed if the dataset has multiple configurations.</li> </ul> <p>Output columns     - dynamic, based on the dataset being loaded</p> Source code in <code>src/distilabel/steps/generators/huggingface.py</code> <pre><code>class LoadHubDataset(GeneratorStep):\n    \"\"\"A generator step that loads a dataset from the Hugging Face Hub using the `datasets`\n    library.\n\n    This step will load the dataset in streaming mode, which means that it will not load the\n    entire dataset into memory at once. Instead, it will load the dataset in chunks and yield\n    the transformed data as it is loaded from the Hugging Face Hub.\n\n    Attributes:\n        repo_id: The Hugging Face Hub repository ID of the dataset to load.\n        split: The split of the dataset to load.\n        config: The configuration of the dataset to load. This is optional and only needed\n            if the dataset has multiple configurations.\n\n    Runtime parameters:\n        - `batch_size`: The batch size to use when processing the data.\n        - `repo_id`: The Hugging Face Hub repository ID of the dataset to load.\n        - `split`: The split of the dataset to load. Defaults to 'train'.\n        - `config`: The configuration of the dataset to load. This is optional and only\n            needed if the dataset has multiple configurations.\n\n    Output columns\n        - dynamic, based on the dataset being loaded\n    \"\"\"\n\n    repo_id: RuntimeParameter[str] = Field(\n        default=None,\n        description=\"The Hugging Face Hub repository ID of the dataset to load.\",\n    )\n    split: RuntimeParameter[str] = Field(\n        default=\"train\",\n        description=\"The split of the dataset to load. Defaults to 'train'.\",\n    )\n    config: Optional[RuntimeParameter[str]] = Field(\n        default=None,\n        description=\"The configuration of the dataset to load. This is optional and only\"\n        \" needed if the dataset has multiple configurations.\",\n    )\n\n    _dataset: Union[IterableDataset, None] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        \"\"\"Load the dataset from the Hugging Face Hub\"\"\"\n        super().load()\n\n        self._dataset = load_dataset(\n            self.repo_id,  # type: ignore\n            self.config,\n            split=self.split,\n            streaming=True,\n        )\n\n    def process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":\n        \"\"\"Yields batches from the loaded dataset from the Hugging Face Hub.\n\n        Args:\n            offset: The offset to start yielding the data from. Will be used during the caching\n                process to help skipping already processed data.\n\n        Yields:\n            A tuple containing a batch of rows and a boolean indicating if the batch is\n            the last one.\n        \"\"\"\n        num_examples = self._get_dataset_num_examples()\n        num_returned_rows = 0\n        for batch_num, batch in enumerate(\n            self._dataset.iter(batch_size=self.batch_size)  # type: ignore\n        ):\n            if batch_num * self.batch_size &lt; offset:\n                continue\n            transformed_batch = self._transform_batch(batch)\n            batch_size = len(transformed_batch)\n            num_returned_rows += batch_size\n            yield transformed_batch, num_returned_rows == num_examples\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The columns that will be generated by this step, based on the datasets loaded\n        from the Hugging Face Hub.\n\n        Returns:\n            The columns that will be generated by this step.\n        \"\"\"\n        return self._get_dataset_columns()\n\n    def _transform_batch(self, batch: Dict[str, Any]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Transform a batch of data from the Hugging Face Hub into a list of rows.\n\n        Args:\n            batch: The batch of data from the Hugging Face Hub.\n\n        Returns:\n            A list of rows, where each row is a dictionary of column names and values.\n        \"\"\"\n        length = len(next(iter(batch.values())))\n        rows = []\n        for i in range(length):\n            rows.append({col: values[i] for col, values in batch.items()})\n        return rows\n\n    def _get_dataset_num_examples(self) -&gt; int:\n        \"\"\"Get the number of examples in the dataset, based on the `split` and `config`\n        runtime parameters provided.\n\n        Returns:\n            The number of examples in the dataset.\n        \"\"\"\n        dataset_info = self._get_dataset_info()\n        split = self.split\n        if self.config:\n            return dataset_info[\"splits\"][split][\"num_examples\"]\n        return dataset_info[\"default\"][\"splits\"][split][\"num_examples\"]\n\n    def _get_dataset_columns(self) -&gt; List[str]:\n        \"\"\"Get the columns of the dataset, based on the `config` runtime parameter provided.\n\n        Returns:\n            The columns of the dataset.\n        \"\"\"\n        dataset_info = self._get_dataset_info()\n        if self.config:\n            return list(dataset_info[\"features\"].keys())\n        return list(dataset_info[\"default\"][\"features\"].keys())\n\n    def _get_dataset_info(self) -&gt; Dict[str, Any]:\n        \"\"\"Calls the Datasets Server API from Hugging Face to obtain the dataset information.\n\n        Returns:\n            The dataset information.\n        \"\"\"\n        repo_id = self.repo_id\n        config = self.config\n        return _get_hf_dataset_info(repo_id, config)\n</code></pre>"},{"location":"reference/distilabel/steps/generators/huggingface/#distilabel.steps.generators.huggingface.LoadHubDataset.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The columns that will be generated by this step, based on the datasets loaded from the Hugging Face Hub.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The columns that will be generated by this step.</p>"},{"location":"reference/distilabel/steps/generators/huggingface/#distilabel.steps.generators.huggingface.LoadHubDataset.load","title":"<code>load()</code>","text":"<p>Load the dataset from the Hugging Face Hub</p> Source code in <code>src/distilabel/steps/generators/huggingface.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Load the dataset from the Hugging Face Hub\"\"\"\n    super().load()\n\n    self._dataset = load_dataset(\n        self.repo_id,  # type: ignore\n        self.config,\n        split=self.split,\n        streaming=True,\n    )\n</code></pre>"},{"location":"reference/distilabel/steps/generators/huggingface/#distilabel.steps.generators.huggingface.LoadHubDataset.process","title":"<code>process(offset=0)</code>","text":"<p>Yields batches from the loaded dataset from the Hugging Face Hub.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The offset to start yielding the data from. Will be used during the caching process to help skipping already processed data.</p> <code>0</code> <p>Yields:</p> Type Description <code>GeneratorStepOutput</code> <p>A tuple containing a batch of rows and a boolean indicating if the batch is</p> <code>GeneratorStepOutput</code> <p>the last one.</p> Source code in <code>src/distilabel/steps/generators/huggingface.py</code> <pre><code>def process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":\n    \"\"\"Yields batches from the loaded dataset from the Hugging Face Hub.\n\n    Args:\n        offset: The offset to start yielding the data from. Will be used during the caching\n            process to help skipping already processed data.\n\n    Yields:\n        A tuple containing a batch of rows and a boolean indicating if the batch is\n        the last one.\n    \"\"\"\n    num_examples = self._get_dataset_num_examples()\n    num_returned_rows = 0\n    for batch_num, batch in enumerate(\n        self._dataset.iter(batch_size=self.batch_size)  # type: ignore\n    ):\n        if batch_num * self.batch_size &lt; offset:\n            continue\n        transformed_batch = self._transform_batch(batch)\n        batch_size = len(transformed_batch)\n        num_returned_rows += batch_size\n        yield transformed_batch, num_returned_rows == num_examples\n</code></pre>"},{"location":"reference/distilabel/steps/globals/","title":"Index","text":""},{"location":"reference/distilabel/steps/globals/huggingface/","title":"Huggingface","text":""},{"location":"reference/distilabel/steps/globals/huggingface/#distilabel.steps.globals.huggingface.PushToHub","title":"<code>PushToHub</code>","text":"<p>             Bases: <code>GlobalStep</code></p> <p>A <code>GlobalStep</code> which creates a <code>datasets.Dataset</code> with the input data and pushes it to the Hugging Face Hub.</p> <p>Attributes:</p> Name Type Description <code>repo_id</code> <code>RuntimeParameter[str]</code> <p>The Hugging Face Hub repository ID where the dataset will be uploaded.</p> <code>split</code> <code>RuntimeParameter[str]</code> <p>The split of the dataset that will be pushed. Defaults to <code>\"train\"</code>.</p> <code>private</code> <code>RuntimeParameter[bool]</code> <p>Whether the dataset to be pushed should be private or not. Defaults to <code>False</code>.</p> <code>token</code> <code>Optional[RuntimeParameter[str]]</code> <p>The token that will be used to authenticate in the Hub. If not provided, the token will be tried to be obtained from the environment variable <code>HF_TOKEN</code>. If not provided using one of the previous methods, then <code>huggingface_hub</code> library will try to use the token from the local Hugging Face CLI configuration. Defaults to <code>None</code>.</p> Runtime parameters <ul> <li><code>repo_id</code>: The Hugging Face Hub repository ID where the dataset will be uploaded.</li> <li><code>split</code>: The split of the dataset that will be pushed.</li> <li><code>private</code>: Whether the dataset to be pushed should be private or not.</li> <li><code>token</code>: The token that will be used to authenticate in the Hub.</li> </ul> Input columns <ul> <li>dynamic, based on the existing data within inputs</li> </ul> Source code in <code>src/distilabel/steps/globals/huggingface.py</code> <pre><code>class PushToHub(GlobalStep):\n    \"\"\"A `GlobalStep` which creates a `datasets.Dataset` with the input data and pushes\n    it to the Hugging Face Hub.\n\n    Attributes:\n        repo_id: The Hugging Face Hub repository ID where the dataset will be uploaded.\n        split: The split of the dataset that will be pushed. Defaults to `\"train\"`.\n        private: Whether the dataset to be pushed should be private or not. Defaults to\n            `False`.\n        token: The token that will be used to authenticate in the Hub. If not provided, the\n            token will be tried to be obtained from the environment variable `HF_TOKEN`.\n            If not provided using one of the previous methods, then `huggingface_hub` library\n            will try to use the token from the local Hugging Face CLI configuration. Defaults\n            to `None`.\n\n    Runtime parameters:\n        - `repo_id`: The Hugging Face Hub repository ID where the dataset will be uploaded.\n        - `split`: The split of the dataset that will be pushed.\n        - `private`: Whether the dataset to be pushed should be private or not.\n        - `token`: The token that will be used to authenticate in the Hub.\n\n    Input columns:\n        - dynamic, based on the existing data within inputs\n    \"\"\"\n\n    repo_id: RuntimeParameter[str] = Field(\n        default=None,\n        description=\"The Hugging Face Hub repository ID where the dataset will be uploaded.\",\n    )\n    split: RuntimeParameter[str] = Field(\n        default=\"train\",\n        description=\"The split of the dataset that will be pushed. Defaults to 'train'.\",\n    )\n    private: RuntimeParameter[bool] = Field(\n        default=False,\n        description=\"Whether the dataset to be pushed should be private or not. Defaults\"\n        \" to `False`.\",\n    )\n    token: Optional[RuntimeParameter[str]] = Field(\n        default=None,\n        description=\"The token that will be used to authenticate in the Hub. If not provided,\"\n        \" the token will be tried to be obtained from the environment variable `HF_TOKEN`.\"\n        \" If not provided using one of the previous methods, then `huggingface_hub` library\"\n        \" will try to use the token from the local Hugging Face CLI configuration. Defaults\"\n        \" to `None`\",\n    )\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Method that processes the input data, respecting the `datasets.Dataset` formatting,\n        and pushes it to the Hugging Face Hub based on the `RuntimeParameter`s attributes.\n\n        Args:\n            inputs: that input data within a single object (as it's a GlobalStep) that\n                will be transformed into a `datasets.Dataset`.\n\n        Yields:\n            Propagates the received inputs so that the `Distiset` can be generated if this is\n            the last step of the `Pipeline`, or if this is not a leaf step and has follow up\n            steps.\n        \"\"\"\n        dataset_dict = defaultdict(list)\n        for input in inputs:\n            for key, value in input.items():\n                dataset_dict[key].append(value)\n        dataset_dict = dict(dataset_dict)\n        dataset = Dataset.from_dict(dataset_dict)\n        dataset.push_to_hub(\n            self.repo_id,  # type: ignore\n            split=self.split,\n            private=self.private,\n            token=self.token or os.getenv(\"HF_TOKEN\"),\n        )\n        yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/globals/huggingface/#distilabel.steps.globals.huggingface.PushToHub.process","title":"<code>process(inputs)</code>","text":"<p>Method that processes the input data, respecting the <code>datasets.Dataset</code> formatting, and pushes it to the Hugging Face Hub based on the <code>RuntimeParameter</code>s attributes.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>that input data within a single object (as it's a GlobalStep) that will be transformed into a <code>datasets.Dataset</code>.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>Propagates the received inputs so that the <code>Distiset</code> can be generated if this is</p> <code>StepOutput</code> <p>the last step of the <code>Pipeline</code>, or if this is not a leaf step and has follow up</p> <code>StepOutput</code> <p>steps.</p> Source code in <code>src/distilabel/steps/globals/huggingface.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Method that processes the input data, respecting the `datasets.Dataset` formatting,\n    and pushes it to the Hugging Face Hub based on the `RuntimeParameter`s attributes.\n\n    Args:\n        inputs: that input data within a single object (as it's a GlobalStep) that\n            will be transformed into a `datasets.Dataset`.\n\n    Yields:\n        Propagates the received inputs so that the `Distiset` can be generated if this is\n        the last step of the `Pipeline`, or if this is not a leaf step and has follow up\n        steps.\n    \"\"\"\n    dataset_dict = defaultdict(list)\n    for input in inputs:\n        for key, value in input.items():\n            dataset_dict[key].append(value)\n    dataset_dict = dict(dataset_dict)\n    dataset = Dataset.from_dict(dataset_dict)\n    dataset.push_to_hub(\n        self.repo_id,  # type: ignore\n        split=self.split,\n        private=self.private,\n        token=self.token or os.getenv(\"HF_TOKEN\"),\n    )\n    yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/","title":"Index","text":""},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.ChatType","title":"<code>ChatType = List[ChatItem]</code>  <code>module-attribute</code>","text":"<p>ChatType is a type alias for a <code>list</code> of <code>dict</code>s following the OpenAI conversational format.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.ComplexityScorer","title":"<code>ComplexityScorer</code>","text":"<p>             Bases: <code>Task</code></p> <p>This task is used to rank a list of instructions based on their complexity. It's an implementation of the complexity score task from the paper 'What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.</p> <p>Attributes:</p> Name Type Description <code>_template</code> <code>Union[Template, None]</code> <p>The Jinja2 template used to format the input data.</p> Input columns <ul> <li>instructions (<code>List[str]</code>): The list of instructions to be scored.</li> </ul> Output columns <ul> <li>complexity_score (<code>List[float]</code>): The complexity score for each instruction.</li> </ul> References <ul> <li><code>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</code></li> </ul> Source code in <code>src/distilabel/steps/tasks/complexity_scorer.py</code> <pre><code>class ComplexityScorer(Task):\n    \"\"\"This task is used to rank a list of instructions based on their complexity. It's\n    an implementation of the complexity score task from the paper 'What Makes Good Data\n    for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.\n\n    Attributes:\n        _template: The Jinja2 template used to format the input data.\n\n    Input columns:\n        - instructions (`List[str]`): The list of instructions to be scored.\n\n    Output columns:\n        - complexity_score (`List[float]`): The complexity score for each instruction.\n\n    References:\n        - [`What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning`](https://arxiv.org/abs/2312.15685)\n    \"\"\"\n\n    _template: Union[Template, None] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        super().load()\n        self._template = Template(_COMPLEXITY_SCORER_TEMPLATE)\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        return [\"instructions\"]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        return [\"scores\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n        return [{\"role\": \"user\", \"content\": self._template.render(**input)}]  # type: ignore\n\n    def format_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, Any]:\n        if output is None:\n            return {\"scores\": [None] * len(input[\"instructions\"])}\n\n        scores = []\n        score_lines = output.split(\"\\n\")\n        for i, line in enumerate(score_lines):\n            match = _PARSE_SCORE_LINE_REGEX.match(line)\n            score = float(match.group(1)) if match else None\n            scores.append(score)\n            if i == len(input[\"instructions\"]) - 1:\n                break\n\n        return {\"scores\": scores}\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.EvolComplexity","title":"<code>EvolComplexity</code>","text":"<p>             Bases: <code>EvolInstruct</code></p> <p>EvolComplexity is a task that evolves instructions to make them more complex, and it is based in the EvolInstruct task, but using slight different prompts, but the exact same evolutionary approach.</p> <p>Attributes:</p> Name Type Description <code>num_instructions</code> <p>The number of instructions to be generated.</p> <code>generate_answers</code> <p>Whether to generate answers for the instructions or not. Defaults to <code>False</code>.</p> <code>mutation_templates</code> <code>Dict[str, str]</code> <p>The mutation templates to be used for the generation of the instructions.</p> <code>min_length</code> <code>Dict[str, str]</code> <p>Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid. Defaults to <code>512</code>.</p> <code>max_length</code> <code>Dict[str, str]</code> <p>Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid. Defaults to <code>1024</code>.</p> <code>seed</code> <code>Dict[str, str]</code> <p>The seed to be set for <code>numpy</code> in order to randomly pick a mutation method. Defaults to <code>42</code>.</p> Runtime parameters <ul> <li><code>min_length</code>: Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid.</li> <li><code>max_length</code>: Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid.</li> <li><code>seed</code>: The number of evolutions to be run.</li> </ul> Input columns <ul> <li>instruction (<code>str</code>): The instruction to evolve.</li> </ul> Output columns <ul> <li>evolved_instruction (<code>str</code>): The evolved instruction.</li> <li>answer (<code>str</code>, optional): The answer to the instruction if <code>generate_answers=True</code>.</li> <li>model_name (<code>str</code>): The name of the LLM used to evolve the instructions.</li> </ul> References <ul> <li>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</li> <li>WizardLM: Empowering Large Language Models to Follow Complex Instructions</li> </ul> Source code in <code>src/distilabel/steps/tasks/evol_instruct/evol_complexity/base.py</code> <pre><code>class EvolComplexity(EvolInstruct):\n    \"\"\"EvolComplexity is a task that evolves instructions to make them more complex,\n    and it is based in the EvolInstruct task, but using slight different prompts, but the\n    exact same evolutionary approach.\n\n    Attributes:\n        num_instructions: The number of instructions to be generated.\n        generate_answers: Whether to generate answers for the instructions or not. Defaults\n            to `False`.\n        mutation_templates: The mutation templates to be used for the generation of the\n            instructions.\n        min_length: Defines the length (in bytes) that the generated instruction needs to\n            be higher than, to be considered valid. Defaults to `512`.\n        max_length: Defines the length (in bytes) that the generated instruction needs to\n            be lower than, to be considered valid. Defaults to `1024`.\n        seed: The seed to be set for `numpy` in order to randomly pick a mutation method.\n            Defaults to `42`.\n\n    Runtime parameters:\n        - `min_length`: Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid.\n        - `max_length`: Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid.\n        - `seed`: The number of evolutions to be run.\n\n    Input columns:\n        - instruction (`str`): The instruction to evolve.\n\n    Output columns:\n        - evolved_instruction (`str`): The evolved instruction.\n        - answer (`str`, optional): The answer to the instruction if `generate_answers=True`.\n        - model_name (`str`): The name of the LLM used to evolve the instructions.\n\n    References:\n        - [What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning](https://arxiv.org/abs/2312.15685)\n        - [WizardLM: Empowering Large Language Models to Follow Complex Instructions](https://arxiv.org/abs/2304.12244)\n    \"\"\"\n\n    mutation_templates: Dict[str, str] = MUTATION_TEMPLATES\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.EvolComplexityGenerator","title":"<code>EvolComplexityGenerator</code>","text":"<p>             Bases: <code>EvolInstructGenerator</code></p> <p>EvolComplexity is a task that evolves instructions to make them more complex, and it is based in the EvolInstruct task, but using slight different prompts, but the exact same evolutionary approach.</p> <p>Attributes:</p> Name Type Description <code>num_instructions</code> <p>The number of instructions to be generated.</p> <code>generate_answers</code> <p>Whether to generate answers for the instructions or not. Defaults to <code>False</code>.</p> <code>mutation_templates</code> <code>Dict[str, str]</code> <p>The mutation templates to be used for the generation of the instructions.</p> <code>min_length</code> <code>Dict[str, str]</code> <p>Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid. Defaults to <code>512</code>.</p> <code>max_length</code> <code>Dict[str, str]</code> <p>Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid. Defaults to <code>1024</code>.</p> <code>seed</code> <code>Dict[str, str]</code> <p>The seed to be set for <code>numpy</code> in order to randomly pick a mutation method. Defaults to <code>42</code>.</p> Runtime parameters <ul> <li><code>min_length</code>: Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid.</li> <li><code>max_length</code>: Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid.</li> <li><code>seed</code>: The number of evolutions to be run.</li> </ul> Input columns <ul> <li>instruction (<code>str</code>): The instruction to evolve.</li> </ul> Output columns <ul> <li>instruction (<code>str</code>): The evolved instruction.</li> <li>answer (<code>str</code>, optional): The answer to the instruction if <code>generate_answers=True</code>.</li> <li>model_name (<code>str</code>): The name of the LLM used to evolve the instructions.</li> </ul> References <ul> <li>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</li> <li>WizardLM: Empowering Large Language Models to Follow Complex Instructions</li> </ul> Source code in <code>src/distilabel/steps/tasks/evol_instruct/evol_complexity/generator.py</code> <pre><code>class EvolComplexityGenerator(EvolInstructGenerator):\n    \"\"\"EvolComplexity is a task that evolves instructions to make them more complex,\n    and it is based in the EvolInstruct task, but using slight different prompts, but the\n    exact same evolutionary approach.\n\n    Attributes:\n        num_instructions: The number of instructions to be generated.\n        generate_answers: Whether to generate answers for the instructions or not. Defaults\n            to `False`.\n        mutation_templates: The mutation templates to be used for the generation of the\n            instructions.\n        min_length: Defines the length (in bytes) that the generated instruction needs to\n            be higher than, to be considered valid. Defaults to `512`.\n        max_length: Defines the length (in bytes) that the generated instruction needs to\n            be lower than, to be considered valid. Defaults to `1024`.\n        seed: The seed to be set for `numpy` in order to randomly pick a mutation method.\n            Defaults to `42`.\n\n    Runtime parameters:\n        - `min_length`: Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid.\n        - `max_length`: Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid.\n        - `seed`: The number of evolutions to be run.\n\n    Input columns:\n        - instruction (`str`): The instruction to evolve.\n\n    Output columns:\n        - instruction (`str`): The evolved instruction.\n        - answer (`str`, optional): The answer to the instruction if `generate_answers=True`.\n        - model_name (`str`): The name of the LLM used to evolve the instructions.\n\n    References:\n        - [What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning](https://arxiv.org/abs/2312.15685)\n        - [WizardLM: Empowering Large Language Models to Follow Complex Instructions](https://arxiv.org/abs/2304.12244)\n    \"\"\"\n\n    mutation_templates: Dict[str, str] = GENERATION_MUTATION_TEMPLATES\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.EvolInstruct","title":"<code>EvolInstruct</code>","text":"<p>             Bases: <code>Task</code></p> <p>WizardLM: Empowering Large Language Models to Follow Complex Instructions</p> <p>Attributes:</p> Name Type Description <code>num_evolutions</code> <code>int</code> <p>The number of evolutions to be performed.</p> <code>store_evolutions</code> <code>bool</code> <p>Whether to store all the evolutions or just the last one. Defaults to <code>False</code>.</p> <code>generate_answers</code> <code>bool</code> <p>Whether to generate answers for the evolved instructions. Defaults to <code>False</code>.</p> <code>include_original_instruction</code> <code>bool</code> <p>Whether to include the original instruction in the <code>evolved_instructions</code> output column. Defaults to <code>False</code>.</p> <code>mutation_templates</code> <code>Dict[str, str]</code> <p>The mutation templates to be used for evolving the instructions. Defaults to the ones provided in the <code>utils.py</code> file.</p> <code>seed</code> <code>RuntimeParameter[int]</code> <p>The seed to be set for <code>numpy</code> in order to randomly pick a mutation method. Defaults to <code>42</code>.</p> Runtime parameters <ul> <li><code>seed</code>: The seed to be set for <code>numpy</code> in order to randomly pick a mutation method.</li> </ul> Input columns <ul> <li>instruction (<code>str</code>): The instruction to evolve.</li> </ul> Output columns <ul> <li>evolved_instruction (<code>str</code>): The evolved instruction if <code>store_evolutions=False</code>.</li> <li>evolved_instructions (<code>List[str]</code>): The evolved instructions if <code>store_evolutions=True</code>.</li> <li>model_name (<code>str</code>): The name of the LLM used to evolve the instructions.</li> <li>answer (<code>str</code>): The answer to the evolved instruction if <code>generate_answers=True</code>     and <code>store_evolutions=False</code>.</li> <li>answers (<code>List[str]</code>): The answers to the evolved instructions if <code>generate_answers=True</code>     and <code>store_evolutions=True</code>.</li> </ul> References <ul> <li>WizardLM: Empowering Large Language Models to Follow Complex Instructions</li> <li>GitHub: h2oai/h2o-wizardlm</li> </ul> Source code in <code>src/distilabel/steps/tasks/evol_instruct/base.py</code> <pre><code>class EvolInstruct(Task):\n    \"\"\"WizardLM: Empowering Large Language Models to Follow Complex Instructions\n\n    Attributes:\n        num_evolutions: The number of evolutions to be performed.\n        store_evolutions: Whether to store all the evolutions or just the last one. Defaults\n            to `False`.\n        generate_answers: Whether to generate answers for the evolved instructions. Defaults\n            to `False`.\n        include_original_instruction: Whether to include the original instruction in the\n            `evolved_instructions` output column. Defaults to `False`.\n        mutation_templates: The mutation templates to be used for evolving the instructions.\n            Defaults to the ones provided in the `utils.py` file.\n        seed: The seed to be set for `numpy` in order to randomly pick a mutation method.\n            Defaults to `42`.\n\n    Runtime parameters:\n        - `seed`: The seed to be set for `numpy` in order to randomly pick a mutation method.\n\n    Input columns:\n        - instruction (`str`): The instruction to evolve.\n\n    Output columns:\n        - evolved_instruction (`str`): The evolved instruction if `store_evolutions=False`.\n        - evolved_instructions (`List[str]`): The evolved instructions if `store_evolutions=True`.\n        - model_name (`str`): The name of the LLM used to evolve the instructions.\n        - answer (`str`): The answer to the evolved instruction if `generate_answers=True`\n            and `store_evolutions=False`.\n        - answers (`List[str]`): The answers to the evolved instructions if `generate_answers=True`\n            and `store_evolutions=True`.\n\n    References:\n        - [WizardLM: Empowering Large Language Models to Follow Complex Instructions](https://arxiv.org/abs/2304.12244)\n        - [GitHub: h2oai/h2o-wizardlm](https://github.com/h2oai/h2o-wizardlm)\n    \"\"\"\n\n    num_evolutions: int\n    store_evolutions: bool = False\n    generate_answers: bool = False\n    include_original_instruction: bool = False\n    mutation_templates: Dict[str, str] = MUTATION_TEMPLATES\n\n    seed: RuntimeParameter[int] = Field(\n        default=42,\n        description=\"As `numpy` is being used in order to randomly pick a mutation method, then is nice to seed a random seed.\",\n    )\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input for the task is the `instruction`.\"\"\"\n        return [\"instruction\"]\n\n    def format_input(self, input: str) -&gt; ChatType:  # type: ignore\n        \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n        is the first interaction from the user within a conversation. And the\n        `system_prompt` is added as the first message if it exists.\"\"\"\n        return [{\"role\": \"user\", \"content\": input}]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The output for the task are the `evolved_instruction/s`, the `answer` if `generate_answers=True`\n        and the `model_name`.\"\"\"\n        # TODO: having to define a `model_name` column every time as the `Task.outputs` is not ideal,\n        # this could be handled always and the value could be included within the DAG validation when\n        # a `Task` is used, since all the `Task` subclasses will have an `llm` with a `model_name` attr.\n        _outputs = [\n            (\n                \"evolved_instruction\"\n                if not self.store_evolutions\n                else \"evolved_instructions\"\n            ),\n            \"model_name\",\n        ]\n        if self.generate_answers:\n            _outputs.append(\"answer\" if not self.store_evolutions else \"answers\")\n        return _outputs\n\n    @override\n    def format_output(  # type: ignore\n        self, instructions: Union[str, List[str]], answers: Optional[List[str]] = None\n    ) -&gt; Dict[str, Any]:  # type: ignore\n        \"\"\"The output for the task is a dict with: `evolved_instruction` or `evolved_instructions`,\n        depending whether the value is either `False` or `True` for `store_evolutions`, respectively;\n        `answer` if `generate_answers=True`; and, finally, the `model_name`.\n\n        Args:\n            instructions: The instructions to be included within the output.\n            answers: The answers to be included within the output if `generate_answers=True`.\n\n        Returns:\n            If `store_evolutions=False` and `generate_answers=True` return {\"evolved_instruction\": ..., \"model_name\": ..., \"answer\": ...};\n            if `store_evolutions=True` and `generate_answers=True` return {\"evolved_instructions\": ..., \"model_name\": ..., \"answer\": ...};\n            if `store_evolutions=False` and `generate_answers=False` return {\"evolved_instruction\": ..., \"model_name\": ...};\n            if `store_evolutions=True` and `generate_answers=False` return {\"evolved_instructions\": ..., \"model_name\": ...}.\n        \"\"\"\n        _output = {}\n        if not self.store_evolutions:\n            _output[\"evolved_instruction\"] = instructions[-1]\n        else:\n            _output[\"evolved_instructions\"] = instructions\n\n        if self.generate_answers and answers:\n            if not self.store_evolutions:\n                _output[\"answer\"] = answers[-1]\n            else:\n                _output[\"answers\"] = answers\n\n        _output[\"model_name\"] = self.llm.model_name\n        return _output\n\n    @property\n    def mutation_templates_names(self) -&gt; List[str]:\n        \"\"\"Returns the names i.e. keys of the provided `mutation_templates`.\"\"\"\n        return list(self.mutation_templates.keys())\n\n    def _apply_random_mutation(self, instruction: str) -&gt; str:\n        \"\"\"Applies a random mutation from the ones provided as part of the `mutation_templates`\n        enum, and returns the provided instruction within the mutation prompt.\n\n        Args:\n            instruction: The instruction to be included within the mutation prompt.\n\n        Returns:\n            A random mutation prompt with the provided instruction.\n        \"\"\"\n        mutation = np.random.choice(self.mutation_templates_names)\n        return self.mutation_templates[mutation].replace(\"&lt;PROMPT&gt;\", instruction)  # type: ignore\n\n    def _evolve_instructions(self, inputs: \"StepInput\") -&gt; List[List[str]]:\n        \"\"\"Evolves the instructions provided as part of the inputs of the task.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Returns:\n            A list where each item is a list with either the last evolved instruction if\n            `store_evolutions=False` or all the evolved instructions if `store_evolutions=True`.\n        \"\"\"\n\n        instructions: List[List[str]] = [[input[\"instruction\"]] for input in inputs]\n\n        for iter_no in range(self.num_evolutions):\n            formatted_prompts = []\n            for instruction in instructions:\n                formatted_prompts.append(self._apply_random_mutation(instruction[-1]))\n\n            formatted_prompts = [\n                self.format_input(prompt) for prompt in formatted_prompts\n            ]\n            generated_prompts = flatten_responses(\n                self.llm.generate(\n                    formatted_prompts,\n                    **self.llm.generation_kwargs,  # type: ignore\n                )\n            )\n\n            evolved_instructions = []\n            for generated_prompt in generated_prompts:\n                generated_prompt = generated_prompt.split(\"Prompt#:\")[-1].strip()\n                evolved_instructions.append(generated_prompt)\n\n            if self.store_evolutions:\n                instructions = [\n                    instruction + [evolved_instruction]\n                    for instruction, evolved_instruction in zip(\n                        instructions, evolved_instructions\n                    )\n                ]\n            else:\n                instructions = [\n                    [evolved_instruction]\n                    for evolved_instruction in evolved_instructions\n                ]\n\n            self._logger.info(\n                f\"\ud83d\udd04 Ran iteration {iter_no} evolving {len(instructions)} instructions!\"\n            )\n\n        return instructions\n\n    def _generate_answers(\n        self, evolved_instructions: List[List[str]]\n    ) -&gt; List[List[str]]:\n        \"\"\"Generates the answer for the instructions in `instructions`.\n\n        Args:\n            evolved_instructions: A list of lists where each item is a list with either the last\n                evolved instruction if `store_evolutions=False` or all the evolved instructions\n                if `store_evolutions=True`.\n\n        Returns:\n            A list of answers for each instruction.\n        \"\"\"\n        formatted_instructions = [\n            self.format_input(instruction)\n            for instructions in evolved_instructions\n            for instruction in instructions\n        ]\n\n        responses = self.llm.generate(\n            formatted_instructions,\n            num_generations=1,\n            **self.llm.generation_kwargs,  # type: ignore\n        )\n\n        step = (\n            self.num_evolutions\n            if not self.include_original_instruction\n            else self.num_evolutions + 1\n        )\n        return [\n            flatten_responses(responses[i : i + step])\n            for i in range(0, len(responses), step)\n        ]\n\n    @override\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Yields:\n            A list of Python dictionaries with the outputs of the task.\n        \"\"\"\n\n        evolved_instructions = self._evolve_instructions(inputs)\n\n        if self.store_evolutions:\n            # Remove the input instruction from the `evolved_instructions` list\n            from_ = 1 if not self.include_original_instruction else 0\n            evolved_instructions = [\n                instruction[from_:] for instruction in evolved_instructions\n            ]\n\n        if not self.generate_answers:\n            for input, instruction in zip(inputs, evolved_instructions):\n                input.update(self.format_output(instruction))\n            yield inputs\n\n        self._logger.info(\n            f\"\ud83c\udf89 Finished evolving {len(evolved_instructions)} instructions!\"\n        )\n\n        if self.generate_answers:\n            self._logger.info(\n                f\"\ud83e\udde0 Generating answers for the {len(evolved_instructions)} evolved instructions!\"\n            )\n\n            answers = self._generate_answers(evolved_instructions)\n\n            self._logger.info(\n                f\"\ud83c\udf89 Finished generating answers for the {len(evolved_instructions)} evolved\"\n                \" instructions!\"\n            )\n\n            for idx, (input, instruction) in enumerate(\n                zip(inputs, evolved_instructions)\n            ):\n                input.update(self.format_output(instruction, answers[idx]))\n            yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.EvolInstruct.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input for the task is the <code>instruction</code>.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.EvolInstruct.mutation_templates_names","title":"<code>mutation_templates_names: List[str]</code>  <code>property</code>","text":"<p>Returns the names i.e. keys of the provided <code>mutation_templates</code>.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.EvolInstruct.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The output for the task are the <code>evolved_instruction/s</code>, the <code>answer</code> if <code>generate_answers=True</code> and the <code>model_name</code>.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.EvolInstruct.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is formatted as a <code>ChatType</code> assuming that the instruction is the first interaction from the user within a conversation. And the <code>system_prompt</code> is added as the first message if it exists.</p> Source code in <code>src/distilabel/steps/tasks/evol_instruct/base.py</code> <pre><code>def format_input(self, input: str) -&gt; ChatType:  # type: ignore\n    \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n    is the first interaction from the user within a conversation. And the\n    `system_prompt` is added as the first message if it exists.\"\"\"\n    return [{\"role\": \"user\", \"content\": input}]\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.EvolInstruct.format_output","title":"<code>format_output(instructions, answers=None)</code>","text":"<p>The output for the task is a dict with: <code>evolved_instruction</code> or <code>evolved_instructions</code>, depending whether the value is either <code>False</code> or <code>True</code> for <code>store_evolutions</code>, respectively; <code>answer</code> if <code>generate_answers=True</code>; and, finally, the <code>model_name</code>.</p> <p>Parameters:</p> Name Type Description Default <code>instructions</code> <code>Union[str, List[str]]</code> <p>The instructions to be included within the output.</p> required <code>answers</code> <code>Optional[List[str]]</code> <p>The answers to be included within the output if <code>generate_answers=True</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>If <code>store_evolutions=False</code> and <code>generate_answers=True</code> return {\"evolved_instruction\": ..., \"model_name\": ..., \"answer\": ...};</p> <code>Dict[str, Any]</code> <p>if <code>store_evolutions=True</code> and <code>generate_answers=True</code> return {\"evolved_instructions\": ..., \"model_name\": ..., \"answer\": ...};</p> <code>Dict[str, Any]</code> <p>if <code>store_evolutions=False</code> and <code>generate_answers=False</code> return {\"evolved_instruction\": ..., \"model_name\": ...};</p> <code>Dict[str, Any]</code> <p>if <code>store_evolutions=True</code> and <code>generate_answers=False</code> return {\"evolved_instructions\": ..., \"model_name\": ...}.</p> Source code in <code>src/distilabel/steps/tasks/evol_instruct/base.py</code> <pre><code>@override\ndef format_output(  # type: ignore\n    self, instructions: Union[str, List[str]], answers: Optional[List[str]] = None\n) -&gt; Dict[str, Any]:  # type: ignore\n    \"\"\"The output for the task is a dict with: `evolved_instruction` or `evolved_instructions`,\n    depending whether the value is either `False` or `True` for `store_evolutions`, respectively;\n    `answer` if `generate_answers=True`; and, finally, the `model_name`.\n\n    Args:\n        instructions: The instructions to be included within the output.\n        answers: The answers to be included within the output if `generate_answers=True`.\n\n    Returns:\n        If `store_evolutions=False` and `generate_answers=True` return {\"evolved_instruction\": ..., \"model_name\": ..., \"answer\": ...};\n        if `store_evolutions=True` and `generate_answers=True` return {\"evolved_instructions\": ..., \"model_name\": ..., \"answer\": ...};\n        if `store_evolutions=False` and `generate_answers=False` return {\"evolved_instruction\": ..., \"model_name\": ...};\n        if `store_evolutions=True` and `generate_answers=False` return {\"evolved_instructions\": ..., \"model_name\": ...}.\n    \"\"\"\n    _output = {}\n    if not self.store_evolutions:\n        _output[\"evolved_instruction\"] = instructions[-1]\n    else:\n        _output[\"evolved_instructions\"] = instructions\n\n    if self.generate_answers and answers:\n        if not self.store_evolutions:\n            _output[\"answer\"] = answers[-1]\n        else:\n            _output[\"answers\"] = answers\n\n    _output[\"model_name\"] = self.llm.model_name\n    return _output\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.EvolInstruct.process","title":"<code>process(inputs)</code>","text":"<p>Processes the inputs of the task and generates the outputs using the LLM.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>A list of Python dictionaries with the inputs of the task.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>A list of Python dictionaries with the outputs of the task.</p> Source code in <code>src/distilabel/steps/tasks/evol_instruct/base.py</code> <pre><code>@override\ndef process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n    Args:\n        inputs: A list of Python dictionaries with the inputs of the task.\n\n    Yields:\n        A list of Python dictionaries with the outputs of the task.\n    \"\"\"\n\n    evolved_instructions = self._evolve_instructions(inputs)\n\n    if self.store_evolutions:\n        # Remove the input instruction from the `evolved_instructions` list\n        from_ = 1 if not self.include_original_instruction else 0\n        evolved_instructions = [\n            instruction[from_:] for instruction in evolved_instructions\n        ]\n\n    if not self.generate_answers:\n        for input, instruction in zip(inputs, evolved_instructions):\n            input.update(self.format_output(instruction))\n        yield inputs\n\n    self._logger.info(\n        f\"\ud83c\udf89 Finished evolving {len(evolved_instructions)} instructions!\"\n    )\n\n    if self.generate_answers:\n        self._logger.info(\n            f\"\ud83e\udde0 Generating answers for the {len(evolved_instructions)} evolved instructions!\"\n        )\n\n        answers = self._generate_answers(evolved_instructions)\n\n        self._logger.info(\n            f\"\ud83c\udf89 Finished generating answers for the {len(evolved_instructions)} evolved\"\n            \" instructions!\"\n        )\n\n        for idx, (input, instruction) in enumerate(\n            zip(inputs, evolved_instructions)\n        ):\n            input.update(self.format_output(instruction, answers[idx]))\n        yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.EvolInstructGenerator","title":"<code>EvolInstructGenerator</code>","text":"<p>             Bases: <code>GeneratorTask</code></p> <p>WizardLM: Empowering Large Language Models to Follow Complex Instructions</p> <p>Attributes:</p> Name Type Description <code>num_instructions</code> <code>int</code> <p>The number of instructions to be generated.</p> <code>generate_answers</code> <code>bool</code> <p>Whether to generate answers for the instructions or not. Defaults to <code>False</code>.</p> <code>mutation_templates</code> <code>Dict[str, str]</code> <p>The mutation templates to be used for the generation of the instructions.</p> <code>min_length</code> <code>RuntimeParameter[int]</code> <p>Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid. Defaults to <code>512</code>.</p> <code>max_length</code> <code>RuntimeParameter[int]</code> <p>Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid. Defaults to <code>1024</code>.</p> <code>seed</code> <code>RuntimeParameter[int]</code> <p>The seed to be set for <code>numpy</code> in order to randomly pick a mutation method. Defaults to <code>42</code>.</p> Runtime parameters <ul> <li><code>min_length</code>: Defines the length (in bytes) that the generated instruction needs     to be higher than, to be considered valid.</li> <li><code>max_length</code>: Defines the length (in bytes) that the generated instruction needs     to be lower than, to be considered valid.</li> <li><code>seed</code>: The seed to be set for <code>numpy</code> in order to randomly pick a mutation method.</li> </ul> Output columns <ul> <li>instruction (<code>str</code>): The generated instruction if <code>generate_answers=False</code>.</li> <li>answer (<code>str</code>): The generated answer if <code>generate_answers=True</code>.</li> <li>instructions (<code>List[str]</code>): The generated instructions if <code>generate_answers=True</code>.</li> <li>model_name (<code>str</code>): The name of the LLM used to generate and evolve the instructions.</li> </ul> References <ul> <li>WizardLM: Empowering Large Language Models to Follow Complex Instructions</li> <li>GitHub: h2oai/h2o-wizardlm</li> </ul> Source code in <code>src/distilabel/steps/tasks/evol_instruct/generator.py</code> <pre><code>class EvolInstructGenerator(GeneratorTask):\n    \"\"\"WizardLM: Empowering Large Language Models to Follow Complex Instructions\n\n    Attributes:\n        num_instructions: The number of instructions to be generated.\n        generate_answers: Whether to generate answers for the instructions or not. Defaults\n            to `False`.\n        mutation_templates: The mutation templates to be used for the generation of the\n            instructions.\n        min_length: Defines the length (in bytes) that the generated instruction needs to\n            be higher than, to be considered valid. Defaults to `512`.\n        max_length: Defines the length (in bytes) that the generated instruction needs to\n            be lower than, to be considered valid. Defaults to `1024`.\n        seed: The seed to be set for `numpy` in order to randomly pick a mutation method.\n            Defaults to `42`.\n\n    Runtime parameters:\n        - `min_length`: Defines the length (in bytes) that the generated instruction needs\n            to be higher than, to be considered valid.\n        - `max_length`: Defines the length (in bytes) that the generated instruction needs\n            to be lower than, to be considered valid.\n        - `seed`: The seed to be set for `numpy` in order to randomly pick a mutation method.\n\n    Output columns:\n        - instruction (`str`): The generated instruction if `generate_answers=False`.\n        - answer (`str`): The generated answer if `generate_answers=True`.\n        - instructions (`List[str]`): The generated instructions if `generate_answers=True`.\n        - model_name (`str`): The name of the LLM used to generate and evolve the instructions.\n\n    References:\n        - [WizardLM: Empowering Large Language Models to Follow Complex Instructions](https://arxiv.org/abs/2304.12244)\n        - [GitHub: h2oai/h2o-wizardlm](https://github.com/h2oai/h2o-wizardlm)\n    \"\"\"\n\n    num_instructions: int\n    generate_answers: bool = False\n    mutation_templates: Dict[str, str] = GENERATION_MUTATION_TEMPLATES\n\n    min_length: RuntimeParameter[int] = Field(\n        default=512,\n        description=\"Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid.\",\n    )\n    max_length: RuntimeParameter[int] = Field(\n        default=1024,\n        description=\"Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid.\",\n    )\n\n    seed: RuntimeParameter[int] = Field(\n        default=42,\n        description=\"As `numpy` is being used in order to randomly pick a mutation method, then is nice to seed a random seed.\",\n    )\n    _seed_texts: Optional[List[str]] = PrivateAttr(default_factory=list)\n    _prompts: Optional[List[str]] = PrivateAttr(default_factory=list)\n\n    def _generate_seed_texts(self) -&gt; List[str]:\n        \"\"\"Generates a list of seed texts to be used as part of the starting prompts for the task.\n\n        It will use the `FRESH_START` mutation template, as it needs to generate text from scratch; and\n        a list of English words will be used to generate the seed texts that will be provided to the\n        mutation method and included within the prompt.\n\n        Returns:\n            A list of seed texts to be used as part of the starting prompts for the task.\n        \"\"\"\n        seed_texts = []\n        for _ in range(self.num_instructions * 10):\n            num_words = np.random.choice([1, 2, 3, 4])\n            seed_texts.append(\n                self.mutation_templates[\"FRESH_START\"].replace(  # type: ignore\n                    \"&lt;PROMPT&gt;\",\n                    \", \".join(\n                        [\n                            np.random.choice(self._english_nouns).strip()\n                            for _ in range(num_words)\n                        ]\n                    ),\n                )\n            )\n        return seed_texts\n\n    @override\n    def model_post_init(self, __context: Any) -&gt; None:\n        \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n        This is useful if you want to do some validation that requires the entire model to be initialized.\n        \"\"\"\n        super().model_post_init(__context)\n\n        np.random.seed(self.seed)\n\n        self._seed_texts = self._generate_seed_texts()\n        self._prompts = [\n            np.random.choice(self._seed_texts) for _ in range(self.num_instructions)\n        ]\n\n    @cached_property\n    def _english_nouns(self) -&gt; List[str]:\n        \"\"\"A list of English nouns to be used as part of the starting prompts for the task.\n\n        References:\n            - https://github.com/h2oai/h2o-wizardlm\n        \"\"\"\n        _path = str(\n            importlib_resources.files(\"distilabel\")\n            / \"steps/tasks/evol_instruct/english_nouns.txt\"\n        )\n        with open(_path, mode=\"r\") as f:\n            return [line.strip() for line in f.readlines()]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The output for the task are the `instruction`, the `answer` if `generate_answers=True`\n        and the `model_name`.\"\"\"\n        _outputs = [\"instruction\", \"model_name\"]\n        if self.generate_answers:\n            _outputs.append(\"answer\")\n        return _outputs\n\n    def format_output(  # type: ignore\n        self, instruction: str, answer: Optional[str] = None\n    ) -&gt; Dict[str, Any]:\n        \"\"\"The output for the task is a dict with: `instruction`; `answer` if `generate_answers=True`;\n        and, finally, the `model_name`.\n\n        Args:\n            instruction: The instruction to be included within the output.\n            answer: The answer to be included within the output if `generate_answers=True`.\n\n        Returns:\n            If `generate_answers=True` return {\"instruction\": ..., \"answer\": ..., \"model_name\": ...};\n            if `generate_answers=False` return {\"instruction\": ..., \"model_name\": ...};\n        \"\"\"\n        _output = {\n            \"instruction\": instruction,\n            \"model_name\": self.llm.model_name,\n        }\n        if self.generate_answers and answer is not None:\n            _output[\"answer\"] = answer\n        return _output\n\n    @property\n    def mutation_templates_names(self) -&gt; List[str]:\n        \"\"\"Returns the names i.e. keys of the provided `mutation_templates`.\"\"\"\n        return list(self.mutation_templates.keys())\n\n    def _apply_random_mutation(self, iter_no: int) -&gt; List[\"ChatType\"]:\n        \"\"\"Applies a random mutation from the ones provided as part of the `mutation_templates`\n        enum, and returns the provided instruction within the mutation prompt.\n\n        Args:\n            iter_no: The iteration number to be used to check whether the iteration is the\n                first one i.e. FRESH_START, or not.\n\n        Returns:\n            A random mutation prompt with the provided instruction formatted as an OpenAI conversation.\n        \"\"\"\n        prompts = []\n        for idx in range(self.num_instructions):\n            if (\n                iter_no == 0\n                or \"Write one question or request containing\" in self._prompts[idx]  # type: ignore\n            ):\n                mutation = \"FRESH_START\"\n            else:\n                mutation = np.random.choice(self.mutation_templates_names)\n                if mutation == \"FRESH_START\":\n                    self._prompts[idx] = np.random.choice(self._seed_texts)  # type: ignore\n\n            prompt_with_template = (\n                self.mutation_templates[mutation].replace(  # type: ignore\n                    \"&lt;PROMPT&gt;\",\n                    self._prompts[idx],  # type: ignore\n                )  # type: ignore\n                if iter_no != 0\n                else self._prompts[idx]  # type: ignore\n            )\n            prompts.append([{\"role\": \"user\", \"content\": prompt_with_template}])\n        return prompts\n\n    def _generate_answers(self, instructions: List[List[str]]) -&gt; List[str]:\n        \"\"\"Generates the answer for the last instruction in `instructions`.\n\n        Args:\n            instructions: A list of lists where each item is a list with either the last\n                evolved instruction if `store_evolutions=False` or all the evolved instructions\n                if `store_evolutions=True`.\n\n        Returns:\n            A list of answers for the last instruction in `instructions`.\n        \"\"\"\n        # TODO: update to generate answers for all the instructions\n        _formatted_instructions = [\n            [{\"role\": \"user\", \"content\": instruction[-1]}]\n            for instruction in instructions\n        ]\n        responses = self.llm.generate(\n            _formatted_instructions,\n            **self.llm.generation_kwargs,  # type: ignore\n        )\n        return flatten_responses(responses)\n\n    @override\n    def process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":  # type: ignore\n        \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n        Args:\n            offset: The offset to start the generation from. Defaults to 0.\n\n        Yields:\n            A list of Python dictionaries with the outputs of the task, and a boolean\n            flag indicating whether the task has finished or not i.e. is the last batch.\n        \"\"\"\n        instructions = []\n        mutation_no = 0\n\n        iter_no = 0\n        while len(instructions) &lt; self.num_instructions:\n            prompts = self._apply_random_mutation(iter_no=iter_no)\n\n            generated_prompts = flatten_responses(\n                self.llm.generate(prompts, **self.llm.generation_kwargs)  # type: ignore\n            )\n            for idx, generated_prompt in enumerate(generated_prompts):\n                generated_prompt = generated_prompt.split(\"Prompt#:\")[-1].strip()\n                if self.max_length &gt;= len(generated_prompt) &gt;= self.min_length:  # type: ignore\n                    instructions.append(generated_prompt)\n                    self._prompts[idx] = np.random.choice(self._seed_texts)  # type: ignore\n                else:\n                    self._prompts[idx] = generated_prompt  # type: ignore\n\n            self._logger.info(\n                f\"\ud83d\udd04 Ran iteration {iter_no} with {len(instructions)} instructions already evolved!\"\n            )\n            iter_no += 1\n\n            if len(instructions) &gt; self.num_instructions:\n                instructions = instructions[: self.num_instructions]\n            if len(instructions) &gt; mutation_no:\n                mutation_no = len(instructions) - mutation_no\n\n            if not self.generate_answers and len(instructions[-mutation_no:]) &gt; 0:\n                yield (\n                    [\n                        self.format_output(mutated_instruction)\n                        for mutated_instruction in instructions[-mutation_no:]\n                    ],\n                    len(instructions) &gt;= self.num_instructions,\n                )\n\n        self._logger.info(f\"\ud83c\udf89 Finished evolving {len(instructions)} instructions!\")\n\n        if self.generate_answers:\n            self._logger.info(\n                f\"\ud83e\udde0 Generating answers for the {len(instructions)} evolved instructions!\"\n            )\n\n            answers = self._generate_answers(instructions)\n\n            self._logger.info(\n                f\"\ud83c\udf89 Finished generating answers for the {len(instructions)} evolved instructions!\"\n            )\n\n            yield (\n                [\n                    self.format_output(instruction, answer)\n                    for instruction, answer in zip(instructions, answers)\n                ],\n                True,\n            )\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.EvolInstructGenerator.mutation_templates_names","title":"<code>mutation_templates_names: List[str]</code>  <code>property</code>","text":"<p>Returns the names i.e. keys of the provided <code>mutation_templates</code>.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.EvolInstructGenerator.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The output for the task are the <code>instruction</code>, the <code>answer</code> if <code>generate_answers=True</code> and the <code>model_name</code>.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.EvolInstructGenerator.format_output","title":"<code>format_output(instruction, answer=None)</code>","text":"<p>The output for the task is a dict with: <code>instruction</code>; <code>answer</code> if <code>generate_answers=True</code>; and, finally, the <code>model_name</code>.</p> <p>Parameters:</p> Name Type Description Default <code>instruction</code> <code>str</code> <p>The instruction to be included within the output.</p> required <code>answer</code> <code>Optional[str]</code> <p>The answer to be included within the output if <code>generate_answers=True</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>If <code>generate_answers=True</code> return {\"instruction\": ..., \"answer\": ..., \"model_name\": ...};</p> <code>Dict[str, Any]</code> <p>if <code>generate_answers=False</code> return {\"instruction\": ..., \"model_name\": ...};</p> Source code in <code>src/distilabel/steps/tasks/evol_instruct/generator.py</code> <pre><code>def format_output(  # type: ignore\n    self, instruction: str, answer: Optional[str] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"The output for the task is a dict with: `instruction`; `answer` if `generate_answers=True`;\n    and, finally, the `model_name`.\n\n    Args:\n        instruction: The instruction to be included within the output.\n        answer: The answer to be included within the output if `generate_answers=True`.\n\n    Returns:\n        If `generate_answers=True` return {\"instruction\": ..., \"answer\": ..., \"model_name\": ...};\n        if `generate_answers=False` return {\"instruction\": ..., \"model_name\": ...};\n    \"\"\"\n    _output = {\n        \"instruction\": instruction,\n        \"model_name\": self.llm.model_name,\n    }\n    if self.generate_answers and answer is not None:\n        _output[\"answer\"] = answer\n    return _output\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.EvolInstructGenerator.model_post_init","title":"<code>model_post_init(__context)</code>","text":"<p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>src/distilabel/steps/tasks/evol_instruct/generator.py</code> <pre><code>@override\ndef model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n    super().model_post_init(__context)\n\n    np.random.seed(self.seed)\n\n    self._seed_texts = self._generate_seed_texts()\n    self._prompts = [\n        np.random.choice(self._seed_texts) for _ in range(self.num_instructions)\n    ]\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.EvolInstructGenerator.process","title":"<code>process(offset=0)</code>","text":"<p>Processes the inputs of the task and generates the outputs using the LLM.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The offset to start the generation from. Defaults to 0.</p> <code>0</code> <p>Yields:</p> Type Description <code>GeneratorStepOutput</code> <p>A list of Python dictionaries with the outputs of the task, and a boolean</p> <code>GeneratorStepOutput</code> <p>flag indicating whether the task has finished or not i.e. is the last batch.</p> Source code in <code>src/distilabel/steps/tasks/evol_instruct/generator.py</code> <pre><code>@override\ndef process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":  # type: ignore\n    \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n    Args:\n        offset: The offset to start the generation from. Defaults to 0.\n\n    Yields:\n        A list of Python dictionaries with the outputs of the task, and a boolean\n        flag indicating whether the task has finished or not i.e. is the last batch.\n    \"\"\"\n    instructions = []\n    mutation_no = 0\n\n    iter_no = 0\n    while len(instructions) &lt; self.num_instructions:\n        prompts = self._apply_random_mutation(iter_no=iter_no)\n\n        generated_prompts = flatten_responses(\n            self.llm.generate(prompts, **self.llm.generation_kwargs)  # type: ignore\n        )\n        for idx, generated_prompt in enumerate(generated_prompts):\n            generated_prompt = generated_prompt.split(\"Prompt#:\")[-1].strip()\n            if self.max_length &gt;= len(generated_prompt) &gt;= self.min_length:  # type: ignore\n                instructions.append(generated_prompt)\n                self._prompts[idx] = np.random.choice(self._seed_texts)  # type: ignore\n            else:\n                self._prompts[idx] = generated_prompt  # type: ignore\n\n        self._logger.info(\n            f\"\ud83d\udd04 Ran iteration {iter_no} with {len(instructions)} instructions already evolved!\"\n        )\n        iter_no += 1\n\n        if len(instructions) &gt; self.num_instructions:\n            instructions = instructions[: self.num_instructions]\n        if len(instructions) &gt; mutation_no:\n            mutation_no = len(instructions) - mutation_no\n\n        if not self.generate_answers and len(instructions[-mutation_no:]) &gt; 0:\n            yield (\n                [\n                    self.format_output(mutated_instruction)\n                    for mutated_instruction in instructions[-mutation_no:]\n                ],\n                len(instructions) &gt;= self.num_instructions,\n            )\n\n    self._logger.info(f\"\ud83c\udf89 Finished evolving {len(instructions)} instructions!\")\n\n    if self.generate_answers:\n        self._logger.info(\n            f\"\ud83e\udde0 Generating answers for the {len(instructions)} evolved instructions!\"\n        )\n\n        answers = self._generate_answers(instructions)\n\n        self._logger.info(\n            f\"\ud83c\udf89 Finished generating answers for the {len(instructions)} evolved instructions!\"\n        )\n\n        yield (\n            [\n                self.format_output(instruction, answer)\n                for instruction, answer in zip(instructions, answers)\n            ],\n            True,\n        )\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.GenerateEmbeddings","title":"<code>GenerateEmbeddings</code>","text":"<p>             Bases: <code>Step</code></p> <p>Generate embeddings for a text input using the last hidden state of an <code>LLM</code>, as described in the paper 'What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.</p> <p>Attributes:</p> Name Type Description <code>llm</code> <code>LLM</code> <p>The <code>LLM</code> to use to generate the embeddings.</p> Input columns <ul> <li>text (<code>str</code>, <code>List[Dict[str, str]]</code>): The input text or conversation to generate     embeddings for.</li> </ul> Output columns <ul> <li>embedding (<code>List[float]</code>): The embedding of the input text or conversation.</li> </ul> References <ul> <li>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</li> </ul> Source code in <code>src/distilabel/steps/tasks/generate_embeddings.py</code> <pre><code>class GenerateEmbeddings(Step):\n    \"\"\"Generate embeddings for a text input using the last hidden state of an `LLM`, as\n    described in the paper 'What Makes Good Data for Alignment? A Comprehensive Study of\n    Automatic Data Selection in Instruction Tuning'.\n\n    Attributes:\n        llm: The `LLM` to use to generate the embeddings.\n\n    Input columns:\n        - text (`str`, `List[Dict[str, str]]`): The input text or conversation to generate\n            embeddings for.\n\n    Output columns:\n        - embedding (`List[float]`): The embedding of the input text or conversation.\n\n    References:\n        - [What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning](https://arxiv.org/abs/2312.15685)\n    \"\"\"\n\n    llm: LLM\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `LLM` used to generate the embeddings.\"\"\"\n        super().load()\n        self.llm.load()\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The inputs for the task is a `text` column containing either a string or a\n        list of dictionaries in OpenAI chat-like format.\"\"\"\n        return [\"text\"]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The outputs for the task is an `embedding` column containing the embedding of\n        the `text` input.\"\"\"\n        return [\"embedding\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n        \"\"\"Formats the input to be used by the LLM to generate the embeddings. The input\n        can be in `ChatType` format or a string. If a string, it will be converted to a\n        list of dictionaries in OpenAI chat-like format.\n\n        Args:\n            input: The input to format.\n\n        Returns:\n            The OpenAI chat-like format of the input.\n        \"\"\"\n        text = input[\"text\"] = input[\"text\"]\n\n        # input is in `ChatType` format\n        if isinstance(text, str):\n            return [{\"role\": \"user\", \"content\": text}]\n\n        if is_openai_format(text):\n            return text\n\n        raise ValueError(\n            f\"Couldn't format input for step {self.name}. The `text` input column has to\"\n            \" be a string or a list of dictionaries in OpenAI chat-like format.\"\n        )\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Generates an embedding for each input using the last hidden state of the `LLM`.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Yields:\n            A list of Python dictionaries with the outputs of the task.\n        \"\"\"\n        formatted_inputs = [self.format_input(input) for input in inputs]\n        last_hidden_states = self.llm.get_last_hidden_states(formatted_inputs)\n        for input, hidden_state in zip(inputs, last_hidden_states):\n            input[\"embedding\"] = hidden_state[-1].tolist()\n        yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.GenerateEmbeddings.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The inputs for the task is a <code>text</code> column containing either a string or a list of dictionaries in OpenAI chat-like format.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.GenerateEmbeddings.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The outputs for the task is an <code>embedding</code> column containing the embedding of the <code>text</code> input.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.GenerateEmbeddings.format_input","title":"<code>format_input(input)</code>","text":"<p>Formats the input to be used by the LLM to generate the embeddings. The input can be in <code>ChatType</code> format or a string. If a string, it will be converted to a list of dictionaries in OpenAI chat-like format.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Dict[str, Any]</code> <p>The input to format.</p> required <p>Returns:</p> Type Description <code>ChatType</code> <p>The OpenAI chat-like format of the input.</p> Source code in <code>src/distilabel/steps/tasks/generate_embeddings.py</code> <pre><code>def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n    \"\"\"Formats the input to be used by the LLM to generate the embeddings. The input\n    can be in `ChatType` format or a string. If a string, it will be converted to a\n    list of dictionaries in OpenAI chat-like format.\n\n    Args:\n        input: The input to format.\n\n    Returns:\n        The OpenAI chat-like format of the input.\n    \"\"\"\n    text = input[\"text\"] = input[\"text\"]\n\n    # input is in `ChatType` format\n    if isinstance(text, str):\n        return [{\"role\": \"user\", \"content\": text}]\n\n    if is_openai_format(text):\n        return text\n\n    raise ValueError(\n        f\"Couldn't format input for step {self.name}. The `text` input column has to\"\n        \" be a string or a list of dictionaries in OpenAI chat-like format.\"\n    )\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.GenerateEmbeddings.load","title":"<code>load()</code>","text":"<p>Loads the <code>LLM</code> used to generate the embeddings.</p> Source code in <code>src/distilabel/steps/tasks/generate_embeddings.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `LLM` used to generate the embeddings.\"\"\"\n    super().load()\n    self.llm.load()\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.GenerateEmbeddings.process","title":"<code>process(inputs)</code>","text":"<p>Generates an embedding for each input using the last hidden state of the <code>LLM</code>.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>A list of Python dictionaries with the inputs of the task.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>A list of Python dictionaries with the outputs of the task.</p> Source code in <code>src/distilabel/steps/tasks/generate_embeddings.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Generates an embedding for each input using the last hidden state of the `LLM`.\n\n    Args:\n        inputs: A list of Python dictionaries with the inputs of the task.\n\n    Yields:\n        A list of Python dictionaries with the outputs of the task.\n    \"\"\"\n    formatted_inputs = [self.format_input(input) for input in inputs]\n    last_hidden_states = self.llm.get_last_hidden_states(formatted_inputs)\n    for input, hidden_state in zip(inputs, last_hidden_states):\n        input[\"embedding\"] = hidden_state[-1].tolist()\n    yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.GeneratorTask","title":"<code>GeneratorTask</code>","text":"<p>             Bases: <code>_Task</code>, <code>GeneratorStep</code></p> <p>GeneratorTask is a class that implements the <code>_Task</code> abstract class and adds the <code>GeneratorStep</code> interface to be used as a step in the pipeline.</p> <p>Attributes:</p> Name Type Description <code>llm</code> <p>the <code>LLM</code> to be used to generate the outputs of the task.</p> <code>group_generations</code> <p>whether to group the <code>num_generations</code> generated per input in a list or create a row per generation. Defaults to <code>False</code>.</p> <code>num_generations</code> <p>The number of generations to be produced per input.</p> Source code in <code>src/distilabel/steps/tasks/base.py</code> <pre><code>class GeneratorTask(_Task, GeneratorStep):\n    \"\"\"GeneratorTask is a class that implements the `_Task` abstract class and adds the\n    `GeneratorStep` interface to be used as a step in the pipeline.\n\n    Attributes:\n        llm: the `LLM` to be used to generate the outputs of the task.\n        group_generations: whether to group the `num_generations` generated per input in\n            a list or create a row per generation. Defaults to `False`.\n        num_generations: The number of generations to be produced per input.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.InstructionBacktranslation","title":"<code>InstructionBacktranslation</code>","text":"<p>             Bases: <code>Task</code></p> <p>Self-Alignment with Instruction Backtranslation.</p> <p>Attributes:</p> Name Type Description <code>_template</code> <code>Optional[Template]</code> <p>the Jinja2 template to use for the Instruction Backtranslation task.</p> Input columns <ul> <li>instruction (<code>str</code>): The reference instruction to evaluate the text output.</li> <li>generation (<code>str</code>): The text output to evaluate for the given instruction.</li> </ul> Output columns <ul> <li>score (<code>str</code>): The score for the generation based on the given instruction.</li> </ul> References <ul> <li><code>Self-Alignment with Instruction Backtranslation</code></li> </ul> Source code in <code>src/distilabel/steps/tasks/instruction_backtranslation.py</code> <pre><code>class InstructionBacktranslation(Task):\n    \"\"\"Self-Alignment with Instruction Backtranslation.\n\n    Attributes:\n        _template: the Jinja2 template to use for the Instruction Backtranslation task.\n\n    Input columns:\n        - instruction (`str`): The reference instruction to evaluate the text output.\n        - generation (`str`): The text output to evaluate for the given instruction.\n\n    Output columns:\n        - score (`str`): The score for the generation based on the given instruction.\n\n    References:\n        - [`Self-Alignment with Instruction Backtranslation`](https://arxiv.org/abs/2308.06259)\n    \"\"\"\n\n    _template: Optional[\"Template\"] = PrivateAttr(default=...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the Jinja2 template with the Instruction Backtranslation prompt.\"\"\"\n        super().load()\n\n        _path = str(\n            importlib_resources.files(\"distilabel\")\n            / \"steps\"\n            / \"tasks\"\n            / \"templates\"\n            / \"instruction-backtranslation.jinja2\"\n        )\n\n        self._template = Template(open(_path).read())\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input for the task is the `instruction`, and the `generation` for it.\"\"\"\n        return [\"instruction\", \"generation\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n        \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n        is the first interaction from the user within a conversation.\"\"\"\n        return [\n            {\n                \"role\": \"user\",\n                \"content\": self._template.render(  # type: ignore\n                    instruction=input[\"instruction\"], generation=input[\"generation\"]\n                ),\n            },\n        ]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The output for the task is the `score`, `reason` and the `model_name`.\"\"\"\n        return [\"score\", \"reason\", \"model_name\"]\n\n    def format_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, Any]:\n        \"\"\"The output is formatted as a dictionary with the `score` and `reason`. The\n        `model_name` will be automatically included within the `process` method of `Task`.\n\n        Args:\n            output: a string representing the output of the LLM via the `process` method.\n            input: the input to the task, as required by some tasks to format the output.\n\n        Returns:\n            A dictionary containing the `score` and the `reason` for the provided `score`.\n        \"\"\"\n        pattern = r\"(.+?)Score: (\\d)\"\n\n        matches = None\n        if output is not None:\n            matches = re.findall(pattern, output, re.DOTALL)\n        if matches is None:\n            return {\"score\": None, \"reason\": None}\n\n        return {\n            \"score\": int(matches[0][1]),\n            \"reason\": matches[0][0].strip(),\n        }\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.InstructionBacktranslation.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input for the task is the <code>instruction</code>, and the <code>generation</code> for it.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.InstructionBacktranslation.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The output for the task is the <code>score</code>, <code>reason</code> and the <code>model_name</code>.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.InstructionBacktranslation.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is formatted as a <code>ChatType</code> assuming that the instruction is the first interaction from the user within a conversation.</p> Source code in <code>src/distilabel/steps/tasks/instruction_backtranslation.py</code> <pre><code>def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n    \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n    is the first interaction from the user within a conversation.\"\"\"\n    return [\n        {\n            \"role\": \"user\",\n            \"content\": self._template.render(  # type: ignore\n                instruction=input[\"instruction\"], generation=input[\"generation\"]\n            ),\n        },\n    ]\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.InstructionBacktranslation.format_output","title":"<code>format_output(output, input)</code>","text":"<p>The output is formatted as a dictionary with the <code>score</code> and <code>reason</code>. The <code>model_name</code> will be automatically included within the <code>process</code> method of <code>Task</code>.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>Union[str, None]</code> <p>a string representing the output of the LLM via the <code>process</code> method.</p> required <code>input</code> <code>Dict[str, Any]</code> <p>the input to the task, as required by some tasks to format the output.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary containing the <code>score</code> and the <code>reason</code> for the provided <code>score</code>.</p> Source code in <code>src/distilabel/steps/tasks/instruction_backtranslation.py</code> <pre><code>def format_output(\n    self, output: Union[str, None], input: Dict[str, Any]\n) -&gt; Dict[str, Any]:\n    \"\"\"The output is formatted as a dictionary with the `score` and `reason`. The\n    `model_name` will be automatically included within the `process` method of `Task`.\n\n    Args:\n        output: a string representing the output of the LLM via the `process` method.\n        input: the input to the task, as required by some tasks to format the output.\n\n    Returns:\n        A dictionary containing the `score` and the `reason` for the provided `score`.\n    \"\"\"\n    pattern = r\"(.+?)Score: (\\d)\"\n\n    matches = None\n    if output is not None:\n        matches = re.findall(pattern, output, re.DOTALL)\n    if matches is None:\n        return {\"score\": None, \"reason\": None}\n\n    return {\n        \"score\": int(matches[0][1]),\n        \"reason\": matches[0][0].strip(),\n    }\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.InstructionBacktranslation.load","title":"<code>load()</code>","text":"<p>Loads the Jinja2 template with the Instruction Backtranslation prompt.</p> Source code in <code>src/distilabel/steps/tasks/instruction_backtranslation.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the Jinja2 template with the Instruction Backtranslation prompt.\"\"\"\n    super().load()\n\n    _path = str(\n        importlib_resources.files(\"distilabel\")\n        / \"steps\"\n        / \"tasks\"\n        / \"templates\"\n        / \"instruction-backtranslation.jinja2\"\n    )\n\n    self._template = Template(open(_path).read())\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.PairRM","title":"<code>PairRM</code>","text":"<p>             Bases: <code>Step</code></p> <p>Rank the candidates based on the input using the <code>LLM</code> model.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>The model to use for the ranking. Defaults to <code>\"llm-blender/PairRM\"</code>.</p> <code>input_batch_size</code> <code>int</code> <p>The batch size to use when processing the input. Defauls to <code>8</code>.</p> <code>instructions</code> <code>Optional[str]</code> <p>The instructions to use for the model. Defaults to <code>None</code>.</p> Input columns <ul> <li>inputs (<code>List[Dict[str, Any]]</code>): The input text or conversation to rank the candidates for.</li> <li>candidates (<code>List[Dict[str, Any]]</code>): The candidates to rank.</li> </ul> Output columns <ul> <li>ranks (<code>List[int]</code>): The ranks of the candidates based on the input.</li> <li>ranked_candidates (<code>List[Dict[str, Any]]</code>): The candidates ranked based on the input.</li> </ul> References <ul> <li>LLM-Blender: Ensembling Large Language Models with Pairwise Ranking and Generative Fusion.</li> <li>Pair Ranking Model.</li> </ul> Note <p>This step differs to other tasks as there is a single implementation of this model currently, and we will use a specific <code>LLM</code>.</p> Source code in <code>src/distilabel/steps/tasks/pair_rm.py</code> <pre><code>class PairRM(Step):\n    \"\"\"Rank the candidates based on the input using the `LLM` model.\n\n    Attributes:\n        model: The model to use for the ranking. Defaults to `\"llm-blender/PairRM\"`.\n        input_batch_size: The batch size to use when processing the input. Defauls to `8`.\n        instructions: The instructions to use for the model. Defaults to `None`.\n\n    Input columns:\n        - inputs (`List[Dict[str, Any]]`): The input text or conversation to rank the candidates for.\n        - candidates (`List[Dict[str, Any]]`): The candidates to rank.\n\n    Output columns:\n        - ranks (`List[int]`): The ranks of the candidates based on the input.\n        - ranked_candidates (`List[Dict[str, Any]]`): The candidates ranked based on the input.\n\n    References:\n        - [LLM-Blender: Ensembling Large Language Models with Pairwise Ranking and Generative Fusion](https://arxiv.org/abs/2306.02561).\n        - [Pair Ranking Model](https://huggingface.co/llm-blender/PairRM).\n\n    Note:\n        This step differs to other tasks as there is a single implementation of this model\n        currently, and we will use a specific `LLM`.\n    \"\"\"\n\n    model: str = \"llm-blender/PairRM\"\n    input_batch_size: int = 8\n    instructions: Optional[str] = None\n\n    def load(self) -&gt; None:\n        try:\n            import llm_blender\n        except ImportError as e:\n            raise ImportError(\n                \"The `llm_blender` package is required to use the `PairRM` class.\"\n                \"Please install it with `pip install git+https://github.com/yuchenlin/LLM-Blender.git`.\"\n            ) from e\n        self._blender = llm_blender.Blender()\n        self._blender.loadranker(self.model)\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input columns correspond to the two required arguments from `Blender.rank`:\n        `inputs` and `candidates`.\"\"\"\n        return [\"input\", \"candidates\"]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The outputs will include the `ranks` and the `ranked_candidates`.\"\"\"\n        return [\"ranks\", \"ranked_candidates\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"The input is expected to be a dictionary with the keys `input` and `candidates`,\n        where the `input` corresponds to the instruction of a model and `candidates` are a\n        list of responses to be ranked.\n        \"\"\"\n        return input\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Generates the ranks for the candidates based on the input.\n\n        The ranks are the positions of the candidates, where lower is better,\n        and the ranked candidates correspond to the candidates sorted according to the\n        ranks obtained.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Yields:\n            An iterator with the inputs containing the `ranks` and the `ranked_candidates`.\n        \"\"\"\n        input_texts = []\n        candidates = []\n        for input in inputs:\n            formatted_input = self.format_input(input)\n            input_texts.append(formatted_input[\"input\"])\n            candidates.append(formatted_input[\"candidates\"])\n\n        instructions = (\n            [self.instructions] * len(input_texts) if self.instructions else None\n        )\n\n        ranks = self._blender.rank(\n            input_texts,\n            candidates,\n            instructions=instructions,\n            return_scores=False,\n            batch_size=self.input_batch_size,\n        )\n        # Sort the candidates based on the ranks\n        ranked_candidates = np.take_along_axis(\n            np.array(candidates), ranks - 1, axis=1\n        ).tolist()\n        ranks = ranks.tolist()\n        for input, rank, ranked_candidate in zip(inputs, ranks, ranked_candidates):\n            input[\"ranks\"] = rank\n            input[\"ranked_candidates\"] = ranked_candidate\n\n        yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.PairRM.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input columns correspond to the two required arguments from <code>Blender.rank</code>: <code>inputs</code> and <code>candidates</code>.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.PairRM.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The outputs will include the <code>ranks</code> and the <code>ranked_candidates</code>.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.PairRM.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is expected to be a dictionary with the keys <code>input</code> and <code>candidates</code>, where the <code>input</code> corresponds to the instruction of a model and <code>candidates</code> are a list of responses to be ranked.</p> Source code in <code>src/distilabel/steps/tasks/pair_rm.py</code> <pre><code>def format_input(self, input: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"The input is expected to be a dictionary with the keys `input` and `candidates`,\n    where the `input` corresponds to the instruction of a model and `candidates` are a\n    list of responses to be ranked.\n    \"\"\"\n    return input\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.PairRM.process","title":"<code>process(inputs)</code>","text":"<p>Generates the ranks for the candidates based on the input.</p> <p>The ranks are the positions of the candidates, where lower is better, and the ranked candidates correspond to the candidates sorted according to the ranks obtained.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>A list of Python dictionaries with the inputs of the task.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>An iterator with the inputs containing the <code>ranks</code> and the <code>ranked_candidates</code>.</p> Source code in <code>src/distilabel/steps/tasks/pair_rm.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Generates the ranks for the candidates based on the input.\n\n    The ranks are the positions of the candidates, where lower is better,\n    and the ranked candidates correspond to the candidates sorted according to the\n    ranks obtained.\n\n    Args:\n        inputs: A list of Python dictionaries with the inputs of the task.\n\n    Yields:\n        An iterator with the inputs containing the `ranks` and the `ranked_candidates`.\n    \"\"\"\n    input_texts = []\n    candidates = []\n    for input in inputs:\n        formatted_input = self.format_input(input)\n        input_texts.append(formatted_input[\"input\"])\n        candidates.append(formatted_input[\"candidates\"])\n\n    instructions = (\n        [self.instructions] * len(input_texts) if self.instructions else None\n    )\n\n    ranks = self._blender.rank(\n        input_texts,\n        candidates,\n        instructions=instructions,\n        return_scores=False,\n        batch_size=self.input_batch_size,\n    )\n    # Sort the candidates based on the ranks\n    ranked_candidates = np.take_along_axis(\n        np.array(candidates), ranks - 1, axis=1\n    ).tolist()\n    ranks = ranks.tolist()\n    for input, rank, ranked_candidate in zip(inputs, ranks, ranked_candidates):\n        input[\"ranks\"] = rank\n        input[\"ranked_candidates\"] = ranked_candidate\n\n    yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.QualityScorer","title":"<code>QualityScorer</code>","text":"<p>             Bases: <code>Task</code></p> <p>QualityScorer is a pre-defined task that defines the <code>instruction</code> as the input and <code>score</code> as the output. This task is used to rate the quality of instructions and responses. It's an implementation of the quality score task from the paper 'What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'. The task follows the same scheme as the Complexity Scorer, but the instruction-response pairs are scored in terms of quality, obtaining a quality score for each instruction.</p> <p>Attributes:</p> Name Type Description <code>_template</code> <code>Union[Template, None]</code> <p>a Jinja2 template used to format the input for the LLM.</p> Input columns <ul> <li>instruction (<code>str</code>): The instruction that was used to generate the <code>responses</code>.</li> <li>responses (<code>List[str]</code>): The responses to be scored. Each response forms a pair with the instruction.</li> </ul> Output columns <ul> <li>quality_score (<code>List[float]</code>): The quality score for each instruction.</li> </ul> References <ul> <li><code>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</code></li> </ul> Source code in <code>src/distilabel/steps/tasks/quality_scorer.py</code> <pre><code>class QualityScorer(Task):\n    \"\"\"QualityScorer is a pre-defined task that defines the `instruction` as the input\n    and `score` as the output. This task is used to rate the quality of instructions and responses.\n    It's an implementation of the quality score task from the paper 'What Makes Good Data\n    for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.\n    The task follows the same scheme as the Complexity Scorer, but the instruction-response pairs\n    are scored in terms of quality, obtaining a quality score for each instruction.\n\n    Attributes:\n        _template: a Jinja2 template used to format the input for the LLM.\n\n    Input columns:\n        - instruction (`str`): The instruction that was used to generate the `responses`.\n        - responses (`List[str]`): The responses to be scored. Each response forms a pair with the instruction.\n\n    Output columns:\n        - quality_score (`List[float]`): The quality score for each instruction.\n\n    References:\n        - [`What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning`](https://arxiv.org/abs/2312.15685)\n    \"\"\"\n\n    _template: Union[Template, None] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        super().load()\n        self._template = Template(_QUALITY_SCORER_TEMPLATE)\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input for the task are `instruction` and `responses`.\"\"\"\n        return [\"instruction\", \"responses\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; ChatType:  # type: ignore\n        \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n        is the first interaction from the user within a conversation.\"\"\"\n        return [{\"role\": \"user\", \"content\": self._template.render(**input)}]  # type: ignore\n\n    @property\n    def outputs(self):\n        \"\"\"The output for the task is a list of `quality_scores` containing the quality score for each\n        response in `responses`.\"\"\"\n        return [\"scores\"]\n\n    def format_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, Any]:\n        \"\"\"The output is formatted as a list with the score of each instruction-response pair.\n\n        Args:\n            output: the raw output of the LLM.\n            input: the input to the task. Used for obtaining the number of responses.\n\n        Returns:\n            A dict with containing the scores for each instruction-response pair.\n        \"\"\"\n\n        if output is None:\n            return {self.outputs[0]: [None] * len(input[\"responses\"])}\n\n        scores = []\n        score_lines = output.split(\"\\n\")\n\n        for i, line in enumerate(score_lines):\n            match = _PARSE_SCORE_LINE_REGEX.match(line)\n            score = float(match.group(1)) if match else None\n            scores.append(score)\n            if i == len(input[\"responses\"]) - 1:\n                break\n\n        return {self.outputs[0]: scores}\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.QualityScorer.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input for the task are <code>instruction</code> and <code>responses</code>.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.QualityScorer.outputs","title":"<code>outputs</code>  <code>property</code>","text":"<p>The output for the task is a list of <code>quality_scores</code> containing the quality score for each response in <code>responses</code>.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.QualityScorer.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is formatted as a <code>ChatType</code> assuming that the instruction is the first interaction from the user within a conversation.</p> Source code in <code>src/distilabel/steps/tasks/quality_scorer.py</code> <pre><code>def format_input(self, input: Dict[str, Any]) -&gt; ChatType:  # type: ignore\n    \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n    is the first interaction from the user within a conversation.\"\"\"\n    return [{\"role\": \"user\", \"content\": self._template.render(**input)}]  # type: ignore\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.QualityScorer.format_output","title":"<code>format_output(output, input)</code>","text":"<p>The output is formatted as a list with the score of each instruction-response pair.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>Union[str, None]</code> <p>the raw output of the LLM.</p> required <code>input</code> <code>Dict[str, Any]</code> <p>the input to the task. Used for obtaining the number of responses.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dict with containing the scores for each instruction-response pair.</p> Source code in <code>src/distilabel/steps/tasks/quality_scorer.py</code> <pre><code>def format_output(\n    self, output: Union[str, None], input: Dict[str, Any]\n) -&gt; Dict[str, Any]:\n    \"\"\"The output is formatted as a list with the score of each instruction-response pair.\n\n    Args:\n        output: the raw output of the LLM.\n        input: the input to the task. Used for obtaining the number of responses.\n\n    Returns:\n        A dict with containing the scores for each instruction-response pair.\n    \"\"\"\n\n    if output is None:\n        return {self.outputs[0]: [None] * len(input[\"responses\"])}\n\n    scores = []\n    score_lines = output.split(\"\\n\")\n\n    for i, line in enumerate(score_lines):\n        match = _PARSE_SCORE_LINE_REGEX.match(line)\n        score = float(match.group(1)) if match else None\n        scores.append(score)\n        if i == len(input[\"responses\"]) - 1:\n            break\n\n    return {self.outputs[0]: scores}\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.SelfInstruct","title":"<code>SelfInstruct</code>","text":"<p>             Bases: <code>Task</code></p> <p>SelfInstruct is a pre-defined task that, given a number of instructions, a certain criteria for query generations, an application description, and an input, generates a number of instruction related to the given input and following what is stated in the criteria for query generation and the application description. It is based in the SelfInstruct framework from the paper \"Self-Instruct: Aligning Language Models with Self-Generated Instructions\".</p> <p>Attributes:</p> Name Type Description <code>num_instructions</code> <code>int</code> <p>The number of instructions to be generated. Defaults to 5.</p> <code>criteria_for_query_generation</code> <code>str</code> <p>The criteria for the query generation. Defaults to the criteria defined within the paper.</p> <code>application_description</code> <code>str</code> <p>The description of the AI application that one want to build with these instructions. Defaults to <code>AI assistant</code>.</p> Input columns <ul> <li>input (<code>str</code>): The input to generate the instructions. It's also called seed in the paper.</li> </ul> Output columns <ul> <li>instructions (<code>List[str]</code>): The generated instructions.</li> </ul> Reference <ul> <li><code>Self-Instruct: Aligning Language Models with Self-Generated Instructions</code></li> </ul> Source code in <code>src/distilabel/steps/tasks/self_instruct.py</code> <pre><code>class SelfInstruct(Task):\n    \"\"\"SelfInstruct is a pre-defined task that, given a number of instructions, a\n    certain criteria for query generations, an application description, and an input,\n    generates a number of instruction related to the given input and following what\n    is stated in the criteria for query generation and the application description.\n    It is based in the SelfInstruct framework from the paper \"Self-Instruct: Aligning\n    Language Models with Self-Generated Instructions\".\n\n    Attributes:\n        num_instructions: The number of instructions to be generated. Defaults to 5.\n        criteria_for_query_generation: The criteria for the query generation. Defaults\n            to the criteria defined within the paper.\n        application_description: The description of the AI application that one want\n            to build with these instructions. Defaults to `AI assistant`.\n\n    Input columns:\n        - input (`str`): The input to generate the instructions. It's also called seed in the paper.\n\n    Output columns:\n        - instructions (`List[str]`): The generated instructions.\n\n    Reference:\n        - [`Self-Instruct: Aligning Language Models with Self-Generated Instructions`](https://arxiv.org/abs/2212.10560)\n    \"\"\"\n\n    num_instructions: int = 5\n\n    criteria_for_query_generation: str = (\n        \"Incorporate a diverse range of verbs, avoiding repetition.\\n\"\n        \"Ensure queries are compatible with AI model's text generation functions and are limited to 1-2 sentences.\\n\"\n        \"Design queries to be self-contained and standalone.\\n\"\n        'Blend interrogative (e.g., \"What is the significance of x?\") and imperative (e.g., \"Detail the process of x.\") styles.'\n    )\n\n    application_description: str = \"AI assistant\"\n\n    _template: Template = PrivateAttr(default=...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the Jinja2 template for SelfInstruct.\"\"\"\n        super().load()\n\n        _path = str(\n            importlib_resources.files(\"distilabel\")\n            / \"steps\"\n            / \"tasks\"\n            / \"templates\"\n            / \"self-instruct.jinja2\"\n        )\n\n        self._template = Template(open(_path).read())\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input for the task is the `input` i.e. seed text.\"\"\"\n        return [\"input\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n        \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n        is the first interaction from the user within a conversation.\"\"\"\n\n        return [\n            {\n                \"role\": \"user\",\n                \"content\": self._template.render(\n                    input=input[\"input\"],\n                    application_description=self.application_description,\n                    criteria_for_query_generation=self.criteria_for_query_generation,\n                    num_instructions=self.num_instructions,\n                ),\n            }\n        ]\n\n    @property\n    def outputs(self):\n        \"\"\"The output for the task is a list of `instructions` containing the generated instructions.\"\"\"\n        return [\"instructions\"]\n\n    def format_output(\n        self,\n        output: Union[str, None],\n        input: Optional[Dict[str, Any]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"The output is formatted as a list with the generated instructions.\n\n        Args:\n            output: the raw output of the LLM.\n            input: the input to the task. Used for obtaining the number of responses.\n\n        Returns:\n            A dict with containing the generated instructions.\n        \"\"\"\n\n        if output is None:\n            return {\"instructions\": []}\n\n        lines = [line for line in output.split(\"\\n\") if line != \"\"]\n        return {\"instructions\": lines}\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.SelfInstruct.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input for the task is the <code>input</code> i.e. seed text.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.SelfInstruct.outputs","title":"<code>outputs</code>  <code>property</code>","text":"<p>The output for the task is a list of <code>instructions</code> containing the generated instructions.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.SelfInstruct.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is formatted as a <code>ChatType</code> assuming that the instruction is the first interaction from the user within a conversation.</p> Source code in <code>src/distilabel/steps/tasks/self_instruct.py</code> <pre><code>def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n    \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n    is the first interaction from the user within a conversation.\"\"\"\n\n    return [\n        {\n            \"role\": \"user\",\n            \"content\": self._template.render(\n                input=input[\"input\"],\n                application_description=self.application_description,\n                criteria_for_query_generation=self.criteria_for_query_generation,\n                num_instructions=self.num_instructions,\n            ),\n        }\n    ]\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.SelfInstruct.format_output","title":"<code>format_output(output, input=None)</code>","text":"<p>The output is formatted as a list with the generated instructions.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>Union[str, None]</code> <p>the raw output of the LLM.</p> required <code>input</code> <code>Optional[Dict[str, Any]]</code> <p>the input to the task. Used for obtaining the number of responses.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dict with containing the generated instructions.</p> Source code in <code>src/distilabel/steps/tasks/self_instruct.py</code> <pre><code>def format_output(\n    self,\n    output: Union[str, None],\n    input: Optional[Dict[str, Any]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"The output is formatted as a list with the generated instructions.\n\n    Args:\n        output: the raw output of the LLM.\n        input: the input to the task. Used for obtaining the number of responses.\n\n    Returns:\n        A dict with containing the generated instructions.\n    \"\"\"\n\n    if output is None:\n        return {\"instructions\": []}\n\n    lines = [line for line in output.split(\"\\n\") if line != \"\"]\n    return {\"instructions\": lines}\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.SelfInstruct.load","title":"<code>load()</code>","text":"<p>Loads the Jinja2 template for SelfInstruct.</p> Source code in <code>src/distilabel/steps/tasks/self_instruct.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the Jinja2 template for SelfInstruct.\"\"\"\n    super().load()\n\n    _path = str(\n        importlib_resources.files(\"distilabel\")\n        / \"steps\"\n        / \"tasks\"\n        / \"templates\"\n        / \"self-instruct.jinja2\"\n    )\n\n    self._template = Template(open(_path).read())\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.Task","title":"<code>Task</code>","text":"<p>             Bases: <code>_Task</code>, <code>Step</code></p> <p>Task is a class that implements the <code>_Task</code> abstract class and adds the <code>Step</code> interface to be used as a step in the pipeline.</p> <p>Attributes:</p> Name Type Description <code>llm</code> <p>the <code>LLM</code> to be used to generate the outputs of the task.</p> <code>group_generations</code> <p>whether to group the <code>num_generations</code> generated per input in a list or create a row per generation. Defaults to <code>False</code>.</p> <code>num_generations</code> <p>The number of generations to be produced per input.</p> Source code in <code>src/distilabel/steps/tasks/base.py</code> <pre><code>class Task(_Task, Step):\n    \"\"\"Task is a class that implements the `_Task` abstract class and adds the `Step`\n    interface to be used as a step in the pipeline.\n\n    Attributes:\n        llm: the `LLM` to be used to generate the outputs of the task.\n        group_generations: whether to group the `num_generations` generated per input in\n            a list or create a row per generation. Defaults to `False`.\n        num_generations: The number of generations to be produced per input.\n    \"\"\"\n\n    @abstractmethod\n    def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n        \"\"\"Abstract method to format the inputs of the task. It needs to receive an input\n        as a Python dictionary, and generates an OpenAI chat-like list of dicts.\"\"\"\n        pass\n\n    def _format_inputs(self, inputs: List[Dict[str, Any]]) -&gt; List[\"ChatType\"]:\n        \"\"\"Formats the inputs of the task using the `format_input` method.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Returns:\n            A list containing the formatted inputs, which are `ChatType`-like following\n            the OpenAI formatting.\n        \"\"\"\n        return [self.format_input(input) for input in inputs]\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Yields:\n            A list of Python dictionaries with the outputs of the task.\n        \"\"\"\n\n        formatted_inputs = self._format_inputs(inputs)\n        outputs = self.llm.generate(\n            inputs=formatted_inputs,\n            num_generations=self.num_generations,  # type: ignore\n            **self.llm.generation_kwargs,  # type: ignore\n        )\n\n        task_outputs = []\n        for input, input_outputs in zip(inputs, outputs):\n            formatted_outputs = self._format_outputs(input_outputs, inputs)\n\n            if self.group_generations:\n                combined = combine_dicts(*formatted_outputs)\n                task_outputs.append(\n                    {**input, \"model_name\": self.llm.model_name, **combined}\n                )\n                continue\n\n            # Create a row per generation\n            for formatted_output in formatted_outputs:\n                task_outputs.append(\n                    {**input, \"model_name\": self.llm.model_name, **formatted_output}\n                )\n\n        yield task_outputs\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.Task.format_input","title":"<code>format_input(input)</code>  <code>abstractmethod</code>","text":"<p>Abstract method to format the inputs of the task. It needs to receive an input as a Python dictionary, and generates an OpenAI chat-like list of dicts.</p> Source code in <code>src/distilabel/steps/tasks/base.py</code> <pre><code>@abstractmethod\ndef format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n    \"\"\"Abstract method to format the inputs of the task. It needs to receive an input\n    as a Python dictionary, and generates an OpenAI chat-like list of dicts.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.Task.process","title":"<code>process(inputs)</code>","text":"<p>Processes the inputs of the task and generates the outputs using the LLM.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>A list of Python dictionaries with the inputs of the task.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>A list of Python dictionaries with the outputs of the task.</p> Source code in <code>src/distilabel/steps/tasks/base.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n    Args:\n        inputs: A list of Python dictionaries with the inputs of the task.\n\n    Yields:\n        A list of Python dictionaries with the outputs of the task.\n    \"\"\"\n\n    formatted_inputs = self._format_inputs(inputs)\n    outputs = self.llm.generate(\n        inputs=formatted_inputs,\n        num_generations=self.num_generations,  # type: ignore\n        **self.llm.generation_kwargs,  # type: ignore\n    )\n\n    task_outputs = []\n    for input, input_outputs in zip(inputs, outputs):\n        formatted_outputs = self._format_outputs(input_outputs, inputs)\n\n        if self.group_generations:\n            combined = combine_dicts(*formatted_outputs)\n            task_outputs.append(\n                {**input, \"model_name\": self.llm.model_name, **combined}\n            )\n            continue\n\n        # Create a row per generation\n        for formatted_output in formatted_outputs:\n            task_outputs.append(\n                {**input, \"model_name\": self.llm.model_name, **formatted_output}\n            )\n\n    yield task_outputs\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.TextGeneration","title":"<code>TextGeneration</code>","text":"<p>             Bases: <code>Task</code></p> <p>TextGeneration is a pre-defined task that defines the <code>instruction</code> as the input and <code>generation</code> as the output. This task is used to generate text based on the input instruction. The model_name is also returned as part of the output in order to enhance it.</p> Input columns <ul> <li>instruction (<code>str</code>): The instruction to generate text from.</li> </ul> Output columns <ul> <li>generation (<code>str</code>): The generated text.</li> <li>model_name (<code>str</code>): The model name used to generate the text.</li> </ul> Source code in <code>src/distilabel/steps/tasks/text_generation.py</code> <pre><code>class TextGeneration(Task):\n    \"\"\"TextGeneration is a pre-defined task that defines the `instruction` as the input\n    and `generation` as the output. This task is used to generate text based on the input\n    instruction. The model_name is also returned as part of the output in order to enhance it.\n\n    Input columns:\n        - instruction (`str`): The instruction to generate text from.\n\n    Output columns:\n        - generation (`str`): The generated text.\n        - model_name (`str`): The model name used to generate the text.\n    \"\"\"\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input for the task is the `instruction`.\"\"\"\n        return [\"instruction\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; ChatType:\n        \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n        is the first interaction from the user within a conversation.\"\"\"\n        return [\n            {\"role\": \"user\", \"content\": input[\"instruction\"]},\n        ]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The output for the task is the `generation` and the `model_name`.\"\"\"\n        return [\"generation\", \"model_name\"]\n\n    def format_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, Any]:\n        \"\"\"The output is formatted as a dictionary with the `generation`. The `model_name`\n        will be automatically included within the `process` method of `Task`.\"\"\"\n        return {\"generation\": output}\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.TextGeneration.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input for the task is the <code>instruction</code>.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.TextGeneration.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The output for the task is the <code>generation</code> and the <code>model_name</code>.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.TextGeneration.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is formatted as a <code>ChatType</code> assuming that the instruction is the first interaction from the user within a conversation.</p> Source code in <code>src/distilabel/steps/tasks/text_generation.py</code> <pre><code>def format_input(self, input: Dict[str, Any]) -&gt; ChatType:\n    \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n    is the first interaction from the user within a conversation.\"\"\"\n    return [\n        {\"role\": \"user\", \"content\": input[\"instruction\"]},\n    ]\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.TextGeneration.format_output","title":"<code>format_output(output, input)</code>","text":"<p>The output is formatted as a dictionary with the <code>generation</code>. The <code>model_name</code> will be automatically included within the <code>process</code> method of <code>Task</code>.</p> Source code in <code>src/distilabel/steps/tasks/text_generation.py</code> <pre><code>def format_output(\n    self, output: Union[str, None], input: Dict[str, Any]\n) -&gt; Dict[str, Any]:\n    \"\"\"The output is formatted as a dictionary with the `generation`. The `model_name`\n    will be automatically included within the `process` method of `Task`.\"\"\"\n    return {\"generation\": output}\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.UltraFeedback","title":"<code>UltraFeedback</code>","text":"<p>             Bases: <code>Task</code></p> <p>UltraFeedback: Boosting Language Models with High-quality Feedback.</p> <p>Attributes:</p> Name Type Description <code>aspect</code> <code>Literal['helpfulness', 'honesty', 'instruction-following', 'truthfulness', 'overall-rating']</code> <p>The aspect to perform with the <code>UltraFeedback</code> model. The available aspects are: - <code>helpfulness</code>: Evaluate text outputs based on helpfulness. - <code>honesty</code>: Evaluate text outputs based on honesty. - <code>instruction-following</code>: Evaluate text outputs based on given instructions. - <code>truthfulness</code>: Evaluate text outputs based on truthfulness. Additionally, a custom aspect has been defined by Argilla, so as to evaluate the overall assessment of the text outputs within a single prompt. The custom aspect is: - <code>overall-rating</code>: Evaluate text outputs based on an overall assessment.</p> Input columns <ul> <li>instruction (<code>str</code>): The reference instruction to evaluate the text outputs.</li> <li>generations (<code>List[str]</code>): The text outputs to evaluate for the given instruction.</li> </ul> Output columns <ul> <li>ratings (<code>List[float]</code>): The ratings for each of the provided text outputs.</li> <li>rationales (<code>List[str]</code>): The rationales for each of the provided text outputs.</li> <li>model_name (<code>str</code>): The name of the model used to generate the ratings and rationales.</li> </ul> References <ul> <li><code>UltraFeedback: Boosting Language Models with High-quality Feedback</code></li> <li><code>UltraFeedback - GitHub Repository</code></li> </ul> Source code in <code>src/distilabel/steps/tasks/ultrafeedback.py</code> <pre><code>class UltraFeedback(Task):\n    \"\"\"UltraFeedback: Boosting Language Models with High-quality Feedback.\n\n    Attributes:\n        aspect: The aspect to perform with the `UltraFeedback` model. The available aspects are:\n            - `helpfulness`: Evaluate text outputs based on helpfulness.\n            - `honesty`: Evaluate text outputs based on honesty.\n            - `instruction-following`: Evaluate text outputs based on given instructions.\n            - `truthfulness`: Evaluate text outputs based on truthfulness.\n            Additionally, a custom aspect has been defined by Argilla, so as to evaluate the overall\n            assessment of the text outputs within a single prompt. The custom aspect is:\n            - `overall-rating`: Evaluate text outputs based on an overall assessment.\n\n    Input columns:\n        - instruction (`str`): The reference instruction to evaluate the text outputs.\n        - generations (`List[str]`): The text outputs to evaluate for the given instruction.\n\n    Output columns:\n        - ratings (`List[float]`): The ratings for each of the provided text outputs.\n        - rationales (`List[str]`): The rationales for each of the provided text outputs.\n        - model_name (`str`): The name of the model used to generate the ratings and rationales.\n\n    References:\n        - [`UltraFeedback: Boosting Language Models with High-quality Feedback`](https://arxiv.org/abs/2310.01377)\n        - [`UltraFeedback - GitHub Repository`](https://github.com/OpenBMB/UltraFeedback)\n    \"\"\"\n\n    aspect: Literal[\n        \"helpfulness\",\n        \"honesty\",\n        \"instruction-following\",\n        \"truthfulness\",\n        # Custom aspects\n        \"overall-rating\",\n    ]\n\n    _system_prompt: str = PrivateAttr(\n        default=(\n            \"Your role is to evaluate text quality based on given criteria.\\n\"\n            'You\\'ll receive an instructional description (\"Instruction\") and {no_texts} text outputs (\"Text\").\\n'\n            \"Understand and interpret instructions to evaluate effectively.\\n\"\n            \"Provide annotations for each text with a rating and rationale.\\n\"\n            \"The {no_texts} texts given are independent, and should be evaluated separately.\\n\"\n        )\n    )\n    _template: Optional[\"Template\"] = PrivateAttr(default=...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the Jinja2 template for the given `aspect`.\"\"\"\n        super().load()\n\n        _path = str(\n            importlib_resources.files(\"distilabel\")\n            / \"steps\"\n            / \"tasks\"\n            / \"templates\"\n            / \"ultrafeedback\"\n            / f\"{self.aspect}.jinja2\"\n        )\n\n        self._template = Template(open(_path).read())\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input for the task is the `instruction`, and the `generations` for it.\"\"\"\n        return [\"instruction\", \"generations\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; ChatType:\n        \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n        is the first interaction from the user within a conversation.\"\"\"\n        return [\n            {\n                \"role\": \"system\",\n                \"content\": self._system_prompt.format(\n                    no_texts=len(input[\"generations\"])\n                ),\n            },\n            {\n                \"role\": \"user\",\n                \"content\": self._template.render(  # type: ignore\n                    instruction=input[\"instruction\"], generations=input[\"generations\"]\n                ),\n            },\n        ]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The output for the task is the `generation` and the `model_name`.\"\"\"\n        columns = []\n        if self.aspect in [\"honesty\", \"instruction-following\", \"overall-rating\"]:\n            columns = [\"ratings\", \"rationales\"]\n        elif self.aspect in [\"helpfulness\", \"truthfulness\"]:\n            columns = [\"types\", \"rationales\", \"ratings\", \"rationales-for-ratings\"]\n        return columns + [\"model_name\"]\n\n    def format_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, Any]:\n        \"\"\"The output is formatted as a dictionary with the `ratings` and `rationales` for\n        each of the provided `generations` for the given `instruction`. The `model_name`\n        will be automatically included within the `process` method of `Task`.\n\n        Args:\n            output: a string representing the output of the LLM via the `process` method.\n            input: the input to the task, as required by some tasks to format the output.\n\n        Returns:\n            A dictionary containing either the `ratings` and `rationales` for each of the provided\n            `generations` for the given `instruction` if the provided aspect is either `honesty`,\n            `instruction-following`, or `overall-rating`; or the `types`, `rationales`,\n            `ratings`, and `rationales-for-ratings` for each of the provided `generations` for the\n            given `instruction` if the provided aspect is either `helpfulness` or `truthfulness`.\n        \"\"\"\n        if self.aspect in [\n            \"honesty\",\n            \"instruction-following\",\n            \"overall-rating\",\n        ]:\n            return self._format_ratings_rationales_output(output, input)\n        else:\n            return self._format_types_ratings_rationales_output(output, input)\n\n    def _format_ratings_rationales_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, List[Any]]:\n        \"\"\"Formats the output when the aspect is either `honesty`, `instruction-following`, or `overall-rating`.\"\"\"\n        if output is None:\n            return {\n                \"ratings\": [None] * len(input[\"generations\"]),\n                \"rationales\": [None] * len(input[\"generations\"]),\n            }\n\n        pattern = r\"Rating: (.+?)\\nRationale: (.+)\"\n        sections = output.split(\"\\n\\n\")\n\n        formatted_outputs = []\n        for section in sections:\n            matches = None\n            if section is not None and section != \"\":\n                matches = re.search(pattern, section, re.DOTALL)\n            if not matches:\n                formatted_outputs.append({\"ratings\": None, \"rationales\": None})\n                continue\n\n            formatted_outputs.append(\n                {\n                    \"ratings\": int(re.findall(r\"\\b\\d+\\b\", matches.group(1))[0])\n                    if matches.group(1) not in [\"None\", \"N/A\"]\n                    else None,\n                    \"rationales\": matches.group(2),\n                }\n            )\n        return combine_dicts(*formatted_outputs)\n\n    def _format_types_ratings_rationales_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, List[Any]]:\n        \"\"\"Formats the output when the aspect is either `helpfulness` or `truthfulness`.\"\"\"\n        if output is None:\n            return {\n                \"types\": [None] * len(input[\"generations\"]),\n                \"rationales\": [None] * len(input[\"generations\"]),\n                \"ratings\": [None] * len(input[\"generations\"]),\n                \"rationales-for-ratings\": [None] * len(input[\"generations\"]),\n            }\n\n        pattern = r\"Type: (.+?)\\nRationale: (.+?)\\nRating: (.+?)\\nRationale: (.+)\"\n\n        sections = output.split(\"\\n\\n\")\n\n        formatted_outputs = []\n        for section in sections:\n            matches = None\n            if section is not None and section != \"\":\n                matches = re.search(pattern, section, re.DOTALL)\n            if not matches:\n                formatted_outputs.append(\n                    {\n                        \"types\": None,\n                        \"rationales\": None,\n                        \"ratings\": None,\n                        \"rationales-for-ratings\": None,\n                    }\n                )\n                continue\n\n            formatted_outputs.append(\n                {\n                    \"types\": int(re.findall(r\"\\b\\d+\\b\", matches.group(1))[0])\n                    if matches.group(1) not in [\"None\", \"N/A\"]\n                    else None,\n                    \"rationales\": matches.group(2),\n                    \"ratings\": int(re.findall(r\"\\b\\d+\\b\", matches.group(3))[0])\n                    if matches.group(3) not in [\"None\", \"N/A\"]\n                    else None,\n                    \"rationales-for-ratings\": matches.group(4),\n                }\n            )\n        return combine_dicts(*formatted_outputs)\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.UltraFeedback.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input for the task is the <code>instruction</code>, and the <code>generations</code> for it.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.UltraFeedback.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The output for the task is the <code>generation</code> and the <code>model_name</code>.</p>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.UltraFeedback.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is formatted as a <code>ChatType</code> assuming that the instruction is the first interaction from the user within a conversation.</p> Source code in <code>src/distilabel/steps/tasks/ultrafeedback.py</code> <pre><code>def format_input(self, input: Dict[str, Any]) -&gt; ChatType:\n    \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n    is the first interaction from the user within a conversation.\"\"\"\n    return [\n        {\n            \"role\": \"system\",\n            \"content\": self._system_prompt.format(\n                no_texts=len(input[\"generations\"])\n            ),\n        },\n        {\n            \"role\": \"user\",\n            \"content\": self._template.render(  # type: ignore\n                instruction=input[\"instruction\"], generations=input[\"generations\"]\n            ),\n        },\n    ]\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.UltraFeedback.format_output","title":"<code>format_output(output, input)</code>","text":"<p>The output is formatted as a dictionary with the <code>ratings</code> and <code>rationales</code> for each of the provided <code>generations</code> for the given <code>instruction</code>. The <code>model_name</code> will be automatically included within the <code>process</code> method of <code>Task</code>.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>Union[str, None]</code> <p>a string representing the output of the LLM via the <code>process</code> method.</p> required <code>input</code> <code>Dict[str, Any]</code> <p>the input to the task, as required by some tasks to format the output.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary containing either the <code>ratings</code> and <code>rationales</code> for each of the provided</p> <code>Dict[str, Any]</code> <p><code>generations</code> for the given <code>instruction</code> if the provided aspect is either <code>honesty</code>,</p> <code>Dict[str, Any]</code> <p><code>instruction-following</code>, or <code>overall-rating</code>; or the <code>types</code>, <code>rationales</code>,</p> <code>Dict[str, Any]</code> <p><code>ratings</code>, and <code>rationales-for-ratings</code> for each of the provided <code>generations</code> for the</p> <code>Dict[str, Any]</code> <p>given <code>instruction</code> if the provided aspect is either <code>helpfulness</code> or <code>truthfulness</code>.</p> Source code in <code>src/distilabel/steps/tasks/ultrafeedback.py</code> <pre><code>def format_output(\n    self, output: Union[str, None], input: Dict[str, Any]\n) -&gt; Dict[str, Any]:\n    \"\"\"The output is formatted as a dictionary with the `ratings` and `rationales` for\n    each of the provided `generations` for the given `instruction`. The `model_name`\n    will be automatically included within the `process` method of `Task`.\n\n    Args:\n        output: a string representing the output of the LLM via the `process` method.\n        input: the input to the task, as required by some tasks to format the output.\n\n    Returns:\n        A dictionary containing either the `ratings` and `rationales` for each of the provided\n        `generations` for the given `instruction` if the provided aspect is either `honesty`,\n        `instruction-following`, or `overall-rating`; or the `types`, `rationales`,\n        `ratings`, and `rationales-for-ratings` for each of the provided `generations` for the\n        given `instruction` if the provided aspect is either `helpfulness` or `truthfulness`.\n    \"\"\"\n    if self.aspect in [\n        \"honesty\",\n        \"instruction-following\",\n        \"overall-rating\",\n    ]:\n        return self._format_ratings_rationales_output(output, input)\n    else:\n        return self._format_types_ratings_rationales_output(output, input)\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/#distilabel.steps.tasks.UltraFeedback.load","title":"<code>load()</code>","text":"<p>Loads the Jinja2 template for the given <code>aspect</code>.</p> Source code in <code>src/distilabel/steps/tasks/ultrafeedback.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the Jinja2 template for the given `aspect`.\"\"\"\n    super().load()\n\n    _path = str(\n        importlib_resources.files(\"distilabel\")\n        / \"steps\"\n        / \"tasks\"\n        / \"templates\"\n        / \"ultrafeedback\"\n        / f\"{self.aspect}.jinja2\"\n    )\n\n    self._template = Template(open(_path).read())\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/base/","title":"Base","text":""},{"location":"reference/distilabel/steps/tasks/base/#distilabel.steps.tasks.base.GeneratorTask","title":"<code>GeneratorTask</code>","text":"<p>             Bases: <code>_Task</code>, <code>GeneratorStep</code></p> <p>GeneratorTask is a class that implements the <code>_Task</code> abstract class and adds the <code>GeneratorStep</code> interface to be used as a step in the pipeline.</p> <p>Attributes:</p> Name Type Description <code>llm</code> <p>the <code>LLM</code> to be used to generate the outputs of the task.</p> <code>group_generations</code> <p>whether to group the <code>num_generations</code> generated per input in a list or create a row per generation. Defaults to <code>False</code>.</p> <code>num_generations</code> <p>The number of generations to be produced per input.</p> Source code in <code>src/distilabel/steps/tasks/base.py</code> <pre><code>class GeneratorTask(_Task, GeneratorStep):\n    \"\"\"GeneratorTask is a class that implements the `_Task` abstract class and adds the\n    `GeneratorStep` interface to be used as a step in the pipeline.\n\n    Attributes:\n        llm: the `LLM` to be used to generate the outputs of the task.\n        group_generations: whether to group the `num_generations` generated per input in\n            a list or create a row per generation. Defaults to `False`.\n        num_generations: The number of generations to be produced per input.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/base/#distilabel.steps.tasks.base.Task","title":"<code>Task</code>","text":"<p>             Bases: <code>_Task</code>, <code>Step</code></p> <p>Task is a class that implements the <code>_Task</code> abstract class and adds the <code>Step</code> interface to be used as a step in the pipeline.</p> <p>Attributes:</p> Name Type Description <code>llm</code> <p>the <code>LLM</code> to be used to generate the outputs of the task.</p> <code>group_generations</code> <p>whether to group the <code>num_generations</code> generated per input in a list or create a row per generation. Defaults to <code>False</code>.</p> <code>num_generations</code> <p>The number of generations to be produced per input.</p> Source code in <code>src/distilabel/steps/tasks/base.py</code> <pre><code>class Task(_Task, Step):\n    \"\"\"Task is a class that implements the `_Task` abstract class and adds the `Step`\n    interface to be used as a step in the pipeline.\n\n    Attributes:\n        llm: the `LLM` to be used to generate the outputs of the task.\n        group_generations: whether to group the `num_generations` generated per input in\n            a list or create a row per generation. Defaults to `False`.\n        num_generations: The number of generations to be produced per input.\n    \"\"\"\n\n    @abstractmethod\n    def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n        \"\"\"Abstract method to format the inputs of the task. It needs to receive an input\n        as a Python dictionary, and generates an OpenAI chat-like list of dicts.\"\"\"\n        pass\n\n    def _format_inputs(self, inputs: List[Dict[str, Any]]) -&gt; List[\"ChatType\"]:\n        \"\"\"Formats the inputs of the task using the `format_input` method.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Returns:\n            A list containing the formatted inputs, which are `ChatType`-like following\n            the OpenAI formatting.\n        \"\"\"\n        return [self.format_input(input) for input in inputs]\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Yields:\n            A list of Python dictionaries with the outputs of the task.\n        \"\"\"\n\n        formatted_inputs = self._format_inputs(inputs)\n        outputs = self.llm.generate(\n            inputs=formatted_inputs,\n            num_generations=self.num_generations,  # type: ignore\n            **self.llm.generation_kwargs,  # type: ignore\n        )\n\n        task_outputs = []\n        for input, input_outputs in zip(inputs, outputs):\n            formatted_outputs = self._format_outputs(input_outputs, inputs)\n\n            if self.group_generations:\n                combined = combine_dicts(*formatted_outputs)\n                task_outputs.append(\n                    {**input, \"model_name\": self.llm.model_name, **combined}\n                )\n                continue\n\n            # Create a row per generation\n            for formatted_output in formatted_outputs:\n                task_outputs.append(\n                    {**input, \"model_name\": self.llm.model_name, **formatted_output}\n                )\n\n        yield task_outputs\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/base/#distilabel.steps.tasks.base.Task.format_input","title":"<code>format_input(input)</code>  <code>abstractmethod</code>","text":"<p>Abstract method to format the inputs of the task. It needs to receive an input as a Python dictionary, and generates an OpenAI chat-like list of dicts.</p> Source code in <code>src/distilabel/steps/tasks/base.py</code> <pre><code>@abstractmethod\ndef format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n    \"\"\"Abstract method to format the inputs of the task. It needs to receive an input\n    as a Python dictionary, and generates an OpenAI chat-like list of dicts.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/base/#distilabel.steps.tasks.base.Task.process","title":"<code>process(inputs)</code>","text":"<p>Processes the inputs of the task and generates the outputs using the LLM.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>A list of Python dictionaries with the inputs of the task.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>A list of Python dictionaries with the outputs of the task.</p> Source code in <code>src/distilabel/steps/tasks/base.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n    Args:\n        inputs: A list of Python dictionaries with the inputs of the task.\n\n    Yields:\n        A list of Python dictionaries with the outputs of the task.\n    \"\"\"\n\n    formatted_inputs = self._format_inputs(inputs)\n    outputs = self.llm.generate(\n        inputs=formatted_inputs,\n        num_generations=self.num_generations,  # type: ignore\n        **self.llm.generation_kwargs,  # type: ignore\n    )\n\n    task_outputs = []\n    for input, input_outputs in zip(inputs, outputs):\n        formatted_outputs = self._format_outputs(input_outputs, inputs)\n\n        if self.group_generations:\n            combined = combine_dicts(*formatted_outputs)\n            task_outputs.append(\n                {**input, \"model_name\": self.llm.model_name, **combined}\n            )\n            continue\n\n        # Create a row per generation\n        for formatted_output in formatted_outputs:\n            task_outputs.append(\n                {**input, \"model_name\": self.llm.model_name, **formatted_output}\n            )\n\n    yield task_outputs\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/complexity_scorer/","title":"Complexity scorer","text":""},{"location":"reference/distilabel/steps/tasks/complexity_scorer/#distilabel.steps.tasks.complexity_scorer.ComplexityScorer","title":"<code>ComplexityScorer</code>","text":"<p>             Bases: <code>Task</code></p> <p>This task is used to rank a list of instructions based on their complexity. It's an implementation of the complexity score task from the paper 'What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.</p> <p>Attributes:</p> Name Type Description <code>_template</code> <code>Union[Template, None]</code> <p>The Jinja2 template used to format the input data.</p> Input columns <ul> <li>instructions (<code>List[str]</code>): The list of instructions to be scored.</li> </ul> Output columns <ul> <li>complexity_score (<code>List[float]</code>): The complexity score for each instruction.</li> </ul> References <ul> <li><code>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</code></li> </ul> Source code in <code>src/distilabel/steps/tasks/complexity_scorer.py</code> <pre><code>class ComplexityScorer(Task):\n    \"\"\"This task is used to rank a list of instructions based on their complexity. It's\n    an implementation of the complexity score task from the paper 'What Makes Good Data\n    for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.\n\n    Attributes:\n        _template: The Jinja2 template used to format the input data.\n\n    Input columns:\n        - instructions (`List[str]`): The list of instructions to be scored.\n\n    Output columns:\n        - complexity_score (`List[float]`): The complexity score for each instruction.\n\n    References:\n        - [`What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning`](https://arxiv.org/abs/2312.15685)\n    \"\"\"\n\n    _template: Union[Template, None] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        super().load()\n        self._template = Template(_COMPLEXITY_SCORER_TEMPLATE)\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        return [\"instructions\"]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        return [\"scores\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n        return [{\"role\": \"user\", \"content\": self._template.render(**input)}]  # type: ignore\n\n    def format_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, Any]:\n        if output is None:\n            return {\"scores\": [None] * len(input[\"instructions\"])}\n\n        scores = []\n        score_lines = output.split(\"\\n\")\n        for i, line in enumerate(score_lines):\n            match = _PARSE_SCORE_LINE_REGEX.match(line)\n            score = float(match.group(1)) if match else None\n            scores.append(score)\n            if i == len(input[\"instructions\"]) - 1:\n                break\n\n        return {\"scores\": scores}\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/generate_embeddings/","title":"Generate embeddings","text":""},{"location":"reference/distilabel/steps/tasks/generate_embeddings/#distilabel.steps.tasks.generate_embeddings.GenerateEmbeddings","title":"<code>GenerateEmbeddings</code>","text":"<p>             Bases: <code>Step</code></p> <p>Generate embeddings for a text input using the last hidden state of an <code>LLM</code>, as described in the paper 'What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.</p> <p>Attributes:</p> Name Type Description <code>llm</code> <code>LLM</code> <p>The <code>LLM</code> to use to generate the embeddings.</p> Input columns <ul> <li>text (<code>str</code>, <code>List[Dict[str, str]]</code>): The input text or conversation to generate     embeddings for.</li> </ul> Output columns <ul> <li>embedding (<code>List[float]</code>): The embedding of the input text or conversation.</li> </ul> References <ul> <li>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</li> </ul> Source code in <code>src/distilabel/steps/tasks/generate_embeddings.py</code> <pre><code>class GenerateEmbeddings(Step):\n    \"\"\"Generate embeddings for a text input using the last hidden state of an `LLM`, as\n    described in the paper 'What Makes Good Data for Alignment? A Comprehensive Study of\n    Automatic Data Selection in Instruction Tuning'.\n\n    Attributes:\n        llm: The `LLM` to use to generate the embeddings.\n\n    Input columns:\n        - text (`str`, `List[Dict[str, str]]`): The input text or conversation to generate\n            embeddings for.\n\n    Output columns:\n        - embedding (`List[float]`): The embedding of the input text or conversation.\n\n    References:\n        - [What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning](https://arxiv.org/abs/2312.15685)\n    \"\"\"\n\n    llm: LLM\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the `LLM` used to generate the embeddings.\"\"\"\n        super().load()\n        self.llm.load()\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The inputs for the task is a `text` column containing either a string or a\n        list of dictionaries in OpenAI chat-like format.\"\"\"\n        return [\"text\"]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The outputs for the task is an `embedding` column containing the embedding of\n        the `text` input.\"\"\"\n        return [\"embedding\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n        \"\"\"Formats the input to be used by the LLM to generate the embeddings. The input\n        can be in `ChatType` format or a string. If a string, it will be converted to a\n        list of dictionaries in OpenAI chat-like format.\n\n        Args:\n            input: The input to format.\n\n        Returns:\n            The OpenAI chat-like format of the input.\n        \"\"\"\n        text = input[\"text\"] = input[\"text\"]\n\n        # input is in `ChatType` format\n        if isinstance(text, str):\n            return [{\"role\": \"user\", \"content\": text}]\n\n        if is_openai_format(text):\n            return text\n\n        raise ValueError(\n            f\"Couldn't format input for step {self.name}. The `text` input column has to\"\n            \" be a string or a list of dictionaries in OpenAI chat-like format.\"\n        )\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Generates an embedding for each input using the last hidden state of the `LLM`.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Yields:\n            A list of Python dictionaries with the outputs of the task.\n        \"\"\"\n        formatted_inputs = [self.format_input(input) for input in inputs]\n        last_hidden_states = self.llm.get_last_hidden_states(formatted_inputs)\n        for input, hidden_state in zip(inputs, last_hidden_states):\n            input[\"embedding\"] = hidden_state[-1].tolist()\n        yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/generate_embeddings/#distilabel.steps.tasks.generate_embeddings.GenerateEmbeddings.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The inputs for the task is a <code>text</code> column containing either a string or a list of dictionaries in OpenAI chat-like format.</p>"},{"location":"reference/distilabel/steps/tasks/generate_embeddings/#distilabel.steps.tasks.generate_embeddings.GenerateEmbeddings.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The outputs for the task is an <code>embedding</code> column containing the embedding of the <code>text</code> input.</p>"},{"location":"reference/distilabel/steps/tasks/generate_embeddings/#distilabel.steps.tasks.generate_embeddings.GenerateEmbeddings.format_input","title":"<code>format_input(input)</code>","text":"<p>Formats the input to be used by the LLM to generate the embeddings. The input can be in <code>ChatType</code> format or a string. If a string, it will be converted to a list of dictionaries in OpenAI chat-like format.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Dict[str, Any]</code> <p>The input to format.</p> required <p>Returns:</p> Type Description <code>ChatType</code> <p>The OpenAI chat-like format of the input.</p> Source code in <code>src/distilabel/steps/tasks/generate_embeddings.py</code> <pre><code>def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n    \"\"\"Formats the input to be used by the LLM to generate the embeddings. The input\n    can be in `ChatType` format or a string. If a string, it will be converted to a\n    list of dictionaries in OpenAI chat-like format.\n\n    Args:\n        input: The input to format.\n\n    Returns:\n        The OpenAI chat-like format of the input.\n    \"\"\"\n    text = input[\"text\"] = input[\"text\"]\n\n    # input is in `ChatType` format\n    if isinstance(text, str):\n        return [{\"role\": \"user\", \"content\": text}]\n\n    if is_openai_format(text):\n        return text\n\n    raise ValueError(\n        f\"Couldn't format input for step {self.name}. The `text` input column has to\"\n        \" be a string or a list of dictionaries in OpenAI chat-like format.\"\n    )\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/generate_embeddings/#distilabel.steps.tasks.generate_embeddings.GenerateEmbeddings.load","title":"<code>load()</code>","text":"<p>Loads the <code>LLM</code> used to generate the embeddings.</p> Source code in <code>src/distilabel/steps/tasks/generate_embeddings.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the `LLM` used to generate the embeddings.\"\"\"\n    super().load()\n    self.llm.load()\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/generate_embeddings/#distilabel.steps.tasks.generate_embeddings.GenerateEmbeddings.process","title":"<code>process(inputs)</code>","text":"<p>Generates an embedding for each input using the last hidden state of the <code>LLM</code>.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>A list of Python dictionaries with the inputs of the task.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>A list of Python dictionaries with the outputs of the task.</p> Source code in <code>src/distilabel/steps/tasks/generate_embeddings.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Generates an embedding for each input using the last hidden state of the `LLM`.\n\n    Args:\n        inputs: A list of Python dictionaries with the inputs of the task.\n\n    Yields:\n        A list of Python dictionaries with the outputs of the task.\n    \"\"\"\n    formatted_inputs = [self.format_input(input) for input in inputs]\n    last_hidden_states = self.llm.get_last_hidden_states(formatted_inputs)\n    for input, hidden_state in zip(inputs, last_hidden_states):\n        input[\"embedding\"] = hidden_state[-1].tolist()\n    yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/instruction_backtranslation/","title":"Instruction backtranslation","text":""},{"location":"reference/distilabel/steps/tasks/instruction_backtranslation/#distilabel.steps.tasks.instruction_backtranslation.InstructionBacktranslation","title":"<code>InstructionBacktranslation</code>","text":"<p>             Bases: <code>Task</code></p> <p>Self-Alignment with Instruction Backtranslation.</p> <p>Attributes:</p> Name Type Description <code>_template</code> <code>Optional[Template]</code> <p>the Jinja2 template to use for the Instruction Backtranslation task.</p> Input columns <ul> <li>instruction (<code>str</code>): The reference instruction to evaluate the text output.</li> <li>generation (<code>str</code>): The text output to evaluate for the given instruction.</li> </ul> Output columns <ul> <li>score (<code>str</code>): The score for the generation based on the given instruction.</li> </ul> References <ul> <li><code>Self-Alignment with Instruction Backtranslation</code></li> </ul> Source code in <code>src/distilabel/steps/tasks/instruction_backtranslation.py</code> <pre><code>class InstructionBacktranslation(Task):\n    \"\"\"Self-Alignment with Instruction Backtranslation.\n\n    Attributes:\n        _template: the Jinja2 template to use for the Instruction Backtranslation task.\n\n    Input columns:\n        - instruction (`str`): The reference instruction to evaluate the text output.\n        - generation (`str`): The text output to evaluate for the given instruction.\n\n    Output columns:\n        - score (`str`): The score for the generation based on the given instruction.\n\n    References:\n        - [`Self-Alignment with Instruction Backtranslation`](https://arxiv.org/abs/2308.06259)\n    \"\"\"\n\n    _template: Optional[\"Template\"] = PrivateAttr(default=...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the Jinja2 template with the Instruction Backtranslation prompt.\"\"\"\n        super().load()\n\n        _path = str(\n            importlib_resources.files(\"distilabel\")\n            / \"steps\"\n            / \"tasks\"\n            / \"templates\"\n            / \"instruction-backtranslation.jinja2\"\n        )\n\n        self._template = Template(open(_path).read())\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input for the task is the `instruction`, and the `generation` for it.\"\"\"\n        return [\"instruction\", \"generation\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n        \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n        is the first interaction from the user within a conversation.\"\"\"\n        return [\n            {\n                \"role\": \"user\",\n                \"content\": self._template.render(  # type: ignore\n                    instruction=input[\"instruction\"], generation=input[\"generation\"]\n                ),\n            },\n        ]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The output for the task is the `score`, `reason` and the `model_name`.\"\"\"\n        return [\"score\", \"reason\", \"model_name\"]\n\n    def format_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, Any]:\n        \"\"\"The output is formatted as a dictionary with the `score` and `reason`. The\n        `model_name` will be automatically included within the `process` method of `Task`.\n\n        Args:\n            output: a string representing the output of the LLM via the `process` method.\n            input: the input to the task, as required by some tasks to format the output.\n\n        Returns:\n            A dictionary containing the `score` and the `reason` for the provided `score`.\n        \"\"\"\n        pattern = r\"(.+?)Score: (\\d)\"\n\n        matches = None\n        if output is not None:\n            matches = re.findall(pattern, output, re.DOTALL)\n        if matches is None:\n            return {\"score\": None, \"reason\": None}\n\n        return {\n            \"score\": int(matches[0][1]),\n            \"reason\": matches[0][0].strip(),\n        }\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/instruction_backtranslation/#distilabel.steps.tasks.instruction_backtranslation.InstructionBacktranslation.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input for the task is the <code>instruction</code>, and the <code>generation</code> for it.</p>"},{"location":"reference/distilabel/steps/tasks/instruction_backtranslation/#distilabel.steps.tasks.instruction_backtranslation.InstructionBacktranslation.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The output for the task is the <code>score</code>, <code>reason</code> and the <code>model_name</code>.</p>"},{"location":"reference/distilabel/steps/tasks/instruction_backtranslation/#distilabel.steps.tasks.instruction_backtranslation.InstructionBacktranslation.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is formatted as a <code>ChatType</code> assuming that the instruction is the first interaction from the user within a conversation.</p> Source code in <code>src/distilabel/steps/tasks/instruction_backtranslation.py</code> <pre><code>def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n    \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n    is the first interaction from the user within a conversation.\"\"\"\n    return [\n        {\n            \"role\": \"user\",\n            \"content\": self._template.render(  # type: ignore\n                instruction=input[\"instruction\"], generation=input[\"generation\"]\n            ),\n        },\n    ]\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/instruction_backtranslation/#distilabel.steps.tasks.instruction_backtranslation.InstructionBacktranslation.format_output","title":"<code>format_output(output, input)</code>","text":"<p>The output is formatted as a dictionary with the <code>score</code> and <code>reason</code>. The <code>model_name</code> will be automatically included within the <code>process</code> method of <code>Task</code>.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>Union[str, None]</code> <p>a string representing the output of the LLM via the <code>process</code> method.</p> required <code>input</code> <code>Dict[str, Any]</code> <p>the input to the task, as required by some tasks to format the output.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary containing the <code>score</code> and the <code>reason</code> for the provided <code>score</code>.</p> Source code in <code>src/distilabel/steps/tasks/instruction_backtranslation.py</code> <pre><code>def format_output(\n    self, output: Union[str, None], input: Dict[str, Any]\n) -&gt; Dict[str, Any]:\n    \"\"\"The output is formatted as a dictionary with the `score` and `reason`. The\n    `model_name` will be automatically included within the `process` method of `Task`.\n\n    Args:\n        output: a string representing the output of the LLM via the `process` method.\n        input: the input to the task, as required by some tasks to format the output.\n\n    Returns:\n        A dictionary containing the `score` and the `reason` for the provided `score`.\n    \"\"\"\n    pattern = r\"(.+?)Score: (\\d)\"\n\n    matches = None\n    if output is not None:\n        matches = re.findall(pattern, output, re.DOTALL)\n    if matches is None:\n        return {\"score\": None, \"reason\": None}\n\n    return {\n        \"score\": int(matches[0][1]),\n        \"reason\": matches[0][0].strip(),\n    }\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/instruction_backtranslation/#distilabel.steps.tasks.instruction_backtranslation.InstructionBacktranslation.load","title":"<code>load()</code>","text":"<p>Loads the Jinja2 template with the Instruction Backtranslation prompt.</p> Source code in <code>src/distilabel/steps/tasks/instruction_backtranslation.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the Jinja2 template with the Instruction Backtranslation prompt.\"\"\"\n    super().load()\n\n    _path = str(\n        importlib_resources.files(\"distilabel\")\n        / \"steps\"\n        / \"tasks\"\n        / \"templates\"\n        / \"instruction-backtranslation.jinja2\"\n    )\n\n    self._template = Template(open(_path).read())\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/pair_rm/","title":"Pair rm","text":""},{"location":"reference/distilabel/steps/tasks/pair_rm/#distilabel.steps.tasks.pair_rm.PairRM","title":"<code>PairRM</code>","text":"<p>             Bases: <code>Step</code></p> <p>Rank the candidates based on the input using the <code>LLM</code> model.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>The model to use for the ranking. Defaults to <code>\"llm-blender/PairRM\"</code>.</p> <code>input_batch_size</code> <code>int</code> <p>The batch size to use when processing the input. Defauls to <code>8</code>.</p> <code>instructions</code> <code>Optional[str]</code> <p>The instructions to use for the model. Defaults to <code>None</code>.</p> Input columns <ul> <li>inputs (<code>List[Dict[str, Any]]</code>): The input text or conversation to rank the candidates for.</li> <li>candidates (<code>List[Dict[str, Any]]</code>): The candidates to rank.</li> </ul> Output columns <ul> <li>ranks (<code>List[int]</code>): The ranks of the candidates based on the input.</li> <li>ranked_candidates (<code>List[Dict[str, Any]]</code>): The candidates ranked based on the input.</li> </ul> References <ul> <li>LLM-Blender: Ensembling Large Language Models with Pairwise Ranking and Generative Fusion.</li> <li>Pair Ranking Model.</li> </ul> Note <p>This step differs to other tasks as there is a single implementation of this model currently, and we will use a specific <code>LLM</code>.</p> Source code in <code>src/distilabel/steps/tasks/pair_rm.py</code> <pre><code>class PairRM(Step):\n    \"\"\"Rank the candidates based on the input using the `LLM` model.\n\n    Attributes:\n        model: The model to use for the ranking. Defaults to `\"llm-blender/PairRM\"`.\n        input_batch_size: The batch size to use when processing the input. Defauls to `8`.\n        instructions: The instructions to use for the model. Defaults to `None`.\n\n    Input columns:\n        - inputs (`List[Dict[str, Any]]`): The input text or conversation to rank the candidates for.\n        - candidates (`List[Dict[str, Any]]`): The candidates to rank.\n\n    Output columns:\n        - ranks (`List[int]`): The ranks of the candidates based on the input.\n        - ranked_candidates (`List[Dict[str, Any]]`): The candidates ranked based on the input.\n\n    References:\n        - [LLM-Blender: Ensembling Large Language Models with Pairwise Ranking and Generative Fusion](https://arxiv.org/abs/2306.02561).\n        - [Pair Ranking Model](https://huggingface.co/llm-blender/PairRM).\n\n    Note:\n        This step differs to other tasks as there is a single implementation of this model\n        currently, and we will use a specific `LLM`.\n    \"\"\"\n\n    model: str = \"llm-blender/PairRM\"\n    input_batch_size: int = 8\n    instructions: Optional[str] = None\n\n    def load(self) -&gt; None:\n        try:\n            import llm_blender\n        except ImportError as e:\n            raise ImportError(\n                \"The `llm_blender` package is required to use the `PairRM` class.\"\n                \"Please install it with `pip install git+https://github.com/yuchenlin/LLM-Blender.git`.\"\n            ) from e\n        self._blender = llm_blender.Blender()\n        self._blender.loadranker(self.model)\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input columns correspond to the two required arguments from `Blender.rank`:\n        `inputs` and `candidates`.\"\"\"\n        return [\"input\", \"candidates\"]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The outputs will include the `ranks` and the `ranked_candidates`.\"\"\"\n        return [\"ranks\", \"ranked_candidates\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"The input is expected to be a dictionary with the keys `input` and `candidates`,\n        where the `input` corresponds to the instruction of a model and `candidates` are a\n        list of responses to be ranked.\n        \"\"\"\n        return input\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Generates the ranks for the candidates based on the input.\n\n        The ranks are the positions of the candidates, where lower is better,\n        and the ranked candidates correspond to the candidates sorted according to the\n        ranks obtained.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Yields:\n            An iterator with the inputs containing the `ranks` and the `ranked_candidates`.\n        \"\"\"\n        input_texts = []\n        candidates = []\n        for input in inputs:\n            formatted_input = self.format_input(input)\n            input_texts.append(formatted_input[\"input\"])\n            candidates.append(formatted_input[\"candidates\"])\n\n        instructions = (\n            [self.instructions] * len(input_texts) if self.instructions else None\n        )\n\n        ranks = self._blender.rank(\n            input_texts,\n            candidates,\n            instructions=instructions,\n            return_scores=False,\n            batch_size=self.input_batch_size,\n        )\n        # Sort the candidates based on the ranks\n        ranked_candidates = np.take_along_axis(\n            np.array(candidates), ranks - 1, axis=1\n        ).tolist()\n        ranks = ranks.tolist()\n        for input, rank, ranked_candidate in zip(inputs, ranks, ranked_candidates):\n            input[\"ranks\"] = rank\n            input[\"ranked_candidates\"] = ranked_candidate\n\n        yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/pair_rm/#distilabel.steps.tasks.pair_rm.PairRM.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input columns correspond to the two required arguments from <code>Blender.rank</code>: <code>inputs</code> and <code>candidates</code>.</p>"},{"location":"reference/distilabel/steps/tasks/pair_rm/#distilabel.steps.tasks.pair_rm.PairRM.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The outputs will include the <code>ranks</code> and the <code>ranked_candidates</code>.</p>"},{"location":"reference/distilabel/steps/tasks/pair_rm/#distilabel.steps.tasks.pair_rm.PairRM.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is expected to be a dictionary with the keys <code>input</code> and <code>candidates</code>, where the <code>input</code> corresponds to the instruction of a model and <code>candidates</code> are a list of responses to be ranked.</p> Source code in <code>src/distilabel/steps/tasks/pair_rm.py</code> <pre><code>def format_input(self, input: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"The input is expected to be a dictionary with the keys `input` and `candidates`,\n    where the `input` corresponds to the instruction of a model and `candidates` are a\n    list of responses to be ranked.\n    \"\"\"\n    return input\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/pair_rm/#distilabel.steps.tasks.pair_rm.PairRM.process","title":"<code>process(inputs)</code>","text":"<p>Generates the ranks for the candidates based on the input.</p> <p>The ranks are the positions of the candidates, where lower is better, and the ranked candidates correspond to the candidates sorted according to the ranks obtained.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>A list of Python dictionaries with the inputs of the task.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>An iterator with the inputs containing the <code>ranks</code> and the <code>ranked_candidates</code>.</p> Source code in <code>src/distilabel/steps/tasks/pair_rm.py</code> <pre><code>def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Generates the ranks for the candidates based on the input.\n\n    The ranks are the positions of the candidates, where lower is better,\n    and the ranked candidates correspond to the candidates sorted according to the\n    ranks obtained.\n\n    Args:\n        inputs: A list of Python dictionaries with the inputs of the task.\n\n    Yields:\n        An iterator with the inputs containing the `ranks` and the `ranked_candidates`.\n    \"\"\"\n    input_texts = []\n    candidates = []\n    for input in inputs:\n        formatted_input = self.format_input(input)\n        input_texts.append(formatted_input[\"input\"])\n        candidates.append(formatted_input[\"candidates\"])\n\n    instructions = (\n        [self.instructions] * len(input_texts) if self.instructions else None\n    )\n\n    ranks = self._blender.rank(\n        input_texts,\n        candidates,\n        instructions=instructions,\n        return_scores=False,\n        batch_size=self.input_batch_size,\n    )\n    # Sort the candidates based on the ranks\n    ranked_candidates = np.take_along_axis(\n        np.array(candidates), ranks - 1, axis=1\n    ).tolist()\n    ranks = ranks.tolist()\n    for input, rank, ranked_candidate in zip(inputs, ranks, ranked_candidates):\n        input[\"ranks\"] = rank\n        input[\"ranked_candidates\"] = ranked_candidate\n\n    yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/quality_scorer/","title":"Quality scorer","text":""},{"location":"reference/distilabel/steps/tasks/quality_scorer/#distilabel.steps.tasks.quality_scorer.QualityScorer","title":"<code>QualityScorer</code>","text":"<p>             Bases: <code>Task</code></p> <p>QualityScorer is a pre-defined task that defines the <code>instruction</code> as the input and <code>score</code> as the output. This task is used to rate the quality of instructions and responses. It's an implementation of the quality score task from the paper 'What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'. The task follows the same scheme as the Complexity Scorer, but the instruction-response pairs are scored in terms of quality, obtaining a quality score for each instruction.</p> <p>Attributes:</p> Name Type Description <code>_template</code> <code>Union[Template, None]</code> <p>a Jinja2 template used to format the input for the LLM.</p> Input columns <ul> <li>instruction (<code>str</code>): The instruction that was used to generate the <code>responses</code>.</li> <li>responses (<code>List[str]</code>): The responses to be scored. Each response forms a pair with the instruction.</li> </ul> Output columns <ul> <li>quality_score (<code>List[float]</code>): The quality score for each instruction.</li> </ul> References <ul> <li><code>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</code></li> </ul> Source code in <code>src/distilabel/steps/tasks/quality_scorer.py</code> <pre><code>class QualityScorer(Task):\n    \"\"\"QualityScorer is a pre-defined task that defines the `instruction` as the input\n    and `score` as the output. This task is used to rate the quality of instructions and responses.\n    It's an implementation of the quality score task from the paper 'What Makes Good Data\n    for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.\n    The task follows the same scheme as the Complexity Scorer, but the instruction-response pairs\n    are scored in terms of quality, obtaining a quality score for each instruction.\n\n    Attributes:\n        _template: a Jinja2 template used to format the input for the LLM.\n\n    Input columns:\n        - instruction (`str`): The instruction that was used to generate the `responses`.\n        - responses (`List[str]`): The responses to be scored. Each response forms a pair with the instruction.\n\n    Output columns:\n        - quality_score (`List[float]`): The quality score for each instruction.\n\n    References:\n        - [`What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning`](https://arxiv.org/abs/2312.15685)\n    \"\"\"\n\n    _template: Union[Template, None] = PrivateAttr(...)\n\n    def load(self) -&gt; None:\n        super().load()\n        self._template = Template(_QUALITY_SCORER_TEMPLATE)\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input for the task are `instruction` and `responses`.\"\"\"\n        return [\"instruction\", \"responses\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; ChatType:  # type: ignore\n        \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n        is the first interaction from the user within a conversation.\"\"\"\n        return [{\"role\": \"user\", \"content\": self._template.render(**input)}]  # type: ignore\n\n    @property\n    def outputs(self):\n        \"\"\"The output for the task is a list of `quality_scores` containing the quality score for each\n        response in `responses`.\"\"\"\n        return [\"scores\"]\n\n    def format_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, Any]:\n        \"\"\"The output is formatted as a list with the score of each instruction-response pair.\n\n        Args:\n            output: the raw output of the LLM.\n            input: the input to the task. Used for obtaining the number of responses.\n\n        Returns:\n            A dict with containing the scores for each instruction-response pair.\n        \"\"\"\n\n        if output is None:\n            return {self.outputs[0]: [None] * len(input[\"responses\"])}\n\n        scores = []\n        score_lines = output.split(\"\\n\")\n\n        for i, line in enumerate(score_lines):\n            match = _PARSE_SCORE_LINE_REGEX.match(line)\n            score = float(match.group(1)) if match else None\n            scores.append(score)\n            if i == len(input[\"responses\"]) - 1:\n                break\n\n        return {self.outputs[0]: scores}\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/quality_scorer/#distilabel.steps.tasks.quality_scorer.QualityScorer.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input for the task are <code>instruction</code> and <code>responses</code>.</p>"},{"location":"reference/distilabel/steps/tasks/quality_scorer/#distilabel.steps.tasks.quality_scorer.QualityScorer.outputs","title":"<code>outputs</code>  <code>property</code>","text":"<p>The output for the task is a list of <code>quality_scores</code> containing the quality score for each response in <code>responses</code>.</p>"},{"location":"reference/distilabel/steps/tasks/quality_scorer/#distilabel.steps.tasks.quality_scorer.QualityScorer.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is formatted as a <code>ChatType</code> assuming that the instruction is the first interaction from the user within a conversation.</p> Source code in <code>src/distilabel/steps/tasks/quality_scorer.py</code> <pre><code>def format_input(self, input: Dict[str, Any]) -&gt; ChatType:  # type: ignore\n    \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n    is the first interaction from the user within a conversation.\"\"\"\n    return [{\"role\": \"user\", \"content\": self._template.render(**input)}]  # type: ignore\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/quality_scorer/#distilabel.steps.tasks.quality_scorer.QualityScorer.format_output","title":"<code>format_output(output, input)</code>","text":"<p>The output is formatted as a list with the score of each instruction-response pair.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>Union[str, None]</code> <p>the raw output of the LLM.</p> required <code>input</code> <code>Dict[str, Any]</code> <p>the input to the task. Used for obtaining the number of responses.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dict with containing the scores for each instruction-response pair.</p> Source code in <code>src/distilabel/steps/tasks/quality_scorer.py</code> <pre><code>def format_output(\n    self, output: Union[str, None], input: Dict[str, Any]\n) -&gt; Dict[str, Any]:\n    \"\"\"The output is formatted as a list with the score of each instruction-response pair.\n\n    Args:\n        output: the raw output of the LLM.\n        input: the input to the task. Used for obtaining the number of responses.\n\n    Returns:\n        A dict with containing the scores for each instruction-response pair.\n    \"\"\"\n\n    if output is None:\n        return {self.outputs[0]: [None] * len(input[\"responses\"])}\n\n    scores = []\n    score_lines = output.split(\"\\n\")\n\n    for i, line in enumerate(score_lines):\n        match = _PARSE_SCORE_LINE_REGEX.match(line)\n        score = float(match.group(1)) if match else None\n        scores.append(score)\n        if i == len(input[\"responses\"]) - 1:\n            break\n\n    return {self.outputs[0]: scores}\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/self_instruct/","title":"Self instruct","text":""},{"location":"reference/distilabel/steps/tasks/self_instruct/#distilabel.steps.tasks.self_instruct.SelfInstruct","title":"<code>SelfInstruct</code>","text":"<p>             Bases: <code>Task</code></p> <p>SelfInstruct is a pre-defined task that, given a number of instructions, a certain criteria for query generations, an application description, and an input, generates a number of instruction related to the given input and following what is stated in the criteria for query generation and the application description. It is based in the SelfInstruct framework from the paper \"Self-Instruct: Aligning Language Models with Self-Generated Instructions\".</p> <p>Attributes:</p> Name Type Description <code>num_instructions</code> <code>int</code> <p>The number of instructions to be generated. Defaults to 5.</p> <code>criteria_for_query_generation</code> <code>str</code> <p>The criteria for the query generation. Defaults to the criteria defined within the paper.</p> <code>application_description</code> <code>str</code> <p>The description of the AI application that one want to build with these instructions. Defaults to <code>AI assistant</code>.</p> Input columns <ul> <li>input (<code>str</code>): The input to generate the instructions. It's also called seed in the paper.</li> </ul> Output columns <ul> <li>instructions (<code>List[str]</code>): The generated instructions.</li> </ul> Reference <ul> <li><code>Self-Instruct: Aligning Language Models with Self-Generated Instructions</code></li> </ul> Source code in <code>src/distilabel/steps/tasks/self_instruct.py</code> <pre><code>class SelfInstruct(Task):\n    \"\"\"SelfInstruct is a pre-defined task that, given a number of instructions, a\n    certain criteria for query generations, an application description, and an input,\n    generates a number of instruction related to the given input and following what\n    is stated in the criteria for query generation and the application description.\n    It is based in the SelfInstruct framework from the paper \"Self-Instruct: Aligning\n    Language Models with Self-Generated Instructions\".\n\n    Attributes:\n        num_instructions: The number of instructions to be generated. Defaults to 5.\n        criteria_for_query_generation: The criteria for the query generation. Defaults\n            to the criteria defined within the paper.\n        application_description: The description of the AI application that one want\n            to build with these instructions. Defaults to `AI assistant`.\n\n    Input columns:\n        - input (`str`): The input to generate the instructions. It's also called seed in the paper.\n\n    Output columns:\n        - instructions (`List[str]`): The generated instructions.\n\n    Reference:\n        - [`Self-Instruct: Aligning Language Models with Self-Generated Instructions`](https://arxiv.org/abs/2212.10560)\n    \"\"\"\n\n    num_instructions: int = 5\n\n    criteria_for_query_generation: str = (\n        \"Incorporate a diverse range of verbs, avoiding repetition.\\n\"\n        \"Ensure queries are compatible with AI model's text generation functions and are limited to 1-2 sentences.\\n\"\n        \"Design queries to be self-contained and standalone.\\n\"\n        'Blend interrogative (e.g., \"What is the significance of x?\") and imperative (e.g., \"Detail the process of x.\") styles.'\n    )\n\n    application_description: str = \"AI assistant\"\n\n    _template: Template = PrivateAttr(default=...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the Jinja2 template for SelfInstruct.\"\"\"\n        super().load()\n\n        _path = str(\n            importlib_resources.files(\"distilabel\")\n            / \"steps\"\n            / \"tasks\"\n            / \"templates\"\n            / \"self-instruct.jinja2\"\n        )\n\n        self._template = Template(open(_path).read())\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input for the task is the `input` i.e. seed text.\"\"\"\n        return [\"input\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n        \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n        is the first interaction from the user within a conversation.\"\"\"\n\n        return [\n            {\n                \"role\": \"user\",\n                \"content\": self._template.render(\n                    input=input[\"input\"],\n                    application_description=self.application_description,\n                    criteria_for_query_generation=self.criteria_for_query_generation,\n                    num_instructions=self.num_instructions,\n                ),\n            }\n        ]\n\n    @property\n    def outputs(self):\n        \"\"\"The output for the task is a list of `instructions` containing the generated instructions.\"\"\"\n        return [\"instructions\"]\n\n    def format_output(\n        self,\n        output: Union[str, None],\n        input: Optional[Dict[str, Any]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"The output is formatted as a list with the generated instructions.\n\n        Args:\n            output: the raw output of the LLM.\n            input: the input to the task. Used for obtaining the number of responses.\n\n        Returns:\n            A dict with containing the generated instructions.\n        \"\"\"\n\n        if output is None:\n            return {\"instructions\": []}\n\n        lines = [line for line in output.split(\"\\n\") if line != \"\"]\n        return {\"instructions\": lines}\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/self_instruct/#distilabel.steps.tasks.self_instruct.SelfInstruct.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input for the task is the <code>input</code> i.e. seed text.</p>"},{"location":"reference/distilabel/steps/tasks/self_instruct/#distilabel.steps.tasks.self_instruct.SelfInstruct.outputs","title":"<code>outputs</code>  <code>property</code>","text":"<p>The output for the task is a list of <code>instructions</code> containing the generated instructions.</p>"},{"location":"reference/distilabel/steps/tasks/self_instruct/#distilabel.steps.tasks.self_instruct.SelfInstruct.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is formatted as a <code>ChatType</code> assuming that the instruction is the first interaction from the user within a conversation.</p> Source code in <code>src/distilabel/steps/tasks/self_instruct.py</code> <pre><code>def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n    \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n    is the first interaction from the user within a conversation.\"\"\"\n\n    return [\n        {\n            \"role\": \"user\",\n            \"content\": self._template.render(\n                input=input[\"input\"],\n                application_description=self.application_description,\n                criteria_for_query_generation=self.criteria_for_query_generation,\n                num_instructions=self.num_instructions,\n            ),\n        }\n    ]\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/self_instruct/#distilabel.steps.tasks.self_instruct.SelfInstruct.format_output","title":"<code>format_output(output, input=None)</code>","text":"<p>The output is formatted as a list with the generated instructions.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>Union[str, None]</code> <p>the raw output of the LLM.</p> required <code>input</code> <code>Optional[Dict[str, Any]]</code> <p>the input to the task. Used for obtaining the number of responses.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dict with containing the generated instructions.</p> Source code in <code>src/distilabel/steps/tasks/self_instruct.py</code> <pre><code>def format_output(\n    self,\n    output: Union[str, None],\n    input: Optional[Dict[str, Any]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"The output is formatted as a list with the generated instructions.\n\n    Args:\n        output: the raw output of the LLM.\n        input: the input to the task. Used for obtaining the number of responses.\n\n    Returns:\n        A dict with containing the generated instructions.\n    \"\"\"\n\n    if output is None:\n        return {\"instructions\": []}\n\n    lines = [line for line in output.split(\"\\n\") if line != \"\"]\n    return {\"instructions\": lines}\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/self_instruct/#distilabel.steps.tasks.self_instruct.SelfInstruct.load","title":"<code>load()</code>","text":"<p>Loads the Jinja2 template for SelfInstruct.</p> Source code in <code>src/distilabel/steps/tasks/self_instruct.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the Jinja2 template for SelfInstruct.\"\"\"\n    super().load()\n\n    _path = str(\n        importlib_resources.files(\"distilabel\")\n        / \"steps\"\n        / \"tasks\"\n        / \"templates\"\n        / \"self-instruct.jinja2\"\n    )\n\n    self._template = Template(open(_path).read())\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/text_generation/","title":"Text generation","text":""},{"location":"reference/distilabel/steps/tasks/text_generation/#distilabel.steps.tasks.text_generation.TextGeneration","title":"<code>TextGeneration</code>","text":"<p>             Bases: <code>Task</code></p> <p>TextGeneration is a pre-defined task that defines the <code>instruction</code> as the input and <code>generation</code> as the output. This task is used to generate text based on the input instruction. The model_name is also returned as part of the output in order to enhance it.</p> Input columns <ul> <li>instruction (<code>str</code>): The instruction to generate text from.</li> </ul> Output columns <ul> <li>generation (<code>str</code>): The generated text.</li> <li>model_name (<code>str</code>): The model name used to generate the text.</li> </ul> Source code in <code>src/distilabel/steps/tasks/text_generation.py</code> <pre><code>class TextGeneration(Task):\n    \"\"\"TextGeneration is a pre-defined task that defines the `instruction` as the input\n    and `generation` as the output. This task is used to generate text based on the input\n    instruction. The model_name is also returned as part of the output in order to enhance it.\n\n    Input columns:\n        - instruction (`str`): The instruction to generate text from.\n\n    Output columns:\n        - generation (`str`): The generated text.\n        - model_name (`str`): The model name used to generate the text.\n    \"\"\"\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input for the task is the `instruction`.\"\"\"\n        return [\"instruction\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; ChatType:\n        \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n        is the first interaction from the user within a conversation.\"\"\"\n        return [\n            {\"role\": \"user\", \"content\": input[\"instruction\"]},\n        ]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The output for the task is the `generation` and the `model_name`.\"\"\"\n        return [\"generation\", \"model_name\"]\n\n    def format_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, Any]:\n        \"\"\"The output is formatted as a dictionary with the `generation`. The `model_name`\n        will be automatically included within the `process` method of `Task`.\"\"\"\n        return {\"generation\": output}\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/text_generation/#distilabel.steps.tasks.text_generation.TextGeneration.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input for the task is the <code>instruction</code>.</p>"},{"location":"reference/distilabel/steps/tasks/text_generation/#distilabel.steps.tasks.text_generation.TextGeneration.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The output for the task is the <code>generation</code> and the <code>model_name</code>.</p>"},{"location":"reference/distilabel/steps/tasks/text_generation/#distilabel.steps.tasks.text_generation.TextGeneration.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is formatted as a <code>ChatType</code> assuming that the instruction is the first interaction from the user within a conversation.</p> Source code in <code>src/distilabel/steps/tasks/text_generation.py</code> <pre><code>def format_input(self, input: Dict[str, Any]) -&gt; ChatType:\n    \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n    is the first interaction from the user within a conversation.\"\"\"\n    return [\n        {\"role\": \"user\", \"content\": input[\"instruction\"]},\n    ]\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/text_generation/#distilabel.steps.tasks.text_generation.TextGeneration.format_output","title":"<code>format_output(output, input)</code>","text":"<p>The output is formatted as a dictionary with the <code>generation</code>. The <code>model_name</code> will be automatically included within the <code>process</code> method of <code>Task</code>.</p> Source code in <code>src/distilabel/steps/tasks/text_generation.py</code> <pre><code>def format_output(\n    self, output: Union[str, None], input: Dict[str, Any]\n) -&gt; Dict[str, Any]:\n    \"\"\"The output is formatted as a dictionary with the `generation`. The `model_name`\n    will be automatically included within the `process` method of `Task`.\"\"\"\n    return {\"generation\": output}\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/typing/","title":"Typing","text":""},{"location":"reference/distilabel/steps/tasks/typing/#distilabel.steps.tasks.typing.ChatType","title":"<code>ChatType = List[ChatItem]</code>  <code>module-attribute</code>","text":"<p>ChatType is a type alias for a <code>list</code> of <code>dict</code>s following the OpenAI conversational format.</p>"},{"location":"reference/distilabel/steps/tasks/ultrafeedback/","title":"Ultrafeedback","text":""},{"location":"reference/distilabel/steps/tasks/ultrafeedback/#distilabel.steps.tasks.ultrafeedback.UltraFeedback","title":"<code>UltraFeedback</code>","text":"<p>             Bases: <code>Task</code></p> <p>UltraFeedback: Boosting Language Models with High-quality Feedback.</p> <p>Attributes:</p> Name Type Description <code>aspect</code> <code>Literal['helpfulness', 'honesty', 'instruction-following', 'truthfulness', 'overall-rating']</code> <p>The aspect to perform with the <code>UltraFeedback</code> model. The available aspects are: - <code>helpfulness</code>: Evaluate text outputs based on helpfulness. - <code>honesty</code>: Evaluate text outputs based on honesty. - <code>instruction-following</code>: Evaluate text outputs based on given instructions. - <code>truthfulness</code>: Evaluate text outputs based on truthfulness. Additionally, a custom aspect has been defined by Argilla, so as to evaluate the overall assessment of the text outputs within a single prompt. The custom aspect is: - <code>overall-rating</code>: Evaluate text outputs based on an overall assessment.</p> Input columns <ul> <li>instruction (<code>str</code>): The reference instruction to evaluate the text outputs.</li> <li>generations (<code>List[str]</code>): The text outputs to evaluate for the given instruction.</li> </ul> Output columns <ul> <li>ratings (<code>List[float]</code>): The ratings for each of the provided text outputs.</li> <li>rationales (<code>List[str]</code>): The rationales for each of the provided text outputs.</li> <li>model_name (<code>str</code>): The name of the model used to generate the ratings and rationales.</li> </ul> References <ul> <li><code>UltraFeedback: Boosting Language Models with High-quality Feedback</code></li> <li><code>UltraFeedback - GitHub Repository</code></li> </ul> Source code in <code>src/distilabel/steps/tasks/ultrafeedback.py</code> <pre><code>class UltraFeedback(Task):\n    \"\"\"UltraFeedback: Boosting Language Models with High-quality Feedback.\n\n    Attributes:\n        aspect: The aspect to perform with the `UltraFeedback` model. The available aspects are:\n            - `helpfulness`: Evaluate text outputs based on helpfulness.\n            - `honesty`: Evaluate text outputs based on honesty.\n            - `instruction-following`: Evaluate text outputs based on given instructions.\n            - `truthfulness`: Evaluate text outputs based on truthfulness.\n            Additionally, a custom aspect has been defined by Argilla, so as to evaluate the overall\n            assessment of the text outputs within a single prompt. The custom aspect is:\n            - `overall-rating`: Evaluate text outputs based on an overall assessment.\n\n    Input columns:\n        - instruction (`str`): The reference instruction to evaluate the text outputs.\n        - generations (`List[str]`): The text outputs to evaluate for the given instruction.\n\n    Output columns:\n        - ratings (`List[float]`): The ratings for each of the provided text outputs.\n        - rationales (`List[str]`): The rationales for each of the provided text outputs.\n        - model_name (`str`): The name of the model used to generate the ratings and rationales.\n\n    References:\n        - [`UltraFeedback: Boosting Language Models with High-quality Feedback`](https://arxiv.org/abs/2310.01377)\n        - [`UltraFeedback - GitHub Repository`](https://github.com/OpenBMB/UltraFeedback)\n    \"\"\"\n\n    aspect: Literal[\n        \"helpfulness\",\n        \"honesty\",\n        \"instruction-following\",\n        \"truthfulness\",\n        # Custom aspects\n        \"overall-rating\",\n    ]\n\n    _system_prompt: str = PrivateAttr(\n        default=(\n            \"Your role is to evaluate text quality based on given criteria.\\n\"\n            'You\\'ll receive an instructional description (\"Instruction\") and {no_texts} text outputs (\"Text\").\\n'\n            \"Understand and interpret instructions to evaluate effectively.\\n\"\n            \"Provide annotations for each text with a rating and rationale.\\n\"\n            \"The {no_texts} texts given are independent, and should be evaluated separately.\\n\"\n        )\n    )\n    _template: Optional[\"Template\"] = PrivateAttr(default=...)\n\n    def load(self) -&gt; None:\n        \"\"\"Loads the Jinja2 template for the given `aspect`.\"\"\"\n        super().load()\n\n        _path = str(\n            importlib_resources.files(\"distilabel\")\n            / \"steps\"\n            / \"tasks\"\n            / \"templates\"\n            / \"ultrafeedback\"\n            / f\"{self.aspect}.jinja2\"\n        )\n\n        self._template = Template(open(_path).read())\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input for the task is the `instruction`, and the `generations` for it.\"\"\"\n        return [\"instruction\", \"generations\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; ChatType:\n        \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n        is the first interaction from the user within a conversation.\"\"\"\n        return [\n            {\n                \"role\": \"system\",\n                \"content\": self._system_prompt.format(\n                    no_texts=len(input[\"generations\"])\n                ),\n            },\n            {\n                \"role\": \"user\",\n                \"content\": self._template.render(  # type: ignore\n                    instruction=input[\"instruction\"], generations=input[\"generations\"]\n                ),\n            },\n        ]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The output for the task is the `generation` and the `model_name`.\"\"\"\n        columns = []\n        if self.aspect in [\"honesty\", \"instruction-following\", \"overall-rating\"]:\n            columns = [\"ratings\", \"rationales\"]\n        elif self.aspect in [\"helpfulness\", \"truthfulness\"]:\n            columns = [\"types\", \"rationales\", \"ratings\", \"rationales-for-ratings\"]\n        return columns + [\"model_name\"]\n\n    def format_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, Any]:\n        \"\"\"The output is formatted as a dictionary with the `ratings` and `rationales` for\n        each of the provided `generations` for the given `instruction`. The `model_name`\n        will be automatically included within the `process` method of `Task`.\n\n        Args:\n            output: a string representing the output of the LLM via the `process` method.\n            input: the input to the task, as required by some tasks to format the output.\n\n        Returns:\n            A dictionary containing either the `ratings` and `rationales` for each of the provided\n            `generations` for the given `instruction` if the provided aspect is either `honesty`,\n            `instruction-following`, or `overall-rating`; or the `types`, `rationales`,\n            `ratings`, and `rationales-for-ratings` for each of the provided `generations` for the\n            given `instruction` if the provided aspect is either `helpfulness` or `truthfulness`.\n        \"\"\"\n        if self.aspect in [\n            \"honesty\",\n            \"instruction-following\",\n            \"overall-rating\",\n        ]:\n            return self._format_ratings_rationales_output(output, input)\n        else:\n            return self._format_types_ratings_rationales_output(output, input)\n\n    def _format_ratings_rationales_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, List[Any]]:\n        \"\"\"Formats the output when the aspect is either `honesty`, `instruction-following`, or `overall-rating`.\"\"\"\n        if output is None:\n            return {\n                \"ratings\": [None] * len(input[\"generations\"]),\n                \"rationales\": [None] * len(input[\"generations\"]),\n            }\n\n        pattern = r\"Rating: (.+?)\\nRationale: (.+)\"\n        sections = output.split(\"\\n\\n\")\n\n        formatted_outputs = []\n        for section in sections:\n            matches = None\n            if section is not None and section != \"\":\n                matches = re.search(pattern, section, re.DOTALL)\n            if not matches:\n                formatted_outputs.append({\"ratings\": None, \"rationales\": None})\n                continue\n\n            formatted_outputs.append(\n                {\n                    \"ratings\": int(re.findall(r\"\\b\\d+\\b\", matches.group(1))[0])\n                    if matches.group(1) not in [\"None\", \"N/A\"]\n                    else None,\n                    \"rationales\": matches.group(2),\n                }\n            )\n        return combine_dicts(*formatted_outputs)\n\n    def _format_types_ratings_rationales_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, List[Any]]:\n        \"\"\"Formats the output when the aspect is either `helpfulness` or `truthfulness`.\"\"\"\n        if output is None:\n            return {\n                \"types\": [None] * len(input[\"generations\"]),\n                \"rationales\": [None] * len(input[\"generations\"]),\n                \"ratings\": [None] * len(input[\"generations\"]),\n                \"rationales-for-ratings\": [None] * len(input[\"generations\"]),\n            }\n\n        pattern = r\"Type: (.+?)\\nRationale: (.+?)\\nRating: (.+?)\\nRationale: (.+)\"\n\n        sections = output.split(\"\\n\\n\")\n\n        formatted_outputs = []\n        for section in sections:\n            matches = None\n            if section is not None and section != \"\":\n                matches = re.search(pattern, section, re.DOTALL)\n            if not matches:\n                formatted_outputs.append(\n                    {\n                        \"types\": None,\n                        \"rationales\": None,\n                        \"ratings\": None,\n                        \"rationales-for-ratings\": None,\n                    }\n                )\n                continue\n\n            formatted_outputs.append(\n                {\n                    \"types\": int(re.findall(r\"\\b\\d+\\b\", matches.group(1))[0])\n                    if matches.group(1) not in [\"None\", \"N/A\"]\n                    else None,\n                    \"rationales\": matches.group(2),\n                    \"ratings\": int(re.findall(r\"\\b\\d+\\b\", matches.group(3))[0])\n                    if matches.group(3) not in [\"None\", \"N/A\"]\n                    else None,\n                    \"rationales-for-ratings\": matches.group(4),\n                }\n            )\n        return combine_dicts(*formatted_outputs)\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/ultrafeedback/#distilabel.steps.tasks.ultrafeedback.UltraFeedback.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input for the task is the <code>instruction</code>, and the <code>generations</code> for it.</p>"},{"location":"reference/distilabel/steps/tasks/ultrafeedback/#distilabel.steps.tasks.ultrafeedback.UltraFeedback.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The output for the task is the <code>generation</code> and the <code>model_name</code>.</p>"},{"location":"reference/distilabel/steps/tasks/ultrafeedback/#distilabel.steps.tasks.ultrafeedback.UltraFeedback.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is formatted as a <code>ChatType</code> assuming that the instruction is the first interaction from the user within a conversation.</p> Source code in <code>src/distilabel/steps/tasks/ultrafeedback.py</code> <pre><code>def format_input(self, input: Dict[str, Any]) -&gt; ChatType:\n    \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n    is the first interaction from the user within a conversation.\"\"\"\n    return [\n        {\n            \"role\": \"system\",\n            \"content\": self._system_prompt.format(\n                no_texts=len(input[\"generations\"])\n            ),\n        },\n        {\n            \"role\": \"user\",\n            \"content\": self._template.render(  # type: ignore\n                instruction=input[\"instruction\"], generations=input[\"generations\"]\n            ),\n        },\n    ]\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/ultrafeedback/#distilabel.steps.tasks.ultrafeedback.UltraFeedback.format_output","title":"<code>format_output(output, input)</code>","text":"<p>The output is formatted as a dictionary with the <code>ratings</code> and <code>rationales</code> for each of the provided <code>generations</code> for the given <code>instruction</code>. The <code>model_name</code> will be automatically included within the <code>process</code> method of <code>Task</code>.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>Union[str, None]</code> <p>a string representing the output of the LLM via the <code>process</code> method.</p> required <code>input</code> <code>Dict[str, Any]</code> <p>the input to the task, as required by some tasks to format the output.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary containing either the <code>ratings</code> and <code>rationales</code> for each of the provided</p> <code>Dict[str, Any]</code> <p><code>generations</code> for the given <code>instruction</code> if the provided aspect is either <code>honesty</code>,</p> <code>Dict[str, Any]</code> <p><code>instruction-following</code>, or <code>overall-rating</code>; or the <code>types</code>, <code>rationales</code>,</p> <code>Dict[str, Any]</code> <p><code>ratings</code>, and <code>rationales-for-ratings</code> for each of the provided <code>generations</code> for the</p> <code>Dict[str, Any]</code> <p>given <code>instruction</code> if the provided aspect is either <code>helpfulness</code> or <code>truthfulness</code>.</p> Source code in <code>src/distilabel/steps/tasks/ultrafeedback.py</code> <pre><code>def format_output(\n    self, output: Union[str, None], input: Dict[str, Any]\n) -&gt; Dict[str, Any]:\n    \"\"\"The output is formatted as a dictionary with the `ratings` and `rationales` for\n    each of the provided `generations` for the given `instruction`. The `model_name`\n    will be automatically included within the `process` method of `Task`.\n\n    Args:\n        output: a string representing the output of the LLM via the `process` method.\n        input: the input to the task, as required by some tasks to format the output.\n\n    Returns:\n        A dictionary containing either the `ratings` and `rationales` for each of the provided\n        `generations` for the given `instruction` if the provided aspect is either `honesty`,\n        `instruction-following`, or `overall-rating`; or the `types`, `rationales`,\n        `ratings`, and `rationales-for-ratings` for each of the provided `generations` for the\n        given `instruction` if the provided aspect is either `helpfulness` or `truthfulness`.\n    \"\"\"\n    if self.aspect in [\n        \"honesty\",\n        \"instruction-following\",\n        \"overall-rating\",\n    ]:\n        return self._format_ratings_rationales_output(output, input)\n    else:\n        return self._format_types_ratings_rationales_output(output, input)\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/ultrafeedback/#distilabel.steps.tasks.ultrafeedback.UltraFeedback.load","title":"<code>load()</code>","text":"<p>Loads the Jinja2 template for the given <code>aspect</code>.</p> Source code in <code>src/distilabel/steps/tasks/ultrafeedback.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Loads the Jinja2 template for the given `aspect`.\"\"\"\n    super().load()\n\n    _path = str(\n        importlib_resources.files(\"distilabel\")\n        / \"steps\"\n        / \"tasks\"\n        / \"templates\"\n        / \"ultrafeedback\"\n        / f\"{self.aspect}.jinja2\"\n    )\n\n    self._template = Template(open(_path).read())\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/evol_instruct/","title":"Index","text":""},{"location":"reference/distilabel/steps/tasks/evol_instruct/base/","title":"Base","text":""},{"location":"reference/distilabel/steps/tasks/evol_instruct/base/#distilabel.steps.tasks.evol_instruct.base.EvolInstruct","title":"<code>EvolInstruct</code>","text":"<p>             Bases: <code>Task</code></p> <p>WizardLM: Empowering Large Language Models to Follow Complex Instructions</p> <p>Attributes:</p> Name Type Description <code>num_evolutions</code> <code>int</code> <p>The number of evolutions to be performed.</p> <code>store_evolutions</code> <code>bool</code> <p>Whether to store all the evolutions or just the last one. Defaults to <code>False</code>.</p> <code>generate_answers</code> <code>bool</code> <p>Whether to generate answers for the evolved instructions. Defaults to <code>False</code>.</p> <code>include_original_instruction</code> <code>bool</code> <p>Whether to include the original instruction in the <code>evolved_instructions</code> output column. Defaults to <code>False</code>.</p> <code>mutation_templates</code> <code>Dict[str, str]</code> <p>The mutation templates to be used for evolving the instructions. Defaults to the ones provided in the <code>utils.py</code> file.</p> <code>seed</code> <code>RuntimeParameter[int]</code> <p>The seed to be set for <code>numpy</code> in order to randomly pick a mutation method. Defaults to <code>42</code>.</p> Runtime parameters <ul> <li><code>seed</code>: The seed to be set for <code>numpy</code> in order to randomly pick a mutation method.</li> </ul> Input columns <ul> <li>instruction (<code>str</code>): The instruction to evolve.</li> </ul> Output columns <ul> <li>evolved_instruction (<code>str</code>): The evolved instruction if <code>store_evolutions=False</code>.</li> <li>evolved_instructions (<code>List[str]</code>): The evolved instructions if <code>store_evolutions=True</code>.</li> <li>model_name (<code>str</code>): The name of the LLM used to evolve the instructions.</li> <li>answer (<code>str</code>): The answer to the evolved instruction if <code>generate_answers=True</code>     and <code>store_evolutions=False</code>.</li> <li>answers (<code>List[str]</code>): The answers to the evolved instructions if <code>generate_answers=True</code>     and <code>store_evolutions=True</code>.</li> </ul> References <ul> <li>WizardLM: Empowering Large Language Models to Follow Complex Instructions</li> <li>GitHub: h2oai/h2o-wizardlm</li> </ul> Source code in <code>src/distilabel/steps/tasks/evol_instruct/base.py</code> <pre><code>class EvolInstruct(Task):\n    \"\"\"WizardLM: Empowering Large Language Models to Follow Complex Instructions\n\n    Attributes:\n        num_evolutions: The number of evolutions to be performed.\n        store_evolutions: Whether to store all the evolutions or just the last one. Defaults\n            to `False`.\n        generate_answers: Whether to generate answers for the evolved instructions. Defaults\n            to `False`.\n        include_original_instruction: Whether to include the original instruction in the\n            `evolved_instructions` output column. Defaults to `False`.\n        mutation_templates: The mutation templates to be used for evolving the instructions.\n            Defaults to the ones provided in the `utils.py` file.\n        seed: The seed to be set for `numpy` in order to randomly pick a mutation method.\n            Defaults to `42`.\n\n    Runtime parameters:\n        - `seed`: The seed to be set for `numpy` in order to randomly pick a mutation method.\n\n    Input columns:\n        - instruction (`str`): The instruction to evolve.\n\n    Output columns:\n        - evolved_instruction (`str`): The evolved instruction if `store_evolutions=False`.\n        - evolved_instructions (`List[str]`): The evolved instructions if `store_evolutions=True`.\n        - model_name (`str`): The name of the LLM used to evolve the instructions.\n        - answer (`str`): The answer to the evolved instruction if `generate_answers=True`\n            and `store_evolutions=False`.\n        - answers (`List[str]`): The answers to the evolved instructions if `generate_answers=True`\n            and `store_evolutions=True`.\n\n    References:\n        - [WizardLM: Empowering Large Language Models to Follow Complex Instructions](https://arxiv.org/abs/2304.12244)\n        - [GitHub: h2oai/h2o-wizardlm](https://github.com/h2oai/h2o-wizardlm)\n    \"\"\"\n\n    num_evolutions: int\n    store_evolutions: bool = False\n    generate_answers: bool = False\n    include_original_instruction: bool = False\n    mutation_templates: Dict[str, str] = MUTATION_TEMPLATES\n\n    seed: RuntimeParameter[int] = Field(\n        default=42,\n        description=\"As `numpy` is being used in order to randomly pick a mutation method, then is nice to seed a random seed.\",\n    )\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input for the task is the `instruction`.\"\"\"\n        return [\"instruction\"]\n\n    def format_input(self, input: str) -&gt; ChatType:  # type: ignore\n        \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n        is the first interaction from the user within a conversation. And the\n        `system_prompt` is added as the first message if it exists.\"\"\"\n        return [{\"role\": \"user\", \"content\": input}]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The output for the task are the `evolved_instruction/s`, the `answer` if `generate_answers=True`\n        and the `model_name`.\"\"\"\n        # TODO: having to define a `model_name` column every time as the `Task.outputs` is not ideal,\n        # this could be handled always and the value could be included within the DAG validation when\n        # a `Task` is used, since all the `Task` subclasses will have an `llm` with a `model_name` attr.\n        _outputs = [\n            (\n                \"evolved_instruction\"\n                if not self.store_evolutions\n                else \"evolved_instructions\"\n            ),\n            \"model_name\",\n        ]\n        if self.generate_answers:\n            _outputs.append(\"answer\" if not self.store_evolutions else \"answers\")\n        return _outputs\n\n    @override\n    def format_output(  # type: ignore\n        self, instructions: Union[str, List[str]], answers: Optional[List[str]] = None\n    ) -&gt; Dict[str, Any]:  # type: ignore\n        \"\"\"The output for the task is a dict with: `evolved_instruction` or `evolved_instructions`,\n        depending whether the value is either `False` or `True` for `store_evolutions`, respectively;\n        `answer` if `generate_answers=True`; and, finally, the `model_name`.\n\n        Args:\n            instructions: The instructions to be included within the output.\n            answers: The answers to be included within the output if `generate_answers=True`.\n\n        Returns:\n            If `store_evolutions=False` and `generate_answers=True` return {\"evolved_instruction\": ..., \"model_name\": ..., \"answer\": ...};\n            if `store_evolutions=True` and `generate_answers=True` return {\"evolved_instructions\": ..., \"model_name\": ..., \"answer\": ...};\n            if `store_evolutions=False` and `generate_answers=False` return {\"evolved_instruction\": ..., \"model_name\": ...};\n            if `store_evolutions=True` and `generate_answers=False` return {\"evolved_instructions\": ..., \"model_name\": ...}.\n        \"\"\"\n        _output = {}\n        if not self.store_evolutions:\n            _output[\"evolved_instruction\"] = instructions[-1]\n        else:\n            _output[\"evolved_instructions\"] = instructions\n\n        if self.generate_answers and answers:\n            if not self.store_evolutions:\n                _output[\"answer\"] = answers[-1]\n            else:\n                _output[\"answers\"] = answers\n\n        _output[\"model_name\"] = self.llm.model_name\n        return _output\n\n    @property\n    def mutation_templates_names(self) -&gt; List[str]:\n        \"\"\"Returns the names i.e. keys of the provided `mutation_templates`.\"\"\"\n        return list(self.mutation_templates.keys())\n\n    def _apply_random_mutation(self, instruction: str) -&gt; str:\n        \"\"\"Applies a random mutation from the ones provided as part of the `mutation_templates`\n        enum, and returns the provided instruction within the mutation prompt.\n\n        Args:\n            instruction: The instruction to be included within the mutation prompt.\n\n        Returns:\n            A random mutation prompt with the provided instruction.\n        \"\"\"\n        mutation = np.random.choice(self.mutation_templates_names)\n        return self.mutation_templates[mutation].replace(\"&lt;PROMPT&gt;\", instruction)  # type: ignore\n\n    def _evolve_instructions(self, inputs: \"StepInput\") -&gt; List[List[str]]:\n        \"\"\"Evolves the instructions provided as part of the inputs of the task.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Returns:\n            A list where each item is a list with either the last evolved instruction if\n            `store_evolutions=False` or all the evolved instructions if `store_evolutions=True`.\n        \"\"\"\n\n        instructions: List[List[str]] = [[input[\"instruction\"]] for input in inputs]\n\n        for iter_no in range(self.num_evolutions):\n            formatted_prompts = []\n            for instruction in instructions:\n                formatted_prompts.append(self._apply_random_mutation(instruction[-1]))\n\n            formatted_prompts = [\n                self.format_input(prompt) for prompt in formatted_prompts\n            ]\n            generated_prompts = flatten_responses(\n                self.llm.generate(\n                    formatted_prompts,\n                    **self.llm.generation_kwargs,  # type: ignore\n                )\n            )\n\n            evolved_instructions = []\n            for generated_prompt in generated_prompts:\n                generated_prompt = generated_prompt.split(\"Prompt#:\")[-1].strip()\n                evolved_instructions.append(generated_prompt)\n\n            if self.store_evolutions:\n                instructions = [\n                    instruction + [evolved_instruction]\n                    for instruction, evolved_instruction in zip(\n                        instructions, evolved_instructions\n                    )\n                ]\n            else:\n                instructions = [\n                    [evolved_instruction]\n                    for evolved_instruction in evolved_instructions\n                ]\n\n            self._logger.info(\n                f\"\ud83d\udd04 Ran iteration {iter_no} evolving {len(instructions)} instructions!\"\n            )\n\n        return instructions\n\n    def _generate_answers(\n        self, evolved_instructions: List[List[str]]\n    ) -&gt; List[List[str]]:\n        \"\"\"Generates the answer for the instructions in `instructions`.\n\n        Args:\n            evolved_instructions: A list of lists where each item is a list with either the last\n                evolved instruction if `store_evolutions=False` or all the evolved instructions\n                if `store_evolutions=True`.\n\n        Returns:\n            A list of answers for each instruction.\n        \"\"\"\n        formatted_instructions = [\n            self.format_input(instruction)\n            for instructions in evolved_instructions\n            for instruction in instructions\n        ]\n\n        responses = self.llm.generate(\n            formatted_instructions,\n            num_generations=1,\n            **self.llm.generation_kwargs,  # type: ignore\n        )\n\n        step = (\n            self.num_evolutions\n            if not self.include_original_instruction\n            else self.num_evolutions + 1\n        )\n        return [\n            flatten_responses(responses[i : i + step])\n            for i in range(0, len(responses), step)\n        ]\n\n    @override\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Yields:\n            A list of Python dictionaries with the outputs of the task.\n        \"\"\"\n\n        evolved_instructions = self._evolve_instructions(inputs)\n\n        if self.store_evolutions:\n            # Remove the input instruction from the `evolved_instructions` list\n            from_ = 1 if not self.include_original_instruction else 0\n            evolved_instructions = [\n                instruction[from_:] for instruction in evolved_instructions\n            ]\n\n        if not self.generate_answers:\n            for input, instruction in zip(inputs, evolved_instructions):\n                input.update(self.format_output(instruction))\n            yield inputs\n\n        self._logger.info(\n            f\"\ud83c\udf89 Finished evolving {len(evolved_instructions)} instructions!\"\n        )\n\n        if self.generate_answers:\n            self._logger.info(\n                f\"\ud83e\udde0 Generating answers for the {len(evolved_instructions)} evolved instructions!\"\n            )\n\n            answers = self._generate_answers(evolved_instructions)\n\n            self._logger.info(\n                f\"\ud83c\udf89 Finished generating answers for the {len(evolved_instructions)} evolved\"\n                \" instructions!\"\n            )\n\n            for idx, (input, instruction) in enumerate(\n                zip(inputs, evolved_instructions)\n            ):\n                input.update(self.format_output(instruction, answers[idx]))\n            yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/evol_instruct/base/#distilabel.steps.tasks.evol_instruct.base.EvolInstruct.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input for the task is the <code>instruction</code>.</p>"},{"location":"reference/distilabel/steps/tasks/evol_instruct/base/#distilabel.steps.tasks.evol_instruct.base.EvolInstruct.mutation_templates_names","title":"<code>mutation_templates_names: List[str]</code>  <code>property</code>","text":"<p>Returns the names i.e. keys of the provided <code>mutation_templates</code>.</p>"},{"location":"reference/distilabel/steps/tasks/evol_instruct/base/#distilabel.steps.tasks.evol_instruct.base.EvolInstruct.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The output for the task are the <code>evolved_instruction/s</code>, the <code>answer</code> if <code>generate_answers=True</code> and the <code>model_name</code>.</p>"},{"location":"reference/distilabel/steps/tasks/evol_instruct/base/#distilabel.steps.tasks.evol_instruct.base.EvolInstruct.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is formatted as a <code>ChatType</code> assuming that the instruction is the first interaction from the user within a conversation. And the <code>system_prompt</code> is added as the first message if it exists.</p> Source code in <code>src/distilabel/steps/tasks/evol_instruct/base.py</code> <pre><code>def format_input(self, input: str) -&gt; ChatType:  # type: ignore\n    \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n    is the first interaction from the user within a conversation. And the\n    `system_prompt` is added as the first message if it exists.\"\"\"\n    return [{\"role\": \"user\", \"content\": input}]\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/evol_instruct/base/#distilabel.steps.tasks.evol_instruct.base.EvolInstruct.format_output","title":"<code>format_output(instructions, answers=None)</code>","text":"<p>The output for the task is a dict with: <code>evolved_instruction</code> or <code>evolved_instructions</code>, depending whether the value is either <code>False</code> or <code>True</code> for <code>store_evolutions</code>, respectively; <code>answer</code> if <code>generate_answers=True</code>; and, finally, the <code>model_name</code>.</p> <p>Parameters:</p> Name Type Description Default <code>instructions</code> <code>Union[str, List[str]]</code> <p>The instructions to be included within the output.</p> required <code>answers</code> <code>Optional[List[str]]</code> <p>The answers to be included within the output if <code>generate_answers=True</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>If <code>store_evolutions=False</code> and <code>generate_answers=True</code> return {\"evolved_instruction\": ..., \"model_name\": ..., \"answer\": ...};</p> <code>Dict[str, Any]</code> <p>if <code>store_evolutions=True</code> and <code>generate_answers=True</code> return {\"evolved_instructions\": ..., \"model_name\": ..., \"answer\": ...};</p> <code>Dict[str, Any]</code> <p>if <code>store_evolutions=False</code> and <code>generate_answers=False</code> return {\"evolved_instruction\": ..., \"model_name\": ...};</p> <code>Dict[str, Any]</code> <p>if <code>store_evolutions=True</code> and <code>generate_answers=False</code> return {\"evolved_instructions\": ..., \"model_name\": ...}.</p> Source code in <code>src/distilabel/steps/tasks/evol_instruct/base.py</code> <pre><code>@override\ndef format_output(  # type: ignore\n    self, instructions: Union[str, List[str]], answers: Optional[List[str]] = None\n) -&gt; Dict[str, Any]:  # type: ignore\n    \"\"\"The output for the task is a dict with: `evolved_instruction` or `evolved_instructions`,\n    depending whether the value is either `False` or `True` for `store_evolutions`, respectively;\n    `answer` if `generate_answers=True`; and, finally, the `model_name`.\n\n    Args:\n        instructions: The instructions to be included within the output.\n        answers: The answers to be included within the output if `generate_answers=True`.\n\n    Returns:\n        If `store_evolutions=False` and `generate_answers=True` return {\"evolved_instruction\": ..., \"model_name\": ..., \"answer\": ...};\n        if `store_evolutions=True` and `generate_answers=True` return {\"evolved_instructions\": ..., \"model_name\": ..., \"answer\": ...};\n        if `store_evolutions=False` and `generate_answers=False` return {\"evolved_instruction\": ..., \"model_name\": ...};\n        if `store_evolutions=True` and `generate_answers=False` return {\"evolved_instructions\": ..., \"model_name\": ...}.\n    \"\"\"\n    _output = {}\n    if not self.store_evolutions:\n        _output[\"evolved_instruction\"] = instructions[-1]\n    else:\n        _output[\"evolved_instructions\"] = instructions\n\n    if self.generate_answers and answers:\n        if not self.store_evolutions:\n            _output[\"answer\"] = answers[-1]\n        else:\n            _output[\"answers\"] = answers\n\n    _output[\"model_name\"] = self.llm.model_name\n    return _output\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/evol_instruct/base/#distilabel.steps.tasks.evol_instruct.base.EvolInstruct.process","title":"<code>process(inputs)</code>","text":"<p>Processes the inputs of the task and generates the outputs using the LLM.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>A list of Python dictionaries with the inputs of the task.</p> required <p>Yields:</p> Type Description <code>StepOutput</code> <p>A list of Python dictionaries with the outputs of the task.</p> Source code in <code>src/distilabel/steps/tasks/evol_instruct/base.py</code> <pre><code>@override\ndef process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n    Args:\n        inputs: A list of Python dictionaries with the inputs of the task.\n\n    Yields:\n        A list of Python dictionaries with the outputs of the task.\n    \"\"\"\n\n    evolved_instructions = self._evolve_instructions(inputs)\n\n    if self.store_evolutions:\n        # Remove the input instruction from the `evolved_instructions` list\n        from_ = 1 if not self.include_original_instruction else 0\n        evolved_instructions = [\n            instruction[from_:] for instruction in evolved_instructions\n        ]\n\n    if not self.generate_answers:\n        for input, instruction in zip(inputs, evolved_instructions):\n            input.update(self.format_output(instruction))\n        yield inputs\n\n    self._logger.info(\n        f\"\ud83c\udf89 Finished evolving {len(evolved_instructions)} instructions!\"\n    )\n\n    if self.generate_answers:\n        self._logger.info(\n            f\"\ud83e\udde0 Generating answers for the {len(evolved_instructions)} evolved instructions!\"\n        )\n\n        answers = self._generate_answers(evolved_instructions)\n\n        self._logger.info(\n            f\"\ud83c\udf89 Finished generating answers for the {len(evolved_instructions)} evolved\"\n            \" instructions!\"\n        )\n\n        for idx, (input, instruction) in enumerate(\n            zip(inputs, evolved_instructions)\n        ):\n            input.update(self.format_output(instruction, answers[idx]))\n        yield inputs\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/evol_instruct/generator/","title":"Generator","text":""},{"location":"reference/distilabel/steps/tasks/evol_instruct/generator/#distilabel.steps.tasks.evol_instruct.generator.EvolInstructGenerator","title":"<code>EvolInstructGenerator</code>","text":"<p>             Bases: <code>GeneratorTask</code></p> <p>WizardLM: Empowering Large Language Models to Follow Complex Instructions</p> <p>Attributes:</p> Name Type Description <code>num_instructions</code> <code>int</code> <p>The number of instructions to be generated.</p> <code>generate_answers</code> <code>bool</code> <p>Whether to generate answers for the instructions or not. Defaults to <code>False</code>.</p> <code>mutation_templates</code> <code>Dict[str, str]</code> <p>The mutation templates to be used for the generation of the instructions.</p> <code>min_length</code> <code>RuntimeParameter[int]</code> <p>Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid. Defaults to <code>512</code>.</p> <code>max_length</code> <code>RuntimeParameter[int]</code> <p>Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid. Defaults to <code>1024</code>.</p> <code>seed</code> <code>RuntimeParameter[int]</code> <p>The seed to be set for <code>numpy</code> in order to randomly pick a mutation method. Defaults to <code>42</code>.</p> Runtime parameters <ul> <li><code>min_length</code>: Defines the length (in bytes) that the generated instruction needs     to be higher than, to be considered valid.</li> <li><code>max_length</code>: Defines the length (in bytes) that the generated instruction needs     to be lower than, to be considered valid.</li> <li><code>seed</code>: The seed to be set for <code>numpy</code> in order to randomly pick a mutation method.</li> </ul> Output columns <ul> <li>instruction (<code>str</code>): The generated instruction if <code>generate_answers=False</code>.</li> <li>answer (<code>str</code>): The generated answer if <code>generate_answers=True</code>.</li> <li>instructions (<code>List[str]</code>): The generated instructions if <code>generate_answers=True</code>.</li> <li>model_name (<code>str</code>): The name of the LLM used to generate and evolve the instructions.</li> </ul> References <ul> <li>WizardLM: Empowering Large Language Models to Follow Complex Instructions</li> <li>GitHub: h2oai/h2o-wizardlm</li> </ul> Source code in <code>src/distilabel/steps/tasks/evol_instruct/generator.py</code> <pre><code>class EvolInstructGenerator(GeneratorTask):\n    \"\"\"WizardLM: Empowering Large Language Models to Follow Complex Instructions\n\n    Attributes:\n        num_instructions: The number of instructions to be generated.\n        generate_answers: Whether to generate answers for the instructions or not. Defaults\n            to `False`.\n        mutation_templates: The mutation templates to be used for the generation of the\n            instructions.\n        min_length: Defines the length (in bytes) that the generated instruction needs to\n            be higher than, to be considered valid. Defaults to `512`.\n        max_length: Defines the length (in bytes) that the generated instruction needs to\n            be lower than, to be considered valid. Defaults to `1024`.\n        seed: The seed to be set for `numpy` in order to randomly pick a mutation method.\n            Defaults to `42`.\n\n    Runtime parameters:\n        - `min_length`: Defines the length (in bytes) that the generated instruction needs\n            to be higher than, to be considered valid.\n        - `max_length`: Defines the length (in bytes) that the generated instruction needs\n            to be lower than, to be considered valid.\n        - `seed`: The seed to be set for `numpy` in order to randomly pick a mutation method.\n\n    Output columns:\n        - instruction (`str`): The generated instruction if `generate_answers=False`.\n        - answer (`str`): The generated answer if `generate_answers=True`.\n        - instructions (`List[str]`): The generated instructions if `generate_answers=True`.\n        - model_name (`str`): The name of the LLM used to generate and evolve the instructions.\n\n    References:\n        - [WizardLM: Empowering Large Language Models to Follow Complex Instructions](https://arxiv.org/abs/2304.12244)\n        - [GitHub: h2oai/h2o-wizardlm](https://github.com/h2oai/h2o-wizardlm)\n    \"\"\"\n\n    num_instructions: int\n    generate_answers: bool = False\n    mutation_templates: Dict[str, str] = GENERATION_MUTATION_TEMPLATES\n\n    min_length: RuntimeParameter[int] = Field(\n        default=512,\n        description=\"Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid.\",\n    )\n    max_length: RuntimeParameter[int] = Field(\n        default=1024,\n        description=\"Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid.\",\n    )\n\n    seed: RuntimeParameter[int] = Field(\n        default=42,\n        description=\"As `numpy` is being used in order to randomly pick a mutation method, then is nice to seed a random seed.\",\n    )\n    _seed_texts: Optional[List[str]] = PrivateAttr(default_factory=list)\n    _prompts: Optional[List[str]] = PrivateAttr(default_factory=list)\n\n    def _generate_seed_texts(self) -&gt; List[str]:\n        \"\"\"Generates a list of seed texts to be used as part of the starting prompts for the task.\n\n        It will use the `FRESH_START` mutation template, as it needs to generate text from scratch; and\n        a list of English words will be used to generate the seed texts that will be provided to the\n        mutation method and included within the prompt.\n\n        Returns:\n            A list of seed texts to be used as part of the starting prompts for the task.\n        \"\"\"\n        seed_texts = []\n        for _ in range(self.num_instructions * 10):\n            num_words = np.random.choice([1, 2, 3, 4])\n            seed_texts.append(\n                self.mutation_templates[\"FRESH_START\"].replace(  # type: ignore\n                    \"&lt;PROMPT&gt;\",\n                    \", \".join(\n                        [\n                            np.random.choice(self._english_nouns).strip()\n                            for _ in range(num_words)\n                        ]\n                    ),\n                )\n            )\n        return seed_texts\n\n    @override\n    def model_post_init(self, __context: Any) -&gt; None:\n        \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n        This is useful if you want to do some validation that requires the entire model to be initialized.\n        \"\"\"\n        super().model_post_init(__context)\n\n        np.random.seed(self.seed)\n\n        self._seed_texts = self._generate_seed_texts()\n        self._prompts = [\n            np.random.choice(self._seed_texts) for _ in range(self.num_instructions)\n        ]\n\n    @cached_property\n    def _english_nouns(self) -&gt; List[str]:\n        \"\"\"A list of English nouns to be used as part of the starting prompts for the task.\n\n        References:\n            - https://github.com/h2oai/h2o-wizardlm\n        \"\"\"\n        _path = str(\n            importlib_resources.files(\"distilabel\")\n            / \"steps/tasks/evol_instruct/english_nouns.txt\"\n        )\n        with open(_path, mode=\"r\") as f:\n            return [line.strip() for line in f.readlines()]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The output for the task are the `instruction`, the `answer` if `generate_answers=True`\n        and the `model_name`.\"\"\"\n        _outputs = [\"instruction\", \"model_name\"]\n        if self.generate_answers:\n            _outputs.append(\"answer\")\n        return _outputs\n\n    def format_output(  # type: ignore\n        self, instruction: str, answer: Optional[str] = None\n    ) -&gt; Dict[str, Any]:\n        \"\"\"The output for the task is a dict with: `instruction`; `answer` if `generate_answers=True`;\n        and, finally, the `model_name`.\n\n        Args:\n            instruction: The instruction to be included within the output.\n            answer: The answer to be included within the output if `generate_answers=True`.\n\n        Returns:\n            If `generate_answers=True` return {\"instruction\": ..., \"answer\": ..., \"model_name\": ...};\n            if `generate_answers=False` return {\"instruction\": ..., \"model_name\": ...};\n        \"\"\"\n        _output = {\n            \"instruction\": instruction,\n            \"model_name\": self.llm.model_name,\n        }\n        if self.generate_answers and answer is not None:\n            _output[\"answer\"] = answer\n        return _output\n\n    @property\n    def mutation_templates_names(self) -&gt; List[str]:\n        \"\"\"Returns the names i.e. keys of the provided `mutation_templates`.\"\"\"\n        return list(self.mutation_templates.keys())\n\n    def _apply_random_mutation(self, iter_no: int) -&gt; List[\"ChatType\"]:\n        \"\"\"Applies a random mutation from the ones provided as part of the `mutation_templates`\n        enum, and returns the provided instruction within the mutation prompt.\n\n        Args:\n            iter_no: The iteration number to be used to check whether the iteration is the\n                first one i.e. FRESH_START, or not.\n\n        Returns:\n            A random mutation prompt with the provided instruction formatted as an OpenAI conversation.\n        \"\"\"\n        prompts = []\n        for idx in range(self.num_instructions):\n            if (\n                iter_no == 0\n                or \"Write one question or request containing\" in self._prompts[idx]  # type: ignore\n            ):\n                mutation = \"FRESH_START\"\n            else:\n                mutation = np.random.choice(self.mutation_templates_names)\n                if mutation == \"FRESH_START\":\n                    self._prompts[idx] = np.random.choice(self._seed_texts)  # type: ignore\n\n            prompt_with_template = (\n                self.mutation_templates[mutation].replace(  # type: ignore\n                    \"&lt;PROMPT&gt;\",\n                    self._prompts[idx],  # type: ignore\n                )  # type: ignore\n                if iter_no != 0\n                else self._prompts[idx]  # type: ignore\n            )\n            prompts.append([{\"role\": \"user\", \"content\": prompt_with_template}])\n        return prompts\n\n    def _generate_answers(self, instructions: List[List[str]]) -&gt; List[str]:\n        \"\"\"Generates the answer for the last instruction in `instructions`.\n\n        Args:\n            instructions: A list of lists where each item is a list with either the last\n                evolved instruction if `store_evolutions=False` or all the evolved instructions\n                if `store_evolutions=True`.\n\n        Returns:\n            A list of answers for the last instruction in `instructions`.\n        \"\"\"\n        # TODO: update to generate answers for all the instructions\n        _formatted_instructions = [\n            [{\"role\": \"user\", \"content\": instruction[-1]}]\n            for instruction in instructions\n        ]\n        responses = self.llm.generate(\n            _formatted_instructions,\n            **self.llm.generation_kwargs,  # type: ignore\n        )\n        return flatten_responses(responses)\n\n    @override\n    def process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":  # type: ignore\n        \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n        Args:\n            offset: The offset to start the generation from. Defaults to 0.\n\n        Yields:\n            A list of Python dictionaries with the outputs of the task, and a boolean\n            flag indicating whether the task has finished or not i.e. is the last batch.\n        \"\"\"\n        instructions = []\n        mutation_no = 0\n\n        iter_no = 0\n        while len(instructions) &lt; self.num_instructions:\n            prompts = self._apply_random_mutation(iter_no=iter_no)\n\n            generated_prompts = flatten_responses(\n                self.llm.generate(prompts, **self.llm.generation_kwargs)  # type: ignore\n            )\n            for idx, generated_prompt in enumerate(generated_prompts):\n                generated_prompt = generated_prompt.split(\"Prompt#:\")[-1].strip()\n                if self.max_length &gt;= len(generated_prompt) &gt;= self.min_length:  # type: ignore\n                    instructions.append(generated_prompt)\n                    self._prompts[idx] = np.random.choice(self._seed_texts)  # type: ignore\n                else:\n                    self._prompts[idx] = generated_prompt  # type: ignore\n\n            self._logger.info(\n                f\"\ud83d\udd04 Ran iteration {iter_no} with {len(instructions)} instructions already evolved!\"\n            )\n            iter_no += 1\n\n            if len(instructions) &gt; self.num_instructions:\n                instructions = instructions[: self.num_instructions]\n            if len(instructions) &gt; mutation_no:\n                mutation_no = len(instructions) - mutation_no\n\n            if not self.generate_answers and len(instructions[-mutation_no:]) &gt; 0:\n                yield (\n                    [\n                        self.format_output(mutated_instruction)\n                        for mutated_instruction in instructions[-mutation_no:]\n                    ],\n                    len(instructions) &gt;= self.num_instructions,\n                )\n\n        self._logger.info(f\"\ud83c\udf89 Finished evolving {len(instructions)} instructions!\")\n\n        if self.generate_answers:\n            self._logger.info(\n                f\"\ud83e\udde0 Generating answers for the {len(instructions)} evolved instructions!\"\n            )\n\n            answers = self._generate_answers(instructions)\n\n            self._logger.info(\n                f\"\ud83c\udf89 Finished generating answers for the {len(instructions)} evolved instructions!\"\n            )\n\n            yield (\n                [\n                    self.format_output(instruction, answer)\n                    for instruction, answer in zip(instructions, answers)\n                ],\n                True,\n            )\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/evol_instruct/generator/#distilabel.steps.tasks.evol_instruct.generator.EvolInstructGenerator.mutation_templates_names","title":"<code>mutation_templates_names: List[str]</code>  <code>property</code>","text":"<p>Returns the names i.e. keys of the provided <code>mutation_templates</code>.</p>"},{"location":"reference/distilabel/steps/tasks/evol_instruct/generator/#distilabel.steps.tasks.evol_instruct.generator.EvolInstructGenerator.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The output for the task are the <code>instruction</code>, the <code>answer</code> if <code>generate_answers=True</code> and the <code>model_name</code>.</p>"},{"location":"reference/distilabel/steps/tasks/evol_instruct/generator/#distilabel.steps.tasks.evol_instruct.generator.EvolInstructGenerator.format_output","title":"<code>format_output(instruction, answer=None)</code>","text":"<p>The output for the task is a dict with: <code>instruction</code>; <code>answer</code> if <code>generate_answers=True</code>; and, finally, the <code>model_name</code>.</p> <p>Parameters:</p> Name Type Description Default <code>instruction</code> <code>str</code> <p>The instruction to be included within the output.</p> required <code>answer</code> <code>Optional[str]</code> <p>The answer to be included within the output if <code>generate_answers=True</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>If <code>generate_answers=True</code> return {\"instruction\": ..., \"answer\": ..., \"model_name\": ...};</p> <code>Dict[str, Any]</code> <p>if <code>generate_answers=False</code> return {\"instruction\": ..., \"model_name\": ...};</p> Source code in <code>src/distilabel/steps/tasks/evol_instruct/generator.py</code> <pre><code>def format_output(  # type: ignore\n    self, instruction: str, answer: Optional[str] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"The output for the task is a dict with: `instruction`; `answer` if `generate_answers=True`;\n    and, finally, the `model_name`.\n\n    Args:\n        instruction: The instruction to be included within the output.\n        answer: The answer to be included within the output if `generate_answers=True`.\n\n    Returns:\n        If `generate_answers=True` return {\"instruction\": ..., \"answer\": ..., \"model_name\": ...};\n        if `generate_answers=False` return {\"instruction\": ..., \"model_name\": ...};\n    \"\"\"\n    _output = {\n        \"instruction\": instruction,\n        \"model_name\": self.llm.model_name,\n    }\n    if self.generate_answers and answer is not None:\n        _output[\"answer\"] = answer\n    return _output\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/evol_instruct/generator/#distilabel.steps.tasks.evol_instruct.generator.EvolInstructGenerator.model_post_init","title":"<code>model_post_init(__context)</code>","text":"<p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>src/distilabel/steps/tasks/evol_instruct/generator.py</code> <pre><code>@override\ndef model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n    super().model_post_init(__context)\n\n    np.random.seed(self.seed)\n\n    self._seed_texts = self._generate_seed_texts()\n    self._prompts = [\n        np.random.choice(self._seed_texts) for _ in range(self.num_instructions)\n    ]\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/evol_instruct/generator/#distilabel.steps.tasks.evol_instruct.generator.EvolInstructGenerator.process","title":"<code>process(offset=0)</code>","text":"<p>Processes the inputs of the task and generates the outputs using the LLM.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The offset to start the generation from. Defaults to 0.</p> <code>0</code> <p>Yields:</p> Type Description <code>GeneratorStepOutput</code> <p>A list of Python dictionaries with the outputs of the task, and a boolean</p> <code>GeneratorStepOutput</code> <p>flag indicating whether the task has finished or not i.e. is the last batch.</p> Source code in <code>src/distilabel/steps/tasks/evol_instruct/generator.py</code> <pre><code>@override\ndef process(self, offset: int = 0) -&gt; \"GeneratorStepOutput\":  # type: ignore\n    \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n    Args:\n        offset: The offset to start the generation from. Defaults to 0.\n\n    Yields:\n        A list of Python dictionaries with the outputs of the task, and a boolean\n        flag indicating whether the task has finished or not i.e. is the last batch.\n    \"\"\"\n    instructions = []\n    mutation_no = 0\n\n    iter_no = 0\n    while len(instructions) &lt; self.num_instructions:\n        prompts = self._apply_random_mutation(iter_no=iter_no)\n\n        generated_prompts = flatten_responses(\n            self.llm.generate(prompts, **self.llm.generation_kwargs)  # type: ignore\n        )\n        for idx, generated_prompt in enumerate(generated_prompts):\n            generated_prompt = generated_prompt.split(\"Prompt#:\")[-1].strip()\n            if self.max_length &gt;= len(generated_prompt) &gt;= self.min_length:  # type: ignore\n                instructions.append(generated_prompt)\n                self._prompts[idx] = np.random.choice(self._seed_texts)  # type: ignore\n            else:\n                self._prompts[idx] = generated_prompt  # type: ignore\n\n        self._logger.info(\n            f\"\ud83d\udd04 Ran iteration {iter_no} with {len(instructions)} instructions already evolved!\"\n        )\n        iter_no += 1\n\n        if len(instructions) &gt; self.num_instructions:\n            instructions = instructions[: self.num_instructions]\n        if len(instructions) &gt; mutation_no:\n            mutation_no = len(instructions) - mutation_no\n\n        if not self.generate_answers and len(instructions[-mutation_no:]) &gt; 0:\n            yield (\n                [\n                    self.format_output(mutated_instruction)\n                    for mutated_instruction in instructions[-mutation_no:]\n                ],\n                len(instructions) &gt;= self.num_instructions,\n            )\n\n    self._logger.info(f\"\ud83c\udf89 Finished evolving {len(instructions)} instructions!\")\n\n    if self.generate_answers:\n        self._logger.info(\n            f\"\ud83e\udde0 Generating answers for the {len(instructions)} evolved instructions!\"\n        )\n\n        answers = self._generate_answers(instructions)\n\n        self._logger.info(\n            f\"\ud83c\udf89 Finished generating answers for the {len(instructions)} evolved instructions!\"\n        )\n\n        yield (\n            [\n                self.format_output(instruction, answer)\n                for instruction, answer in zip(instructions, answers)\n            ],\n            True,\n        )\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/evol_instruct/utils/","title":"Utils","text":""},{"location":"reference/distilabel/steps/tasks/evol_instruct/evol_complexity/","title":"Index","text":""},{"location":"reference/distilabel/steps/tasks/evol_instruct/evol_complexity/base/","title":"Base","text":""},{"location":"reference/distilabel/steps/tasks/evol_instruct/evol_complexity/base/#distilabel.steps.tasks.evol_instruct.evol_complexity.base.EvolComplexity","title":"<code>EvolComplexity</code>","text":"<p>             Bases: <code>EvolInstruct</code></p> <p>EvolComplexity is a task that evolves instructions to make them more complex, and it is based in the EvolInstruct task, but using slight different prompts, but the exact same evolutionary approach.</p> <p>Attributes:</p> Name Type Description <code>num_instructions</code> <p>The number of instructions to be generated.</p> <code>generate_answers</code> <p>Whether to generate answers for the instructions or not. Defaults to <code>False</code>.</p> <code>mutation_templates</code> <code>Dict[str, str]</code> <p>The mutation templates to be used for the generation of the instructions.</p> <code>min_length</code> <code>Dict[str, str]</code> <p>Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid. Defaults to <code>512</code>.</p> <code>max_length</code> <code>Dict[str, str]</code> <p>Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid. Defaults to <code>1024</code>.</p> <code>seed</code> <code>Dict[str, str]</code> <p>The seed to be set for <code>numpy</code> in order to randomly pick a mutation method. Defaults to <code>42</code>.</p> Runtime parameters <ul> <li><code>min_length</code>: Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid.</li> <li><code>max_length</code>: Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid.</li> <li><code>seed</code>: The number of evolutions to be run.</li> </ul> Input columns <ul> <li>instruction (<code>str</code>): The instruction to evolve.</li> </ul> Output columns <ul> <li>evolved_instruction (<code>str</code>): The evolved instruction.</li> <li>answer (<code>str</code>, optional): The answer to the instruction if <code>generate_answers=True</code>.</li> <li>model_name (<code>str</code>): The name of the LLM used to evolve the instructions.</li> </ul> References <ul> <li>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</li> <li>WizardLM: Empowering Large Language Models to Follow Complex Instructions</li> </ul> Source code in <code>src/distilabel/steps/tasks/evol_instruct/evol_complexity/base.py</code> <pre><code>class EvolComplexity(EvolInstruct):\n    \"\"\"EvolComplexity is a task that evolves instructions to make them more complex,\n    and it is based in the EvolInstruct task, but using slight different prompts, but the\n    exact same evolutionary approach.\n\n    Attributes:\n        num_instructions: The number of instructions to be generated.\n        generate_answers: Whether to generate answers for the instructions or not. Defaults\n            to `False`.\n        mutation_templates: The mutation templates to be used for the generation of the\n            instructions.\n        min_length: Defines the length (in bytes) that the generated instruction needs to\n            be higher than, to be considered valid. Defaults to `512`.\n        max_length: Defines the length (in bytes) that the generated instruction needs to\n            be lower than, to be considered valid. Defaults to `1024`.\n        seed: The seed to be set for `numpy` in order to randomly pick a mutation method.\n            Defaults to `42`.\n\n    Runtime parameters:\n        - `min_length`: Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid.\n        - `max_length`: Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid.\n        - `seed`: The number of evolutions to be run.\n\n    Input columns:\n        - instruction (`str`): The instruction to evolve.\n\n    Output columns:\n        - evolved_instruction (`str`): The evolved instruction.\n        - answer (`str`, optional): The answer to the instruction if `generate_answers=True`.\n        - model_name (`str`): The name of the LLM used to evolve the instructions.\n\n    References:\n        - [What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning](https://arxiv.org/abs/2312.15685)\n        - [WizardLM: Empowering Large Language Models to Follow Complex Instructions](https://arxiv.org/abs/2304.12244)\n    \"\"\"\n\n    mutation_templates: Dict[str, str] = MUTATION_TEMPLATES\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/evol_instruct/evol_complexity/generator/","title":"Generator","text":""},{"location":"reference/distilabel/steps/tasks/evol_instruct/evol_complexity/generator/#distilabel.steps.tasks.evol_instruct.evol_complexity.generator.EvolComplexityGenerator","title":"<code>EvolComplexityGenerator</code>","text":"<p>             Bases: <code>EvolInstructGenerator</code></p> <p>EvolComplexity is a task that evolves instructions to make them more complex, and it is based in the EvolInstruct task, but using slight different prompts, but the exact same evolutionary approach.</p> <p>Attributes:</p> Name Type Description <code>num_instructions</code> <p>The number of instructions to be generated.</p> <code>generate_answers</code> <p>Whether to generate answers for the instructions or not. Defaults to <code>False</code>.</p> <code>mutation_templates</code> <code>Dict[str, str]</code> <p>The mutation templates to be used for the generation of the instructions.</p> <code>min_length</code> <code>Dict[str, str]</code> <p>Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid. Defaults to <code>512</code>.</p> <code>max_length</code> <code>Dict[str, str]</code> <p>Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid. Defaults to <code>1024</code>.</p> <code>seed</code> <code>Dict[str, str]</code> <p>The seed to be set for <code>numpy</code> in order to randomly pick a mutation method. Defaults to <code>42</code>.</p> Runtime parameters <ul> <li><code>min_length</code>: Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid.</li> <li><code>max_length</code>: Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid.</li> <li><code>seed</code>: The number of evolutions to be run.</li> </ul> Input columns <ul> <li>instruction (<code>str</code>): The instruction to evolve.</li> </ul> Output columns <ul> <li>instruction (<code>str</code>): The evolved instruction.</li> <li>answer (<code>str</code>, optional): The answer to the instruction if <code>generate_answers=True</code>.</li> <li>model_name (<code>str</code>): The name of the LLM used to evolve the instructions.</li> </ul> References <ul> <li>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</li> <li>WizardLM: Empowering Large Language Models to Follow Complex Instructions</li> </ul> Source code in <code>src/distilabel/steps/tasks/evol_instruct/evol_complexity/generator.py</code> <pre><code>class EvolComplexityGenerator(EvolInstructGenerator):\n    \"\"\"EvolComplexity is a task that evolves instructions to make them more complex,\n    and it is based in the EvolInstruct task, but using slight different prompts, but the\n    exact same evolutionary approach.\n\n    Attributes:\n        num_instructions: The number of instructions to be generated.\n        generate_answers: Whether to generate answers for the instructions or not. Defaults\n            to `False`.\n        mutation_templates: The mutation templates to be used for the generation of the\n            instructions.\n        min_length: Defines the length (in bytes) that the generated instruction needs to\n            be higher than, to be considered valid. Defaults to `512`.\n        max_length: Defines the length (in bytes) that the generated instruction needs to\n            be lower than, to be considered valid. Defaults to `1024`.\n        seed: The seed to be set for `numpy` in order to randomly pick a mutation method.\n            Defaults to `42`.\n\n    Runtime parameters:\n        - `min_length`: Defines the length (in bytes) that the generated instruction needs to be higher than, to be considered valid.\n        - `max_length`: Defines the length (in bytes) that the generated instruction needs to be lower than, to be considered valid.\n        - `seed`: The number of evolutions to be run.\n\n    Input columns:\n        - instruction (`str`): The instruction to evolve.\n\n    Output columns:\n        - instruction (`str`): The evolved instruction.\n        - answer (`str`, optional): The answer to the instruction if `generate_answers=True`.\n        - model_name (`str`): The name of the LLM used to evolve the instructions.\n\n    References:\n        - [What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning](https://arxiv.org/abs/2312.15685)\n        - [WizardLM: Empowering Large Language Models to Follow Complex Instructions](https://arxiv.org/abs/2304.12244)\n    \"\"\"\n\n    mutation_templates: Dict[str, str] = GENERATION_MUTATION_TEMPLATES\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/evol_instruct/evol_complexity/utils/","title":"Utils","text":""},{"location":"reference/distilabel/steps/tasks/evol_quality/","title":"Index","text":""},{"location":"reference/distilabel/steps/tasks/evol_quality/base/","title":"Base","text":""},{"location":"reference/distilabel/steps/tasks/evol_quality/base/#distilabel.steps.tasks.evol_quality.base.EvolQuality","title":"<code>EvolQuality</code>","text":"<p>             Bases: <code>Task</code></p> <p>The <code>EvolQuality</code> task is used to evolve the quality of the responses given a prompt, by generating a new response with a language model. This step implements the evolution quality task from the paper 'What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning'.</p> <p>Attributes:</p> Name Type Description <code>num_evolutions</code> <code>int</code> <p>The number of evolutions to be performed on the responses.</p> <code>store_evolutions</code> <code>bool</code> <p>Whether to store all the evolved responses or just the last one. Defaults to <code>False</code>.</p> <code>include_original_response</code> <code>bool</code> <p>Whether to include the original response within the evolved responses. Defaults to <code>False</code>.</p> <code>mutation_templates</code> <code>Dict[str, str]</code> <p>The mutation templates to be used to evolve the responses.</p> <code>seed</code> <code>RuntimeParameter[int]</code> <p>The seed to be set for <code>numpy</code> in order to randomly pick a mutation method. Defaults to <code>42</code>.</p> Runtime parameters <ul> <li><code>seed</code>: The seed to be set for <code>numpy</code> in order to randomly pick a mutation method.</li> </ul> Input columns <ul> <li>instruction (<code>str</code>): The instruction that was used to generate the <code>responses</code>.</li> <li>responses (<code>List[str]</code>): The responses to be scored. Each response forms a pair with the instruction.</li> </ul> Output columns <ul> <li>evolved_response (<code>str</code>): The evolved response if <code>store_evolutions=False</code>.</li> <li>evolved_responses (<code>List[str]</code>): The evolved responses if <code>store_evolutions=True</code>.</li> <li>model_name (<code>str</code>): The name of the LLM used to evolve the responses.</li> </ul> References <ul> <li><code>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</code></li> </ul> Source code in <code>src/distilabel/steps/tasks/evol_quality/base.py</code> <pre><code>class EvolQuality(Task):\n    \"\"\"The `EvolQuality` task is used to evolve the quality of the responses given a prompt,\n    by generating a new response with a language model. This step implements the evolution\n    quality task from the paper 'What Makes Good Data for Alignment? A Comprehensive Study of\n    Automatic Data Selection in Instruction Tuning'.\n\n    Attributes:\n        num_evolutions: The number of evolutions to be performed on the responses.\n        store_evolutions: Whether to store all the evolved responses or just the last one.\n            Defaults to `False`.\n        include_original_response: Whether to include the original response within the evolved\n            responses. Defaults to `False`.\n        mutation_templates: The mutation templates to be used to evolve the responses.\n        seed: The seed to be set for `numpy` in order to randomly pick a mutation method.\n            Defaults to `42`.\n\n    Runtime parameters:\n        - `seed`: The seed to be set for `numpy` in order to randomly pick a mutation method.\n\n    Input columns:\n        - instruction (`str`): The instruction that was used to generate the `responses`.\n        - responses (`List[str]`): The responses to be scored. Each response forms a pair with the instruction.\n\n    Output columns:\n        - evolved_response (`str`): The evolved response if `store_evolutions=False`.\n        - evolved_responses (`List[str]`): The evolved responses if `store_evolutions=True`.\n        - model_name (`str`): The name of the LLM used to evolve the responses.\n\n    References:\n        - [`What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning`](https://arxiv.org/abs/2312.15685)\n    \"\"\"\n\n    num_evolutions: int\n    store_evolutions: bool = False\n    include_original_response: bool = False\n    mutation_templates: Dict[str, str] = MUTATION_TEMPLATES\n\n    seed: RuntimeParameter[int] = Field(\n        default=42,\n        description=\"As `numpy` is being used in order to randomly pick a mutation method, then is nice to set a random seed.\",\n    )\n\n    @override\n    def model_post_init(self, __context: Any) -&gt; None:\n        \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n        This is useful if you want to do some validation that requires the entire model to be initialized.\n        \"\"\"\n        super().model_post_init(__context)\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        \"\"\"The input for the task are the `instruction` and `response`.\"\"\"\n        return [\"instruction\", \"response\"]\n\n    def format_input(self, input: str) -&gt; ChatType:  # type: ignore\n        \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n        is the first interaction from the user within a conversation. And the\n        `system_prompt` is added as the first message if it exists.\"\"\"\n        return [{\"role\": \"user\", \"content\": input}]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        \"\"\"The output for the task are the `evolved_response/s` and the `model_name`.\"\"\"\n        # TODO: having to define a `model_name` column every time as the `Task.outputs` is not ideal,\n        # this could be handled always and the value could be included within the DAG validation when\n        # a `Task` is used, since all the `Task` subclasses will have an `llm` with a `model_name` attr.\n        _outputs = [\n            (\"evolved_response\" if not self.store_evolutions else \"evolved_responses\"),\n            \"model_name\",\n        ]\n\n        return _outputs\n\n    def format_output(self, responses: Union[str, List[str]]) -&gt; Dict[str, Any]:  # type: ignore\n        \"\"\"The output for the task is a dict with: `evolved_response` or `evolved_responses`,\n        depending whether the value is either `False` or `True` for `store_evolutions`, respectively;\n        and, finally, the `model_name`.\n\n        Args:\n            responses: The responses to be included within the output.\n\n        Returns:\n            if `store_evolutions=False` return {\"evolved_response\": ..., \"model_name\": ...};\n            if `store_evolutions=True` return {\"evolved_responses\": ..., \"model_name\": ...}.\n        \"\"\"\n        _output = {}\n\n        if not self.store_evolutions:\n            _output[\"evolved_response\"] = responses[-1]\n        else:\n            _output[\"evolved_responses\"] = responses\n\n        _output[\"model_name\"] = self.llm.model_name\n        return _output\n\n    @property\n    def mutation_templates_names(self) -&gt; List[str]:\n        \"\"\"Returns the names i.e. keys of the provided `mutation_templates` enum.\"\"\"\n        return list(self.mutation_templates.keys())\n\n    def _apply_random_mutation(self, instruction: str, response: str) -&gt; str:\n        \"\"\"Applies a random mutation from the ones provided as part of the `mutation_templates`\n        enum, and returns the provided instruction within the mutation prompt.\n\n        Args:\n            instruction: The instruction to be included within the mutation prompt.\n\n        Returns:\n            A random mutation prompt with the provided instruction.\n        \"\"\"\n        mutation = np.random.choice(self.mutation_templates_names)\n        return (\n            self.mutation_templates[mutation]\n            .replace(\"&lt;PROMPT&gt;\", instruction)\n            .replace(\"&lt;RESPONSE&gt;\", response[-1])\n        )\n\n    def _evolve_reponses(self, inputs: \"StepInput\") -&gt; List[List[str]]:\n        \"\"\"Evolves the instructions provided as part of the inputs of the task.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Returns:\n            A list where each item is a list with either the last evolved instruction if\n            `store_evolutions=False` or all the evolved instructions if `store_evolutions=True`.\n        \"\"\"\n        np.random.seed(self.seed)\n        instructions: List[List[str]] = [[input[\"instruction\"]] for input in inputs]\n        responses: List[List[str]] = [[input[\"response\"]] for input in inputs]\n\n        for iter_no in range(self.num_evolutions):\n            formatted_prompts = []\n            for instruction, response in zip(instructions, responses):\n                formatted_prompts.append(\n                    self._apply_random_mutation(instruction[-1], response[-1])\n                )\n\n            formatted_prompts = [\n                self.format_input(prompt) for prompt in formatted_prompts\n            ]\n\n            generated_responses = self.llm.generate(\n                formatted_prompts,\n                **self.llm.generation_kwargs,  # type: ignore\n            )\n\n            if self.store_evolutions:\n                responses = [\n                    response + [evolved_response[0]]\n                    for response, evolved_response in zip(\n                        responses, generated_responses\n                    )\n                ]\n            else:\n                responses = [\n                    [evolved_response[0]] for evolved_response in generated_responses\n                ]\n\n            self._logger.info(\n                f\"\ud83d\udd04 Ran iteration {iter_no} evolving {len(responses)} responses!\"\n            )\n\n        return responses\n\n    @override\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n        \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n        Args:\n            inputs: A list of Python dictionaries with the inputs of the task.\n\n        Returns:\n            A list of Python dictionaries with the outputs of the task.\n        \"\"\"\n\n        responses = self._evolve_reponses(inputs)\n\n        if self.store_evolutions:\n            # Remove the input instruction from the `evolved_responses` list\n            from_ = 1 if not self.include_original_response else 0\n            responses = [response[from_:] for response in responses]\n\n        for input, response in zip(inputs, responses):\n            input.update(self.format_output(response))\n        yield inputs\n\n        self._logger.info(f\"\ud83c\udf89 Finished evolving {len(responses)} instructions!\")\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/evol_quality/base/#distilabel.steps.tasks.evol_quality.base.EvolQuality.inputs","title":"<code>inputs: List[str]</code>  <code>property</code>","text":"<p>The input for the task are the <code>instruction</code> and <code>response</code>.</p>"},{"location":"reference/distilabel/steps/tasks/evol_quality/base/#distilabel.steps.tasks.evol_quality.base.EvolQuality.mutation_templates_names","title":"<code>mutation_templates_names: List[str]</code>  <code>property</code>","text":"<p>Returns the names i.e. keys of the provided <code>mutation_templates</code> enum.</p>"},{"location":"reference/distilabel/steps/tasks/evol_quality/base/#distilabel.steps.tasks.evol_quality.base.EvolQuality.outputs","title":"<code>outputs: List[str]</code>  <code>property</code>","text":"<p>The output for the task are the <code>evolved_response/s</code> and the <code>model_name</code>.</p>"},{"location":"reference/distilabel/steps/tasks/evol_quality/base/#distilabel.steps.tasks.evol_quality.base.EvolQuality.format_input","title":"<code>format_input(input)</code>","text":"<p>The input is formatted as a <code>ChatType</code> assuming that the instruction is the first interaction from the user within a conversation. And the <code>system_prompt</code> is added as the first message if it exists.</p> Source code in <code>src/distilabel/steps/tasks/evol_quality/base.py</code> <pre><code>def format_input(self, input: str) -&gt; ChatType:  # type: ignore\n    \"\"\"The input is formatted as a `ChatType` assuming that the instruction\n    is the first interaction from the user within a conversation. And the\n    `system_prompt` is added as the first message if it exists.\"\"\"\n    return [{\"role\": \"user\", \"content\": input}]\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/evol_quality/base/#distilabel.steps.tasks.evol_quality.base.EvolQuality.format_output","title":"<code>format_output(responses)</code>","text":"<p>The output for the task is a dict with: <code>evolved_response</code> or <code>evolved_responses</code>, depending whether the value is either <code>False</code> or <code>True</code> for <code>store_evolutions</code>, respectively; and, finally, the <code>model_name</code>.</p> <p>Parameters:</p> Name Type Description Default <code>responses</code> <code>Union[str, List[str]]</code> <p>The responses to be included within the output.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>if <code>store_evolutions=False</code> return {\"evolved_response\": ..., \"model_name\": ...};</p> <code>Dict[str, Any]</code> <p>if <code>store_evolutions=True</code> return {\"evolved_responses\": ..., \"model_name\": ...}.</p> Source code in <code>src/distilabel/steps/tasks/evol_quality/base.py</code> <pre><code>def format_output(self, responses: Union[str, List[str]]) -&gt; Dict[str, Any]:  # type: ignore\n    \"\"\"The output for the task is a dict with: `evolved_response` or `evolved_responses`,\n    depending whether the value is either `False` or `True` for `store_evolutions`, respectively;\n    and, finally, the `model_name`.\n\n    Args:\n        responses: The responses to be included within the output.\n\n    Returns:\n        if `store_evolutions=False` return {\"evolved_response\": ..., \"model_name\": ...};\n        if `store_evolutions=True` return {\"evolved_responses\": ..., \"model_name\": ...}.\n    \"\"\"\n    _output = {}\n\n    if not self.store_evolutions:\n        _output[\"evolved_response\"] = responses[-1]\n    else:\n        _output[\"evolved_responses\"] = responses\n\n    _output[\"model_name\"] = self.llm.model_name\n    return _output\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/evol_quality/base/#distilabel.steps.tasks.evol_quality.base.EvolQuality.model_post_init","title":"<code>model_post_init(__context)</code>","text":"<p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> Source code in <code>src/distilabel/steps/tasks/evol_quality/base.py</code> <pre><code>@override\ndef model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n    super().model_post_init(__context)\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/evol_quality/base/#distilabel.steps.tasks.evol_quality.base.EvolQuality.process","title":"<code>process(inputs)</code>","text":"<p>Processes the inputs of the task and generates the outputs using the LLM.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>StepInput</code> <p>A list of Python dictionaries with the inputs of the task.</p> required <p>Returns:</p> Type Description <code>StepOutput</code> <p>A list of Python dictionaries with the outputs of the task.</p> Source code in <code>src/distilabel/steps/tasks/evol_quality/base.py</code> <pre><code>@override\ndef process(self, inputs: StepInput) -&gt; \"StepOutput\":  # type: ignore\n    \"\"\"Processes the inputs of the task and generates the outputs using the LLM.\n\n    Args:\n        inputs: A list of Python dictionaries with the inputs of the task.\n\n    Returns:\n        A list of Python dictionaries with the outputs of the task.\n    \"\"\"\n\n    responses = self._evolve_reponses(inputs)\n\n    if self.store_evolutions:\n        # Remove the input instruction from the `evolved_responses` list\n        from_ = 1 if not self.include_original_response else 0\n        responses = [response[from_:] for response in responses]\n\n    for input, response in zip(inputs, responses):\n        input.update(self.format_output(response))\n    yield inputs\n\n    self._logger.info(f\"\ud83c\udf89 Finished evolving {len(responses)} instructions!\")\n</code></pre>"},{"location":"reference/distilabel/steps/tasks/evol_quality/utils/","title":"Utils","text":""},{"location":"reference/distilabel/utils/","title":"Index","text":""},{"location":"reference/distilabel/utils/chat/","title":"Chat","text":""},{"location":"reference/distilabel/utils/chat/#distilabel.utils.chat.is_openai_format","title":"<code>is_openai_format(input)</code>","text":"<p>Checks if the input is in OpenAI chat-like format:</p> <pre><code>[\n    {\"role\": \"user\", \"content\": \"Hello!\"},\n    {\"role\": \"assistant\", \"content\": \"Hi! How can I help you?\"},\n]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Any</code> <p>The input to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating if the input is in OpenAI chat-like format.</p> Source code in <code>src/distilabel/utils/chat.py</code> <pre><code>def is_openai_format(input: Any) -&gt; bool:\n    \"\"\"Checks if the input is in OpenAI chat-like format:\n\n    ```python\n    [\n        {\"role\": \"user\", \"content\": \"Hello!\"},\n        {\"role\": \"assistant\", \"content\": \"Hi! How can I help you?\"},\n    ]\n    ```\n\n    Args:\n        input: The input to check.\n\n    Returns:\n        A boolean indicating if the input is in OpenAI chat-like format.\n    \"\"\"\n    if not isinstance(input, list):\n        return False\n    return all(\n        isinstance(x, dict) and \"role\" in x.keys() and \"content\" in x.keys()\n        for x in input\n    )\n</code></pre>"},{"location":"reference/distilabel/utils/dicts/","title":"Dicts","text":""},{"location":"reference/distilabel/utils/dicts/#distilabel.utils.dicts.combine_dicts","title":"<code>combine_dicts(*dicts)</code>","text":"<p>Combines multiple dictionaries into a single dictionary joining the values as a list for each key.</p> <p>Parameters:</p> Name Type Description Default <code>*dicts</code> <code>Dict[_K, Any]</code> <p>the dictionaries to be combined.</p> <code>()</code> <p>Returns:</p> Type Description <code>Dict[_K, List[Any]]</code> <p>The combined dictionary.</p> Source code in <code>src/distilabel/utils/dicts.py</code> <pre><code>def combine_dicts(*dicts: Dict[_K, Any]) -&gt; Dict[_K, List[Any]]:\n    \"\"\"Combines multiple dictionaries into a single dictionary joining the values\n    as a list for each key.\n\n    Args:\n        *dicts: the dictionaries to be combined.\n\n    Returns:\n        The combined dictionary.\n    \"\"\"\n    combined_dict = defaultdict(list)\n    for d in dicts:\n        for key, value in d.items():\n            combined_dict[key].append(value)\n    return dict(combined_dict)\n</code></pre>"},{"location":"reference/distilabel/utils/docstring/","title":"Docstring","text":""},{"location":"reference/distilabel/utils/docstring/#distilabel.utils.docstring.parse_google_docstring","title":"<code>parse_google_docstring(func)</code>","text":"<p>Parses the Google-style docstring of the given function into a more structured format.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function whose docstring will be parsed.</p> required <p>Returns:</p> Type Description <code>Docstring</code> <p>A dictionary with keys 'description', 'args', 'returns', and 'raises',</p> <code>Docstring</code> <p>with 'args' and 'raises' being dictionaries themselves, mapping parameter</p> <code>Docstring</code> <p>and exception names to their descriptions, respectively.</p> Source code in <code>src/distilabel/utils/docstring.py</code> <pre><code>def parse_google_docstring(func: Callable) -&gt; Docstring:\n    \"\"\"Parses the Google-style docstring of the given function into a more structured format.\n\n    Parameters:\n        func: The function whose docstring will be parsed.\n\n    Returns:\n        A dictionary with keys 'description', 'args', 'returns', and 'raises',\n        with 'args' and 'raises' being dictionaries themselves, mapping parameter\n        and exception names to their descriptions, respectively.\n    \"\"\"\n    sections: Docstring = {\"description\": \"\", \"args\": {}, \"returns\": \"\", \"raises\": {}}\n\n    if not func.__doc__:\n        return sections\n\n    docstring = func.__doc__\n    sections = {\"description\": \"\", \"args\": {}, \"returns\": \"\", \"raises\": {}}\n\n    # Split the docstring into sections\n    parts = re.split(r\"\\n\\s*(Args|Returns|Raises):\\s*\\n\", docstring)\n\n    sections[\"description\"] = parts[0].strip()\n    for i in range(1, len(parts), 2):\n        section_name = parts[i].lower()\n        section_content = parts[i + 1].strip()\n        if section_name in (\"args\", \"raises\"):\n            # Parse arguments or exceptions into a dictionary\n            items = re.findall(\n                r\"\\s*(\\w+):\\s*(.*?)\\s*(?=\\n\\s*\\w+:|$)\", section_content, re.DOTALL\n            )\n            sections[section_name] = {\n                item[0]: re.sub(r\"[\\t\\n]+|[ ]{2,}\", \" \", item[1]).strip()\n                for item in items\n            }\n        else:\n            sections[section_name] = section_content\n\n    return sections\n</code></pre>"},{"location":"reference/distilabel/utils/files/","title":"Files","text":""},{"location":"reference/distilabel/utils/files/#distilabel.utils.files.list_files_in_dir","title":"<code>list_files_in_dir(dir_path)</code>","text":"<p>List all files in a directory.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>Path</code> <p>Path to the directory.</p> required <p>Returns:</p> Type Description <code>List[Path]</code> <p>A list of file names in the directory.</p> Source code in <code>src/distilabel/utils/files.py</code> <pre><code>def list_files_in_dir(dir_path: Path) -&gt; List[Path]:\n    \"\"\"List all files in a directory.\n\n    Args:\n        dir_path: Path to the directory.\n\n    Returns:\n        A list of file names in the directory.\n    \"\"\"\n    return [f for f in dir_path.iterdir() if f.is_file()]\n</code></pre>"},{"location":"reference/distilabel/utils/itertools/","title":"Itertools","text":""},{"location":"reference/distilabel/utils/itertools/#distilabel.utils.itertools.grouper","title":"<code>grouper(iterable, n, *, incomplete='fill', fillvalue=None)</code>","text":"<p>Collect data into non-overlapping fixed-length chunks or blocks.</p> Source code in <code>src/distilabel/utils/itertools.py</code> <pre><code>def grouper(\n    iterable: Iterable[Any],\n    n: int,\n    *,\n    incomplete: Literal[\"fill\", \"strict\", \"ignore\"] = \"fill\",\n    fillvalue: Any = None,\n) -&gt; Iterable[Any]:\n    \"Collect data into non-overlapping fixed-length chunks or blocks.\"\n    # grouper('ABCDEFG', 3, fillvalue='x') --&gt; ABC DEF Gxx\n    # grouper('ABCDEFG', 3, incomplete='strict') --&gt; ABC DEF ValueError\n    # grouper('ABCDEFG', 3, incomplete='ignore') --&gt; ABC DEF\n    args = [iter(iterable)] * n\n\n    if incomplete == \"fill\":\n        return zip_longest(*args, fillvalue=fillvalue)\n\n    if incomplete == \"strict\":\n        return zip(*args, strict=True)\n\n    if incomplete == \"ignore\":\n        return zip(*args)\n\n    raise ValueError(\"Expected fill, strict, or ignore\")\n</code></pre>"},{"location":"reference/distilabel/utils/lists/","title":"Lists","text":""},{"location":"reference/distilabel/utils/lists/#distilabel.utils.lists.flatten_responses","title":"<code>flatten_responses(responses)</code>","text":"<p>Flattens the list of lists of strings into a single list of strings.</p> <p>Parameters:</p> Name Type Description Default <code>responses</code> <code>List[List[str]]</code> <p>The list of lists of strings to flatten.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A single list of strings containing the last item of each list.</p> Source code in <code>src/distilabel/utils/lists.py</code> <pre><code>def flatten_responses(responses: List[List[str]]) -&gt; List[str]:\n    \"\"\"Flattens the list of lists of strings into a single list of strings.\n\n    Args:\n        responses: The list of lists of strings to flatten.\n\n    Returns:\n        A single list of strings containing the last item of each list.\n    \"\"\"\n    return [response[-1] for response in responses]\n</code></pre>"},{"location":"reference/distilabel/utils/logging/","title":"Logging","text":""},{"location":"reference/distilabel/utils/logging/#distilabel.utils.logging.setup_logging","title":"<code>setup_logging(log_queue)</code>","text":"<p>Sets up logging to use a queue across all processes.</p> Source code in <code>src/distilabel/utils/logging.py</code> <pre><code>def setup_logging(log_queue: \"Queue[Any]\") -&gt; None:\n    \"\"\"Sets up logging to use a queue across all processes.\"\"\"\n    global queue_listener\n\n    # Disable overly verbose loggers\n    logging.getLogger(\"argilla.client.feedback.dataset.local.mixins\").disabled = True\n    for logger in _SILENT_LOGGERS:\n        logging.getLogger(logger).setLevel(logging.CRITICAL)\n\n    # If the current process is the main process, set up a `QueueListener`\n    # to handle logs from all subprocesses\n    if mp.current_process().name == \"MainProcess\":\n        formatter = logging.Formatter(\"['%(name)s'] %(message)s\")\n        handler = RichHandler(rich_tracebacks=True)\n        handler.setFormatter(formatter)\n        queue_listener = QueueListener(log_queue, handler, respect_handler_level=True)\n        queue_listener.start()\n\n    log_level = os.environ.get(\"DISTILABEL_LOG_LEVEL\", \"INFO\").upper()\n    if log_level not in [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]:\n        warnings.warn(\n            f\"Invalid log level '{log_level}', using default 'INFO' instead.\",\n            stacklevel=2,\n        )\n        log_level = \"INFO\"\n\n    root_logger = logging.getLogger()\n    root_logger.handlers.clear()\n    root_logger.setLevel(log_level)\n    root_logger.addHandler(QueueHandler(log_queue))\n</code></pre>"},{"location":"reference/distilabel/utils/logging/#distilabel.utils.logging.stop_logging","title":"<code>stop_logging()</code>","text":"<p>Stops the <code>QueueListener</code> if it's running.</p> Source code in <code>src/distilabel/utils/logging.py</code> <pre><code>def stop_logging() -&gt; None:\n    \"\"\"Stops the `QueueListener` if it's running.\"\"\"\n    global queue_listener\n    if queue_listener is not None:\n        queue_listener.stop()\n        queue_listener = None\n</code></pre>"},{"location":"reference/distilabel/utils/notebook/","title":"Notebook","text":""},{"location":"reference/distilabel/utils/notebook/#distilabel.utils.notebook.in_notebook","title":"<code>in_notebook()</code>","text":"<p>Checks if the current code is being executed from a Jupyter Notebook. This is useful for better handling the <code>asyncio</code> events under <code>nest_asyncio</code>, as Jupyter Notebook runs a separate event loop.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the current code is being executed from a Jupyter Notebook.</p> References <ul> <li>https://stackoverflow.com/a/22424821</li> </ul> Source code in <code>src/distilabel/utils/notebook.py</code> <pre><code>def in_notebook() -&gt; bool:\n    \"\"\"Checks if the current code is being executed from a Jupyter Notebook.\n    This is useful for better handling the `asyncio` events under `nest_asyncio`,\n    as Jupyter Notebook runs a separate event loop.\n\n    Returns:\n        Whether the current code is being executed from a Jupyter Notebook.\n\n    References:\n        - https://stackoverflow.com/a/22424821\n    \"\"\"\n    try:\n        from IPython import get_ipython\n\n        if \"IPKernelApp\" not in get_ipython().config:  # pragma: no cover\n            return False\n    except ImportError:\n        return False\n    except AttributeError:\n        return False\n    return True\n</code></pre>"},{"location":"reference/distilabel/utils/serialization/","title":"Serialization","text":""},{"location":"reference/distilabel/utils/serialization/#distilabel.utils.serialization.load_from_dict","title":"<code>load_from_dict(class_)</code>","text":"<p>Creates an instance of a class from a dictionary containing the type info and the serialized data of the class.</p> <p>Parameters:</p> Name Type Description Default <code>class_</code> <code>Dict[str, Any]</code> <p>dictionary containing the type info and the serialized data of the class.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>An instance of the class with the data loaded from the dictionary.</p> Source code in <code>src/distilabel/utils/serialization.py</code> <pre><code>def load_from_dict(class_: Dict[str, Any]) -&gt; Any:\n    \"\"\"Creates an instance of a class from a dictionary containing the type info and the\n    serialized data of the class.\n\n    Args:\n        class_: dictionary containing the type info and the serialized data of the class.\n\n    Returns:\n        An instance of the class with the data loaded from the dictionary.\n    \"\"\"\n    type_info = class_.pop(TYPE_INFO_KEY)\n    if TYPE_INFO_KEY in type_info:\n        # There is a nested type_info, load the class recursively\n        type_info = load_from_dict(type_info)\n\n    cls = _get_class(type_info[\"module\"], type_info[\"name\"])\n\n    for k, v in class_.items():\n        if isinstance(v, dict) and \"_type\" in v and v[\"_type\"] == \"enum\":\n            class_[k] = Enum(v[\"_name\"], v[\"_values\"], type=eval(v[\"_enum_type\"]))\n\n    instance = cls(**class_)\n    return instance\n</code></pre>"},{"location":"reference/distilabel/utils/serialization/#distilabel.utils.serialization.read_json","title":"<code>read_json(filename)</code>","text":"<p>Reads a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>StrOrPath</code> <p>the path to the JSON file.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The data from the file.</p> Source code in <code>src/distilabel/utils/serialization.py</code> <pre><code>def read_json(filename: StrOrPath) -&gt; Any:\n    \"\"\"Reads a JSON file.\n\n    Args:\n        filename: the path to the JSON file.\n\n    Returns:\n        The data from the file.\n    \"\"\"\n    with open(filename, \"r\") as file:\n        return json.load(file)\n</code></pre>"},{"location":"reference/distilabel/utils/serialization/#distilabel.utils.serialization.read_yaml","title":"<code>read_yaml(filename)</code>","text":"<p>Reads a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>StrOrPath</code> <p>the path to the YAML file.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The data from the file.</p> Source code in <code>src/distilabel/utils/serialization.py</code> <pre><code>def read_yaml(filename: StrOrPath) -&gt; Dict[str, Any]:\n    \"\"\"Reads a YAML file.\n\n    Args:\n        filename: the path to the YAML file.\n\n    Returns:\n        The data from the file.\n    \"\"\"\n    with open(filename, \"r\") as file:\n        return yaml.load(file, Loader=yaml.FullLoader)\n</code></pre>"},{"location":"reference/distilabel/utils/serialization/#distilabel.utils.serialization.write_json","title":"<code>write_json(filename, data)</code>","text":"<p>Writes a JSON file to the given path, creating the parent dir if needed.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>the path to the file.</p> required <code>data</code> <code>Any</code> <p>the data to write to the file.</p> required Source code in <code>src/distilabel/utils/serialization.py</code> <pre><code>def write_json(filename: Path, data: Any) -&gt; None:\n    \"\"\"Writes a JSON file to the given path, creating the parent dir if needed.\n\n    Args:\n        filename: the path to the file.\n        data: the data to write to the file.\n    \"\"\"\n    filename.parent.mkdir(parents=True, exist_ok=True)\n    with open(filename, \"w\") as file:\n        json.dump(data, file, indent=2)\n</code></pre>"},{"location":"reference/distilabel/utils/serialization/#distilabel.utils.serialization.write_yaml","title":"<code>write_yaml(filename, data)</code>","text":"<p>Writes a YAML file to the given path, creating the parent dir if needed.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>the path to the file.</p> required <code>data</code> <code>Dict[str, Any]</code> <p>the data to write to the file.</p> required Source code in <code>src/distilabel/utils/serialization.py</code> <pre><code>def write_yaml(filename: Path, data: Dict[str, Any]) -&gt; None:\n    \"\"\"Writes a YAML file to the given path, creating the parent dir if needed.\n\n    Args:\n        filename: the path to the file.\n        data: the data to write to the file.\n    \"\"\"\n    filename.parent.mkdir(parents=True, exist_ok=True)\n    with open(filename, \"w\") as file:\n        yaml.dump(data, file, default_flow_style=False, sort_keys=False)\n</code></pre>"},{"location":"reference/distilabel/utils/typing_/","title":"Typing","text":""},{"location":"reference/distilabel/utils/typing_/#distilabel.utils.typing_.is_parameter_annotated_with","title":"<code>is_parameter_annotated_with(parameter, annotation)</code>","text":"<p>Checks if a parameter type hint is <code>typing.Annotated</code> and in that case if it contains <code>annotation</code> as metadata.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>Parameter</code> <p>the parameter to check.</p> required <code>annotation</code> <code>Any</code> <p>the annotation to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the parameter type hint is <code>typing.Annotated</code> and contains <code>annotation</code></p> <code>bool</code> <p>as metadata, <code>False</code> otherwise.</p> Source code in <code>src/distilabel/utils/typing_.py</code> <pre><code>def is_parameter_annotated_with(parameter: inspect.Parameter, annotation: Any) -&gt; bool:\n    \"\"\"Checks if a parameter type hint is `typing.Annotated` and in that case if it contains\n    `annotation` as metadata.\n\n    Args:\n        parameter: the parameter to check.\n        annotation: the annotation to check.\n\n    Returns:\n        `True` if the parameter type hint is `typing.Annotated` and contains `annotation`\n        as metadata, `False` otherwise.\n    \"\"\"\n    if get_origin(parameter.annotation) is not Annotated:\n        return False\n\n    for metadata in get_args(parameter.annotation):\n        if metadata == annotation:\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/distilabel/utils/card/","title":"Index","text":""},{"location":"reference/distilabel/utils/card/dataset_card/","title":"Dataset card","text":""},{"location":"reference/distilabel/utils/card/dataset_card/#distilabel.utils.card.dataset_card.DistilabelDatasetCard","title":"<code>DistilabelDatasetCard</code>","text":"<p>             Bases: <code>DatasetCard</code></p> <p>A <code>DatasetCard</code> subclass that uses the Distilabel template by default.</p> Source code in <code>src/distilabel/utils/card/dataset_card.py</code> <pre><code>class DistilabelDatasetCard(DatasetCard):\n    \"\"\"A `DatasetCard` subclass that uses the Distilabel template by default.\"\"\"\n\n    default_template_path = TEMPLATE_DISTILABEL_DATASET_CARD_PATH\n</code></pre>"},{"location":"sections/learn/","title":"Learn","text":""},{"location":"sections/learn/#learn","title":"Learn","text":"<p><code>Distilabel</code> since version <code>1.0.0</code> works with a new concept of <code>Pipeline</code> made of <code>Steps</code>. These steps can be thought of as <code>Nodes</code> in a graph (a <code>Pipeline</code> in <code>distilabel</code> is mapped internally to a <code>Directed Acyclic Graph (DAG)</code>), and can be freely combined to generate synthetic and AI feedback datasets.</p> <p>This guide can be considered a tutorial, which will guide through the different components of <code>distilabel</code>.</p>"},{"location":"sections/learn/caching/","title":"Caching","text":"<p>Distilabel <code>Pipelines</code> automatically save all the intermediate steps to to avoid loosing any data in case of error.</p>"},{"location":"sections/learn/caching/#cache-directory","title":"Cache directory","text":"<p>Out of the box, the <code>Pipeline</code> will use the <code>~/.cache/distilabel/pipelines</code> directory to store the different pipelines:</p> <pre><code>from distilabel.pipeline.local import Pipeline\n\nwith Pipeline(\"cache_testing\") as pipeline:\n    ...\n</code></pre> <p>This directory can be modified by setting the <code>DISTILABEL_CACHE_DIR</code> environment variable (<code>export DISTILABEL_CACHE_DIR=my_cache_dir</code>) or by explicitely passing the <code>cache_dir</code> variable to the <code>Pipeline</code> constructor like so:</p> <pre><code>with Pipeline(\"cache_testing\", cache_dir=\"~/my_cache_dir\") as pipeline:\n    ...\n</code></pre>"},{"location":"sections/learn/caching/#how-does-it-work","title":"How does it work?","text":"<p>Let's take a look at the logging messages from a sample pipeline.</p> <p>When we run a <code>Pipeline</code> for the first time</p> <p></p> <p>If we decide to stop the pipeline (say we kill the run altogether via <code>CTRL + C</code> or <code>CMD + C</code> in macOS), we will see the signal sent to the different workers:</p> <p></p> <p>After this step, when we run again the pipeline, the first log message we see corresponds to \"Load pipeline from cache\", which will restart processing from where it stopped:</p> <p></p> <p>Finally, if we decide to run the same <code>Pipeline</code> after it has finished completely, it won't start again but resume the process, as we already have all the data processed:</p> <p></p>"},{"location":"sections/learn/caching/#serialization","title":"Serialization","text":"<p>Let's see what get's serialized by looking at a sample <code>Pipeline</code>'s cached folder:</p> <pre><code>$ tree ~/.cache/distilabel/pipelines/73ca3f6b7a613fb9694db7631cc038d379f1f533\n\u251c\u2500\u2500 batch_manager.json\n\u251c\u2500\u2500 batch_manager_steps\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 generate_response.json\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 rename_columns.json\n\u251c\u2500\u2500 data\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 generate_response\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 00001.parquet\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 00002.parquet\n\u2514\u2500\u2500 pipeline.yaml\n</code></pre> <p>The <code>Pipeline</code> will have a signature created from the arguments that define it so we can find it afterwards, and the contents are the following:</p> <ul> <li> <p><code>batch_manager.json</code></p> <p>Folder that stores the content of the internal batch manager to keep track of the data. Along with the <code>batch_manager_steps/</code> they store the information to restart the <code>Pipeline</code>. One shouldn't need to know about it.</p> </li> <li> <p><code>pipeline.yaml</code></p> <p>This file contains a representation of the <code>Pipeline</code> in YAML format. If we push a <code>Distiset</code> to the hub as obtained from calling <code>Pipeline.run</code>, this file will be stored at our datasets' repository, allowing to reproduce the <code>Pipeline</code> using the <code>CLI</code>:</p> <pre><code>distilabel pipeline run --config \"path/to/pipeline.yaml\"\n</code></pre> </li> <li> <p><code>data/</code></p> <p>Folder that stores the data generated, with a special folder to keep track of each <code>leaf_step</code> separately. We can recreate a <code>Distiset</code> from the contents of this folder (Parquet files), as we will see next.</p> </li> </ul> <p>In case we wanted to regenerate the dataset from the <code>cache</code> folder for whatever reason, we can do it using the <code>create_distiset</code> and passing the path to the <code>/data</code> folder inside our <code>Pipeline</code>:</p> <pre><code>from pathlib import Path\nfrom distilabel.distiset import create_distiset\n\npath = Path(\"~/.cache/distilabel/pipelines/73ca3f6b7a613fb9694db7631cc038d379f1f533/data\")\nds = create_distiset(path)\nds\n# Distiset({\n#     generate_response: DatasetDict({\n#         train: Dataset({\n#             features: ['instruction', 'response'],\n#             num_rows: 80\n#         })\n#     })\n# })\n</code></pre>"},{"location":"sections/learn/cli/","title":"Command Line Interface","text":"<p><code>Distilabel</code> offers a <code>CLI</code> to initially explore and rerun <code>Pipelines</code>, let's take a look.</p>"},{"location":"sections/learn/cli/#available-commands","title":"Available commands","text":"<p>We have two commands under the <code>CLI</code> app, <code>distilabel pipeline</code>:</p> <pre><code>$ distilabel pipeline --help\n\n Usage: distilabel pipeline [OPTIONS] COMMAND [ARGS]...\n\n Commands to run and inspect Distilabel pipelines.\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help          Show this message and exit.                                             \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 info      Get information about a Distilabel pipeline.                                  \u2502\n\u2502 run       Run a Distilabel pipeline.                                                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Will run them using as an example the following dataset for testing purposes:</p>"},{"location":"sections/learn/cli/#pipeline-info","title":"Pipeline info","text":"<p>The first command is <code>distilabel pipeline info</code>:</p> <pre><code>$ distilabel pipeline info --help\n\n Usage: distilabel pipeline info [OPTIONS]\n\n Get information about a Distilabel pipeline.\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --config        TEXT  Path or URL to the Distilabel pipeline configuration file. \u2502\n\u2502                          [default: None]                                            \u2502\n\u2502                          [required]                                                 \u2502\n\u2502    --help                Show this message and exit.                                \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>As we can see from the help message, we need to pass either a <code>Path</code> or a <code>URL</code>. This second option comes handy for datasets stored in HuggingFace hub, for example:</p> <pre><code>distilabel pipeline info --config \"https://huggingface.co/datasets/distilabel-internal-testing/ultrafeedback-mini/raw/main/pipeline.yaml\"\n</code></pre> <p>If we take a look (this <code>Pipeline</code> is a bit long, so the following captures are shortened for brevity):</p> <p></p> <p></p> <p>The pipeline information includes the steps used in the <code>Pipeline</code> along with the <code>Runtime Parameter</code> that was used, as well as a description of each of them, and also the connections between these steps. These can be helpful to explore the Pipeline locally.</p>"},{"location":"sections/learn/cli/#running-a-pipeline","title":"Running a Pipeline","text":"<p>We can also run a <code>Pipeline</code> from the CLI just pointing to the same <code>pipeline.yaml</code> file or an URL pointing to it and calling <code>distilabel pipeline run</code>:</p> <pre><code>$ distilabel pipeline run --help\n\n Usage: distilabel pipeline run [OPTIONS]\n\n Run a Distilabel pipeline.\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --config                                 TEXT                 Path or URL to the Distilabel pipeline configuration file.   \u2502\n\u2502                                                                  [default: None]                                              \u2502\n\u2502                                                                  [required]                                                   \u2502\n\u2502    --param                                  PARSE_RUNTIME_PARAM  [default: (dynamic)]                                         \u2502\n\u2502    --ignore-cache      --no-ignore-cache                         Whether to ignore the cache and re-run the pipeline from     \u2502\n\u2502                                                                  scratch.                                                     \u2502\n\u2502                                                                  [default: no-ignore-cache]                                   \u2502\n\u2502    --repo-id                                TEXT                 The Hugging Face Hub repository ID to push the resulting     \u2502\n\u2502                                                                  dataset to.                                                  \u2502\n\u2502                                                                  [default: None]                                              \u2502\n\u2502    --commit-message                         TEXT                 The commit message to use when pushing the dataset.          \u2502\n\u2502                                                                  [default: None]                                              \u2502\n\u2502    --private           --no-private                              Whether to make the resulting dataset private on the Hub.    \u2502\n\u2502                                                                  [default: no-private]                                        \u2502\n\u2502    --token                                  TEXT                 The Hugging Face Hub API token to use when pushing the       \u2502\n\u2502                                                                  dataset.                                                     \u2502\n\u2502                                                                  [default: None]                                              \u2502\n\u2502    --help                                                        Show this message and exit.                                  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>To specify the runtime parameters of the steps we will need to use the <code>--param</code> option and the value of the parameter in the following format:</p> <pre><code>distilabel pipeline run --config \"https://huggingface.co/datasets/distilabel-internal-testing/ultrafeedback-mini/raw/main/pipeline.yaml\" \\\n  --param load_dataset.repo_id=HuggingFaceH4/instruction-dataset \\\n  --param load_dataset.split=test \\\n  --param text_generation_with_notus.generation_kwargs.max_new_tokens=512 \\\n  --param text_generation_with_notus.generation_kwargs.temperature=0.7 \\\n  --param text_generation_with_zephyr.generation_kwargs.max_new_tokens=512 \\\n  --param text_generation_with_zephyr.generation_kwargs.temperature=0.7 \\\n  --param ultrafeedback_overall_rating.generation_kwargs.max_new_tokens=1024 \\\n  --param ultrafeedback_overall_rating.generation_kwargs.temperature=0.7\n</code></pre> <p>Again, this helps with the reproducibility of the results, and simplifies sharing not only the final dataset but also the process to generate it.</p>"},{"location":"sections/learn/distiset/","title":"Distiset","text":"<p>Distilabel pipelines return a special type of dataset: <code>Distiset</code>.</p> <p>This class is a wrapper around <code>datasets.Dataset</code> which comes with some extra functionality to easily deal with the dataset pieces that a <code>Pipeline</code> can generate.</p> <pre><code>from distilabel.distiset import Distiset\nfrom datasets import Dataset\n\nds = Distiset(\n    {\n        \"leaf_step_1\": Dataset.from_dict({\"instruction\": [1, 2, 3]}),\n        \"leaf_step_2\": Dataset.from_dict(\n            {\"instruction\": [1, 2, 3, 4], \"generation\": [5, 6, 7, 8]}\n        ),\n    }\n)\n</code></pre> <p>This object works like a python dictionary (the same approach followed by <code>datasets.DatasetDict</code>), where each key corresponds to one of the <code>leaf_steps</code> from a <code>Pipeline</code>.</p>"},{"location":"sections/learn/distiset/#distiset-methods","title":"Distiset methods","text":"<p>We can interact with the different pieces generated by the <code>Pipeline</code> and treat them as different <code>configurations</code>. The <code>Distiset</code> contains just two methods:</p>"},{"location":"sections/learn/distiset/#traintest-split","title":"Train/Test split","text":"<p>Which easily does the train/test split partition of the dataset for the different configurations or subsets.</p> <pre><code>&gt;&gt;&gt; ds.train_test_split(train_size=0.9)\nDistiset({\n    leaf_step_1: DatasetDict({\n        train: Dataset({\n            features: ['instruction'],\n            num_rows: 2\n        })\n        test: Dataset({\n            features: ['instruction'],\n            num_rows: 1\n        })\n    })\n    leaf_step_2: DatasetDict({\n        train: Dataset({\n            features: ['instruction', 'generation'],\n            num_rows: 3\n        })\n        test: Dataset({\n            features: ['instruction', 'generation'],\n            num_rows: 1\n        })\n    })\n})\n</code></pre>"},{"location":"sections/learn/distiset/#push-to-huggingface-hub","title":"Push to HuggingFace hub","text":"<p>Pushes the internal subsets to a huggingface repo, where each one of the subsets will be a different configuration, so it's easy to download them and continue working with any of the pieces.</p> <pre><code>ds.push_to_hub(\n    \"my_org/dataset\",\n    commit_message=\"My first Distiset\",\n    private=False,\n    token=os.getenv(\"HF_API_TOKEN\"),\n)\n</code></pre>"},{"location":"sections/learn/distiset/#dataset-card","title":"Dataset card","text":"<p>Having this special type of dataset comes with an added advantage. When calling <code>Distiset.push_to_hub</code>:</p> <pre><code>ds.push_to_hub(\"my_org/dataset\", generate_card=True)\n</code></pre> <p>We will have an automatic dataset card (an example can be seen here) with some handy information like reproducing the <code>Pipeline</code> with the <code>CLI</code>, or examples of the records from the different subsets.</p>"},{"location":"sections/learn/llms/","title":"LLMs","text":"<p>The LLMs are implemented as subclasses of either <code>LLM</code> or <code>AsyncLLM</code>, and are only in charge of running the text generation for a given prompt or conversation. The LLMs are intended to be used together with the <code>Task</code> and any of its subclasses, via the <code>llm</code> argument, this means that any of the implemented LLMs can be easily plugged seamlessly into any task.</p>"},{"location":"sections/learn/llms/#working-with-llms","title":"Working with LLMs","text":"<p>The subclasses of both <code>LLM</code> or <code>AsyncLLM</code> are intended to be used within the scope of a <code>Task</code>, since those are seamlessly integrated within the different tasks; but nonetheless, they can be used standalone if needed.</p> <pre><code>from distilabel.llms import OpenAILLM\n\nllm = OpenAILLM(model=\"gpt-4\")\nllm.load()\n\nllm.generate(\n    inputs=[\n        [\n            {\"role\": \"user\", \"content\": \"What's the capital of Spain?\"},\n        ],\n    ],\n)\n# \"The capital of Spain is Madrid.\"\n</code></pre> <p>Note</p> <p>The <code>load</code> method needs to be called ALWAYS if using the LLMs as standalone or as part of a task, otherwise, if the <code>Pipeline</code> context manager is used, there's no need to call that method, since it will be automatically called on <code>Pipeline.run</code>; but in any other case the method <code>load</code> needs to be called from the parent class e.g. a <code>Task</code> with an <code>LLM</code> will need to call <code>Task.load</code> to load both the task and the LLM.</p>"},{"location":"sections/learn/llms/#within-a-task","title":"Within a Task","text":"<p>Now, in order to use the LLM within a Task, we need to pass it as an argument to the task, and the task will take care of the rest.</p> <pre><code>from distilabel.llms import OpenAILLM\nfrom distilabel.steps.tasks import TextGeneration\n\n\nllm = OpenAILLM(model=\"gpt-4\")\ntask = TextGeneration(name=\"text_generation\", llm=llm)\n\ntask.load()\n\nnext(task.process(inputs=[{\"instruction\": \"What's the capital of Spain?\"}]))\n# [{'instruction': \"What's the capital of Spain?\", \"generation\": \"The capital of Spain is Madrid.\"}]\n</code></pre>"},{"location":"sections/learn/llms/#runtime-parameters","title":"Runtime Parameters","text":"<p>Additionally, besides the runtime parameters that can / need to be provided to the Task, the LLMs can also define their own runtime parameters such as the <code>generation_kwargs</code>, and those need to be provided within the <code>Pipeline.run</code> method via the variable <code>params</code>.</p> <p>Note</p> <p>Each LLM subclass may have its own runtime parameters and those can differ between the different implementations, as those are not aligned, since the LLM engines offer different functionalities.</p> <pre><code>from distilabel.pipeline import Pipeline\nfrom distilabel.llms import OpenAILLM\nfrom distilabel.steps import LoadDataFromDicts\nfrom distilabel.steps.tasks import TextGeneration\n\n\nwith Pipeline(name=\"text-generation-pipeline\") as pipeline:\n    load_dataset = LoadDataFromDicts(\n        name=\"load_dataset\",\n        data=[\n            {\n                \"instruction\": \"Write a short story about a dragon that saves a princess from a tower.\",\n            },\n        ],\n    )\n\n    text_generation = TextGeneration(\n        name=\"text_generation\",\n        llm=OpenAILLM(model=\"gpt-4\"),\n    )\n    load_dataset.connect(text_generation)\n\nif __name__ == \"__main__\":\n    pipeline.run(params={\"text_generation\": {\"llm\": {\"generation_kwargs\": {\"temperature\": 0.3}}}})\n</code></pre>"},{"location":"sections/learn/llms/#defining-custom-llms","title":"Defining custom LLMs","text":"<p>In order to define custom LLMs, one must subclass either <code>LLM</code> or <code>AsyncLLM</code>, to define a synchronous or asynchronous LLM, respectively.</p> <p>One can either extend any of the existing LLMs to override the default behaviour if needed, but also to define a new one from scratch, that could be potentially contributed to the <code>distilabel</code> codebase.</p> <p>In order to define a new LLM, one must define the following methods:</p> <ul> <li> <p><code>model_name</code>: is a property that contains the name of the model to be used, which means that it needs to be retrieved from the LLM using the LLM-specific approach i.e. for <code>TransformersLLM</code> the <code>model_name</code> will be the <code>model_name_or_path</code> provided as an argument, or in <code>OpenAILLM</code> the <code>model_name</code> will be the <code>model</code> provided as an argument.</p> </li> <li> <p><code>generate</code>: is a method that will take a list of prompts and return a list of generated texts. This method will be called by the <code>Task</code> to generate the texts, so it's the most important method to define. This method will be implemented in the subclass of the LLM i.e. the synchronous LLM.</p> </li> <li> <p><code>agenerate</code>: is a method that will take a single prompt and return a list of generated texts, since the rest of the behaviour will be controlled by the <code>generate</code> method that cannot be overwritten when subclassing AsyncLLM. This method will be called by the <code>Task</code> to generate the texts, so it's the most important method to define. This method will be implemented in the subclass of the AsyncLLM i.e. the asynchronous LLM.</p> </li> <li> <p>(optional) <code>get_last_hidden_state</code>: is a method that will take a list of prompts and return a list of hidden states. This method is optional and will be used by some tasks such as the GenerateEmbeddings task.</p> </li> </ul> <p>Once those methods have been implemented, then the custom LLM will be ready to be integrated within either any of the existing or a new task.</p> <pre><code>from typing import Any\n\nfrom distilabel.llms import AsyncLLM, LLM\nfrom distilabel.llms.typing import GenerateOutput, HiddenState\nfrom distilabel.steps.tasks.typing import ChatType\n\nclass CustomLLM(LLM):\n    @property\n    def model_name(self) -&gt; str:\n        return \"my-model\"\n\n    def generate(self, inputs: List[ChatType], num_generations: int = 1) -&gt; List[GenerateOutput]:\n        for _ in range(num_generations):\n            ...\n\n    def get_last_hidden_state(self, inputs: List[ChatType]) -&gt; List[HiddenState]:\n        ...\n\n\nclass CustomAsyncLLM(AsyncLLM):\n    @property\n    def model_name(self) -&gt; str:\n        return \"my-model\"\n\n    async def agenerate(self, input: ChatType, num_generations: int = 1, **kwargs: Any) -&gt; GenerateOutput:\n        for _ in range(num_generations):\n            ...\n\n    def get_last_hidden_state(self, inputs: List[ChatType]) -&gt; List[HiddenState]:\n        ...\n</code></pre>"},{"location":"sections/learn/llms/#available-llms","title":"Available LLMs","text":"<p>Here's a list with the available LLMs that can be used within the <code>distilabel</code> library:</p> <ul> <li>AnthropicLLM</li> <li>AnyscaleLLM</li> <li>AzureOpenAILLM</li> <li>CohereLLM</li> <li>InferenceEndpointsLLM</li> <li>LiteLLM</li> <li>LlamaCppLLM</li> <li>MistralLLM</li> <li>OllamaLLM</li> <li>OpenAILLM</li> <li>TogetherLLM</li> <li>TransformersLLM</li> <li>VertexAILLM</li> <li>vLLM</li> </ul>"},{"location":"sections/learn/pipelines/","title":"Pipeline","text":"<p>The <code>Pipeline</code> is the central point in <code>distilabel</code>, the way to organize the steps to create your datasets. Up to this point we've seen how we can define different <code>Steps</code> and <code>Tasks</code>, that together with an <code>LLM</code> are the building blocks of our datasets, in this section we will take a look at how all these blocks are organized inside a <code>Pipeline</code>.</p> <p>Note</p> <p>Currently <code>distilabel</code> implements a local version of a <code>Pipeline</code>, and will assume that's the only definition, but this can be extended in the future to include remote execution of the <code>Pipeline</code>.</p>"},{"location":"sections/learn/pipelines/#how-to-create-a-pipeline","title":"How to create a pipeline","text":"<p>The most common way a <code>Pipeline</code> should be created is by making use of the context manager, we just need to give our <code>Pipeline</code> a name, and optionally a description, and that's it<sup>1</sup>:</p> <pre><code>from distilabel.pipeline import Pipeline\n\nwith Pipeline(\"pipe-name\", description=\"My first pipe\") as pipeline:  # (1)\n    ...\n</code></pre> <ol> <li>Use the context manager to create a <code>Pipeline</code> with a name and an optional description.</li> </ol> <p>This way, we ensure all the steps we define there are connected with each other under the same <code>Pipeline</code>. The next step is to define the steps of our <code>Pipeline</code>. It's mandatory that the root steps of the pipeline i.e. the ones that doesn't have any predecessors, are <code>GeneratorStep</code>s such as <code>LoadDataFromDicts</code> or <code>LoadHubDataset</code>.</p> <pre><code>from distilabel.pipeline import Pipeline\nfrom distilabel.steps import LoadHubDataset\n\nwith Pipeline(\"pipe-name\", description=\"My first pipe\") as pipeline:\n    load_dataset = LoadHubDataset(name=\"load_dataset\")  # (1)\n    ...\n</code></pre> <ol> <li>Define the first step of the pipeline, in this case <code>LoadHubDataset</code>, a <code>GeneratorStep</code> used to load a dataset from the Hugging Face Hub.</li> </ol> <p>Once we have a source of data, we can create another <code>Step</code>s that will consume and process the data generated by the <code>GeneratorStep</code>s. Let's assume that the dataset we're going to load from the Hub contains a <code>prompt</code> column and that we want to generate texts based on this prompt. We also want to use several <code>LLM</code>s for this task. To do so, we will create several <code>TextGeneration</code> tasks, each with a different <code>LLM</code>.  </p> <pre><code>from distilabel.llms import MistralLLM, OpenAILLM, VertexAILLM\nfrom distilabel.pipeline import Pipeline\nfrom distilabel.steps import LoadHubDataset\nfrom distilabel.steps.tasks import TextGeneration\n\nwith Pipeline(\"pipe-name\", description=\"My first pipe\") as pipeline:\n    load_dataset = LoadHubDataset(name=\"load_dataset\")\n\n    for llm in (\n        OpenAILLM(model=\"gpt-4-0125-preview\"),\n        MistralLLM(model=\"mistral-large-2402\"),\n        VertexAILLM(model=\"gemini-1.5-pro\"),\n    ):\n        task = TextGeneration(name=f\"text_generation_with_{llm.model_name}\", llm=llm)  # (1)\n        task.connect(load_dataset)  # (2)\n\n    ...\n</code></pre> <ol> <li>Create a <code>TextGeneration</code> task for each <code>LLM</code> we want to use.</li> <li>Connect the <code>TextGeneration</code> task with the <code>LoadHubDataset</code> step, so the output data from the dataset is passed to the task.</li> </ol> <p>Note</p> <p>The order of the execution of the steps will be determined by the connections of the steps. In this case, the <code>TextGeneration</code> tasks will be executed after the <code>LoadHubDataset</code> step.</p> <p>For each row of the dataset, the <code>TextGeneration</code> task will generate a text based on the <code>instruction</code> column and the <code>LLM</code> model, and store the result (a single string) in a new column called <code>generation</code>. As we would like to have all the <code>response</code>s in the same column, we will add an extra step to combine them all in the same column, so the value of this column is a list of strings or responses. </p> <pre><code>from distilabel.llms import MistralLLM, OpenAILLM, VertexAILLM\nfrom distilabel.pipeline import Pipeline\nfrom distilabel.steps import CombineColumns, LoadHubDataset\nfrom distilabel.steps.tasks import TextGeneration\n\nwith Pipeline(\"pipe-name\", description=\"My first pipe\") as pipeline:\n    load_dataset = LoadHubDataset(name=\"load_dataset\")\n\n    combine_generations = CombineColumns(  # (1)\n        name=\"combine_generations\",\n        columns=[\"generation\", \"model_name\"],\n        output_columns=[\"generations\", \"model_names\"],\n    )\n\n    for llm in (\n        OpenAILLM(model=\"gpt-4-0125-preview\"),\n        MistralLLM(model=\"mistral-large-2402\"),\n        VertexAILLM(model=\"gemini-1.5-pro\"),\n    ):\n        task = TextGeneration(name=f\"text_generation_with_{llm.model_name}\", llm=llm)\n        load_dataset.connect(task)\n        task.connect(combine_generations)  # (2)\n</code></pre> <ol> <li>Create a <code>CombineColumns</code> step to combine all the <code>generation</code> columns into a single column called <code>generations</code> and the <code>model_name</code> columns into a single column called <code>model_names</code>.</li> <li>Connect the <code>TextGeneration</code> task with the <code>CombineColumns</code> step, so the output data from the task is passed to the step that will combine all the <code>generation</code> columns.</li> </ol> <p>As the <code>CombineColumns</code> is the last step or it's a leaf step of the pipeline because it doesn't have any successors, that means that the outputs of this step will be included in the returned <code>Distiset</code> by the pipeline.</p> <p>Note</p> <p>One pipeline can have several leaf steps, which means that the outputs of all the leaf steps will be included in the returned <code>Distiset</code>, which will contain several subsets, one for each leaf step.</p>"},{"location":"sections/learn/pipelines/#running-the-pipeline","title":"Running the pipeline","text":"<p>Once we have created the pipeline, we can run it. To do so, we need to call the <code>run</code> method of the <code>Pipeline</code>, and specify the runtime parameters for each step:</p> <pre><code>with Pipeline(\"pipe-name\", description=\"My first pipe\") as pipeline:\n    ...\n\nif __name__ == \"__main__\":\n    distiset = pipeline.run(\n        parameters={\n            \"load_dataset\": {\n                \"repo_id\": \"distilabel-internal-testing/instruction-dataset-mini\",\n                \"split\": \"test\",\n            },\n            \"text_generation_with_openai-gpt-4-0125-preview\": {\n                \"generation_kwargs\": {\n                    \"temperature\": 0.7,\n                    \"max_new_tokens\": 512,\n                }\n            },\n            \"text_generation_with_mistral-large-2402\": {\n                \"generation_kwargs\": {\n                    \"temperature\": 0.7,\n                    \"max_new_tokens\": 512,\n                }\n            },\n            \"text_generation_with_vertexai-gemini-1.5-pro\": {\n                \"generation_kwargs\": {\n                    \"temperature\": 0.7,\n                    \"max_new_tokens\": 512,\n                }\n            },\n        }\n    )\n</code></pre> <p>But if we run it, we will see that the <code>run</code> method will fail:</p> <pre><code>ValueError: Step 'text_generation_with_gpt-4-0125-preview' requires inputs ['instruction'] which are not available when the step gets to be executed in the pipeline. Please make sure previous steps to 'text_generation_with_gpt-4-0125-preview' are \ngenerating the required inputs. Available inputs are: ['prompt', 'completion', 'meta']\n</code></pre> <p>This is because, before actually running the pipeline, the pipeline is validated to verify that everything is correct and all the steps in the pipeline are chainable i.e. each step has the necessary inputs to be executed. In this case, the <code>TextGeneration</code> task requires the <code>instruction</code> column, but the <code>LoadHubDataset</code> step generates the <code>prompt</code> column. To solve this, we can use the <code>output_mappings</code> argument that every <code>Step</code> has, to map or rename the output columns of a step to the required input columns of another step:</p> <pre><code>with Pipeline(\"pipe-name\", description=\"My first pipe\") as pipeline:\n    load_dataset = LoadHubDataset(\n        name=\"load_dataset\",\n        output_mappings={\"prompt\": \"instruction\"},  # (1)\n    )\n\n    ...\n</code></pre> <ol> <li>Use the <code>output_mappings</code> argument to map the <code>prompt</code> column generated by the <code>LoadHubDataset</code> step to the <code>instruction</code> column required by the <code>TextGeneration</code> task.</li> </ol> <p>If we execute the pipeline again, it will run successfully and we will have a <code>Distiset</code> with the outputs of all the leaf steps of the pipeline which we can push to the Hugging Face Hub.</p> <pre><code>if __name__ == \"__main__\":\n    distiset = pipeline.run(...)\n    distiset.push_to_hub(\"distilabel-internal-testing/instruction-dataset-mini-with-generations\")\n</code></pre>"},{"location":"sections/learn/pipelines/#cache","title":"Cache","text":"<p>If we try to execute the pipeline again, the pipeline won't execute as it will load the dataset from the cache, and the outputs of the pipeline will be the same as the previous run. If for some reason, we decide to stop the pipeline execution in the middle of the process pressing CTRL + C, the pipeline will stop and the state of the pipeline and the outputs will be stored in the cache, so we can resume the pipeline execution from the point where it was stopped.</p> <p>If we want to force the pipeline to run again, then we can use the <code>use_cache</code> argument of the <code>run</code> method and set it to <code>False</code>:</p> <pre><code>if __name__ == \"__main__\":\n    distiset = pipeline.run(parameters={...}, use_cache=False)\n</code></pre>"},{"location":"sections/learn/pipelines/#adjusting-the-batch-size-for-each-step","title":"Adjusting the batch size for each step","text":"<p>It's very likely that in some pipelines the batch size of the steps (the number of dictionaries that will receive every <code>Step.process</code> method when called) will need to be adjusted in order to avoid memory issues or a more efficient processing. To do so, we can use the <code>input_batch_size</code> argument of the <code>run</code> method:</p> <pre><code>from distilabel.llms import MistralLLM, OpenAILLM, VertexAILLM\nfrom distilabel.pipeline import Pipeline\nfrom distilabel.steps import CombineColumns, LoadHubDataset\nfrom distilabel.steps.tasks import TextGeneration\n\nwith Pipeline(\"pipe-name\", description=\"My first pipe\") as pipeline:\n    ...\n\n    for llm in (\n        OpenAILLM(model=\"gpt-4-0125-preview\"),\n        MistralLLM(model=\"mistral-large-2402\"),\n        VertexAILLM(model=\"gemini-1.5-pro\"),\n    ):\n        task = TextGeneration(\n            name=f\"text_generation_with_{llm.model_name}\", \n            llm=llm,\n            input_batch_size=5,  # (1)\n        )\n\n    ...\n</code></pre> <ol> <li>Use the <code>input_batch_size</code> argument to set the batch size of the <code>TextGeneration</code> task to 5.</li> </ol> <p>When we run the pipeline, the <code>TextGeneration</code> task will receive 5 dictionaries in every call to the <code>process</code> method. In addition, we can also adjust the batch size of the generated batches by the <code>GeneratorStep</code>s using the <code>batch_size</code> argument:</p> <pre><code>with Pipeline(\"pipe-name\", description=\"My first pipe\") as pipeline:\n    load_dataset = LoadHubDataset(\n        name=\"load_dataset\",\n        output_mappings={\"prompt\": \"instruction\"},\n        batch_size=10  # (1)\n    )\n\n    ...\n</code></pre> <ol> <li>Use the <code>batch_size</code> argument to set the batch size of the <code>LoadHubDataset</code> step to 10.</li> </ol> <p>By default, both arguments have a value of <code>50</code>.</p>"},{"location":"sections/learn/pipelines/#serializing-the-pipeline","title":"Serializing the pipeline","text":"<p>Sharing a pipeline with others is very easy, as we can serialize the pipeline object using the <code>save</code> method. We can save the pipeline in different formats, such as <code>yaml</code> or <code>json</code>:</p> <pre><code>if __name__ == \"__main__\":\n    pipeline.save(\"pipeline.yaml\", format=\"yaml\")\n</code></pre> <p>To load the pipeline, we can use the <code>from_yaml</code> or <code>from_json</code> methods:</p> <pre><code>pipeline = Pipeline.from_yaml(\"pipeline.yaml\")\n</code></pre> <p>Serializing the pipeline is very useful when we want to share the pipeline with others, or when we want to store the pipeline for future use. It can even be hosted online, so the pipeline can be executed directly using the CLI knowing the URL of the pipeline.</p>"},{"location":"sections/learn/pipelines/#fully-working-example","title":"Fully working example","text":"<p>To sump up, here is the full code of the pipeline we have created in this section. Note that you will need to change the name of the Hugging Face repository where the resulting will be pushed, set <code>OPENAI_API_KEY</code> environment variable, set <code>MISTRAL_API_KEY</code> and have <code>gcloud</code> installed and configured:</p> Code <pre><code>from distilabel.llms import MistralLLM, OpenAILLM, VertexAILLM\nfrom distilabel.pipeline import Pipeline\nfrom distilabel.steps import CombineColumns, LoadHubDataset\nfrom distilabel.steps.tasks import TextGeneration\n\nwith Pipeline(\"pipe-name\", description=\"My first pipe\") as pipeline:\n    load_dataset = LoadHubDataset(\n        name=\"load_dataset\",\n        output_mappings={\"prompt\": \"instruction\"},\n    )\n\n    combine_generations = CombineColumns(\n        name=\"combine_generations\",\n        columns=[\"generation\", \"model_name\"],\n        output_columns=[\"generations\", \"model_names\"],\n    )\n\n    for llm in (\n        OpenAILLM(model=\"gpt-4-0125-preview\"),\n        MistralLLM(model=\"mistral-large-2402\"),\n        VertexAILLM(model=\"gemini-1.0-pro\"),\n    ):\n        task = TextGeneration(name=f\"text_generation_with_{llm.model_name}\", llm=llm)\n        load_dataset.connect(task)\n        task.connect(combine_generations)\n\nif __name__ == \"__main__\":\n    distiset = pipeline.run(\n        parameters={\n            \"load_dataset\": {\n                \"repo_id\": \"distilabel-internal-testing/instruction-dataset-mini\",\n                \"split\": \"test\",\n            },\n            \"text_generation_with_gpt-4-0125-preview\": {\n                \"generation_kwargs\": {\n                    \"temperature\": 0.7,\n                    \"max_new_tokens\": 512,\n                }\n            },\n            \"text_generation_with_mistral-large-2402\": {\n                \"generation_kwargs\": {\n                    \"temperature\": 0.7,\n                    \"max_new_tokens\": 512,\n                }\n            },\n            \"text_generation_with_gemini-1.0-pro\": {\n                \"generation_kwargs\": {\n                    \"temperature\": 0.7,\n                    \"max_new_tokens\": 512,\n                }\n            },\n        },\n    )\n    distiset.push_to_hub(\n        \"distilabel-internal-testing/instruction-dataset-mini-with-generations\"\n    )\n</code></pre> <ol> <li> <p>We also have the cache_dir argument to pass, for more information on this parameter, we refer the reader to the caching section.\u00a0\u21a9</p> </li> </ol>"},{"location":"sections/learn/steps/","title":"Steps","text":"<p>The <code>Step</code> is the base class in <code>distilabel</code>, every unit of work in a <code>Pipeline</code> will inherit from it.</p>"},{"location":"sections/learn/steps/#whats-a-step-in-distilabel","title":"What's a Step in distilabel?","text":"<p>It's a base class is in charge of processing data, which in the end will be lists of dictionaries. In order to process, it defines two properties: <code>inputs</code> and <code>outputs</code>, which are a list of strings that represent the names of the columns that the step needs as input or output respectively i.e. the keys that have to be present in the list of dictionaries received by the step and the keys that will be added to these dictionaries after running it.</p> <p>Every <code>Step</code> is connected to a <code>Pipeline</code>, which in practice means that we will build them in the context of a <code>Pipeline</code>.</p> <p>Lastly, these steps inherit from <code>pydantic.BaseModel</code>, so all the attributes of a step will be validated upon definition.</p>"},{"location":"sections/learn/steps/#an-example-conversationtemplate","title":"An example: ConversationTemplate","text":"<p>Let's see one simple type of step as an example, the <code>ConversationTemplate</code>. Let's take a look at it's definition (the docstrings are removed for clarity, but it can be reviewd in the API reference):</p> <pre><code>class ConversationTemplate(Step):\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        return [\"instruction\", \"response\"]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        return [\"conversation\"]\n\n    def process(self, inputs: StepInput) -&gt; \"StepOutput\":\n        for input in inputs:\n            input[\"conversation\"] = [\n                {\"role\": \"user\", \"content\": input[\"instruction\"]},\n                {\"role\": \"assistant\", \"content\": input[\"response\"]},\n            ]\n        yield inputs\n</code></pre> <p>At the very minimal, we need to define the <code>inputs</code> and <code>outputs</code> properties with the column names required as input, and returned as output respectively, and the processing logic of the step in the <code>process</code> method.</p> <p>In this example, we see that it takes <code>inputs</code> as argument, annotated as <code>StepInput</code>, which is a list of dictionaries with the data, and yields a <code>StepOutput</code>.</p>"},{"location":"sections/learn/steps/#working-with-the-step","title":"Working with the step","text":"<p>Let's see how to instantiate this <code>Step</code> outside of a <code>Pipeline</code>:</p> <pre><code>from distilabel.pipeline.local import Pipeline\nfrom distilabel.steps.conversation import ConversationTemplate\n\nconversation_template = ConversationTemplate(\n    name=\"my-conversation-template\",\n    pipeline=Pipeline(name=\"my-pipeline\"),\n)\n</code></pre> <p>As we mentioned, every <code>Step</code> must be defined in the context of a <code>Pipeline</code>, which means we need to pass it as an argument if we decide to create a standalone step. If we take a look at the <code>conversation_template</code> step, we see the following fields:</p> <pre><code>conversation_template\n# ConversationTemplate(name='my-conversation-template', input_mappings={}, output_mappings={}, input_batch_size=50)\n</code></pre> <ul> <li>The <code>name</code> of the <code>Step</code>, a mandatory field to identify the <code>Step</code> within the <code>Pipeline</code>. </li> <li><code>input_mappings</code>, which is a dictionary that can be useful to map keys from the input dictionaries to the keys expected by the step. For example, if <code>input_mappings={\"instruction\": \"prompt\"}</code>, that means that the key <code>prompt</code> from the input dictionaries will be used as the key <code>instruction</code> for the step.</li> <li><code>output_mappings</code>, which is a dictionary that can be used to map the <code>outputs</code> of the step to other names. For example, if <code>output_mappings={\"conversation\": \"prompt\"}</code>, that means that the key <code>conversation</code> generated by the step will be renamed to <code>prompt</code> and the output dictionaries of this step will contain a key called <code>prompt</code> instead of <code>conversation</code>.</li> <li><code>input_batch_size</code> (by default set to 50), which is independent for every step and will determine how many input dictionaries will process at once. If won't matter that much in this step, but as we will see later, other types of steps will come with an <code>LLM</code>, so having this flexibility will be really useful.</li> </ul>"},{"location":"sections/learn/steps/#processing-data","title":"Processing data","text":"<p>Internally, the <code>Pipeline</code> will call the <code>process</code> method when appropriate, but we can see it in action with some dummy data:</p> <pre><code>next(conversation_template.process([{\"instruction\": \"Hello\", \"response\": \"Hi\"}]))\n# [\n#   {\n#     \"instruction\": \"Hello\",\n#     \"response\": \"Hi\",\n#     \"conversation\": [\n#       {\n#         \"role\": \"user\",\n#         \"content\": \"Hello\"\n#       },\n#       {\n#         \"role\": \"assistant\",\n#         \"content\": \"Hi\"\n#       }\n#     ]\n#   }\n# ]\n</code></pre> <p>It takes the dictionary with data, adds another <code>conversation</code> with the data formatted as a conversation template, and passes this data to the following step.</p> <p>This is a small type step that shows what to expect when we are creating our <code>Step</code> objects, which can start from something as simple as generating a conversation template from some columns on a dataset.</p>"},{"location":"sections/learn/steps/#runtime-parameters","title":"Runtime Parameters","text":"<p>Let's take a look at a special argument implementation that we will find when dealing with the <code>Steps</code>, the Runtime paramaters. Let's inspect them using the previous example class:</p> <pre><code>print(conversation_template.runtime_parameters_names)\n# {'input_batch_size': True}\n</code></pre> <p>The <code>ConversationTemplate</code> only has one <code>runtime_parameter</code>, which comes defined from the <code>Step</code> class, and can be defined as such:</p> <pre><code>from distilabel.mixins.runtime_parameters import RuntimeParameter\n\nclass Step(...):\n    ...\n    input_batch_size: RuntimeParameter[PositiveInt] = Field(\n        default=DEFAULT_INPUT_BATCH_SIZE,\n        description=\"The number of rows that will contain the batches processed by the\"\n        \" step.\",\n    )\n</code></pre> <p>When we define the <code>input_batch_size</code> as a <code>RuntimeParameter</code>, the most direct effect we can see is we have some access to some extra information, thanks to the RuntimeParamatersMixin:</p> <pre><code>print(conversation_template.get_runtime_parameters_info())\n# [{'name': 'input_batch_size', 'optional': True, 'description': 'The number of rows that will contain the batches processed by the step.'}]\n</code></pre> <p>But other than accessing some extra information internally, we can directly interact with these parameters when we interacting or modifying the arguments of our <code>Steps</code> while running them in the context of a <code>Pipeline</code>. We will see them in action once we interact with the <code>Steps</code> inside of a <code>Pipeline</code>.</p>"},{"location":"sections/learn/steps/#step-decorator","title":"step decorator","text":"<p>If all that we want to apply in a step is some simple processing, it can be easier to just create a plain function, and decorate it. We can find more examples in the API reference, but let's see how we could define the previous step as a function and use the decorator:</p> <pre><code>from distilabel.steps import StepInput, StepOutput, step \n\n# Normal step\n@step(inputs=[\"instruction\", \"response\"], outputs=[\"conversation\"])\ndef ConversationTemplate(inputs: StepInput) -&gt; StepOutput:\n    for input in inputs:\n        input[\"conversation\"] = [\n            {\"role\": \"user\", \"content\": input[\"instruction\"]},\n            {\"role\": \"assistant\", \"content\": input[\"response\"]},\n        ]\n    yield inputs\n</code></pre> <p>Which can be instantiated exactly the same as the <code>ConversationTemplate</code> class:</p> <pre><code>conversation_template = ConversationTemplate(\n    name=\"my-conversation-template\",\n    pipeline=Pipeline(name=\"my-pipeline\"),\n)\n</code></pre> <p>This <code>@step</code> decorator has a special type depending <code>step_type</code> which will be better understood once we see the different types of steps.</p>"},{"location":"sections/learn/steps/#types-of-steps","title":"Types of steps","text":"<p>Other than the general or normal steps we have seen, there are special types of steps that have a restricted behaviour compared to the general <code>Step</code>.</p>"},{"location":"sections/learn/steps/#generator-steps","title":"Generator steps","text":"<p>These are steps that are able to generate data, and don't need to receive any input from previous step, as it's implied in the normal steps. The typical use for these steps will be loading data for example, as can be seen in <code>LoadDataFromDicts</code>. For this type of steps we will only need to define the <code>process</code> method, and we can optionally pass a <code>batch_size</code> argument, that will determine the batch size of the generated batches.</p>"},{"location":"sections/learn/steps/#global-steps","title":"Global steps","text":"<p>Other special type of step are the global steps. These steps don't have any <code>inputs</code> or <code>outputs</code>, and their <code>process</code> method receives all the data at once instead of using batches. This kind of behavior is necessary for example to push a dataset to a specific place, or doing some filtering on the whole data before continuing with the pipeline.</p>"},{"location":"sections/learn/steps/argilla/","title":"Argilla","text":"<p>As an additional step, besides being able to restore the dataset from the <code>Pipeline</code> output as a <code>Distiset</code> (which is a <code>datasets.DatasetDict</code> with multiple configurations depending on the leaf nodes of the <code>Pipeline</code>), one can also include a <code>Step</code> within the <code>Pipeline</code> to easily export the datasets to Argilla with a pre-defined configuration, suiting the annotation purposes.</p> <p>Being able to export the generated synthetic datasets to Argilla, was one of the core features we wanted to have fully integrated within <code>distilabel</code>, not only because we're biased, but also because we believe in the potential of synthetic data, but always having an annotator or group of annotators to review the data and draw conclusions from it. So on, the Argilla integration will make it easier than ever to push a dataset to Argilla while the <code>Pipeline</code> is running, and be able to follow along the generation process, as well as annotating the records on the fly.</p> <p>Before using any of the steps about to be described below, you should first have an Argilla instance up and running, so that you can successfully upload the data to Argilla. In order to deploy Argilla, the easiest and most straight forward way is to deploy it via the Argilla Template in Hugging Face Spaces as simply as following the steps there, or just via the following button:</p> <p> </p> <p>Additionally, Argilla offer multiple deployment options listed in the Argilla Documentation - Installation page.</p>"},{"location":"sections/learn/steps/argilla/#text-generation","title":"Text Generation","text":"<p>For text generation scenarios, i.e. when the <code>Pipeline</code> contains a <code>TextGeneration</code> step, we have designed the task <code>TextGenerationToArgilla</code>, which will seamlessly push the generated data to Argilla, and allow the annotator to review the records.</p> <p>The dataset will be pushed with the following configuration:</p> <ul> <li> <p>Fields: <code>instruction</code> and <code>generation</code>, both being fields of type <code>argilla.TextField</code>, plus the automatically generated <code>id</code> for the given <code>instruction</code> to be able to search with it. The field <code>instruction</code> must always be a string, while the field <code>generation</code> can either be a single string or a list of strings (useful when there are multiple parent nodes of type <code>TextGeneration</code>); even though each record will always contain at most one <code>instruction</code>-<code>generation</code> pair.</p> </li> <li> <p>Questions: <code>quality</code> will be the only question for the annotators to answer i.e. to annotate, and it will be an <code>argilla.LabelQuestion</code> referring to the quality of the provided generation for the given instruction, and can be annotated with either \ud83d\udc4e (bad) or \ud83d\udc4d (good).</p> </li> </ul> <p>Note</p> <p>The <code>TextGenerationToArgilla</code> step will only work as is if the <code>Pipeline</code> contains one or multiple <code>TextGeneration</code> steps, or if the columns <code>instruction</code> and <code>generation</code> are available within the batch data. Otherwise, the variable <code>input_mappings</code> will need to be set so that either both or one of <code>instruction</code> and <code>generation</code> are mapped to one of the existing columns in the batch data.</p> <pre><code>from distilabel.llms import OpenAILLM\nfrom distilabel.steps import LoadDataFromDicts, PreferenceToArgilla\nfrom distilabel.steps.tasks import TextGeneration\n\n\nwith Pipeline(name=\"my-pipeline\") as pipeline:\n    load_dataset = LoadDataFromDicts(\n        name=\"load_dataset\",\n        data=[\n            {\n                \"instruction\": \"Write a short story about a dragon that saves a princess from a tower.\",\n            },\n        ],\n    )\n\n    text_generation = TextGeneration(\n        name=\"text_generation\",\n        llm=OpenAILLM(model=\"gpt-4\"),\n    )\n    load_dataset.connect(text_generation)\n\n    to_argilla = TextGenerationToArgilla(\n        dataset_name=\"my-dataset\",\n        dataset_workspace=\"admin\",\n        api_url=\"&lt;ARGILLA_API_URL&gt;\",\n        api_key=\"&lt;ARGILLA_API_KEY&gt;\",\n    )\n\n    text_generation.connect(to_argilla)\n\npipeline.run()\n</code></pre> <p></p>"},{"location":"sections/learn/steps/argilla/#preference","title":"Preference","text":"<p>For preference scenarios, i.e. when the <code>Pipeline</code> contains multiple <code>TextGeneration</code> steps, we have designed the task <code>PreferenceToArgilla</code>, which will seamlessly push the generated data to Argilla, and allow the annotator to review the records.</p> <p>The dataset will be pushed with the following configuration:</p> <ul> <li> <p>Fields: <code>instruction</code> and <code>generations</code>, both being fields of type <code>argilla.TextField</code>, plus the automatically generated <code>id</code> for the given <code>instruction</code> to be able to search with it. The field <code>instruction</code> must always be a string, while the field <code>generations</code> must be a list of strings, containing the generated texts for the given <code>instruction</code> so that at least there are two generations to compare. Other than that, the number of <code>generation</code> fields within each record in Argilla will be defined by the value of the variable <code>num_generations</code> to be provided in the <code>PreferenceToArgilla</code> step.</p> </li> <li> <p>Questions: <code>rating</code> and <code>rationale</code> will be the pairs of questions to be defined per each generation i.e. per each value within the range from 0 to <code>num_generations</code>, and those will be of types <code>argilla.RatingQuestion</code> and <code>argilla.TextQuestion</code>, respectively. Also note that only the first pair of questions will be mandatory, since only one generation is ensured to be within the batch data. Additionally, note that the provided ratings will range from 1 to 5, and to mention that Argilla only supports values above 0.</p> </li> </ul> <p>Note</p> <p>The <code>PreferenceToArgilla</code> step will only work as is if the <code>Pipeline</code> contains multiple <code>TextGeneration</code> steps, or if the columns <code>instruction</code> and <code>generations</code> are available within the batch data. Otherwise, the variable <code>input_mappings</code> will need to be set so that either both or one of <code>instruction</code> and <code>generations</code> are mapped to one of the existing columns in the batch data.</p> <p>Note</p> <p>Additionally, if the <code>Pipeline</code> contains an <code>UltraFeedback</code> step, the <code>ratings</code> and <code>rationales</code> will also be available, so if that's the case, those will be automatically injected as suggestions to the existing dataset so that the annotator only needs to review those, instead of fulfilling those by themselves.</p> <pre><code>from distilabel.llms import OpenAILLM\nfrom distilabel.steps import LoadDataFromDicts, PreferenceToArgilla\nfrom distilabel.steps.tasks import TextGeneration\n\n\nwith Pipeline(name=\"my-pipeline\") as pipeline:\n    load_dataset = LoadDataFromDicts(\n        name=\"load_dataset\",\n        data=[\n            {\n                \"instruction\": \"Write a short story about a dragon that saves a princess from a tower.\",\n            },\n        ],\n    )\n\n    text_generation = TextGeneration(\n        name=\"text_generation\",\n        llm=OpenAILLM(model=\"gpt-4\"),\n        num_generations=4,\n        group_generations=True,\n    )\n    load_dataset.connect(text_generation)\n\n    to_argilla = PreferenceToArgilla(\n        dataset_name=\"my-dataset\",\n        dataset_workspace=\"admin\",\n        api_url=\"&lt;ARGILLA_API_URL&gt;\",\n        api_key=\"&lt;ARGILLA_API_KEY&gt;\",\n        num_generations=4,\n    )\n    text_generation.connect(to_argilla)\n\npipeline.run()\n</code></pre> <p></p> <p>Note</p> <p>If you are willing to also add the suggestions, feel free to check UltraFeedback: Boosting Language Models with High-quality Feedback where the <code>UltraFeedback</code> task is used to generate both ratings and rationales for each of the generations of a given instruction.</p>"},{"location":"sections/learn/steps/general_steps/","title":"General Steps","text":"<p>This section shows some steps that don't belong to the special category of <code>global</code> or <code>generator</code> steps.</p>"},{"location":"sections/learn/steps/general_steps/#processing-columns-of-the-dataset","title":"Processing columns of the dataset","text":"<p>The following steps correspond to some common operations that can be helpful during the dataset generation.</p> <p>Note</p> <p>We will use a sample dataset from a dict, keep in mind that as we are working with iterators (note the call to <code>next</code> function), you may need to recreate the dataset to execute all the steps at once.</p> <pre><code>from distilabel.pipeline.local import Pipeline\nfrom distilabel.steps.generators.data import LoadDataFromDicts\n\nload_data = LoadDataFromDicts(\n    name=\"load_data\",\n    data=[\n        {\n            \"instruction\": \"What if the Beatles had never formed as a band?\",\n            \"completion\": \"The Beatles are widely credited with starting the British Invasion, a wave of rock and roll bands from the United Kingdom that became popular in America in the 1960s. If the Beatles had never formed, this musical movement may have never happened, and the world may have been exposed to a different kind of music. So, without the Beatles\\u2019 fame and success, other bands wouldn\\u2019t have been able to break into the American music scene and create a wider range of sounds. We could have ended up with a less interesting mix of songs playing on the radio.\"\n        },\n        {\n            \"instruction\": \"Given that f(x) = 5x^3 - 2x + 3, find the value of f(2).\",\n            \"completion\": \"The problem is asking us to find the value of the function f(x) = 5x^3 - 2x + 3 at the point x = 2. \\n\\nStep 1: Substitute x with 2 in the function\\nWe replace every x in the function with 2. This gives us:\\nf(2) = 5(2)^3 - 2(2) + 3\\n\\nStep 2: Simplify the expression\\nNext, we simplify the expression by performing the operations in order from left to right.\\n\\nFirst, calculate the cube of 2, which is 8. Substitute this back into the expression:\\nf(2) = 5(8) - 4 + 3\\n\\nThen, multiply 5 by 8 which gives us 40:\\nf(2) = 40 - 4 + 3\\n\\nFinally, subtract 4 from 40 which gives us 36, and then add 3 to that:\\nf(2) = 36 + 3\\n\\nStep 3: Final calculation\\nNow, add 36 and 3 together:\\nf(2) = 39\\n\\nSo, the value of the function f(x) = 5x^3 - 2x + 3 at the point x = 2 is 39.\"\n        }\n    ],\n    pipeline=Pipeline(name=\"data-pipeline\")\n)\n</code></pre>"},{"location":"sections/learn/steps/general_steps/#keep-columns","title":"Keep Columns","text":"<p>There is a special step to keep only the specified columns after a processing step: <code>KeepColumns</code>. Let's use it to keep only the <code>instruction</code> column from the previous dataset:</p> <pre><code>from distilabel.pipeline.local import Pipeline\nfrom distilabel.steps.keep import KeepColumns\n\nkeep_columns = KeepColumns(\n    name=\"keep-columns\",\n    columns=[\"instruction\"],\n    pipeline=Pipeline(name=\"keeper-pipeline\"),\n)\n</code></pre> <p>And to see it in action, let's grab the first batch of data:</p> <pre><code>batch = next(load_data.process())[0]\nprint(json.dumps(next(keep_columns.process(batch)), indent=2))\n# [\n#   {\n#     \"instruction\": \"What if the Beatles had never formed as a band?\"\n#   },\n#   {\n#     \"instruction\": \"Given that f(x) = 5x^3 - 2x + 3, find the value of f(2).\"\n#   }\n# ]\n</code></pre> <p>After this step has processed the batch we have lost the <code>completion</code> column. This step can be useful to just keep the relevant columns after a step that generates some intermediate steps for example.</p>"},{"location":"sections/learn/steps/general_steps/#combine-columns","title":"Combine Columns","text":"<p>This next step allows us to merge the output from multiple steps into a single row for further processing, let's take a look at <code>CombineColumns</code>:</p> <pre><code>from distilabel.pipeline.local import Pipeline\nfrom distilabel.steps.combine import CombineColumns\n\ncombine_columns = CombineColumns(\n    name=\"combine_columns\",\n    columns=[\"instruction\", \"completion\"],\n    pipeline=Pipeline(name=\"combine-pipeline\"),\n)\n</code></pre> <p>To see the step in action, we are going to pass the previous batch as individual lists per row, mimicking what we would see during a pipeline in which we are combining the output from two different steps that could be generating data. We can understand each of these <code>[batch[i]]</code> as if it was the result from two different steps generating data:</p> <pre><code>batch = next(load_data.process())[0]\ncombined = next(combine_columns.process([batch[0]], [batch[1]]))\nprint(json.dumps(combined, indent=2))\n# [\n#   {\n#     \"merged_instruction\": [\n#       \"What if the Beatles had never formed as a band?\",\n#       \"Given that f(x) = 5x^3 - 2x + 3, find the value of f(2).\"\n#     ],\n#     \"merged_completion\": [\n#       \"The Beatles are widely credited with starting the British Invasion, a wave of rock and roll bands from the United Kingdom that became popular in America in the 1960s. If the Beatles had never formed, this musical movement may have never happened, and the world may have been exposed to a different kind of music. So, without the Beatles\\u2019 fame and success, other bands wouldn\\u2019t have been able to break into the American music scene and create a wider range of sounds. We could have ended up with a less interesting mix of songs playing on the radio.\",\n#       \"The problem is asking us to find the value of the function f(x) = 5x^3 - 2x + 3 at the point x = 2. \\n\\nStep 1: Substitute x with 2 in the function\\nWe replace every x in the function with 2. This gives us:\\nf(2) = 5(2)^3 - 2(2) + 3\\n\\nStep 2: Simplify the expression\\nNext, we simplify the expression by performing the operations in order from left to right.\\n\\nFirst, calculate the cube of 2, which is 8. Substitute this back into the expression:\\nf(2) = 5(8) - 4 + 3\\n\\nThen, multiply 5 by 8 which gives us 40:\\nf(2) = 40 - 4 + 3\\n\\nFinally, subtract 4 from 40 which gives us 36, and then add 3 to that:\\nf(2) = 36 + 3\\n\\nStep 3: Final calculation\\nNow, add 36 and 3 together:\\nf(2) = 39\\n\\nSo, the value of the function f(x) = 5x^3 - 2x + 3 at the point x = 2 is 39.\"\n#     ]\n#   }\n# ]\n</code></pre> <p>We have both <code>instruction</code> and <code>completion</code> from the 2 different lists merged as a single column: <code>merged_instruction</code> and <code>merged_completion</code> respectively.</p> <p>This step is necessary to build more complicated pipelines like <code>UltraFeedback</code>, where we need to have the merged content of multiple <code>LLMs</code> to rate them.</p>"},{"location":"sections/learn/steps/general_steps/#expand-columns","title":"Expand Columns","text":"<p>Just as we may have the necessity to merge the output from different steps, we can equally want to expand the current columns to behave as multiple rows, let's see the <code>ExpandColumns</code> work on the output from the previous step:</p> <pre><code>from distilabel.pipeline.local import Pipeline\nfrom distilabel.steps.expand import ExpandColumns\n\nexpand_columns = ExpandColumns(\n    name=\"expand_columns\",\n    columns=[\"merged_instruction\", \"merged_completion\"],\n    pipeline=Pipeline(name=\"expand-pipeline\"),\n)\n</code></pre> <p>We can pass to the process method the <code>combined</code> variable, which is the output from the previous step directly:</p> <pre><code>print(json.dumps(next(expand_columns.process(combined)), indent=2))\n# [\n#   {\n#     \"merged_instruction\": \"What if the Beatles had never formed as a band?\",\n#     \"merged_completion\": \"The Beatles are widely credited with starting the British Invasion, a wave of rock and roll bands from the United Kingdom that became popular in America in the 1960s. If the Beatles had never formed, this musical movement may have never happened, and the world may have been exposed to a different kind of music. So, without the Beatles\\u2019 fame and success, other bands wouldn\\u2019t have been able to break into the American music scene and create a wider range of sounds. We could have ended up with a less interesting mix of songs playing on the radio.\"\n#   },\n#   {\n#     \"merged_instruction\": \"Given that f(x) = 5x^3 - 2x + 3, find the value of f(2).\",\n#     \"merged_completion\": \"The problem is asking us to find the value of the function f(x) = 5x^3 - 2x + 3 at the point x = 2. \\n\\nStep 1: Substitute x with 2 in the function\\nWe replace every x in the function with 2. This gives us:\\nf(2) = 5(2)^3 - 2(2) + 3\\n\\nStep 2: Simplify the expression\\nNext, we simplify the expression by performing the operations in order from left to right.\\n\\nFirst, calculate the cube of 2, which is 8. Substitute this back into the expression:\\nf(2) = 5(8) - 4 + 3\\n\\nThen, multiply 5 by 8 which gives us 40:\\nf(2) = 40 - 4 + 3\\n\\nFinally, subtract 4 from 40 which gives us 36, and then add 3 to that:\\nf(2) = 36 + 3\\n\\nStep 3: Final calculation\\nNow, add 36 and 3 together:\\nf(2) = 39\\n\\nSo, the value of the function f(x) = 5x^3 - 2x + 3 at the point x = 2 is 39.\"\n#   }\n# ]\n</code></pre> <p>Obtaining the columns as a list of rows, that could be processed for a further step requiring the data in that special format.</p>"},{"location":"sections/learn/steps/generator_steps/","title":"Generator Steps","text":"<p>This section shows a special type of step that don't need a prior step to generate data, the generator steps, which will be in charge of loading and yielding data.</p>"},{"location":"sections/learn/steps/generator_steps/#just-load-some-data","title":"Just load some data","text":"<p>The easiest way to create a step that generates some data is to pass some dict with the fields and the data we want. This is what <code>LoadDataFromDicts</code> does for us. Let's see an example of how to instantiate it with a couple of examples of instruction/completion pairs:</p> <pre><code>from distilabel.pipeline.local import Pipeline\nfrom distilabel.steps.generators.data import LoadDataFromDicts\n\nload_data = LoadDataFromDicts(\n    name=\"load_data\",\n    data=[\n        {\n            \"instruction\": \"What if the Beatles had never formed as a band?\",\n            \"completion\": \"The Beatles are widely credited with starting the British Invasion, a wave of rock and roll bands from the United Kingdom that became popular in America in the 1960s. If the Beatles had never formed, this musical movement may have never happened, and the world may have been exposed to a different kind of music. So, without the Beatles\\u2019 fame and success, other bands wouldn\\u2019t have been able to break into the American music scene and create a wider range of sounds. We could have ended up with a less interesting mix of songs playing on the radio.\"\n        },\n        {\n            \"instruction\": \"Given that f(x) = 5x^3 - 2x + 3, find the value of f(2).\",\n            \"completion\": \"The problem is asking us to find the value of the function f(x) = 5x^3 - 2x + 3 at the point x = 2. \\n\\nStep 1: Substitute x with 2 in the function\\nWe replace every x in the function with 2. This gives us:\\nf(2) = 5(2)^3 - 2(2) + 3\\n\\nStep 2: Simplify the expression\\nNext, we simplify the expression by performing the operations in order from left to right.\\n\\nFirst, calculate the cube of 2, which is 8. Substitute this back into the expression:\\nf(2) = 5(8) - 4 + 3\\n\\nThen, multiply 5 by 8 which gives us 40:\\nf(2) = 40 - 4 + 3\\n\\nFinally, subtract 4 from 40 which gives us 36, and then add 3 to that:\\nf(2) = 36 + 3\\n\\nStep 3: Final calculation\\nNow, add 36 and 3 together:\\nf(2) = 39\\n\\nSo, the value of the function f(x) = 5x^3 - 2x + 3 at the point x = 2 is 39.\"\n        }\n    ],\n    batch_size=1,\n    pipeline=Pipeline(name=\"data-pipeline\")\n)\n</code></pre> <p>As we can see, this step doesn't have much processing logic to do, it will generate data with the batch size we tell it to:</p> <pre><code>&gt;&gt;&gt; next(load_data.process())\n([{'instruction': 'What if the Beatles had never formed as a band?', 'completion': 'The Beatles are widely credited with starting the British Invasion, a wave of rock and roll bands from the United Kingdom that became popular in America in the 1960s. If the Beatles had never formed, this musical movement may have never happened, and the world may have been exposed to a different kind of music. So, without the Beatles\u2019 fame and success, other bands wouldn\u2019t have been able to break into the American music scene and create a wider range of sounds. We could have ended up with a less interesting mix of songs playing on the radio.'}], False)\n</code></pre> <p>It will yield <code>GeneratorStepOutput</code> objects, an iterator of tuples where the first element is the batch of data, and the second is a boolean flag indicating whether this batch is the last one (to internally determine when to stop yielding data).</p>"},{"location":"sections/learn/steps/generator_steps/#loading-structured-data","title":"Loading structured data","text":"<p>Unless we are doing some testing, we are more likely going to work with a proper dataset:</p>"},{"location":"sections/learn/steps/generator_steps/#load-a-dataset-from-huggingface-hub","title":"Load a dataset from HuggingFace hub","text":"<p>The easiest way to ingest data from a dataset is using the <code>LoadHubDataset</code> step, let's see an example:</p> <pre><code>from distilabel.steps.generators.huggingface import LoadHubDataset\n\nload_hub_dataset = LoadHubDataset(\n    name=\"load_dataset\",\n    repo_id=\"distilabel-internal-testing/instruction-dataset-mini\",\n    split=\"test\",\n    batch_size=2,\n    pipeline=Pipeline(name=\"dataset-pipeline\")    \n)\nload_hub_dataset.load()\n</code></pre> <p>We see that creating a step to load a dataset from the hub is almost the same as loading it directly using <code>datasets.load_dataset</code>, with one remark, we have to call <code>.load()</code> on our step. The reason for this extra step is because internally we want to do the actual processing at the correct moment in the whole pipeline, we don't just need to take care of this call because we are working with it outside of a <code>Pipeline</code>.</p> <p>And let's request the following batch:</p> <pre><code>&gt;&gt;&gt; next(load_hub_dataset.process())\n([{'prompt': 'Arianna has 12 chocolates more than Danny. Danny has 6 chocolates more than Robbie. Arianna has twice as many chocolates as Robbie has. How many chocolates does Danny have?', 'completion': 'Denote the number of chocolates each person has by the letter of their first name. We know that\\nA = D + 12\\nD = R + 6\\nA = 2 * R\\n\\nThus, A = (R + 6) + 12 = R + 18\\nSince also A = 2 * R, this means 2 * R = R + 18\\nHence R = 18\\nHence D = 18 + 6 = 24', 'meta': {'id': 0, 'motivation_app': None, 'prompt': 'Arianna has 12 chocolates more than Danny. Danny has 6 chocolates more than Robbie. Arianna has twice as many chocolates as Robbie has. How many chocolates does Danny have?', 'input': None, 'completion': 'Denote the number of chocolates each person has by the letter of their first name. We know that\\nA = D + 12\\nD = R + 6\\nA = 2 * R\\n\\nThus, A = (R + 6) + 12 = R + 18\\nSince also A = 2 * R, this means 2 * R = R + 18\\nHence R = 18\\nHence D = 18 + 6 = 24', 'source': 'surge', 'category': 'Question Answering', 'subcategory': 'Math'}}, {'prompt': 'Write a plot summary for a comedic novel involving Elon Musk and sea travel.', 'completion': 'Elon Musk hires a team of experts to build the ultimate yacht, but when the yacht is completed, he realizes that he has no idea how to sail it. With the help of a quirky crew and a fearless captain, the playboy embarks on a wild and hilarious adventure across the open seas, where the crew have to keep Elon alive despite his inability to do anything himself. All the while, Elon takes credit for their hard work.', 'meta': {'id': 1, 'motivation_app': None, 'prompt': 'Write a plot summary for a comedic novel involving Elon Musk and sea travel.', 'input': None, 'completion': 'Elon Musk hires a team of experts to build the ultimate yacht, but when the yacht is completed, he realizes that he has no idea how to sail it. With the help of a quirky crew and a fearless captain, the playboy embarks on a wild and hilarious adventure across the open seas, where the crew have to keep Elon alive despite his inability to do anything himself. All the while, Elon takes credit for their hard work.', 'source': 'surge', 'category': 'Generation', 'subcategory': 'Story generation'}}], False)\n</code></pre> <p>We can see the same structure (for a different type of dataset) as we had with the simpler <code>LoadDataFromDicts</code>.</p>"},{"location":"sections/learn/steps/global_steps/","title":"Global Steps","text":"<p>The global steps are the ones that in order to do it's processing, they will need access to all the data at once. Some examples include creating a dataset to be pushed to the hub, or a filtering step in a <code>Pipeline</code>.</p>"},{"location":"sections/learn/steps/global_steps/#push-data-to-huggingface-hub-in-batches","title":"Push data to HuggingFace Hub in batches","text":"<p>The first example of a <code>global</code> step corresponds to <code>PushToHub</code>:</p> <pre><code>import os\n\nfrom distilabel.pipeline.local import Pipeline\nfrom distilabel.steps.globals.huggingface import PushToHub\n\npush_to_hub = PushToHub(\n    name=\"push_to_hub\",\n    repo_id=\"org/dataset-name\",\n    split=\"train\",\n    private=False,\n    token=os.getenv(\"HF_API_TOKEN\"),\n    pipeline=Pipeline(name=\"push-pipeline\"),\n)\n</code></pre> <p>This step can be used to push batches of the dataset to the hub as the process advances, enabling a checkpoint strategy in your pipeline.</p>"},{"location":"sections/learn/steps/global_steps/#data-filtering","title":"Data Filtering","text":"<p>For some pipelines we may need to filter data according to some criteria. For example, the implementation of <code>DeitaFiltering</code> does some filtering to determine the examples to keep according to ensure the final dataset has enough diversity. We will see this step in it's own place because it may be difficult to follow out of context.</p>"},{"location":"sections/learn/tasks/","title":"Tasks","text":"<p>This section presents the <code>Task</code> class, a more concrete implementation of a <code>Step</code> that includes extra formatting and the <code>LLM</code> to be directly used in a <code>Pipeline</code>.</p>"},{"location":"sections/learn/tasks/#what-is-a-task-in-distilabel","title":"What is a Task in distilabel?","text":"<p>The <code>Task</code> is a special type of <code>Step</code> that adds a both a <code>format_input</code> and <code>format_output</code> method to the interface, and it's directly related to the <code>LLM</code>, using it as the engine to generate text for us. Let's see an example:</p> <pre><code>import os\n\nfrom distilabel.pipeline import Pipeline\nfrom distilabel.llms.mistral import MistralLLM\nfrom distilabel.steps.tasks.text_generation import TextGeneration\n\ntext_generation = TextGeneration(\n    name=\"text-generation\",\n    llm=MistralLLM(\n        model=\"mistral-tiny\",\n        api_key=os.getenv(\"MISTRALAI_API_KEY\"),  # type: ignore\n    ),\n    input_batch_size=8,\n    pipeline=Pipeline(name=\"sample-text-pipeline\")\n)\n\n# remember to call .load() if testing outside of a Pipeline context\ntext_generation.load()\n</code></pre> <p>We have chosen the most direct type of task, <code>TextGeneration</code>, and <code>MistralLLM</code> with <code>mistral-tiny</code>, the API serving Mistral-7B-Instruct-v0.2. Other than the <code>llm</code>, it's just another type of step, but thanks to the freedom the API let's you, they can be as complex as needed:</p> <pre><code>result = next(text_generation.process([{\"instruction\": \"What's synthetic generated text?\"}]))\n</code></pre> <p>This simple task will add a <code>generation</code> entry in our task's response, let's take a look:</p> <pre><code>print(result[0][\"generation\"])\n# Synthetic generated text refers to text that is created artificially by a computer or machine learning model, rather than being written by a human. This text is often generated based on existing data or rules, and can be used for various purposes such as language translation, text summarization, chatbot responses, or even creative writing.\n\n# One common type of synthetic generated text is known as \"text-to-text\" models, which generate new text based on a given input text. For example, a text-to-text model might be trained on a large dataset of English sentences, and then be able to generate a new sentence based on a given input sentence.\n\n# Another type of synthetic generated text is known as \"text-to-image\" models, which generate descriptions or captions for images. These models can be useful for accessibility purposes, or for generating captions for social media or e-commerce websites.\n\n# Synthetic generated text can be generated in a variety of ways, including using rule-based systems, statistical models, or deep learning models. The quality and accuracy of synthetic generated text can vary widely depending on the specific model and the data it was trained on.\n</code></pre>"},{"location":"sections/learn/tasks/#defining-your-own-task","title":"Defining your own Task","text":"<p>We will see how to create our own task in case we need some extra tuning other than the ones offered. We are going to recreate the generation task from Magicoder: Source Code Is All You Need.</p> <pre><code>from typing import Any, Dict, List, Union\n\nfrom distilabel.steps.tasks.base import Task\nfrom distilabel.steps.tasks.typing import ChatType\n\noss_instruct_prompt = \"\"\"Please gain inspiration from the following random code snippet to create a high-quality programming problem. Present your output in two distinct sections:\n[Problem Description] and [Solution].\nCode snippet for inspiration:\n\n{code}\n\nGuidelines for each section:\n1. [Problem Description]: This should be **completely self-contained**, providing\nall the contextual information one needs to understand and solve the problem.\nAssume common programming knowledge, but ensure that any specific context,\nvariables, or code snippets pertinent to this problem are explicitly included.\n2. [Solution]: Offer a comprehensive, **correct** solution that accurately\naddresses the [Problem Description] you provided.\n\"\"\"\n\nclass OSSInstruct(Task):\n    _system_prompt: str = \"You are exceptionally skilled at crafting high-quality programming problems and offering precise solutions.\"\n    _template: str = oss_instruct_prompt\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        return [\"code_snippet\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; ChatType:\n        return [\n            {\n                \"role\": \"system\",\n                \"content\": self._system_prompt,\n                \"role\": \"user\",\n                \"content\": self._template.format(code=input[\"code_snippet\"])\n            },\n        ]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        return [\"problem\", \"solution\"]\n\n    def format_output(\n        self, output: Union[str, None], input: Dict[str, Any]\n    ) -&gt; Dict[str, Any]:\n        problem, solution = output.split(\"[Solution]\")\n        return {\n            \"problem\": problem.replace(\"[Problem Description]\", \"\").strip(),\n            \"solution\": solution.strip()\n        }\n</code></pre> <p>Let's instantiate our custom task:</p> <pre><code>import os\n\nfrom distilabel.pipeline import Pipeline\nfrom distilabel.llms.mistral import MistralLLM\n\noss_instruct = OSSInstruct(\n    name=\"oss-generation\",\n    num_instructions=1,\n    input_batch_size=8,\n    llm=MistralLLM(\n        model=\"mistral-medium\",\n        api_key=os.getenv(\"MISTRALAI_API_KEY\"),  # type: ignore\n    ),\n    pipeline=Pipeline(name=\"oss-instruct-pipeline\")\n)\n\n# remember to call .load() if testing outside of a Pipeline context\noss_instruct.load()\n</code></pre> <p>And we can generate our own pair of problem and solution by calling the process method:</p> <pre><code>code_snippet = \"\"\"with Pipeline(name=\"quick-example\") as pipeline:\n    load_dataset = LoadHubDataset(\n        name=\"load_dataset\", output_mappings={\"prompt\": \"instruction\"}\n    )\"\"\"\nresult = next(oss_instruct.process([{\"code_snippet\": code_snippet}]))\n</code></pre> <p>And we will print next the synthetic problem and solution generated starting from the code snippet:</p> <pre><code>print(result[0][\"problem\"])\n# In this problem, you will be working with the `Pipeline` class from a hypothetical machine learning library, called `mlflow`. The goal is to create a pipeline that takes a dataset from HubDataset, processes it, and saves the output to a specified location. The dataset contains instructions that a text generation model should follow to generate text. Your task is to:\n\n# 1. Load the dataset using the `LoadHubDataset` component and map the column containing the instructions to the key \"prompt\".\n# 2. Create a custom component named `TextGeneration` that uses a pre-trained text generation model to generate text based on the prompts. The component should take the prompts as input and output the generated text.\n# 3. Save the generated text to a CSV file using the `SaveToCSV` component.\n\n# The final pipeline should be named \"text-generation-pipeline\". Here is some additional information about the components:\n\n# - `LoadHubDataset`: A component that loads a dataset from the `mlflow` HubDataset. It takes no arguments, but you can specify the output mappings to rename or select specific columns.\n# - `TextGeneration`: A custom component that you need to create. It should take prompts as input and output the generated text. In this problem, you can assume that you have access to a pre-trained text generation model called `generator` that takes a prompt as input and returns the generated text.\n# - `SaveToCSV`: A component that saves the input data to a CSV file. It takes a `path` argument to specify the output file location.\n\n# Your task is to implement the `TextGeneration` component and create the complete pipeline as described above.\n\nprint(result[0][\"solution\"])\n# First, let's define the `TextGeneration` component. This component will take the prompts as input and use a pre-trained text generation model to generate text.\n\n# ```python\n# from mlflow.components import func_to_component\n# import numpy as np\n\n# def generate_text(prompts: np.ndarray) -&gt; np.ndarray:\n#     # Assuming you have a pre-trained text generation model called `generator`\n#     text = generator.generate(prompts)\n#     return np.array(text)\n\n# TextGeneration = func_to_component(generate_text)\n# ```\n\n# Now, let's create the complete pipeline.\n\n# ```python\n# from mlflow.pipeline import Pipeline\n# from mlflow.components.builtin import LoadHubDataset, SaveToCSV\n\n# with Pipeline(name=\"text-generation-pipeline\") as pipeline:\n#     load_dataset = LoadHubDataset(\n#         name=\"load_dataset\", output_mappings={\"prompt\": \"instruction\"}\n#     )\n\n#     generate_text_task = TextGeneration(name=\"generate_text_task\")\n\n#     save_to_csv = SaveToCSV(name=\"save_to_csv\", path=\"generated_text.csv\")\n\n#     # Set up the pipeline flow\n#     load_dataset &gt;&gt; generate_text_task &gt;&gt; save_to_csv\n# ```\n\n# This pipeline first loads the dataset using the `LoadHubDataset` component, maps the \"instruction\" column to the key \"prompt\", and passes it to the `TextGeneration` component. The `TextGeneration` component uses the pre-trained text generation model to generate text based on the prompts. Finally, the generated text is saved to a CSV file using the `SaveToCSV` component.\n</code></pre> <p>One can get as creative as needed with their tasks.</p>"},{"location":"sections/learn/tasks/#types-of-tasks","title":"Types of Tasks","text":"<p>The following are the different sections in which we can distinguish the types of <code>Tasks</code> you can expect in <code>distilabel</code>:</p>"},{"location":"sections/learn/tasks/#the-general-text-generation","title":"The general text generation","text":"<p>The main task of an <code>LLM</code> is the text generation, but this text generation can be guided to follow our instructions. The text generation tasks include the broad text generation classes to make custom implementations and some more specific <code>Tasks</code> that have appeared in the literature that can be used to generate text according to some given criteria.</p>"},{"location":"sections/learn/tasks/#feedback-tasks","title":"Feedback tasks","text":"<p>Another type of tasks are those whose intent is to return some kind of feedback, generally in the form of a numeric score or rate, and optionally an explanation of how it got to that. Take a look at the feedback tasks here.</p>"},{"location":"sections/learn/tasks/#special-kinds-of-tasks","title":"Special kinds of tasks","text":"<p>There is a different type of task, in the sense that they don't inherit from <code>Task</code> but from <code>Step</code> (in general due to some kind of restriction), but they can be considered <code>Tasks</code> anyway. This block includes the embedding generation for a posterior process, or some specific implementation of a task like ranking, but that is for example restricted to a specific framework or library and cannot work like the more general <code>Task</code> classes. More information here.</p>"},{"location":"sections/learn/tasks/feedback_tasks/","title":"Feedback Tasks","text":"<p>This section presents tasks that work on the <code>LLM</code> output to return some feedback on the inputs, like <code>UltraFeedback</code> which asks an <code>LLM</code> to rate the responses according to some criteria.</p>"},{"location":"sections/learn/tasks/feedback_tasks/#ultrafeedback","title":"UltraFeedback","text":"<p><code>UltraFeedback</code> is a <code>Task</code> inspired from <code>UltraFeedback: Boosting Language Models with High-quality Feedback</code>, where the authors present the methodology that leaded to the creation of their famous dataset:</p> <pre><code>from distilabel.steps.tasks import UltraFeedback\nfrom distilabel.llms import OpenAILLM\n\nultrafeedback = UltraFeedback(\n    name=\"ultrafeedback_openai\",\n    llm=OpenAILLM(model=\"gpt-4\"),\n    aspect=\"overall-rating\",\n)\n</code></pre> <p>Will see in the following section what this <code>aspect</code> does, let's take a look first at how this task works:</p> <pre><code>result = ultrafeedback.process(\n    [\n        {\n            \"instruction\": \"Arianna has 12 chocolates more than Danny. Danny has 6 chocolates more than Robbie. Arianna has twice as many chocolates as Robbie has. How many chocolates does Danny have?\",\n            \"generations\": [\n                \"To find the number of chocolates Danny has, we can first write an equation that relates the number of chocolates Arianna, Danny, and Robbie have.\\n\\nArianna has 12 more chocolates than Danny, so we can write:\\n\\nArianna = Danny + 12 (1)\\n\\nDanny has 6 more chocolates than Robbie, so we can write:\\n\\nDanny = Robbie + 6 (2)\\n\\nArianna has twice as many chocolates as Robbie has, so we can write:\\n\\n\",\n                \"Let\\u0027s use algebra to solve this problem.\\n\\nLet\\u0027s use the following variables:\\n\\n* C = the number of chocolates Robbie has\\n* C + 6 = the number of chocolates Danny has\\n* C + 12 = the number of chocolates Arianna has\\n\\nWe know that Arianna has twice as many chocolates as Robbie, so we can write:\\n\\nC + 12 = 2 \\\\* C\\n\\nNow we can solve for C:\\n\\nC + 12 = 2 \\\\* C\\n12 = C\\n\\nSo Robbie has 12 chocolates.\\n\\nDanny has 6 more\"\n            ]\n        }\n    ]\n)\n</code></pre> <p>After asking the <code>LLM</code> we will obtain the <code>ratings</code>, that represent the relative rate the <code>LLM</code> assigned following the prompt, as well as the <code>rationale</code> that yielded this values:</p> <pre><code>import json\nprint(json.dumps(next(result), indent=2))\n# {\n#     \"generation_models\": [\n#         \"argilla/notus-7b-v1\",\n#         \"HuggingFaceH4/zephyr-7b-gemma-v0.1\"\n#     ],\n#     \"generations\": [\n#         \"To find the number of chocolates Danny has, we can first write an equation that relates the number of chocolates Arianna, Danny, and Robbie have.\\n\\nArianna has 12 more chocolates than Danny, so we can write:\\n\\nArianna = Danny + 12 (1)\\n\\nDanny has 6 more chocolates than Robbie, so we can write:\\n\\nDanny = Robbie + 6 (2)\\n\\nArianna has twice as many chocolates as Robbie has, so we can write:\\n\\n\",\n#         \"Let\\u0027s use algebra to solve this problem.\\n\\nLet\\u0027s use the following variables:\\n\\n* C = the number of chocolates Robbie has\\n* C + 6 = the number of chocolates Danny has\\n* C + 12 = the number of chocolates Arianna has\\n\\nWe know that Arianna has twice as many chocolates as Robbie, so we can write:\\n\\nC + 12 = 2 \\\\* C\\n\\nNow we can solve for C:\\n\\nC + 12 = 2 \\\\* C\\n12 = C\\n\\nSo Robbie has 12 chocolates.\\n\\nDanny has 6 more\"\n#     ],\n#     \"instruction\": \"Arianna has 12 chocolates more than Danny. Danny has 6 chocolates more than Robbie. Arianna has twice as many chocolates as Robbie has. How many chocolates does Danny have?\",\n#     \"ratings\": [\n#         2,\n#         3\n#     ],\n#     \"rationales\": [\n#         \"The Text 1 has moderate quality. The initial mathematical relationships are correct, but the task of solving the equations and finding out the number of chocolates Danny has is left incomplete. Therefore, it doesn\\u0027t fully provide the informative and accurate answer required. \",\n#         \"The Text 2 has good quality. The text begins to solve the problem using algebra and successfully finds the number of chocolates Robbie has. However, it does not fully answer the instruction since the number of chocolates that Danny has is not ultimately included\"\n#     ],\n#     \"ultrafeedback_model\": \"gpt-4\"\n# }\n</code></pre> <p>Let's see what this different aspects mean.</p>"},{"location":"sections/learn/tasks/feedback_tasks/#different-aspects-of-ultrafeedback","title":"Different aspects of UltraFeedback","text":"<p>The <code>UltraFeedback</code> paper proposes different types of aspect to rate the answers: <code>helpfulness</code>, <code>honesty</code>, <code>instruction-following</code>, <code>truthfulness</code>. If one want's to rate the responses according to the 4 aspects, it would imply running the <code>Pipeline</code> 4 times, incurring in more costs and time of processing. For that reason, we decided to include an extra aspect, which tries to sum up the other ones to return a special type of summary: <code>overall-rating</code>.</p> <p>Note</p> <p>Take a look at this task in a complete <code>Pipeline</code> at <code>UltraFeedback</code>, where you can follow the paper implementation.</p>"},{"location":"sections/learn/tasks/feedback_tasks/#deita-scorers","title":"Deita Scorers","text":"<p>The <code>DEITA</code> paper (<code>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</code>) includes two <code>Tasks</code> that are in charge of rating the complexity and quality of the instructions and responses generate.</p> <p>Note</p> <p>Take a look at this task in a complete <code>Pipeline</code> at <code>DEITA</code>, where you can follow the paper implementation.</p>"},{"location":"sections/learn/tasks/feedback_tasks/#evol-complexity-scorer","title":"Evol Complexity Scorer","text":"<p>The <code>ComplexityScorer</code> is in charge of assigning a score to a list of instructions based on its complexity:</p> <pre><code>from distilabel.llms import OpenAILLM\nfrom distilabel.steps.tasks.complexity_scorer import ComplexityScorer\n\nscorer = ComplexityScorer(\n    name=\"complexity_scorer\",\n    llm=OpenAILLM(model=\"gpt-3.5-turbo\"),\n    pipeline=Pipeline(name=\"complexity-scorer-pipeline\"),\n)\nscorer.load()\n</code></pre> <p>It takes a list of instructions of the following form:</p> <pre><code>result = next(\n    scorer.process(\n        [\n            {\n                \"instructions\": [\n                    \"instruction 1\",\n                    \"instruction 2\"\n                    \"instruction 3\"\n                ]\n            }\n        ]\n    )\n)\n</code></pre> <p>And generates the corresponding list of scores:</p> <pre><code>print(result)\n# [1.0, 2.0, 1.0]\n</code></pre> <p>Warning</p> <p>Keep in mind that this step can fail either due to the <code>LLM</code> not being able to return a score, or return a bad generation which isn't parseable. Using a stronger model for this task reduces the chances of this type of errors.</p>"},{"location":"sections/learn/tasks/feedback_tasks/#evol-quality-scorer","title":"Evol Quality Scorer","text":"<p>The second task presented in the <code>DEITA</code> paper for scoring <code>QualityScorer</code>, a pre-defined task that defines the <code>instruction</code> as the input and <code>score</code> as the output.</p> <pre><code>from distilabel.llms import OpenAILLM\nfrom distilabel.steps.tasks.quality_scorer import QualityScorer\n\nscorer = QualityScorer(\n    name=\"quality_scorer\",\n    llm=OpenAILLM(model=\"gpt-3.5-turbo\"),\n    pipeline=Pipeline(name=\"quality-scorer-pipeline\"),\n)\nscorer.load()\n</code></pre> <p>It works like the previous <code>ComplexityScorer</code> task, but works on both instruction and responses:</p> <pre><code>result = next(\n    scorer.process(\n        [\n            {\n                \"instructin\": \"instruction 1\",\n                \"responses\": [\n                    \"instruction 1\",\n                    \"instruction 2\"\n                    \"instruction 3\"\n                ]\n            }\n        ]\n    )\n)\n</code></pre> <p>And generates the corresponding list of scores:</p> <pre><code>print(result)\n# [1.0, 2.0, 1.0]\n</code></pre> <p>Warning</p> <p>Keep in mind that this step can fail either due to the <code>LLM</code> not being able to return a score, or return a bad generation which isn't parseable. Using a stronger model for this task reduces the chances of this type of errors.</p>"},{"location":"sections/learn/tasks/special_tasks/","title":"Special Tasks","text":"<p>This section covers some tasks that don't implement the <code>Task</code> API, but can be thought of as tasks, instead they inherit from <code>Step</code>.</p>"},{"location":"sections/learn/tasks/special_tasks/#embedding-generation","title":"Embedding Generation","text":"<p>The <code>DEITA</code> paper needs to tackle the challenge of ensuring diversity in the final dataset, and they propose an embedding-based method to filter the dataset. For this end, the <code>GenerateEmbeddings</code> step is in charge of generating embeddings for the datasets' text.</p> <pre><code>from distilabel.llms.huggingface.transformers import TransformersLLM\nfrom distilabel.pipeline.local import Pipeline\nfrom distilabel.steps.tasks.generate_embeddings import GenerateEmbeddings\n\nllm = TransformersLLM(\n    model=\"TaylorAI/bge-micro-v2\",\n    model_kwargs={\"is_decoder\": True},\n)\nllm.load()\n\ntask = GenerateEmbeddings(\n    name=\"task\",\n    llm=llm,\n    pipeline=Pipeline(name=\"unit-test-pipeline\"),\n)\n</code></pre> <p>This step needs an <code>LLM</code> to generate the embeddings, we have chosen to use a <code>TransformersLLM</code> with <code>TaylorAI/bge-micro-v2</code> in this case. Upon call, this step will compute the embedding for the input text and add it to the row:</p> <pre><code>result = next(task.process([{\"text\": \"Hello, how are you?\"}]))\nprint(result[0][\"embedding\"])\n# [-8.12729941, -5.24642847, -6.34003029, ...]\n</code></pre>"},{"location":"sections/learn/tasks/special_tasks/#ranking-llm-responses","title":"Ranking LLM Responses","text":"<p>Jian et al. present in their paper <code>LLM-Blender: Ensembling Large Language Models with Pairwise Ranking and Generative Fusion</code> a \"small\" model that is able to take a instruction and a pair output candidates, and output a score for each candidate to measure their relative quality, hence ranking the responses. You can use <code>PairRM</code> in distilabel to accomplish this task, let's see how it works:</p> <pre><code>from distilabel.pipeline.local import Pipeline\nfrom distilabel.steps.tasks.pair_rm import PairRM\n\nranker = PairRM(\n    name=\"pair_rm_ranker\", pipeline=Pipeline(name=\"ranking-pipeline\")\n)\n# NOTE:\u00a0Keep in mind this call will automatically try to load an LLM internally\nranker.load()\n</code></pre> <p>For this step the model is fixed by default contrary to other steps, as the implementation relies completely on <code>LLM-Blender</code> for it to work.</p> <p>To ingest data for this task you would need an input, which corresponds to the instruction, and a list of candidates to compare, that the model will rank working on pairs:</p> <pre><code>result = next(\n    ranker.process(\n        [\n            {\"input\": \"Hello, how are you?\", \"candidates\": [\"fine\", \"good\", \"bad\"]},\n        ]\n    )\n)\n</code></pre> <p>Let's see what the result looks like:</p> <pre><code>import json\nprint(json.dumps(result, indent=2))\n# [\n#   {\n#     \"input\": \"Hello, how are you?\",\n#     \"candidates\": [\n#       \"fine\",\n#       \"good\",\n#       \"bad\"\n#     ],\n#     \"ranks\": [\n#       2,\n#       1,\n#       3\n#     ],\n#     \"ranked_candidates\": [\n#       \"good\",\n#       \"fine\",\n#       \"bad\"\n#     ]\n#   }\n# ]\n</code></pre> <p>We see we have both the <code>ranks</code>, that determine the position that would order the <code>candidates</code> field, and the <code>ranked_candidates</code> in case these want to be used directly.</p>"},{"location":"sections/learn/tasks/special_tasks/#filtering-data-to-ensure-diversity","title":"Filtering data to ensure diversity","text":"<p>We have already mentioned a global step that appeared in the <code>Global Steps</code> section, but it was quite specific to be introduced at that time. This <code>Task</code> is the <code>DeitaFiltering</code> step.</p> <p>It's a special type of step developed to reproduce the <code>DEITA</code> paper, in charge of filtering responses according to a predefined score. Let's see how it is defined:</p> <pre><code>from distilabel.pipeline.local import Pipeline\nfrom distilabel.steps.deita import DeitaFiltering\n\ndeita_filtering = DeitaFiltering(\n    name=\"deita_filtering\",\n    data_budget=1,\n    pipeline=Pipeline(name=\"deita-filtering-pipeline\"),\n)\n#\u00a0Remember to call the load method if working outside of a Pipeline context\ndeita_filtering.load()\n</code></pre> <p>This step is prepared to work on <code>DEITA</code> outputs: It expects instructions evolved following the <code>Evol Instruct</code> procedure, with a score assigned to the complexity of the instruction and the quality of the response (<code>ComplexityScorer</code> and <code>QualityScorer</code> respectively), and embeddings computed on the responses. The following is a random example following the structure of the input needed from the process method:</p> <pre><code>result = next(\n    deita_filtering.process(\n        [\n            {\n                \"evol_instruction_score\": 0.5,\n                \"evol_response_score\": 0.5,\n                \"embedding\": [-8.12729941, -5.24642847, -6.34003029],\n            },\n            {\n                \"evol_instruction_score\": 0.6,\n                \"evol_response_score\": 0.6,\n                \"embedding\": [2.99329242, 0.7800932, 0.7799726],\n            },\n            {\n                \"evol_instruction_score\": 0.7,\n                \"evol_response_score\": 0.7,\n                \"embedding\": [10.29041806, 14.33088073, 13.00557506],\n            },\n        ]\n    )\n)\n</code></pre> <p>And this is what we could expect from the output:</p> <pre><code>import json\n\nprint(json.dumps(result, indent=2))\n# [\n#   {\n#     \"evol_instruction_score\": 0.5,\n#     \"evol_response_score\": 0.5,\n#     \"embedding\": [\n#       -8.12729941,\n#       -5.24642847,\n#       -6.34003029\n#     ],\n#     \"deita_score\": 0.25,\n#     \"deita_score_computed_with\": [\n#       \"evol_instruction_score\",\n#       \"evol_response_score\"\n#     ],\n#     \"nearest_neighbor_distance\": 1.9042812683723933\n#   }\n# ]\n</code></pre> <p>We would obtain the dataset size expected for our <code>data_budget</code> and <code>diversity_threshold</code> set. For more information on how this <code>Task</code> works take a look at the <code>API Reference</code>.</p>"},{"location":"sections/learn/tasks/text_generation/","title":"Text Generation","text":"<p>This section will walk you through the tasks designed to generate text, from the most basic case to more involved ones like <code>SelfInstruct</code>, which allows to generate instructions starting from a number of seed terms.</p>"},{"location":"sections/learn/tasks/text_generation/#the-text-generation-task","title":"The text generation task","text":"<p>The first <code>Task</code> that we will present is the most general one: <code>TextGeneration</code>. This is a pre-defined task that defines the <code>instruction</code> as the input and <code>generation</code> as the output. We can make use of this task for example with a dataset that already has all the instructions ready to be sent to be used:</p> <pre><code>import os\n\nfrom distilabel.pipeline import Pipeline\nfrom distilabel.llms.mistral import MistralLLM\nfrom distilabel.steps.tasks.text_generation import TextGeneration\n\ntext_generation = TextGeneration(\n    name=\"text-generation\",\n    llm=MistralLLM(\n        model=\"mistral-tiny\",\n        api_key=os.getenv(\"MISTRALAI_API_KEY\"),  # type: ignore\n    ),\n    input_batch_size=8,\n    pipeline=Pipeline(name=\"text-gen-pipeline\")\n)\n\n# remember to call .load() if testing outside of a Pipeline context\ntext_generation.load()\n</code></pre> <p>We can just pass a simple task to test it:</p> <pre><code>result = next(\n    text_generation.process(\n        [\n            {\n                \"instruction\": \"What if the Beatles had never formed as a band?\",\n            },\n        ] \n    )\n)\n</code></pre> <p>And this is what <code>mistral-tiny</code> has to tell us to the question:</p> <pre><code>print(result[0][\"generation\"])\n# The formation of The Beatles in 1960 marked the beginning of a musical revolution that would last for decades. Their innovative songwriting, unique harmonies, and groundbreaking recordings continue to influence musicians and shape the music industry. However, had they never formed as a band, the musical landscape would have looked very different.\n\n# In the absence of The Beatles, other bands and artists would have taken the lead in the British Invasion of the US music charts. Some possibilities include:\n\n# 1. The Rolling Stones: The Rolling Stones emerged as a major rival to The Beatles, and they were also a crucial part of the British Invasion. They developed their own unique sound, with a raw, edgier approach that contrasted with The Beatles' more polished style.\n# 2. The Who: The Who was another influential British band that rose to prominence during the same period as The Beatles. They were known for their powerful live performances and innovative approach to rock music.\n# 3. Gerry &amp; The Pacemakers: Gerry &amp; The Pacemakers were an early Merseybeat band, and they had several hits in the UK and the US before The Beatles. Had The Beatles not formed, they might have continued to be a major force in the music world.\n# 4. Cliff Richard: Cliff Richard was a successful pop singer in the UK before The Beatles, and he continued to have hits throughout the 1960s and beyond. He might have remained the dominant British pop star had The Beatles never emerged.\n# 5. Motown: The Beatles' influence extended beyond rock music, and their success paved the way for other genres to gain mainstream acceptance in the US. Motown, for instance, would have faced more resistance in breaking into the US market without The Beatles' paving the way.\n\n# It's also worth noting that The Beatles' influence extends far beyond their music. They were trendsetters in fashion, hairstyles, and cultural norms. Their break-up in 1970 marked the end of an era in popular culture, and the music industry has never been the same since. So, even if other bands and artists had taken their place, The Beatles' impact on music and culture would still be felt.\n</code></pre> <p>Let's see now how we can tweak this task to adhere a bit more to another more customized task.</p>"},{"location":"sections/learn/tasks/text_generation/#using-a-custom-prompt","title":"Using a custom prompt","text":"<p>The general <code>TextGeneration</code> task assumes our instructions need no further processing, and that we don't want to further process the response of the task for example. Let's see how we can customize the <code>TextGeneration</code> task to fit our use case.</p> <p>For the following example we will implement a step presented in <code>WizardLM: Empowering Large Language Models to Follow Complex Instructions</code>, which asks an <code>LLM</code> to check whether two instructions are equal or not to decide if we should keep or remove them as redundant:</p> <pre><code>import string\nfrom typing import Dict, Any, List\n\nfrom distilabel.steps.tasks.text_generation import TextGeneration\n\nsystem_prompt = \"You are an AI judge in charge of determining the equality of two instructions. \"\n\nwizardllm_equal_prompt = \"\"\"Here are two Instructions, do you think they are equal to each other and meet the following requirements?:\n1. They have the same constraints and requirments.\n2. They have the same depth and breadth of the inquiry.\nThe First Prompt: {instruction_1}\nThe Second Prompt: {instruction_2}\nYour Judgement (Just answer: Equal or Not Equal. No need to explain the reason):\"\"\"\n\n\nclass WizardLMEqualPrompts(TextGeneration):\n    _template: str = wizardllm_equal_prompt\n\n    @property\n    def inputs(self) -&gt; List[str]:\n        return [\"instruction_1\", \"instruction_2\"]\n\n    @property\n    def outputs(self) -&gt; List[str]:\n        return [\"response\"]\n\n    def format_input(self, input: Dict[str, Any]) -&gt; \"ChatType\":\n        return [\n            {\n                \"role\": \"system\", \"content\": system_prompt,\n                \"role\": \"user\", \"content\": self._template.format(**input)\n            }\n        ]\n\n    def format_output(self, output: str | None, input: Dict[str, Any]) -&gt; Dict[str, str]:\n        return {\"response\": output.translate(str.maketrans(\"\", \"\", string.punctuation))}\n</code></pre> <p>Now that we have our brand new task, let's use instantiate it (will use <code>MistralLLM</code>):</p> <pre><code>import os\n\nfrom distilabel.pipeline import Pipeline\nfrom distilabel.llms.mistral import MistralLLM\n\nwizardlm_equality = WizardLMEqualPrompts(\n    name=\"wizardlm_equality\",\n    llm=MistralLLM(\n        model=\"mistral-small\",\n        api_key=os.getenv(\"MISTRALAI_API_KEY\"),  # type: ignore\n    ),\n    input_batch_size=8,\n    pipeline=Pipeline(name=\"wizardlm-equality-pipeline\")\n)\n\n# remember to call .load() if testing outside of a Pipeline context\nwizardlm_equality.load()\n</code></pre> <p>Let's ask it to compare to random instructions:</p> <pre><code>result = next(\n    wizardlm_equality.process(\n        [\n            {\n                \"instruction_1\": \"What if the Beatles had never formed as a band?\",\n                \"instruction_2\": \"What are The Simpsons?\"\n            },\n        ] \n    )\n)\n</code></pre> <p>And see what we have in return:</p> <pre><code>import json\nprint(json.dumps(result, indent=2))\n# [\n#   {\n#     \"instruction_1\": \"What if the Beatles had never formed as a band?\",\n#     \"instruction_2\": \"What are The Simpsons?\",\n#     \"model_name\": \"mistral-small\",\n#     \"response\": \"Not Equal The first prompt is a counterfactual question that invites exploration of the Beatles impact on music and culture if they had not formed while the second prompt asks for an explanation or definition of a longrunning TV show The Simpsons They do not share the same constraints requirements depth or breadth of inquiry\"\n#   }\n# ]\n</code></pre> <p>Note</p> <p>We can see the <code>response</code> contains \"Not Equal\", but it didn't strictly followed the prompt as requested. This can be a hint that a more powerful model is required, or the prompt needs some extra tuning.</p>"},{"location":"sections/learn/tasks/text_generation/#guided-text-generation","title":"Guided text generation","text":"<p>Other than the base generation tasks, the literature has proposed some <code>Tasks</code> to provide extra functionality, like the following:</p>"},{"location":"sections/learn/tasks/text_generation/#self-instruct","title":"Self Instruct","text":"<p>The first we are going to look at is <code>SelfInstruct</code>. This pre-defined task is inspired by <code>Self-Instruct: Aligning Language Models with Self-Generated Instructions</code>, and has the following intent: given a number of instructions, a certain criteria for query generations, an application description, and an input, generates a number of instruction related to the given input and following what is stated in the criteria for query generation and the application description.</p> <pre><code>import os\n\nfrom distilabel.pipeline import Pipeline\nfrom distilabel.llms.mistral import MistralLLM\nfrom distilabel.steps.tasks.self_instruct import SelfInstruct\n\nself_instruct = SelfInstruct(\n    name=\"text-generation\",\n    num_instructions=3,\n    input_batch_size=8,\n    llm=MistralLLM(\n        model=\"mistral-medium\",\n        api_key=os.getenv(\"MISTRALAI_API_KEY\"),  # type: ignore\n    ),\n    pipeline=Pipeline(name=\"self-instruct-pipeline\")\n)\n\n# remember to call .load() if testing outside of a Pipeline context\nself_instruct.load()\n</code></pre> <p>Let's pass a simple input:</p> <pre><code>result = next(\n    self_instruct.process(\n        [\n            {\n                \"input\": \"What are fantasy novels?\",\n            },\n        ] \n    )\n)\n</code></pre> <p>And this is what we have in return:</p> <pre><code>import json\nprint(json.dumps(result[0][\"instructions\"], indent=2))\n# [\n#   \"1. Can you explain the common elements found in fantasy novels and their role in storytelling?\",\n#   \"2. Generate a brief summary of a popular fantasy novel, highlighting its unique features.\",\n#   \"3. Compare and contrast the world-building techniques used by two renowned fantasy authors.\"\n# ]\n</code></pre> <p>By tweaking the <code>num_instructions</code> and the <code>criteria_for_query_generation</code> we can see how this is a really powerful <code>Task</code> to generate synthetic data starting from a small amount of initial instructions.</p>"},{"location":"sections/learn/tasks/text_generation/#evol-instruct","title":"Evol Instruct","text":"<p>This <code>Task</code> was defined in WizardLM: Empowering Large Language Models to Follow Complex Instructions, the idea is, starting from a series of initial instructions, evolve them according to a scheme of prompts to obtain more complex ones. Let's see how we can use <code>EvolInstruct</code>:</p> <pre><code>import os\n\nfrom distilabel.pipeline import Pipeline\nfrom distilabel.llms.mistral import MistralLLM\nfrom distilabel.steps.tasks.evol_instruct.base import EvolInstruct\n\nevol_instruct = EvolInstruct(\n    name=\"evol-instruct\",\n    num_evolutions=2,\n    store_evolutions=True,\n    input_batch_size=8,\n    llm=MistralLLM(\n        model=\"mistral-small\",\n        api_key=os.getenv(\"MISTRALAI_API_KEY\"),  # type: ignore\n    ),\n    pipeline=Pipeline(name=\"evol-instruct-pipeline\")\n)\n\n# remember to call .load() if testing outside of a Pipeline context\nevol_instruct.load()\n</code></pre> <p>We can now use a sample instruction to see what that yields:</p> <pre><code>result = next(\n    evol_instruct.process(\n        [\n            {\n                \"instruction\": \"What are fantasy novels?\",\n            },\n        ] \n    )\n)\n</code></pre> <p>Note</p> <p>As we used <code>store_evolutions=True</code>, we now can see the evolution from the starting point. Remember to visit the <code>API Reference</code> to take into account all the parameters.</p> <p>Let's see the evolved instructions we obtained:</p> <pre><code>import json\nprint(json.dumps(result[0][\"evolved_instructions\"], indent=2))\n# [\n#   \"Can you name some lesser-known literary genres that explore imaginary worlds, magical elements, and epic adventures, similar to fantasy novels, but with a unique twist and a smaller readership?\",\n#   \"How about you suggest some under-the-radar literary categories that, much like fantasy literature, delve into fictional realms, incorporate magical aspects, and narrate grand journeys, but with a distinct flavor and a more limited, devoted readership?\"\n# ]\n</code></pre> <p>This strategy of evolving a set of instructions synthetically has yielded strong results as can be seen in the original paper, leading to the family of WizardLM.</p> <p>We will now take a look at some <code>EvolInstruct</code> inspired tasks that have been used for <code>DEITA</code> datasets.</p>"},{"location":"sections/learn/tasks/text_generation/#evol-complexity","title":"Evol Complexity","text":"<p><code>EvolComplexity</code> evolves the instructions to make them specifically more complex. It follows the evolutionary approach from <code>EvolInstruct</code> but with slightly different prompts.</p> <pre><code>import os\n\nfrom distilabel.pipeline import Pipeline\nfrom distilabel.llms.mistral import MistralLLM\nfrom distilabel.steps.tasks.evol_instruct.evol_complexity.base import EvolComplexity\n\nevol_complexity = EvolComplexity(\n    name=\"evol-complexity\",\n    num_evolutions=1,\n    input_batch_size=8,\n    llm=MistralLLM(\n        model=\"mistral-small\",\n        api_key=os.getenv(\"MISTRALAI_API_KEY\"),  # type: ignore\n    ),\n    pipeline=Pipeline(name=\"evol-complexity-pipeline\")\n)\n\n# remember to call .load() if testing outside of a Pipeline context\nevol_complexity.load()\n</code></pre> <p>Let's see it with the same previous example from <code>EvolInstruct</code>, this time with a single evolution and keeping the last generation:</p> <pre><code>result = next(\n    evol_complexity.process(\n        [\n            {\n                \"instruction\": \"What are fantasy novels?\",\n            },\n        ] \n    )\n)\n</code></pre> <p>This would be the evolved instruction:</p> <pre><code>print(result[0][\"evolved_instruction\"])\n# Could you explain the literary genre of fantasy novels, providing examples and discussing how they differ from science fiction?\n\n# (Note: I added a requirement to discuss the differences between fantasy novels and science fiction, and tried to keep the prompt reasonably concise.)\n</code></pre> <p>And we have similar results to what we obtained with <code>EvolInstruct</code>, with a slight modification in the inner prompts used.</p> <p>Note</p> <p>Take into account there isn't just randomness from the <code>LLM</code>, but also from the mutation selected (the prompt used to evolve the instruction).</p>"},{"location":"sections/learn/tasks/text_generation/#evol-quality","title":"Evol Quality","text":"<p>The <code>EvolQuality</code> <code>Task</code> appeared in <code>What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning</code>, as a posterior step to the previous <code>EvolComplexityGenerator</code>. It takes a different approach: we evolve the quality of the responses given a prompt. Let's see an example:</p> <pre><code>import os\n\nfrom distilabel.pipeline import Pipeline\nfrom distilabel.llms.mistral import MistralLLM\nfrom distilabel.steps.tasks.evol_quality.base import EvolQuality\n\nevol_quality = EvolQuality(\n    name=\"evol-quality\",\n    num_evolutions=1,\n    input_batch_size=8,\n    llm=MistralLLM(\n        model=\"mistral-small\",\n        api_key=os.getenv(\"MISTRALAI_API_KEY\"),  # type: ignore\n    ),\n    pipeline=Pipeline(name=\"evol-quality-pipeline\")\n)\n\n# remember to call .load() if testing outside of a Pipeline context\nevol_quality.load()\n</code></pre> <p>We will use it on the output from <code>EvolComplexity</code> task:</p> <pre><code>result = next(\n    evol_quality.process(\n        [\n            {\n                \"instruction\": \"What are fantasy novels?\",\n                \"response\": \"Could you explain the literary genre of fantasy novels, providing examples and discussing how they differ from science fiction?\\n\\n(Note: I added a requirement to discuss the differences between fantasy novels and science fiction, and tried to keep the prompt reasonably concise.)\"\n            },\n        ] \n    )\n)\n</code></pre> <p>And we obtain in return an evolution from the previous response with a mutation applied to the response:</p> <pre><code>print(result[0][\"evolved_response\"])\n# Fantasy novels are a captivating genre of literature, immersing readers in imaginary worlds filled with magical elements, mythical creatures, and epic adventures. They often feature complex plotlines and unique characters, offering a delightful escape from reality.\n</code></pre> <p>Note</p> <p>Take into account that just as we had with the <code>EvolComplexity</code> task, there is randomness involved with the inner mutation prompt used.</p>"},{"location":"sections/papers/","title":"Paper reproductions","text":""},{"location":"sections/papers/#paper-implementations","title":"Paper Implementations","text":"<p>Contains some implementations for synthetic data generation papers, using <code>distilabel</code>, providing reproducible pipelines so that anyone can play around with those approaches and customize that to their needs. We strongly believe that better data leads to better models, and synthetic data has proven to be really effective towards improving LLMs, so we aim to bridge the gap between research and practice by providing these implementations.</p>"},{"location":"sections/papers/deita/","title":"What Makes Good Data for Alignment? A Comprehensive Study of Automatic Data Selection in Instruction Tuning","text":"<p>DEITA (Data-Efficient Instruction Tuning for Alignment) studies an automatic data selection process by first quantifying the data quality based on complexity, quality and diversity. And second, selecting across the best potential combination from an open-source dataset that would fit into the budget you allocate to tune your own LLM.</p> <p>In most setting we cannot allocate unlimited resources for instruction-tuning LLMs. Therefore, the DEITA authors investigated how to select qualitative data for instruction-tuning based on a principle of fewer high quality samples. Liu et al. tackle the issue of first defining good data and second identifying it to respect an initial budget to instruct-tune your LLM.</p> <p>The strategy utilizes LLMs to replace human effort in time-intensive data quality tasks on instruction tuning datasets. DEITA introduces a way to measure data quality across three critical dimensions: complexity, quality and diversity.</p> <p></p> <p>You can see that we see again the dataset of instructions/responses and we kind of reproducing the second step when we learn how to optimize the responses according to an instruction by comparing several possibilities.</p>"},{"location":"sections/papers/deita/#datasets-and-budget","title":"Datasets and budget","text":"<p>We will dive deeper into the whole process. We will investigate each stage to efficiently select the final dataset used for supervised fine-tuning with a budget constraint. We will tackle technical challenges by explaining exactly how you would assess good data as presented in the paper.</p> <p>As a reminder, we're looking for a strategy to automatically select good data for the instruction-tuning step when you want to fine-tune an LLM to your own use case taking into account a resource constraint. This means that you cannot blindly train a model on any data you encounter on the internet.</p> <p>The DEITA authors assume that you have access to open-source datasets that fit your use case. This may not be the case entirely. But with open-source communities tackling many use cases, with projects such as BLOOM or AYA, it's likely that your use case will be tackled at some point. Furthermore, you could generate your own instruction/response pairs with methods such as self-generated instructions using distilabel. This tutorial assumes that we have a data pool with excessive samples for the project's cost constraint. In short, we aim to achieve adequate performance from fewer samples.</p> <p>The authors claim that the subsample size \"correlates proportionally with the computation consumed in instruction tuning\". Hence on a first approximation, reducing the sample size means reducing computation consumption and so the total development cost. Reproducing the paper notations, we will associate the budget m to a number of instruction/response pairs that you can set depending on your real budget.</p> <p></p> <p>To match the experimental set-up, dataset X_sota is a meta-dataset combining major open-source datasets available to instruct-tune LLMs. This dataset is composed of ShareGPT (58k instruction/response pairs), UltraChat (105k instruction/response pairs) and WizardLM (143k instruction/response pairs). It sums to more than 300k instruction/response pairs. We aim to reduce the final subsample to 6k instruction/response pairs.</p>"},{"location":"sections/papers/deita/#setup-the-notebook-and-packages","title":"Setup the notebook and packages","text":"<p>Let's prepare our dependencies:</p> <pre><code>pip install \"distilabel[openai,hf-transformers]&gt;=1.0.0\"\npip install pynvml huggingface_hub argilla\n</code></pre> <p>Import distilabel:</p> <pre><code>from distilabel.llms import TransformersLLM, OpenAILLM\nfrom distilabel.pipeline import Pipeline\nfrom distilabel.steps import ConversationTemplate, DeitaFiltering, ExpandColumns, LoadHubDataset\nfrom distilabel.steps.tasks import ComplexityScorer, EvolInstruct, EvolQuality, GenerateEmbeddings, QualityScorer\n</code></pre> <p>Define the distilabel Pipeline and load the dataset from the Hugging Face Hub.</p> <pre><code>pipeline = Pipeline(name=\"DEITA\")\n\nload_data = LoadHubDataset(\n    name=\"load_data\", batch_size=100, output_mappings={\"prompt\": \"instruction\"}, pipeline=pipeline\n)\n</code></pre>"},{"location":"sections/papers/deita/#evol-instruct-generate-instructions-with-an-llm","title":"EVOL-INSTRUCT: Generate Instructions with an LLM","text":"<p>Evol-Instruct automates the creation of complex instruction data for training large language models (LLMs) by progressively rewriting an initial set of instructions into more complex forms. This generated data is then used to fine-tune a model named WizardLM.</p> <p>Evaluations show that instructions from Evol-Instruct are superior to human-created ones, and WizardLM achieves performance close to or exceeding GPT3.5-turbo in many skills. In distilabel, we initialise each step of the data generation pipeline. Later, we'll connect them together.</p> <pre><code>evol_instruction_complexity = EvolInstruct(\n    name=\"evol_instruction_complexity\",\n    llm=OpenAILLM(model=\"gpt-3.5-turbo\"),\n    num_evolutions=5,\n    store_evolutions=True,\n    generate_answers=True,\n    include_original_instruction=True,\n    pipeline=pipeline,\n)\n\nevol_instruction_complexity.load()\n\n_evolved_instructions = next(evol_instruction_complexity.process(\n    ([{\"instruction\": \"How many fish are there in a dozen fish?\"}]))\n)\n\nprint(*_evolved_instructions, sep=\"\\n\")\n</code></pre> <p>Output:</p> <pre><code>( 1, 'How many fish are there in a dozen fish?')\n( 2, 'How many rainbow trout are there in a dozen rainbow trout?')\n( 3, 'What is the average weight in pounds of a dozen rainbow trout caught in a specific river in Alaska during the month of May?')\n</code></pre>"},{"location":"sections/papers/deita/#evol-complexity-evaluate-complexity-of-generated-instructions","title":"EVOL COMPLEXITY: Evaluate complexity of generated instructions","text":"<p>The second step is the evaluation of complexity for an instruction in a given instruction-response pair. Like EVOL-INSTRUCT, this method uses LLMs instead of humans to automatically improve instructions, specifically through their complexity. From any instruction-response pair, \\((I, R)\\), we first generate new instructions following the In-Depth Evolving Response. We generate more complex instructions through prompting, as explained by authors, by adding some constraints or reasoning steps. Let\\'s take an example from GPT-4-LLM which aims to generate observations by GPT-4 to instruct-tune LLMs with supervised fine-tuning. And, we have the instruction \\(instruction_0\\):</p> <pre><code>instruction_0 = \"Give three tips for staying healthy.\"\n</code></pre> <p>To make it more complex, you can use, as the authors did, some prompt templates to add constraints or deepen the instruction. They provided some prompts in the paper appendix. For instance, this one was used to add constraints:</p> <pre><code>PROMPT = \"\"\"I want you act as a Prompt Rewriter.\nYour objective is to rewrite a given prompt into a more complex version to\nmake those famous AI systems (e.g., ChatGPT and GPT4) a bit harder to handle.\nBut the rewritten prompt must be reasonable and must be understood and\nresponded by humans.\nYour rewriting cannot omit the non-text parts such as the table and code in\n#Given Prompt#:. Also, please do not omit the input in #Given Prompt#.\nYou SHOULD complicate the given prompt using the following method:\nPlease add one more constraints/requirements into #Given Prompt#\nYou should try your best not to make the #Rewritten Prompt# become verbose,\n#Rewritten Prompt# can only add 10 to 20 words into #Given Prompt#.\n\u2018#Given Prompt#\u2019, \u2018#Rewritten Prompt#\u2019, \u2018given prompt\u2019 and \u2018rewritten prompt\u2019\nare not allowed to appear in #Rewritten Prompt#\n#Given Prompt#:\n&lt;Here is instruction&gt;\n#Rewritten Prompt#:\n\"\"\"\n</code></pre> <p>Prompting this to an LLM, you automatically get a more complex instruction, called \\(instruction_1\\), from an initial instruction \\(instruction_0\\):</p> <pre><code>instruction_1 = \"Provide three recommendations for maintaining well-being, ensuring one focuses on mental health.\"\n</code></pre> <p>With sequences of evolved instructions, we use a further LLM to automatically rank and score them. We provide the 6 instructions at the same time. By providing all instructions together, we force the scoring model to look at minor complexity differences between evolved instructions. Encouraging the model to discriminate between instructions. Taking the example below, \\(instruction_0\\) and \\(instruction_1\\) could deserve the same score independently, but when compared together we would notice the slight difference that makes \\(instruction_1\\) more complex.</p> <p>In <code>distilabel</code>, we implement this like so:</p> <pre><code>instruction_complexity_scorer = ComplexityScorer(\n    name=\"instruction_complexity_scorer\",\n    llm=OpenAILLM(model=\"gpt-3.5-turbo\"),\n    input_mappings={\"instructions\": \"evolved_instructions\"},\n    pipeline=pipeline,\n)\n\nexpand_evolved_instructions = ExpandColumns(\n    name=\"expand_evolved_instructions\",\n    columns=[\"evolved_instructions\", \"answers\", \"scores\"],\n    output_mappings={\n        \"evolved_instructions\": \"evolved_instruction\",\n        \"answers\": \"answer\",\n        \"scores\": \"evol_instruction_score\",\n    },\n    pipeline=pipeline,\n)\n\ninstruction_complexity_scorer.load()\n\n_evolved_instructions = next(instruction_complexity_scorer.process(([{\"evolved_instructions\": [PROMPT + instruction_1]}])))\n\nprint(\"Original Instruction:\")\nprint(instruction_1)\nprint(\"\\nEvolved Instruction:\")\nprint(_evolved_instructions[0][\"evolved_instructions\"][0].split(\"#Rewritten Prompt#:\\n\")[1])\n</code></pre> <p>Output:</p> <pre><code>Original Instruction:\nProvide three recommendations for maintaining well-being, ensuring one focuses on mental health.\n\nEvolved Instruction:\nSuggest three strategies for nurturing overall well-being, with the stipulation that at least one explicitly addresses the enhancement of mental health, incorporating evidence-based practices.\n</code></pre>"},{"location":"sections/papers/deita/#evol-quality-quality-evaluation","title":"EVOL-QUALITY: Quality Evaluation","text":"<p>Now that we have scored the complexity of the instructions, we will focus on the quality of the responses. Similar to EVOL COMPLEXITY, the authors introduced EVOL QUALITY, a method based on LLMs, instead of humans, to automatically score the quality of the response.</p> <p>From an instruction-response pair, \\((I, R)\\), the goal is to make the response evolve into a more helpful and relevant response. The key difference is that we need to also provide the first instruction to guide evolution. Let's take back our example from GPT-4-LLM.</p> <p>Here we have the response \\(response_0\\) and its initial instruction \\(instruction_0\\):</p> <pre><code>instruction_0 = \"Give three tips for staying healthy.\"\nreponse_0 = \"1. Eat a balanced and nutritious diet: Make sure your meals are inclusive of a variety of fruits and vegetables, lean protein, whole grains, and healthy fats. This helps to provide your body with the essential nutrients to function at its best and can help prevent chronic diseases. 2. Engage in regular physical activity: Exercise is crucial for maintaining strong bones, muscles, and cardiovascular health. Aim for at least 150 minutes of moderate aerobic exercise or 75 minutes of vigorous exercise each week. 3. Get enough sleep: Getting enough quality sleep is crucial for physical and mental well-being. It helps to regulate mood, improve cognitive function, and supports healthy growth and immune function. Aim for 7-9 hours of sleep each night.\"\n</code></pre> <p>Again the authors provided several prompts you could use to make your response evolve according to some guidelines. For example, this one was used to enrich the answer:</p> <pre><code>PROMPT = \"\"\"I want you to act as a Response Rewriter\nYour goal is to enhance the quality of the response given by an AI assistant\nto the #Given Prompt# through rewriting.\nBut the rewritten response must be reasonable and must be understood by humans.\nYour rewriting cannot omit the non-text parts such as the table and code in\n#Given Prompt# and #Given Response#. Also, please do not omit the input\nin #Given Prompt#.\nYou Should enhance the quality of the response using the following method:\nPlease make the Response more in-depth\nYou should try your best not to make the #Rewritten Response# become verbose,\n#Rewritten Response# can only add 10 to 20 words into #Given Response#.\n\u2018#Given Response#\u2019, \u2018#Rewritten Response#\u2019, \u2018given response\u2019 and \u2018rewritten response\u2019\nare not allowed to appear in #Rewritten Response#\n#Given Prompt#:\n&lt;instruction_0&gt;\n#Given Response#:\n&lt;response_0&gt;\n#Rewritten Response#:\n\"\"\"\n</code></pre> <p>Prompting this to an LLM, you will automatically get a more enriched response, called \\(response_1\\), from an initial response \\(response_0\\) and initial instruction \\(instruction_0\\):</p> <pre><code>evol_response_quality = EvolQuality(\n    name=\"evol_response_quality\",\n    llm=OpenAILLM(model=\"gpt-3.5-turbo\"),\n    num_evolutions=5,\n    store_evolutions=True,\n    include_original_response=True,\n    input_mappings={\n        \"instruction\": \"evolved_instruction\",\n        \"response\": \"answer\",\n    },\n    pipeline=pipeline,\n)\n\nevol_response_quality.load()\n\n_evolved_responses = next(evol_response_quality.process([{\"instruction\": PROMPT + instruction_0, \"response\": reponse_0}]))\n\nprint(\"Original Response:\")\nprint(reponse_0)\nprint(\"\\nEvolved Response:\")\nprint(*_evolved_responses[0]['evolved_responses'], sep=\"\\n\")\n</code></pre> <p>And now, as in EVOL COMPLEXITY you iterate through this path and use different prompts to make your responses more relevant, helpful or creative. In the paper, they make 4 more iterations to get 5 evolved responses \\((R0, R1, R2, R3, R4)\\) which makes 5 different responses for one initial instruction at the end of this step.</p> <pre><code>response_quality_scorer = QualityScorer(\n    name=\"response_quality_scorer\",\n    llm=OpenAILLM(model=\"gpt-3.5-turbo\"),\n    input_mappings={\n        \"instruction\": \"evolved_instruction\",\n        \"responses\": \"evolved_responses\",\n    },\n    pipeline=pipeline,\n)\n\nexpand_evolved_responses = ExpandColumns(\n    name=\"expand_evolved_responses\",\n    columns=[\"evolved_responses\", \"scores\"],\n    output_mappings={\n        \"evolved_responses\": \"evolved_response\",\n        \"scores\": \"evol_response_score\",\n    },\n    pipeline=pipeline,\n)\n\nresponse_quality_scorer.load()\n\n_scored_responses = next(response_quality_scorer.process([{\"instruction\": PROMPT + instruction_0, \"responses\": _evolved_responses[0]['evolved_responses']}]))\n\nprint(\"Original Response:\")\nprint(reponse_0)\n\nprint(\"\\nScore, Evolved Response:\")\nprint(*zip(_scored_responses[0][\"scores\"], _evolved_responses[0]['evolved_responses']), sep=\"\\n\")\n</code></pre> <p>Output:</p> <pre><code>Original Response:\n1. Eat a balanced and nutritious diet: Make sure your meals are inclusive of a variety of fruits and vegetables, lean protein, whole grains, and healthy fats. This helps to provide your body with the essential nutrients to function at its best and can help prevent chronic diseases. 2. Engage in regular physical activity: Exercise is crucial for maintaining strong bones, muscles, and cardiovascular health. Aim for at least 150 minutes of moderate aerobic exercise or 75 minutes of vigorous exercise each week. 3. Get enough sleep: Getting enough quality sleep is crucial for physical and mental well-being. It helps to regulate mood, improve cognitive function, and supports healthy growth and immune function. Aim for 7-9 hours of sleep each night.\n\nScore, Evolved Response:\n(4.0, 'Here are three essential tips for maintaining good health: \\n1. Prioritize regular exercise \\n2. Eat a balanced diet with plenty of fruits and vegetables \\n3. Get an adequate amount of sleep each night.')\n(2.0, 'Here are three effective strategies to maintain a healthy lifestyle.')\n(5.0, 'Here are three practical tips to maintain good health: Ensure a balanced diet, engage in regular exercise, and prioritize sufficient sleep. These practices support overall well-being.')\n</code></pre>"},{"location":"sections/papers/deita/#improving-data-diversity","title":"Improving Data Diversity","text":"<p>One main component of good data to instruct-tune LLMs is diversity. Real world data can often contain redundancy due repetitive and homogeneous data.</p> <p>The authors of the DEITA paper tackle the challenge of ensuring data diversity in the instruction tuning LLMs to avoid the pitfalls of data redundancy that can lead to over-fitting or poor generalization. They propose an embedding-based method to filter data for diversity. This method, called Repr Filter, uses embeddings generated by the Llama 1 13B model to represent instruction-response pairs in a vector space. The diversity of a new data sample is assessed based on the cosine distance between its embedding and that of its nearest neighbor in the already selected dataset. If this distance is greater than a specified threshold, the sample is considered diverse and is added to the selection. This process prioritizes diversity by assessing each sample's contribution to the variety of the dataset until the data selection budget is met. This approach effectively maintains the diversity of the data used for instruction tuning, as demonstrated by the DEITA models outperforming or matching state-of-the-art models with significantly less training data. In this implementation of DEITA we use the hidden state of the last layer of the Llama 2 model to generate embeddings, instead of a sentence transformer model, because we found that it improved the diversity of the data selection.</p> <p></p> <pre><code>generate_conversation = ConversationTemplate(\n    name=\"generate_conversation\",\n    input_mappings={\n        \"instruction\": \"evolved_instruction\",\n        \"response\": \"evolved_response\",\n    },\n    pipeline=pipeline,\n)\n\ngenerate_embeddings = GenerateEmbeddings(\n    name=\"generate_embeddings\",\n    llm=TransformersLLM(\n        model=\"TinyLlama/TinyLlama-1.1B-Chat-v1.0\",\n        device=\"cuda\",\n        torch_dtype=\"float16\",\n    ),\n    input_mappings={\"text\": \"conversation\"},\n    input_batch_size=5,\n    pipeline=pipeline,\n)\n\ndeita_filtering = DeitaFiltering(name=\"deita_filtering\", pipeline=pipeline)\n</code></pre>"},{"location":"sections/papers/deita/#build-the-distilabel-pipeline","title":"Build the \u2697 distilabel <code>Pipeline</code>","text":"<p>Now we're ready to build a <code>distilabel</code> pipeline using the DEITA method:</p> <pre><code>load_data.connect(evol_instruction_complexity)\nevol_instruction_complexity.connect(instruction_complexity_scorer)\ninstruction_complexity_scorer.connect(expand_evolved_instructions)\nexpand_evolved_instructions.connect(evol_response_quality)\nevol_response_quality.connect(response_quality_scorer)\nresponse_quality_scorer.connect(expand_evolved_responses)\nexpand_evolved_responses.connect(generate_conversation)\ngenerate_conversation.connect(generate_embeddings)\ngenerate_embeddings.connect(deita_filtering)\n</code></pre> <p>Now we can run the pipeline. We use the step names to reference them in the pipeline configuration:</p> <pre><code>distiset = pipeline.run(\n    parameters={\n        \"load_data\": {\n            \"repo_id\": \"distilabel-internal-testing/instruction-dataset-50\",\n            \"split\": \"train\",\n        },\n        \"evol_instruction_complexity\": {\n            \"llm\": {\"generation_kwargs\": {\"max_new_tokens\": 512, \"temperature\": 0.7}}\n        },\n        \"instruction_complexity_scorer\": {\n            \"llm\": {\"generation_kwargs\": {\"temperature\": 0.0}}\n        },\n        \"evol_response_quality\": {\n            \"llm\": {\"generation_kwargs\": {\"max_new_tokens\": 512, \"temperature\": 0.7}}\n        },\n        \"response_quality_scorer\": {\"llm\": {\"generation_kwargs\": {\"temperature\": 0.0}}},\n        \"deita_filtering\": {\"data_budget\": 500, \"diversity_threshold\": 0.04},\n    },\n    use_cache=False,\n)\n</code></pre> <p>We can push the results to the hub:</p> <pre><code>distiset.push_to_hub(\"distilabel-internal-testing/deita-colab\")\n</code></pre>"},{"location":"sections/papers/deita/#results","title":"Results","text":"<p>Again, to show the relevance of EVOL QUALITY method, the authors evaluated on the MT-bench models fine-tuned with different data selections according to how we defined quality responses according to an instruction. Each time they selected 6k data according to the quality score:</p> <p></p> <p>Credit: Liu et al. (2023)</p> <p>The score is much better when selecting data with the EVOL QUALITY method than when we select randomly or according to the length, making a more qualitative response if longer. Nevertheless, we see that the margin we may have seen in the complexity score is thinner. And we'll discuss the strategy in a later part. Nevertheless, this strategy looks to improve the fine-tuning compared to the baselines and now we're interested in mixing quality and complexity assessment with a diversity evaluation to find the right trade-off in our selection process.</p>"},{"location":"sections/papers/deita/#conclusion","title":"Conclusion","text":"<p>In conclusion, if you are looking for some efficient method to align an open-source LLM to your business case with a constrained budget, the solutions provided by DEITA are really worth the shot. This data-centric approach enables one to focus on the content of the dataset to have the best results instead of \"just\" scaling the instruction-tuning with more, and surely less qualitative, data. In a nutshell, the strategy developed, through automatically scoring instructions-responses, aims to substitute the human preference step proprietary models such as GPT-4 have been trained with. There are a few improvements we could think about when it comes to how to select the good data, but it opens a really great way in instruct-tuning LLM with lower computational needs making the whole process intellectually relevant and more sustainable than most of the other methods. We'd be happy to help you out with aligning an LLM with your business case drawing inspiration from such a methodology.</p>"},{"location":"sections/papers/instruction_backtranslation/","title":"Self-Alignment with Instruction Backtranslation","text":"<p>Self Alignment with Instruction Backtranslation presents a scalable method to build a high quality instruction following language model by automatically labelling human-written text with corresponding instructions. Their approach, named instruction backtranslation, starts with a language model finetuned on a small amount of seed data, and a given web corpus. The seed model is used to construct training examples by generating instruction prompts for web documents (self-augmentation), and then selecting high quality examples from among these candidates (self-curation). This data is then used to finetune a stronger model.</p> <p>Their self-training approach assumes access to a base language model, a small amount of seed data, and a collection of unlabelled examples, e.g. a web corpus. The unlabelled data is a large, diverse set of human-written documents which includes writing about all manner of topics humans are interested in \u2013 but crucially is not paired with instructions.</p> <p>A first key assumption is that there exists some subset of this very large human-written text that would be suitable as gold generations for some user instructions. A second key assumption is that they can predict instructions for these candidate gold answers that can be used as high quality example pairs to train an instruction following model.</p> <p>Their overall process, called instruction backtranslation performs two core steps: 1. Self-augment: Generate instructions for unlabelled data, i.e. the web corpus, to produce candidate training data of (instruction, output) pairs for instruction tuning. 2. Self-curate: Self-select high quality demonstration examples as training data to finetune the base model to follow instructions. This approach is done iteratively where a better intermediate instruction-following model can improve on selecting data for finetuning in the next iteration.</p>"},{"location":"sections/papers/instruction_backtranslation/#replication","title":"Replication","text":"<p>To replicate the paper we will be using <code>distilabel</code> and a smaller dataset created by the Hugging Face H4 team named <code>HuggingFaceH4/instruction-dataset</code> for testing purposes.</p>"},{"location":"sections/papers/instruction_backtranslation/#installation","title":"Installation","text":"<p>To replicate Self Alignment with Instruction Backtranslation one will need to install <code>distilabel</code> as it follows:</p> <pre><code>pip install \"distilabel[hf-inference-endpoints,openai]&gt;=1.0.0\"\n</code></pre> <p>And since we will be using <code>hf-inference-endpoints</code> we will need deploy those in advance either locally or in the Hugging Face Hub (alternatively also the serverless endpoints can be used, but most of the times the inference times are slower, and there's a limited quota to use those as those are free) and set both the <code>HF_TOKEN</code> (to use the <code>InferenceEndpointsLLM</code>) and the <code>OPENAI_API_KEY</code> environment variable value (to use the <code>OpenAILLM</code>).</p>"},{"location":"sections/papers/instruction_backtranslation/#building-blocks","title":"Building blocks","text":"<ul> <li><code>LoadHubDataset</code>: Generator Step to load a dataset from the Hugging Face Hub.</li> <li><code>TextGeneration</code>: Task to generate responses for a given instruction using an LLM.<ul> <li><code>InferenceEndpointsLLM</code>: LLM that runs a model from an Inference Endpoint in the Hugging Face Hub.</li> </ul> </li> <li><code>InstructionBacktranslation</code>: Task that generates a score and a reason for a response for a given instruction using the Self Alignment with Instruction Backtranslation prompt.<ul> <li><code>OpenAILLM</code>: LLM that loads a model from OpenAI using <code>OpenAILLM</code>.</li> </ul> </li> </ul>"},{"location":"sections/papers/instruction_backtranslation/#code","title":"Code","text":"<p>As mentioned before, we will put the previously mentioned building blocks together to replicate Self Alignment with Instruction Backtranslation.</p> <pre><code>from distilabel.llms import InferenceEndpointsLLM, OpenAILLM\nfrom distilabel.pipeline import Pipeline\nfrom distilabel.steps import LoadHubDataset\nfrom distilabel.steps.tasks import InstructionBacktranslation, TextGeneration\n\n\nwith Pipeline(name=\"self-alignment-with-instruction-backtranslation\") as pipeline:\n    load_hub_dataset = LoadHubDataset(\n        name=\"load_dataset\",\n        output_mappings={\"prompt\": \"instruction\"},\n    )\n\n    text_generation = TextGeneration(\n        name=\"text_generation\",\n        llm=InferenceEndpointsLLM(\n            base_url=\"&lt;INFERENCE_ENDPOINT_URL&gt;\",\n            tokenizer_id=\"argilla/notus-7b-v1\",\n            model_display_name=\"argilla/notus-7b-v1\",\n        ),\n        input_batch_size=10,\n        output_mappings={\"model_name\": \"generation_model\"},\n    )\n    load_hub_dataset.connect(text_generation)\n\n    instruction_backtranslation = InstructionBacktranslation(\n        name=\"instruction_backtranslation\",\n        llm=OpenAILLM(model=\"gpt-4\"),\n        input_batch_size=10,\n        output_mappings={\"model_name\": \"scoring_model\"},\n    )\n    text_generation.connect(instruction_backtranslation)\n\n    keep_columns = KeepColumns(\n        name=\"keep_columns\",\n        columns=[\n            \"instruction\",\n            \"generation\",\n            \"generation_model\",\n            \"score\",\n            \"reason\",\n            \"scoring_model\",\n        ],\n    )\n    instruction_backtranslation.connect(keep_columns)\n</code></pre> <p>Then we need to call <code>pipeline.run</code> with the runtime parameters so that the pipeline can be launched.</p> <pre><code>dataset = pipeline.run(\n    parameters={\n        \"load_dataset\": {\n            \"repo_id\": \"HuggingFaceH4/instruction-dataset\",\n            \"split\": \"test\",\n        },\n        \"text_generation\": {\n            \"generation_kwargs\": {\n                \"max_new_tokens\": 1024,\n                \"temperature\": 0.7,\n            },\n        },\n        \"instruction_backtranslation\": {\n            \"generation_kwargs\": {\n                \"max_new_tokens\": 1024,\n                \"temperature\": 0.7,\n            },\n        },\n    }\n)\n</code></pre> <p>Finally, we can optionally push the generated dataset, named <code>Distiset</code>, to the Hugging Face Hub via the <code>push_to_hub</code> method, so that each subset generated in the leaf steps is pushed to the Hub.</p> <pre><code>dataset.push_to_hub(\"distilabel-internal-testing/instruction-backtranslation-instruction-dataset\", private=True)\n</code></pre>"},{"location":"sections/papers/ultrafeedback/","title":"UltraFeedback: Boosting Language Models with High-quality Feedback","text":"<p>UltraFeedback is a large-scale, fine-grained, diverse preference dataset, used for training powerful reward models and critic models.</p> <p>UltraFeedback collects about 64k prompts from diverse resources (including UltraChat, ShareGPT, Evol-Instruct, TruthfulQA, FalseQA, and FLAN), then they use these prompts to query multiple LLMs (commercial models, Llama models ranging 7B to 70B, and non-Llama models) and generate four different responses for each prompt, resulting in a total of 256k samples i.e. the UltraFeedback will rate four responses on every OpenAI request.</p> <p>To collect high-quality preference and textual feedback, they design a fine-grained annotation instruction, which contains four different aspects, namely instruction-following, truthfulness, honesty and helpfulness (even though within the paper they also mention a fifth one named verbalized calibration). Finally, GPT-4 is used to generate the ratings for the generated responses to the given prompt using the previously mentioned aspects.</p>"},{"location":"sections/papers/ultrafeedback/#replication","title":"Replication","text":"<p>To replicate the paper we will be using <code>distilabel</code> and a smaller dataset created by the Hugging Face H4 team named <code>HuggingFaceH4/instruction-dataset</code> for testing purposes.</p> <p>Also for testing purposes we will just show how to evaluate the generated responses for a given prompt using a new global aspect named <code>overall-rating</code> defined by Argilla, that computes the average of the four aspects, so as to reduce number of requests to be sent to OpenAI, but note that all the aspects are implemented within <code>distilabel</code> and can be used instead for a more faithful reproduction. Besides that we will generate two responses i.e. run the text generation on top of two LLMs instead of four, to reduce the compute required too.</p>"},{"location":"sections/papers/ultrafeedback/#installation","title":"Installation","text":"<p>To replicate UltraFeedback one will need to install <code>distilabel</code> as it follows:</p> <pre><code>pip install \"distilabel[argilla,openai,vllm]&gt;=1.0.0\"\n</code></pre> <p>And since we will be using <code>vllm</code> we will need to use a VM with at least 2 NVIDIA GPUs with at least 16GB of memory each to run the text generation, and set the <code>OPENAI_API_KEY</code> environment variable value.</p>"},{"location":"sections/papers/ultrafeedback/#building-blocks","title":"Building blocks","text":"<ul> <li><code>LoadHubDataset</code>: Generator Step to load a dataset from the Hugging Face Hub.</li> <li><code>TextGeneration</code>: Task to generate responses for a given instruction using an LLM.<ul> <li><code>vLLM</code>: LLM that loads a model from the Hugging Face Hub using <code>vLLM</code>.</li> </ul> </li> <li><code>CombineColumns</code>: Task that combines multiple columns into a single one i.e. from string to list of strings. Useful when there are multiple parallel steps that are connected to the same node.</li> <li><code>UltraFeedback</code>: Task that generates ratings for the responses of a given instruction using the UltraFeedback prompt.<ul> <li><code>OpenAILLM</code>: LLM that loads a model from OpenAI using <code>OpenAILLM</code>.</li> </ul> </li> <li><code>KeepColumns</code>: Task to keep the desired columns while removing the not needed ones, as well as defining the order for those. </li> <li><code>PreferenceToArgilla</code>: Task to optionally push the generated dataset to Argilla to do some further analysis and human annotation.</li> </ul>"},{"location":"sections/papers/ultrafeedback/#code","title":"Code","text":"<p>As mentioned before, we will put the previously mentioned building blocks together to replicate UltraFeedback.</p> <pre><code>from distilabel.llms import OpenAILLM, vLLM\nfrom distilabel.pipeline import Pipeline\nfrom distilabel.steps import (\n    CombineColumns,\n    KeepColumns,\n    LoadHubDataset,\n    PreferenceToArgilla,\n)\nfrom distilabel.steps.tasks import TextGeneration, UltraFeedback\n\n\nwith Pipeline(name=\"ultrafeedback-pipeline\") as pipeline:\n    load_hub_dataset = LoadHubDataset(\n        name=\"load_dataset\",\n        output_mappings={\"prompt\": \"instruction\"},\n    )\n\n    text_generation_with_notus = TextGeneration(\n        name=\"text_generation_with_notus\",\n        llm=vLLM(model=\"argilla/notus-7b-v1\"),\n        input_batch_size=10,\n        output_mappings={\"model_name\": \"generation_model\"},\n    )\n    text_generation_with_zephyr = TextGeneration(\n        name=\"text_generation_with_zephyr\",\n        llm=vLLM(model=\"HuggingFaceH4/zephyr-7b-gemma-v0.1\"),\n        input_batch_size=10,\n        output_mappings={\"model_name\": \"generation_model\"},\n    )\n    load_hub_dataset.connect(text_generation_with_notus)\n    load_hub_dataset.connect(text_generation_with_zephyr)\n\n    combine_columns = CombineColumns(\n        name=\"combine_columns\",\n        columns=[\"generation\", \"generation_model\"],\n        output_columns=[\"generations\", \"generation_models\"],\n    )\n    text_generation_with_notus.connect(combine_columns)\n    text_generation_with_zephyr.connect(combine_columns)\n\n    ultrafeedback = UltraFeedback(\n        name=\"ultrafeedback_openai\",\n        llm=OpenAILLM(model=\"gpt-4\"),\n        aspect=\"overall-rating\",\n        output_mappings={\"model_name\": \"ultrafeedback_model\"},\n    )\n    combine_columns.connect(ultrafeedback)\n\n    keep_columns = KeepColumns(\n        name=\"keep_columns\",\n        columns=[\n            \"instruction\",\n            \"generations\",\n            \"generation_models\",\n            \"ratings\",\n            \"rationales\",\n            \"ultrafeedback_model\",\n        ],\n    )\n    ultrafeedback.connect(keep_columns)\n\n    # # Optional: Push the generated dataset to Argilla, but will need to `pip install argilla` first\n    # push_to_argilla = PreferenceToArgilla(\n    #     name=\"push_to_argilla\",\n    #     api_url=\"&lt;ARGILLA_API_URL&gt;\",\n    #     api_key=\"&lt;ARGILLA_API_KEY&gt;\",  # type: ignore\n    #     dataset_name=\"ultrafeedback\",\n    #     dataset_workspace=\"admin\",\n    #     num_generations=2,\n    # )\n    # keep_columns.connect(push_to_argilla)\n</code></pre> <p>Then we need to call <code>pipeline.run</code> with the runtime parameters so that the pipeline can be launched.</p> <pre><code>dataset = pipeline.run(\n    parameters={\n        \"load_dataset\": {\n            \"repo_id\": \"HuggingFaceH4/instruction-dataset\",\n            \"split\": \"test\",\n        },\n        \"text_generation_with_notus\": {\n            \"generation_kwargs\": {\n                \"max_new_tokens\": 512,\n                \"temperature\": 0.7,\n            },\n        },\n        \"text_generation_with_zephyr\": {\n            \"generation_kwargs\": {\n                \"max_new_tokens\": 512,\n                \"temperature\": 0.7,\n            },\n        },\n        \"ultrafeedback_overall_rating\": {\n            \"generation_kwargs\": {\n                \"max_new_tokens\": 1024,\n                \"temperature\": 0.7,\n            },\n        },\n    }\n)\n</code></pre> <p>Finally, we can optionally push the generated dataset, named <code>Distiset</code>, to the Hugging Face Hub via the <code>push_to_hub</code> method, so that each subset generated in the leaf steps is pushed to the Hub.</p> <pre><code>dataset.push_to_hub(\"distilabel-internal-testing/ultrafeedback-instruction-dataset\", private=True)\n</code></pre>"}]}